<==========================800start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
31.6注释的布局
763
C++中,声明指针变量时请把星号(*)靠近变量名,或者是去声明指针类型
声明指针变量时将星号写在类型旁边是很常见的,如清单31-55所示。
清单31-55C++指针声明中的星号使用示例
EmployeeList* employees;
File* inputFile;
将星号写在类型名而非变量名旁边的问题是如果一行上有多个声明,星号
只作用于第一个变量。即便声明看上去像对行上所有变量都有效。避免这个问题
的办法是将星号置于变量名而非类型名旁,如清单31-56所示。
清单31-56C++指针声明中的星号使用示例
EmployeeList *employees;
File *inputFile;
这一方法的不足之处在于,似乎星号是变量名的一部分,其实并不是。变量
可以和星号一起使用,也可以单独使用。
最好的办法是先声明指针类型名,再用类型名来声明变量,清单31-57就是
一个例子。
清单31-57C++在声明中合理运用指针类型的示例
EmployeeListPointer employees;
FilePointer inputrile;
解决前面方法提出的特殊问题,要么要求所有指针都用指针类型声明(如清
单31-57所示),要么要求每行只声明一个变量。应确保采用这两种解决方案中的
一种。
Laying Out Comments
注释的布局
交叉参考关于
注释的其他内容,
注释做得好可大大增进程序的可读性,而糟糕的注释却会帮倒忙。注释的布
请参看第32章局与其作用的好坏关系甚大。
“自说明代码”。
代码大全(第2版)

<==========================800end ==============================>
<==========================801start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
764
第31章布局与风格
注释的缩进要与相应代码一致缩进效果是理解程序逻辑结构的辅助工具,
好的注释不会妨碍缩进效果。打个比方,清单31-58中子程序的逻辑结构是怎样
的呢?
清单31-58注释缩进不当的 Visual Basic例子
For transactionId 1 To totalTransactions
'get transaction data
GetTransactionType transactionType
GetTransactionAmount transactionAmount
CODING
HORROR
process transaction based on transaction type
If transactionType Transaction Sale Then
AcceptCustomerSale( transactionAmount)
Else
aneaction
If transactionType Transaction_CustomerReturn Then
either process return automatically or get manager approval, if required
try to get manager approval and then accept or reject the return
based on whether approval is granted
GetMgrApproval isTransactionApproved
If isTransactionApproved Then
AcceptCustomerReturn transactionAmount
Else
RejectCustomerReturn( transactionAmount
End If
Else
manager approval not required so accept return
AcceptCustomerReturn( transactionAmount
End If
End If
End If
Next
从本例中,你无法获取有关程序结构的较多提示,因为注释彻底扰乱了代码
的缩进外观。也许你很难相信有人会故意这样缩进,但我确实在专业程序中见过,
还获悉至少有一本教材里推荐这么做。
清单31-59中的代码和清单31-58完全相同,只是改进了注释的缩进。
代码大全(第2版)

<==========================801end ==============================>
<==========================802start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
31.6注释的布局
765
清单31-59注释合理缩进的 Visual Basic例子
For transactionId 1 To totalTransactions
get transaction data
GetTransactionType( transactionType
Get TransactionAmount transactionAmount
'process transaction based on transaction type
If transactionType Transaction Sale Then
AcceptCustomersale transaction
Else
If transactionType =TransactionCustomerReturn Then
process return automati
'either process return automatic
if required If tran
try to get manager approval and ther
'based on whether approval is granted
GetMgrApproval( isTransactionApproved)
If isTransactionApproved Then
EsAcceptCustomerReturn( transactionAmount
End tectcustomerReturn( transact ionamount
Else
manager approval not required, so accept return
AcceptCustomerReturn transactionAmount
End If
Vetena If
在清单31-59中,逻辑结构更加鲜明。 Shneiderman于1980年开展了一项有
关注释效果的研究,发现有注释未必就是好事研究者认为这是由于它们“千扰
了对程序的扫视”。从这些例子可以明显看出,注释的风格有力地影响着注释是否
具有负面作用。
每行注释用至少一个空行分开如果有人想对你的程序有总体认识,最有效
的办法是看你的注释而非代码。将注释用空行分开有利于读者扫视代码。清单
31-60给出了一个例子。
清单31-60用空行分开注释的Java示例
commnent zero
CodestatementZero
CodestatementOne;
/ comment one
CodestatementTwo;
CodestatementThree;
代码大全(第2版)

<==========================802end ==============================>
<==========================803start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co ^.com!仅供试看^
766
第31章布局与风格
有的人在注释前后都加一空行。两个空行占用了更多显示区域,但是一些人
认为这样的代码看起来更好。清单31-61就是这个样子。
清单31-61用两个空行分开注释的Java示例
/1 comment zero
Codestatement zero;
CodestatementOne;
/ comment one
CodestatementTwo;
CodestatementThree;
除非显示空间非常珍贵,否则这就纯粹是美观方面的看法,你可以自行决定。
就像在其他许多领域一样,有约定比约定的某个特定细节更重要。
31.7
Laying Out Routines
子程序的布局
交叉参考关于子程序由一些独立的语句、数据、控制结构、注释组成,所有这些部件都已
详细内容,请参看在本章其余部分讨论过了。本节只介绍有关子程序布局的原则。
32.5节中的“注
释子程序”,关于用空行分隔子程序的各部分请在子程序的头、数据和常量名声明(如果有
编写子程序的过的话)以及子程序体之间插入空行。
程,请参看9.3节
的通过伪编将子程序参数按标准缩进与其他区的布局情况一样,可选的子程序头布
程过程创建子程
序”;有关优劣子局有:任意布局、行尾布局或标准缩进。在大多数情况下,标准缩进更准确、连
看第7章“高质贯、可读、易维护。清单31-62给出了个未注意子程序头布局的例子。
量的子程序。清单31-62子程序头没有用心布局的C++示例
bool ReadEmployeeData (int maxEmployees, EmployeeList *employees
EmployeeFile *inputFile, int *employeeCount, bool *isInputError)
void InsertionSort(SortArray data, int firstElement, int lastElement)
这样的子程序头纯粹只是为了使用,计算机肯定能读,但对人呢?没意识到
程序还需供人看,会让看的人叫苦不迭,还有比这更糟糕的事吗?
代码大全(第2版)

<==========================803end ==============================>
<==========================804start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo..com!仅供试看
31.7子程序的布局
767
子程序头的第二种布局方式是行尾布局,它通常显得很不错。清单31-63给
出了同样子程序头重排后的表现。
清单31-63C++中使用普通行尾布局的子程序头的示例
bool ReadEmployeeData( intemployees
maxEmployees,
EmployeeList
Employeerile *inputFile,
int *employeecount,
bool *isInputError
void InsertionSort( SortArray data
int
lastElement
交叉参考有行尾布局整齐美观。其主要问题是维护要花费很多气力,而人们常常由于这
关子程序参数种风格维护起来太麻烦就不维护。设想上面函数名由 ReadEmployeeData()被改
的更多细节,请
参看第7.5节为 ReadNewEmplyeeData(),就会让下面四行不再与第一行对齐,你只好对它们
“如何使用子
程序参数"。
重排,以便与更长函数名引起的 maxEmployees的新位置对齐。这样做也许会因
为其中的元素已经太靠右,而跑到了右侧的外面。
清单31-64给出的例子采用标准缩进布局,既美观,维护量也小。
清单31-64子程序头采用易读、易维护的标准缩进布局的C++例子
public bool ReadEmployeeData(
int maxEmployees,
Emp loyeeList *employees,
EmployeeFile *inputFile,
int *employeeCount,
bool *isInputError
public void InsertionSort(
ortArray data,
int firstElement,
int lastElement
这种风格经得起修改。子程序名的变化不会对参数产生任何影响,增删参数
只需要修改一行增加或去掉一个逗号。视觉效果与循环或i语句的缩进一
致。眼睛不必扫视代码页的各部分,就能找到每个子程序的有用信息,因为信息
就在那儿。
代码大全(第2版)

<==========================804end ==============================>
<==========================805start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
768
第31章布局与风格
该风格在 Visual Basic中可直观地表现出来,不过要有续行符,如清单31-65
所示。
清单31-65子程序头采用易读、易维护的标准缩进布局的 Visual Basic示例
此处的字符 Public Sub ReadEmployeeData
“-”是续行
ByVal maxEmployees As Integer,
符
ByRef employees As Employeelist,
ByRef inputFile As Employeerile,
ByRef employeeCount As Integer,
ByRef isInputError As Boolean-
31.8
Laying Out Classes
类的布局
本节说明类代码的布局原则。第一小节描述如何布局类接口,第二小节阐释
怎样编排类实现,最后一小节讨论文件与程序的布局。
Laying Out Class Interfaces
类接口的布局
在布局类接口时,一般应将类成员按如下顺序表示:
交叉参考有关文1.说明类及其完整用法的头部注释
档化类的详细内容,
请参看32.5节中的2.构造函数与析构函数
“注释类、文件和程
序"。关于区别类优3. public子程序
劣的讨论,可以参看
第6章“可以工作4. protected子程序
的类。
5. private子程序和数据成员
Laying Out Class Implementations
类实现的布局
类实现通常应按以下顺序排布:
1.描述类所在文件之内容的头部注释
2.类数据
3. public子程序
4. protected子程序
5. private子程序
代码大全(第2版)

<==========================805end ==============================>
<==========================806start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !-www.shubul.com!仅供试看
31.8类的布局
769
如果文件包含多个类,要清楚地标出每一个类相关子程序应分组放到类中。
别人看了你的代码后应能很容易说得头头是道。用空行将类与相邻类分开,以便
使其井井有条。类就像书的“章”,书都是新起一页开始一章,章名采用大字号印
刷。请以类似手法强调每个类的开头。清单31-6给出将类分隔开来的例子。
清单31-66将类分开布局的C++示例
这是某类的最 create string identical to sourcestring except that the
void EditString: Convert Blanksor
后一个子程 blanks are replaced with underscores
序。
char *sourcestring.
char *targetString
strlen( sourcestrin
Assert( strlen( sourcestring= MAXSTRINGLENGTH)
Assert( sourceString ! NULL
Assert( targetstring ! NULL
int charIndex =;
do
if( sourceString charIndex=="")
targetString[ charIndex
else
cources
targetstring charIndex sourceString[ charIndex ]
charIndex++;
while sourceString charIndex !='\0'
在下一个类的7
开头标记若干
// MATHEMATICAL FUNCTION
空行和类名。
This class contains the program's mathematical functions.
这是新类的第
/ find the arithmetic maximum of argl and arg2
int Math::max int argl, int arg22)
一个子程序。
return argli
else
return arg2;
}
ninimum o
/1 find the arithmetic minimum of arg1 and arg2
这个子程序与 int Math::Min( int arg1, int arg22)(
上一个子程序
if arg1 arg2
以空行分隔。
ral
return argli
),e
else
return arg2i
代码大全(第2版)

<==========================806end ==============================>
<==========================807start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !-www.shubulo...com!仅供试看^
770
第31章布局与风格
不要在类里过度注释。如果对每个子程序都做标记,且用一行星号而非空行
作为注释,要找到能有效强调新类开始的方式就很困难了。清单31-67给出了一
个示例。
清单31-67C++中对类过度布局格式的例子
/*********
/ MATHEMATICAL FUNCTIONS
11 This class contains the program's mathematical function
/***
/** the arithmetic maximum of argl and arg2
//fin
/********★★★★★★★★★★★★★***★**★★★*****★★★★★★
int Math: Max( int argl, int arg2
//*************★******★★
if arg1 arg2 )
return argl;
else
return arg2;
}
★*************★
/1 find the arithmetic maximum of argl and arg2
//**
int Math::min( int argl, int arg2)
*ⅷ*****
ca1a
if argl arg2
return argl;
else
return arg2;
在此例中,很多内容用星号突出,以至于没有什么东西被真正强调了。程序
通身都是星号。尽管这是美观方面的评价而非技术评价,但在格式化时还是少这
么做为好。
如果确实要用专门的字符行将程序各部分划开那就采用一系列的符号(从
紧到松),不要老是只用星号。例如,类分隔用星号,子程序间用连字号(减号),
而重要的注释使用空行。避免将两行星号或者连字号放在一块。清单31-68给出
了示例。
代码大全(第2版)

<==========================807end ==============================>
<==========================808start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.c.com!仅供试看^
31.8类的布局
771
清单31-68格式化较好的有节制的C++示例
*******★★★★
*大
/ MATHEMATICAL FUNCTIONS
cass contains the progr
/ This class contains the program's mathematical functions.
该行相对于星 find the arithmetic maximum of argl1 and arg2
号行较疏松,
/------
视觉突出了子 int Math::Max( int arg11, int arg22){
程序属于此类f(arg>arg2)
的事实
return argli
else
return arg2;
-
find the arithmetic minimum of argl and arg2
-----------------------
int Math: Min( int argl, int arg2
if arg1 arg2)(
return argl;
else
return arg2;
这个在单一文件中怎样标识多个类的建议,只适合于那些限制了你在一个程
序里可使用的文件数目的语言。如果用的是C++、ava、 Visual Basic等支持多个
源文件的语言,那么除非确有充足理由(例如将若干小类组织到一起),请在一个
文件中只放一个类。不过,在一个类里可能有若干个子程序组,你仍可用这里介
绍的技术将其分开。
Laying Out Files and Programs
文件和程序布局
交叉参考有关在类的布局技术之外,还有更大的格式化话题:如何组织文件中的类和子程
文档化类的详细
内容,请参见32.5序?怎样决定哪个类应该放到一个文件的最前面?
节中的“注释类、
文件和程序”。
一个文件应只有一个类文件不能只是存放代码的大筐。如果所用语言允许
的话,一个文件应该是“支持且仅支持一项目的”的一组子程序的集合。文件应
该强化这一子程序集合同属于一个类的思想。
代码大全(第2版)

<==========================808end ==============================>
<==========================809start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !-www.shubulo.com!仅供试看^
772
第31章布局与风格
交叉参考有关一个文件中的所有子程序构成了个类。这样的类才真正得到了本程序的认
类与子程序之间
将子程及如何可,否则该类不过就是设计时创建的一个逻辑实体而已。
的区别
程序集合放
入类的详细内容,
类是语言里的语义概念,文件则是操作系统中的物理概念。类和文件之间的
请参看第6章“可对应只是一种巧合,并且随着时间的推移,越来越多的环境支持将代码放入数据
以工作的类”。
库,从而模糊了子程序、类以及文件的联系,也使这一对应关系日益弱化
文件的命名应与类名有关多数项目的类名和文件名之间具有一一对应的关
系。例如名为 CustomerAccount的类,其文件名应为 CustomerAccount.cpp和
CustomerAccount. h.
在文件中清晰地分隔各子程序至少用两个空行将各子程序分开。空行与星
号行、连字号行一样有效,而其输入和维护却容易得多。采用两到三行空格,可
以清楚地表现出有关空行是子程序里的一部分,还是子程序之间的分隔。清单
31-69给出了例子。
清单31-69在子程序间使用空行的 Visual Basic示例
'find the arithmetic maximum of arg1 and arg
Function Max( arg1 As Integer, arg2 As Integer As Integer
Max argi
Else
Max =arg2
End If
End Function
用至少两个空
行来区分这两
个子程序。
'find the arithmetic minimum of arg1 and arg2
Function Min( arg1 As Integer, arg2 As Integer As Integer
If arg1 arg2 Then
Min arg1
Else
Min arg2
End If
end Function
空行比其他任何分隔符行都更容易键入,看上去也一点儿不差。此例中用了
三个空行,其分隔效果比子程序内的空行明显得多。
按字母顺序排列子程序将相关子程序在文件中分组的替代方案是按字母顺
序排列这些子程序。如果无法将程序分解为若干类,或者你的编辑器不能方便地
查找函数,则按字母排序能够节约查找时间。
代码大全(第2版)

<==========================809end ==============================>
<==========================810start==============================>

该书下载自-书部落-分享计算机经典著--www. ! -www.shubulo. com!^.com!仅供试看
31.8类的布局
773
对于C++,请仔细组织源文件中内容的次序C++源文件内容的典型顺序应
为:
1.文件的描述性注释
2.#include文件行
3.在多个类里使用的常量定义(如果文件里有多个类)
4.在多个类里使用的枚举(如果文件里有多个类)
5.宏函数定义
6.在多个类里使用的类型定义(如果文件里有多个类)
7.导入的全局变量和函数
8.导出的全局变量和函数
9.本文件私用的变量和函数
10.各个类,包括各个类中的常量定义、枚举以及类型定义
CHECKLIST: Layout
ecom314核对表:布局
一般问题
口格式化主要是为了展现代码的逻辑结构吗?
口你的布局方案能统一地运用吗?
口你的布方案能让代码易于维护吗?
口你的布局方案是否有利于代码的可读性?
控制结构的布局
口你的代码中避免 begin--end对或(}的双重缩进了吗?
口相邻的块之间用空行分隔了吗?
口对复杂表达式格式化时考虑到可读性吗?
口对只有一条语句的块的布局始终如一吗?
口case语句与其他控制结构的格式化保持一致了吗?
口对goto语句的格式化是否让其显眼了呢?
代码大全(第2版)

<==========================810end ==============================>
<==========================811start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
774
第31章布与风格
单条语句的布局
口为逻辑表达式、数组下标和子程序参数的可读性而使用空格了吗?
口不完整的语句在行末是以明显有错的方式结束吗?
口后续行按照标准数目缩进了吗?
口每行顶多只有一条语句吗?
口所写的每个语句都没有副作用吗?
口每行顶多只声明一个数据吗?
注释的布局
口注释与其所注释的代码的缩进量相同吗?
口注释的风格便于维护吗?
子程序的布局
口你对每个子程序参数的格式化方式便于看懂、修改、注释吗?
口采用空行分隔子程序的各部分了吗?
类、文件和程序的布局
口多数类和文件之间是一一对应的关系吗?
口如果文件内有多个类,各类中的程序按分组了吗?各类都清楚标识了
吗?
口文件中的子程序用空行清楚地分开了吗?
口在没有更好的组织形式的场合,所有子程序都按字母顺序排列了吗?
Additional Resources
更多资源
cc2.cm301多数编程教材对布局和风格都是只片语,很少有深究编程风格的,讨论布
局的就更少了。下面这些书谈到布局和编程风格。
Kernighan, Brian. and Rob Pike.《 The Practice of Programming》. Readin
mA: Addison-Wesley-,1999该书的第1章着重讨论了C和C++的编程风格。
1译注:中译本《程序设计实践》,机械工业出版社
代码大全(第2版)

<==========================811end ==============================>
<==========================812start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
要点
775
Vermeulen, Allan, et al. The Elements of Java Style). Cambridge University
Press,2000.
Misfeldt, Trevor Greg Bumgardner, and Andrew Gray. The Elements of++
Sryle). Cambridge University Press, 2004.
Kernighan, Brian W., and P. J. Plauger. The Elements of Programming Style),
2ded. New York,ny: MeGraw-hill1978.该书是编程风格方面的经典书籍,是探
讨编程风格的第一本书。
要了解一种对可读性理解迥然不同的方法,可参看下面这本书。
Knuth, Donald E. KLiterate Programming). Cambridge University Press, 2001.
这本书收集了描述文学化编程法的多篇论文,其中将编程语言和书面语言相结合
Knuth写文学化编程的优点已经有20年左右了,尽管他自称为世上最好的程序员,
但文学化编程并不流行。读读他的代码,用你的脑袋去想想为什么会这样。
Key Points
要点
可视化布局的首要任务是指明代码的逻辑组织。评估该任务是否实现的
指标包括准确性、一致性、易读性和易维护性。
外表悦目比起其他指标是最不重要的。然而,如果其他指标都达到了,
代码又质量好,那么布局效果看上去也会不错。
Visual Basic具有纯代码块风格,而Java的传统做法就是使用纯块风格,
所以若用这些语言编程,就请使用纯代码块风格C++中,模拟纯代码块
或者 begin-end块边界都行之有效。
结构化代码有其自身目的。始终如一地沿用某个习惯而少来创新。不能
持久的布局规范只会损害可读性
布局的很多方面涉及信仰问题。应试着将客观需要和主观偏好区分开来。
定出明确的指标,在此基础上讨论风格参数的选择。
代大全(第2版)

<==========================812end ==============================>
<==========================813start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo..com!仅供试看

<==========================813end ==============================>
<==========================814start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
Self-Documenting Code
第32
自说明代码
ccec/3245内容
32.1外部文档:第777页
32.2编程风格作文档:第778页
32.3注释或不注释:第781页
32.4高效注释之关键:第785页
32.5注释技术:第792页
32.6EEE标准:第813页
相关章节
布局:第31章
伪代码编程过程:第9章
可以工作的类:第6章
高质量的子程序:第7章
编码时要把维护编程是交流过程:33.5节和34.3节
你程序的人想象
成知道你住址的
只要文档标准合情合理,多数程序员都喜欢写文档。和布局一样,好的文档
有严重暴力倾向说明是程序员放在程序里面、体现其专业成就的标志。软件文档说明有多种形式,
的精神病人。本章在综述文档的有关情况后,将专注于文档的特殊补充,即“注释”。
佚名
32
External Documentation
外部文档
交叉参考关
软件项目的文档涵盖了源码清单内外的各种信息常见的形式有独立的文
于外部文档的件或者单元开发文件夹。对于大型的正规项目,多数文档位于源码之外(Jones
更多内容,请参
见32.6节1998)。外部结构文档通常比编码的层次更高,但比问题定义、需求和架构活动的
IEEE标准”。层次低一些。
代码大全(第2版)

<==========================814end ==============================>
<==========================815start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看^
778
第32章自说明代码
深入阅读对此单元开发文件夹“单元开发文件夹(unit- -development folder,uF)”又称
的详细讲解请参
见 The Unit
“软件开发文件夹( software-development- folder,SD)”,是一种非正式文档,
Development其中包含了供开发者在编程期间使用的记录。“单元”没有严格的定义,一般指
Folder
(UDF):
An Effctive也可指程序包或者组件UDF主要用途是提供在其他地方没有说明的设计决
Tool for策踪迹很多项目都有标准来指定UDF最少该有什么内容,例如相关需求的复本、
Development》某个单元实现的顶层设计的组成部分、开发标准的复本、当前代码清单,以及单
issla
1976)、《The元开发者的设计记录。尽管用户有时会要软件开发者提供项目的UDF,但它通
Unit
Development常仅限于内部使用。
Folder(UDF): A
Ten-Year
Perspective》
详细设计文档详细设计文档是低层次的设计文档,描述在类层或子程序层
Ingrassia的设计决定,曾考虑过的其他方案,以及采用所选方案的理由。有时候这些信息
1987)
含在某个正式文档中,在这种情况下,通常的考虑是将详细设计和构建过程分开
有时它主要包含收集于UDF的开发者记录;在另一些时候(经常如此),设计细
节说明就存在于代码本身中。
32.2
Programming Style as Documentation
编程风格作文档
与外部文档相比,内部文档嵌入于程序清单本身是最详细的文档,位于源
码层次上。由于内部文档与代码的联系最密切,故也是代码修正后最可能保持正
确的那种文档。
在代码层文档中起主要作用的因素并非注释,而是好的编程风格。编程风格
包括良好的程序结构、直率易懂的方法、有意义的变量名和子程序名、具名常量
(而非文字量)、清晰的布局,以及最低复杂度的控制流及数据结构
这里有一糟糕风格的代码段:
Java示例:不好的编程风格导致差劲文档说明
meetscriteria[i=true;
HORROR for(i=2i<=num2;i++)
hitiinum
while(j<=num)
代码大全(第2版)

<==========================815end ==============================>
<==========================816start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com仅供试看^
32.2编程风格作文档
779
meetsCriteria[ j false;
j=j+
for= 2; i < num; i++
if meetscriterial
system.out. printIn( meets criteria.")
这个子程序在干什么呢?它的难读完全没有必要。这段代码的文档作用之所
以差劲不在于没有注释,而在于缺乏好的编程风格。变量名没有传达任何有价值
的信息,布局粗糙。同样的代码写成下面的样子只是改进了编程风格,就能
使其含义清楚得多。
Java示例:没有注释(但编排风格很好)的文档
交叉参考该段代for( primecandidate=2 primeCandidate=num primecandidate++)
码加入 factorableisPrime primecandidate true
Number变量就是 ac bleNumbe
为了使操作清晰。for( int factor=2; factor<(num2); factor++
有关通过添加变量 int factorableNumber= factor+ factor;
来澄清操作的详细 while( factorableNumber=num)
内容,请参看19.1
isPrime factorableNumber= false
节中的“简化复杂
factorableNumber= factorableNumber+ factor
的表达式”。
mcanditm.
for( primeCandidate=2; primecandida<=num; primecandidate++)
if( isPrime primecandidate)
System.out. println primeCandidate "is prime. ")
与前面那段代码不同,这段代码让人一眼就能看出是与质数有关的。再仔细
看就能知道它用于找出1到Num之间的质数。而前一段代码,光是找到循环在哪
儿结束就得至少读上两遍。
这两段代码的差异与注释毫不相干—它们都没有注释。然而第二段代码更
容易理解,接近了易读性的最高水平:自说明代码。这些代码通过好的编程风格
承担文档说明的很大一部分任务。对于精心编写的代码而言,注释不过是美丽衣
裳上的小饰物而已。
代码大全(第2版)

<==========================816end ==============================>
<==========================817start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
780
第32章自说明代码
CHECKLIST: Self-Documenting Code
c2c3252核对表:自说明代码
类
口你的类接口体现出某种一致的抽象吗?
口你的类名有意义吗,能表明其中心意图吗?
口你的类接口对于如何使用该类显而易见吗?
口你的类接口能抽象到不需考虑其实现过程吗?能把类看成是黑盒吗?
子程序
口你的每个子程序名都能准确地指示该子程序确切干些什么吗?
口你的各子程序的任务明确吗?
口若各子程序中自成一体后更有用,你都将其各自独立出来了吗?
口每个子程序的接口都清晰明了吗?
数据名
口类型名描述有助于说明数据声明吗?
口你的变量名有意义吗?
口变量只用在其名字所代表意义的场合吗?
口你的循坏变量名能给出更多信息,而不是i、j、k之类的吗?
口你用了名字有意义的枚举类型,而非临时拼凑的标识或者布尔变量吗?
口用具名常量代替神秘数值或者字符串了吗?
口你的命名规范能区分类型名、枚举类型、具名常量、局部变量、类变量
以及全局变量吗?
数据组织
口你根据编程清晰的需要,使用了额外变量来提高清晰度吗?
口你对某变量的引用集中吗?
口数据类型简化到了最低复杂度吗?
口你是通过抽象访问子程序(抽象数据类型)来访问复杂数据吗?
控制
口代码中的正常执行路径很清晰吗?
口相关语句放在一起了吗?
代码大全(第2版)

<==========================817end ==============================>
<==========================818start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
32.3注释或不注释
781
口相对独立的语句组打包为子程序了吗?
口正常情况的处理位于if语句之后,而非在else子句中吗?
口控制结构简单明了,以使复杂度最低吗?
每个循环完成且仅完成一个功能,是像定义良好的子程序那么做吗?
口嵌套层次是最少吗?
口逻辑表达式通过额外添加布尔变量、布尔函数和功能表简化了吗?
布局
程序的布局能表现出其逻辑结构吗?
设计
代码直截了当吗?是不是避免了自作聪明或新花样?
口实现细节尽可能隐藏了吗?
口程序是尽可能采用问题领域的术语,而非按照计算机科学或者编程语言
的术语编写的吗?
32.3
To Comment or Not to Comment
注释或不注释
注释写得糟糕很容易,写得出色就难了。注释不好只会帮倒忙。关于注释有
什么效力的热烈讨论通常像是对精神有哪些作用的哲学争论。我觉得如果苏格拉
底(Socrates)是程序员,或许他和他的学生就曾有下面这段对话。
关于注释的讨论
人物:
《Thrasymachus《没有经验的纯理论家,相信自己读过的所有东西
Callicles
从古老学校里经实战磨练出来的老手,“真正”的程序员
Glaucon
年轻自信、热情洋溢的电脑玩家
Ismene
资深程序员,讨厌吹牛皮,热衷于做实事
Socrates
博学的老程序员
译注: Socrates:苏格拉底(公元前469年一公元前399年),古希腊哲学家、思想家
男大全(第2版)

<==========================818end ==============================>
<==========================819start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
782
第32章自说明代码
场景:
小组每天例行的吹风会即将结束
Socrates:散会前谁还有问题吗?
Thrasymachus:我提议项目该有个注释标准。我们有些程序员几乎从不注释
代码,谁都知道没注释的代码是没法阅读的。
Callicles:你一定是刚大学毕业的新手,比我想象的更没有经验注释被当作
是万灵药,可是任何实际编过程序的人都知道,注释反而使代码更难读懂。英语
可不像Java、 Visual Basic那么精确,它会产生大批废话。而编程语言的语句简短
扼要。如果代码不清晰,又怎能注释得清楚呢?再说,代码一变,注释就过时。
要是相信过时的注释,你就该倒霉了。
Glaucon:是这回事!注释过多的代码更难读懂,因为这意味着增大了阅读量。
我已经有够多的代码要读,何必再去读一大堆注释呢?”
Ismene:(把她的咖啡杯里放入两块糖)别这么说嘛。我知道注释会被
滥用,可注释用得好时却妙不可言。有注释和没有注释的代码我都维护过,我还
是愿意维护有注释的代码。我想没必要有标准来规定多少行代码就得有一个注释,
但我们该提倡大家注释自己的代码。
Socrates:要是注释只会浪费时间,为啥还有人用呢? Callicles?
Callicles:要么是因为有人要求他们这样,要么因为他们读到什么东西,里面
说这是有用的。好好想过的人都不会觉得注释有什么用。
Socrates: Ismene认为注释有好处,她在这里已经呆三年了,维护着你们有
注释和没注释的代码,而她更喜欢有注释的代码,你对此如何解释呢?
Callicles:注释只不过以啰嗦的方式又重复一遍代码,所以没什么用
Thrasymachus:得了吧,好注释可不是重复代码,或是解释代码。它们会让
其意图清晰。注释应能在更高抽象层上解释你想干什么。
POINT
代码大全(第2版

<==========================819end ==============================>
<==========================820start==============================>

该书下载自-书部落分享计算机经典巨著!ww. ! --www.shubulo..com!仅供试看
32.3注释或不注释
783
Ismene:太对了。我扫视注释来找出我要修改或调整的地方。你说得对,重
复代码的注释根本没用,因为代码足以说明一切我读注释时,希望它就像书的
标题或者目录那样提纲挈领。注释帮我找到需要的地方,然后我再开始读代码。
读一句注释比分析二十行代码快多了。
(Ismene又给自己倒了杯咖啡…)我想有人不愿写注释有这么几个原因,
是觉得自己的代码已经清晰得没法再清晰了,二是总以为别人对其代码有浓厚
兴趣,三是高估了其他程序员的智商,四就是懒惰,还有就是害怕别人知道其代
码工作的机理。
代码审查对写注释很起作用, Socrates。如果谁自称没必要编写注释,在审查
时就会被同仁们一串串“你这段代码到底做什么?”的提问折磨得焦头烂额,于
是就会去写注释了。如果不主动这样,至少他们的上司会迫使他们这么做的。
我不是说你懒惰, Callicles,也不是说你害怕别人搞懂你的代码。我用过你
的代码,你真是公司最优秀的程序员之一。但是请你发发慈悲吧,如果你有注释,
我用起来就会容易些。
Callicles:可这是在浪费资源。好程序员的代码应该是自说明的,你想知道的
全部信息都在代码里面。
Thrasymachus:(从座位上站起来)不可能!编译器要知道的东西是全在代
码中!你也可以说,你想知道的每件事都在二进制可执行文件中,如果你足够聪
明可以读懂的话!你的意图就不在代码里。
(意识到自己站着,便又坐下了) Socrates,这是太荒唐了。争论注释有无
价值干啥呢?我看过的每样东西都说注释有用应该不受限制地使用。我们是在
浪费时间!
显然,在某个层
Socrates:冷静些, Thrasymachus,你问问 Callicles写程序多久了。
次上注释确实
有用不信这个《1hrasymachus;CaIIcIesy《:Callicles,多久了?
的话,就说明你
的可的程序 Callicles个嘛,我在十五年前就在 Acropolis IV开始职业生涯。我经历过
解性跟
读者对程序的十多个重要系统从问世到淘汰的整个过程我工作过的系统就更多了。其中两个
理解程度无关。系统有五十万行以上的代码,所以我很清楚,注释其实没啥用。
-B.A.Sheil
Socrates:(看着年轻的程序员Thrasymachus) Callicles说得好,注释确有很
多实际问题,如果没有太多经验你是体会不到的。注释写得不合适只会起反作用。
代码大全(第2版)

<==========================820end ==============================>
<==========================821start==============================>

该书下载自书部落分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看
784
第32章自说明代码
Callicles即便写得好也没有。注释不像编程语言那么精确,我情愿彻底没有
注释。
Socrates:不是吧。 Ismene也认同注释是不很精确。她的意思是注释能给你
更高层次的抽象,而大家都知道抽象层次是程序员最有力的工具之一
Glaucon:我可不这么想。我们应该注意让代码更可读,而不是在注释上花费
太多精力。重构能消除我的大部分注释,重构之后,我的代码里写了二三十个子
程序调用都不需要注释了。高手读代码就能明白意图。如果你明知别人的代码有
错,还去了解其意图会有什么好处?(他对自己的发言很得意, Callicles点点头。)
Esmene(忽然像是对顶棚装饰块上的铅笔痕迹有了特别的兴趣):好像你们
这些人从不需要修改别人的代码。一年半载后再读读自己写的代码,你试试!这
样能提高阅读能力,改进你的注释。没必要专门挑选哪个程序去试验。读小说或
许不看章节标题还行,但如果是看技术类的书,就想能很快找到期望的部分。我
可不想为了找到想要修改的那两行,而耗费大量注意力去读懂儿百行代码
Glaucon:错,我明白注释能使扫视代码更方便。(他看过 Ismene的程序,
印象很深)可是说说看, Callicles还有其他观点,比如代码改变后注释过时怎么
办?我只编过几年程序,但据我所知,没人更新程序的注释。
Ismene:嗯, Callicles的话只说对了一半。如果把注释看得太严肃,反而去
怀疑代码,那就麻烦了。实际上,发现注释和代码的含义有差异,往往意味着两
者都不对。某些注释不好并不代表写注释就有错。我得去餐厅倒杯咖啡。
Callicles:我反对注释主要是因为浪费资源
Socrates:谁能想出尽量少花时间注释的办法?
Glaucon:用伪代码设计子程序,然后把伪代码转换成注释,在其中填入代码。
Callicles好吧,只要注释不是重复代码,应该可以。
代码大全(第2版)

<==========================821end ==============================>
<==========================822start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.c.com!仅供试看^
32.4高效注释之关键
785
Ismene:(从餐厅回来)写注释能让你更好地思考代码在干什么。如果注释
困难,要么是因为代码差劲,要么是没有理解透彻代码。不管怎样,都得对代码
再花时间。所以写注释并非在做无用功,而是指出你该做的工作。
Socrates:好了,没什么问题吧。我想今天 Ismene的发言最正确。我们该提
倡加注释,但也不能滥用注释。我们还要审查代码,这样每个人都将了解有益的
注释该是什么样。如果你们理解别人的代码时遇到麻烦,要告诉他如何改进。
32.4
Keys to Effective Comments
高效注释之关键
只要有不合理下面这个子程序在干什么?
怪的Java神秘子程序:第1号
缺陷和不切实/write out the sums1. n for all from to num
际的进度安排, current=1
就会有“真正的previous=0;
pre
程序员”挺身而sum=1
出“解决问题,for(inti=0i<num;i++)(
节省后面的文 System.out. printIn("sum=+sum)
档工作。Fortran
sum= current+ previous
万岁!
previous current;
-Ed Post
current sum;
猜出来了吗?
这段代码计算的是斐波纳契( Fibonacci)2,列的前num个值。其编码风格
比本章开头的子程序好一些,但注释错了。如果盲目相信注释,就会南辕北辙。
下面这段代码呢?
java神秘子程序:第2号
1/ set product to "base"
product base;
/ loop from to "num".
multiply"base"by"product"
product product base;
System.out.println("Product="+ product)
2译注: Fibonacci:斐波纳契(1175-1240),意大利著名数学家。斐波纳契数列是由其本人提出的
一种整数数列,其中每数等于前面两数之和。
代码大全(第2版)

<==========================822end ==============================>
<==========================823start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo. ^.com!仅供试看
786
第32章自说明代码
这段代码计算整数base的num次方。注释正确,但没有给代码带来信息,只
是用啰嗦的方式又说明了一遍代码。
Java神秘子程序:第3号
compute the square root of Num using the Newton-Raphson approximation
r =num 2;
while(abs((numr)) TOLERANCE)
r=0.5(r+(num/r))
System.out. printIn("r="+r)
它用来计算num的平方根,代码一般般,不过注释写得很准确。
哪个例程最易理解呢?这三个例程没有哪个写得特别好变量名尤其不怎
样。但它们毕竟展示了内部注释的优缺点。第一个例程的注释不对;第二个例程
的注释只是重复代码而毫无价值;只有第三个例程的注释真正有用。拙劣的注释
还不如没有好,前两个例程就是这样。
下面将说明撰写高效注释的关键。
Kinds of Comments
注释种类
注释的作用可以分为六种。
Repeat of the Code
重复代码
重复性注释只是用不同文字把代码的工作又描述一次。它除了给读者增加阅
读量外,没有提供更多信息。
Explanation of the Code
解释代码
解释性注释通常用于解释复杂、有巧、敏感的代码块。在这些场合它们能派
上用场,但通常正是因为代码含混不清,才体现出这类注释的价值。如果代码过
于复杂而需要解释,最好是改进代码,而不是添加注释。使代码清晰后再用概述
性注释或者意图性注释。
代码大全(第2版)

<==========================823end ==============================>
<==========================824start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看^
324高效注释之关键
787
Marker in the Code
代码标记
标记性注释并非有意留在代码中,它提醒开发者某处的工作未做完。有的开
发者在程序中打上句法不对的标记(*以便编译器就会标记之,并
提醒还有更多工作要做。还有的开发者在注释中放入特定的字符串,既不影响编
译又能搜索到它们
如果用户报告了某个代码问题,你调试跟踪到诸如下面这样的代码:
return NULL;* NOT DONE! FIX BEFORE RELEASE!!
向用户发布有缺陷的代码已经够倒霉了:如果你早就知道发布的代码有缺陷,则
更糟糕。
我发现很有必要规范标记型注释的风格。若不规范,程序员有的会用
**有的用,有的用“TBD”(To Be Done)等五花八门的方
式。各种各样标记的并存,只会让机器在搜索不完整的代码时很容易出错,甚至
无法进行。统一为特定的标记风格后,就可以将机器搜索不完整代码段的操作,
作为发布前检查清单的步骤之一,以避免前面所说的“FIX BEFORE RELEASE!
7
(发布前必须修正)问题。有些编辑器支持“too标记,还能容易地定位到这种
标记。
Summary of the Code
概述代码
概述性注释是这么做的:将若干代码行的意思以一两句话说出来。这种注释
比重复性注释强多了,因为读者读注释能比读代码更快。概述性注释对于要修改
你代码的其他人来说尤其有用。
Description of the Code's Intent
代码意图说明
目的性注释用来指明一段代码的意图,它指出要解决的问题,而非解决的方
法。比如:
-get current employee information
就是一条意图性注释,然而
update employeeRecord object
代码大全(第2版)

<==========================824end ==============================>
<==========================825start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
788
第32章自说明代码
则是有关解决方案的概述性注释。IBM曾进行过一项长达六个月的研究,发现负
RDA责维护的程序员老爱说“领会代码作者的意图是最困难的事情”(Fjelstad and
HARD DATA Hamlen1 1979)意图性注释和概述性注释并没有明显的界限,其差异也无关紧要。
本章到处都有意图性注释的例子。
Information That Cannot Possibly Be Expressed by the Code Itself
传达代码无法表述的信息
某些信息不能通过代码来表达,但又必须包含在源代码中。这种注释包括版
权声明、保密要求、版本号等杂项信息;与代码设计有关的注意事项;相关要求
或者架构文件的索引;联机参考链接;优化注记;诸如 Javadoc、 Doxygen等编辑
器要求有的注释,等等。
对于完工的代码,只允许有的三种注释类型:代码无法表述的信息、目的性
注释和概述性注释。
Commenting Efficiently
高效注释
高效注释并不费时。注释太多并不比注释太少好,你很容易达到折中点。
注释占用太多时间通常归因于两点。一是,注释的风格可能耗时或枯燥乏味。
如果这样,请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。
如果注释不便修改,人们就不愿意修改。于是乎,注释就会变得不准确,起到误
导作用,反而还不如没有注释。
二是因为说明程序干什么的话不好想出来,所以写注释太难。这通常是你没
有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序
上面,而不管你写不写注释,这些时间注定是得花的。
下面是高效注释的几条指导原则。
采用不会打断或抑制修改的注释风格任何太具想象力的风格维护起来都会
烦人。例如,请指出下面注释中何处不易维护:
Java示例:难以维护的注释风格
/Variable
Meaning
/------
/ xPos
//yPos.
XCoordinate Position (in meters)
. YCoordinate Position(in meters)
代码大全(第2版)

<==========================825end ==============================>
<==========================826start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看
32.4高效注释之关键
789
ndsCmptng...... Needs Computing =o if no computation is needed,
1 if computation is needed)
ptGrattl...
Point Grand Total
11ptValMax....... Point value Maximum
11psblScrMax.....Possible Score Maximum
你要是说那些前导字符()难以维护,就回答对了!它们是好看,但没有
也不碍事。修改注释时,它们会平添大量工作。如果必须选择其一,你应该力求
使注释准确甚于好看而通常确需做出这种选择。
下面是注释风格难以维护的又一例子:
C++示例:难以维护的注释风格
* class: GigaTronGIGATRON.cpp)
hrcoder
author: Dwight K.Coder
Routines to control the twenty-fir century's code evaluation
*tool. The entry point to these routines is the Evaluatecode()
routine at the bottom of this file.
*
这段注释看上去挺美观,显然是一个整体,头尾也很明显。修改这个注释段
的难易程度则不好说。如果想在注释内容的最后一行加入文件名,就得仔细调整
其右边的星号。假如要改变这段注释,左右两边的星号都需小心翼翼地设置。实
际上意味着整段注释都不便维护,因为工作量太大了。如果你按一下键就能得到
整齐排列的星号,那自然好,就用它吧。可星号本身并不是问题,整段注释都不
好维护。下面的注释看上去几乎和它一样美观,但维护却容易得多。
注释风格易于维护的C+示例:
C++示例:易于维护的注释风格
class: GigaTron (GIGATRON. CPP)
author; Dwight K. Coder
date: July 4,2014
Routines to control the twenty-first century's code evaluation
tool. The entry point to these routines is the Evaluatecode()
routine at the bottom of this file.★
★★★★★**★★★★★★**
代码大全(第2版)

<==========================826end ==============================>
<==========================827start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com!仅供试看^
790
第32章自说明代码
下面示例的风格也特别难于维护:
Microsoft Visual Basic示例:难以维护的注释风格
set up Color enumerated type
CODING
HORROR
onumeratd
'set up Vegetable enumerated type
+-----
很难搞清注释里各横线头尾位置的加号有何意义,但容易猜出每当注释改变
时,都得调整横线,以便尾部加号的位置能继续对齐。如果某行注释太长,因而
溢出为两行,该怎么办呢?加号如何对齐呢?难道去掉几个词让其只占一行?或
者按长度均分为两行?如果你试图持久地应用这种风格,就会更麻烦。
对Java和C++的一般编程原则就是遇到类似问题时,应对单行注释使用“”,
而对较长注释应用“*1”,如下所示。
Java示例:不同用途采用不同的注释语法
/1 This is a short comment
/ This is a much longer comment. Four score and seven years ago our
fathers brought forth on this continent a new nation, conceived in
1iberty and dedicated to the proposition that all men are created
equal. Now we are engaged in a great civil war, testing whether that
nation or any nation so conceived and so dedicated can long endure.
We are met on a great battlefield of chat war. We have come to
dedicate a portion of that field as a final resting-place for those
who here gave their lives that that nation might live. It is
altogether fitting and proper that we should do this
*/
第一个注释只要简短,就很容易维护。对于较长的注释,要是各行都要打双斜
线、手工断行,这么做就得不偿失了。所以,对于多行注释来说,“*”正合适。
关键是要注意如何分配你的时间。如果花大量时间增删横线,只是为了对齐
加号,你就不是在编程,而是浪费时光。去找个高效点的风格吧!对于那个用加
KEY POINT号的横线的情况,就该选用没有横线的注释。如果需用横线强调,就找其他办法,
代码大全(第2版)

<==========================827end ==============================>
<==========================828start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
32.4高效注释之关键
791
别用横线与加号的方式。有个办法是采取固定长度的横线,不管注释内容有多长。
这样的线不必维护,还能用文本编辑器的宏命令方便地添加。
交叉参考有用伪代码编程法减少注释时间假如写代码前以注释先勾勒出代码,你就会
关伪代码编程占尽先机。完成代码之日,也是注释写好之时,不必再去专门花时间注释。由于
过程的详细内
,请参看第9在填充低层次的编程语言代码前就已写出高层次的伪代码,因而可以获得所有
章“伪代码编程设计方面的好处。
过程”
将注释集成到你的开发风格中把注释集成到开发风格的相反做法是,项目
临结束才开始写注释,这么做缺点太多了。写注释成了专门的任务,工作量看起
来会比点滴积累的方式更大。事后再写注释将花费较长时间,因为你还得回忆或
思考某行代码干什么,不能像边编程边注释那样把正在考虑的内容写下来。由于
容易忘掉设计中的假设或细节问题,写出来的注释也不够准确。
反对注释的最常见理由是“当精力集中在代码上时,不该分心去写注释。”对
此的适当回答是,如果你编程时集中精力这么难,以至于写写注释就会打断思路,
那么你就该先用伪代码写,之后再把伪码转换成注释。要求注意力太过集中就是
一个警告信号。
如果你的设计很难进行编程,请在你担忧注释或代码之前先着手去简化设计
若你用伪代码理清自己的思路,编码就容易了,注释也自然而然就做好了。
POWT
性能不是逃避注释的好借口在4.3节中的讨论了“你在技术浪潮中的位置”
那里把技术浪潮解释为一种环境,在其中加入注释会付出性能下降的代价。在20
世纪80年代的早期 IBM PC里, Basic程序中的注释会让程序跑慢;90年代的asp
页面也是这样。到了21世纪初, JavaScript等需通过网络连接来传输的代码又表
现出类似的问题。
对于这些情况,最终的解决方案都不是不要注释,而是创建区别于开发版的
发布版代码,通常由专门对代码运行一次的工具完成,由它在把注释全清除掉,
作为构建过程的一部分。
大全(第2版)

<==========================828end ==============================>
<==========================829start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
792
第32章自说明代码
Optimum Number of Comments
最佳注释量
Capers Jones指出,【BM的研究发现,约每条语句有一个注释,这样的密
度时程序清晰度最高。比这小的注释密度会让代码难以理解;更多的注释也会导
HARD DATA
致向样效果( Jones2000)。
这类研究会被滥用,项目有时会采取诸如“程序必须每五行至少有一条注释”
的标准。这种标准应付的只是程序员代码不清的表象,而没有剖析其根源。
如果熟练运用伪代码编程法,日久天长你就会每几行有个注释。不过,注释数目
对方法本身起到副作用。与其操心注释数目,倒不如倾力于检查每个注释有无效用。
如果注释说明了写某代码的来由,又符合本章确立的各原则,这样的注释就足够了。
32.5注释技术
Commenting Techniques
依据注释所在的层次—程序、文件、子程序或单独行,有若十种不同的注
释技术。
Commenting Individual Lines
注释单行
对于好的代码,很少需要注释单条语句。要注释一行代码有两个可能的理由
■该行代码太复杂,因而需要解释
该行语句出过错,你想记下这个错。
关于单行注释,下面有些指导原则。
不要随意添加无关注释多年前我听过一个故事:有位负责维护的程序员半
夜里被叫起来,去修复一个出了毛病的程序程序的作者已离开公司,没法联系
上。这个维护程序员从未接触过这个程序。在仔细检查所有说明后,他只发现了
条注释,注释大致如下:
MOV AX,723hR...L.V.B.
这个维护程序员彻夜研究程序,还是对注释百思不得其解。不过还是成功地
打了个补丁,又回家睡觉了。几个月后,他在一个会上遇到了程序作者,才知道
注释的意思是“安息吧,贝多芬( Rest in peace, Ludwig van Beethoven3贝多
芬于1827年逝世,1827的十六进制正是723.那个地方需要的723h跟注释毫无
3译注: Ludwig van Beethoven:路德维希·范贝多芬(17701827),在全世界享有盛誉的德国作曲
家,留下许多传世佳作。
代码大全(第2版)

<==========================829end ==============================>
<==========================830start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! -www.shubule.com!仅供试看^
32.5注释技术
793
干系。真让人哭笑不得!
Endline Comments and Their Problems
行尾注释及其问题
行尾注释就是在代码行尾出现的注释。
Visual Basic示例:行尾注释
For employeeId 1 To employeecount
GetBonus( employeeId, employeeType, bonusAmount
If employeeType Employ
PayManagerBonus emplo
Else
If bonusAmount > MANAGER_APPROVALLEVEL Then
PayProgrammerBonus( employeeid, StdAmt))pay std. amount
Else
Pay ProgrammerBonus( employeeId, bonusAmount'pay full amount
End If
End If
End
Next
虽然在某些情况下有用,行尾注释还是会引起若干问题。这种注释位于代码
右边,不会影响代码的外观结构。但如果没把它们整齐布放,就会影响代码的视
觉结构。行尾注释往往很难格式化,如果你使用较多,光是对齐就需要花时间。
这些时间你本该用来加深代码理解的,却花到了不停按动空格或制表键的枯燥任
务上。
行尾注释维护起来也很困难。如果有行尾注释的某行代码增长了,它就会把
注释挤出去。难以维护的风格实际上就没人维护因此这种注释将随着修改而不
断恶化,而不会得到改进。
行尾注释还含混不清。因为代码行尾通常不会留下多少空间,要想保留注释
就意味着注释要短。工作变为让注释尽可能地短,而不是尽可能地清晰。
不要对单行代码做行尾注释除了实施问题,行尾注释还有若干概念性问题,
下面的示例有许多行尾注释:
C++示例:毫无用处行尾注释
amount
memoryToInitialize= MemoryAvailabl();/ get amount of memory available
这些注释只不
pointer GetMemory memoryToInitialize 1/ get a ptr to the available memory
过是对代码的
ZeroMemory pointer, memoryToInitial ) set memory to
重复。
FreeMemory pointer
/ free memory allocated
代码大全(第2版)

<==========================830end ==============================>
<==========================831start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo..com!仅供试看^
794
第32章自说明代码
行尾注释的系统性问题是,难以对每行代码都写一句有意义的注释。多数行
尾注释只是重复本行代码,这样起不了好的作用,坏处倒不少。
不要对多行代码做行尾注释如果企图用行尾注释说明多行代码,其格式将
很难说明它究竟应用于哪几行代码:
Visual Basic示例:针对多行代码的含糊不清的行尾注释
For rateidx 1 to rateCount Compute
recompute discounted rates
LookupRegularRate( rateIdx, regularRate
CODING
rate rateIdx)= regularRate discount rateIdx)
HORROR
Next
即便此特定注释的内容是对的,其位置也不合适。人们必须得读懂代码和注
释,才能了解该注释是专门为一条语句还是为整个循环体而设的。
When to Use Endline Comments
何时该用行尾注释
尽管前面反对行尾注释,但这些原则有下列三种例外情况。
行尾注释用于数据声明如果右边的空间有充裕行尾注释对于数据声明的
标注正合适,这时不存在像代码行上的行尾注释那样的系统问题。如果一行有132
个字符,通常就能在数据声明旁边对其做出清楚的解释说明。
交叉参考有Java示例:针对数据声明的良好行尾注释
关对数据声明 int boundary=0
1/ upper index of sorted part of array
做行尾注释的 string insertval=bank;/ data elmt to insert in sorted part of array
其他内容将在 int insertPos=0;/ position to insert elmt in sorted part of array
本节后面的“注
释数据声明”中
避免用行尾注释存放维护注记行尾注释有时用于在初始开发中记录修改。
介绍。
这种注释通常由日期和程序员姓名的首字母组成有时还包括错误报告编号,下
面是个示例:
fori1 to maxElmts-- fixed error#a42310/1/05(scm)
对软件产品调试一整晚后,加入这种注释能给人以满足感。但在产品代码中
确实不应有这种注释。此类注释还是由版本控制程序处理最好。注释应该解释代
码为什么现在能用,而不是过去某个时候为何不工作。
4译注:原书该标题为“Avoid using endline comments for maintenance notes”,上下文语义表明此句有
误,译文以“Use endline comments for maintenance notes”对待
代码大全(第2版)

<==========================831end ==============================>
<==========================832start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
32.5注释技术
795
交叉参考关于用行尾注释标记块尾用行尾注释标记大的代码块的结束位置是很合适的
注释的用法,将例如对于 while循环或者if语句。本章后面会对此详细叙述。
在块尾标记行尾
在本节后面“注
释控制结构”进除了这几种特殊情况外,行尾注释有着概念性的问题,而且常常用于很复杂
一步讨论。的代码,带来编排和维护困难。总之,最好不要用行尾注释。
Commenting Paragraphs of Code
注释代码段
在精心说明的程序中,多数注释都只要一两句话就能阐释一段代码:
ava示例:针对一段代码的良好注释
swap the roots
oldRoot root [o]
root[] root [1]
root[1] oldRoot;
该注释没有重复代码而是说明了代码的意图。这样的注释维护起来相对
容易。比如,即便发现两个root数组元素的值互换的方法有误,注释也无须更改。
非意图的注释就不那么好维护了。
注释应表达代码的意图注释应说明其后代码段的意图。下面是一个例子,
其注释由于描述的并非意图而效果欠佳:
Java示例:低效的注释
/* check each character in"inputString" until dollar sign
交叉参考该代码 is found or all characters have been checked
段完成简单的字符*
串查找功能,只是
done false;
为了说明用。实际
编程时,可使用 maxLen inputstring. length()
Java内置的字符串=0
,
库函数。对所用语 while(!done&&(i< maxLen))
言的理解有多重if( inputString[i==')
要?请参见33.3节
done true;
中的“阅读文档”。
else
i++
读了代码后,可以得知循环在查找“$”(注释要是这样写就会有帮助意义)
这个注释只不过重复了代码内容,并没有明了代码想干什么。下面的注释则好一
些。
代码大全(第2版)

<==========================832end ==============================>
<==========================833start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.c.com!仅供试看^
796
第32章自说明代码
/1 find '$ in inputstring
这个注释之所以好一点,是因为它指明了循环的目标是找到“$”。不过,它还是
没能给出再深层次的信息—为什么循环要找“$”?接下来的注释又进了一步:
/ find the command-word- terminator(s)
该注释实际包含了代码中没有的信息,即“$”是命令字的结束符。仅读代码是没
法知道这个事实的,因此这样的注释才真正有帮助。
另一种在意图层写注释的办法,就是想象如果将这段代码换成同样功能的子
程序,会怎样命名它。如果各段代码目的单一,这件事就不难做到。前面示例代
码段里的注释是说明问题的很好实例。“FindcommandWordTerminator()”就是
相当好的子程序名。其他诸如“Finds InInputstring()、“ CheckEach-
CharacterInInputStrUntilADollarsignIs-
Checked()”(检查输入字符串中的每个字符直到找到$或者所有字符都检查过)
显然都不像样(甚至没法用)。应该把它以未经缩写或简写地描述出来,就像为子
程序命名一样。这种说明就是注释,很可能描述的正是意图。
代码本身应尽力做好说明代码自身总是应首要检查的说明记录。前面例子
中,字符$应以具名常量代替,变量取名也应提供正在干什么的更多提示。如果想
KEY POINT再提高可读性,请添加一个存放搜索结果的变量。这样能将循环变量与循环结果
清楚地区分开。下面是采用好的风格和注释重写这段代码的结果:
ava示例:好注释、好代码
find the command-word terminator
foundTheTerminator false;
commanastringLength= inputstring. length()
testCharPosition 0;
while( foundTheTerminator&&(testc
if inputString[ testCharPosition
该变量存放搜
foundTheTerminator true;
rminstr:
索结果。
terminatorPosition= testCharPosition;
else
testCharPosition testCharpositio
代码大全(第2版)

<==========================833end ==============================>
<==========================834start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com!^.com!仅供试看
32.5注释技术
797
如果代码写得足够好,读起来就能接近意图的层次,以至能代替注释来说明
意图。到了这种程度,注释和代码呈现出某种重复性,不过很少有程序能好到出
现这种问题。
交叉参考关改进代码的另一步骤是创建名为 FindcommandWordTerminator(之类的子
于将一些代码
独立为子程序程序,将上面示例中的代码放进去。用注释说明思路是有用,但随着软件的进展,
的更多内容,请注释比子程序名更容易变得不准确。
参见24.3节中
的“提取子程序注释代码段时应注重“为何做(why)而不是“怎么做(how)”说明“怎
或者方法”。
么做”的注释一般停留在编程语言的层次,而不是为了说明问题。尽力阐述“怎
么做”的注释不大可能会告诉我们操作的意图,而且指明“怎么做”的注释通常
是冗余的。下面注释给出的信息有哪些是代码没有提到的呢?
java示例:着眼于“如何”的注释
1/ if account flag is zero
if( accountFlag==0)
HORROR
代码已经说出了该注释的意思。下面的注释怎么样?
java示例:着眼于“为何”的注释
anew accoun
/ if establishing a new account
if accountFlag ==0 ..
这个注释好得多,因为它给出了代码没能提供的信息。代码自身仍可以继续
改善——用有意义的枚举类型名来代替0变量再换好一些的名。下面是注释和
代码最好的表现:
Java示例:着眼于“为何”的注释,并有良好编码风格
if establishing new account
if account Type = AccountType. NewAccount
若代码的可读性达到这种程度,注释的作用就受到了动摇。由于改善了代码,
注释显得多余,以至于可能被删掉。注释的出路是,其功能可以微妙地变换一下,
就像这样:
Java示例:使用“小节标题”注释
/1 establish a new account
if accountType ==AccountType. NewAccount )
代码大全(第2版)

<==========================834end ==============================>
<==========================835start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看
798
第32章自说明代码
如果注释说明的是if条件语句后面的整段代码,它就成为概述性注释,于是
将它留作小节标题还是比较合适的。
用注释为后面的内容做铺垫好的注释会告诉读者后面有什么内容。读者只
要浏览注释就能够了解代码在做什么,到哪去找特定的操作。这一规则必然要求
注释总应出现在它作用的代码前面。这个思路不应只在编程课上学学而已,还应
是商业实践明确树立的标准。
让每个注释都有用过度注释不是优点—太多的注释只会把其要阐明的代
码搞得含混不清。与其写很多注释,还不如对代码本身的可读性下功夫。
说明非常规做法假如代码本身有些含义未表达明显,就把这些含义放在注
释里。若是用了拐弯抹角的技巧而非直截了当的办法,以求获得性能的提升,请
用注释指出直接方法该怎样做,并量化出你那个花招到底能提高多少性能。下面
是一个例子:
+例:说明非常规做法
for( element0; element elementCount; element++)
/ Use right shift to divide by two.Substituting the
1/ right-shift operation cuts the loop time by 758
elementList element elementList[ element > 1;
其中的向右移位操作是有意为之的。整数向右移1位等于将其除以2,这对有经
验的程序员来说是个常识。
既然是常识,还说明它干什么?因为此处并不是要向右移位,而是执行除以
二的操作。代码没有采取与其目的相匹配的方式而大部分编译器都会将整数除
以二操作优化为向右移位操作,大可不必用这种降低程序清晰度的做法。在这一
特例中,由于已知编译器不会优化整数除以二操作,所以能节约可观的时间。有
了这个标记,读代码的程序员就能理解为何要用这种隐晦的技术。如果没有注释,
他就会抱怨代码没必要耍“小聪明”,又不能带来性能提升。这种抱怨通常是有道
理的,因此确有必要把出乎意料之处标记出来。
代码大全(第2版)

<==========================835end ==============================>
<==========================836start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看^
32.5注释技术
799
别用缩略语注释不应有歧义,应当易读而无须猜测缩写为何意。注释里不
要用缩略语,除非后者很常见。除了行尾注释,缩略语一般没有用场;即使是行
尾注释,也应意识到缩略语不利于可读性。
将主次注释区分开有时,你也许想把不同层次的注释区分开,以指明某个
细节注释是先前某个注释(概括)的一部分。用多种方式可以做到这一点。可以
尝试对主注释加下画线,而次注释不加的办法。
C++示例:使用下画线区分主次注释不建议这么做
主注释标以横 copy the string portion of the table, along the way omitting
线。
/1 strings that are to be deleted
次注释用于主 determine number of strings in the table
注释所述操作
的某部分,不
加横线。
mark the strings to be deleted
这也是次注
释
该办法的缺点是,你不得不对太多的注释加下画线。如果为某注释加了下画
线,那么其后所有没有下画线的注释都似乎从属于它。因此在写注释时,只要不
从属于前面有下画线的注释,都得加下画线,这种情况到处都会有。结果,代码
中会有太多下画线。或者因为某些地方有,而另一些没有,导致格式不统一
该方案的很多变通办法都有同样的问题。例如主注释的字母都大写,而次注
释都小写,跟太多下画线类似,你会有太多的大写字母。有的程序员对主注释的
首字母大写,而次注释仍小写,但其视觉差别很容易被忽视。
好些办法是在次注释前面加入省略号;主注释以普通方式编排。
主注释为一般C++例:用省略号区分主次注释 the way omittin
格式。
/1 copy the string portion of the table, along the way omitting
/1 strings that are to be deleted
次注释用于主 determine number of strings in the table
注释所述操作
的某部分,省
.. mark the strings to be deleted
略号开头
这也是次注
释
代码大全(第2版)

<==========================836end ==============================>
<==========================837start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看^
800
第32章自说明代码
还有一种通常是最好的办法—将主注释所述的操作独立为子程序。子程序
逻辑上应是“扁平的”,其所有行为都在同一个逻辑层次。如果子程序区分主行为
和次行为,该子程序就不是扁平的。通过将复杂行为打包放进各自的子程序,可
以使其成为两个逻辑上平行的子程序,而不是一个逻辑上跌宕起伏的子程序。
这里对主次注释的讨论并不适用于循环和条件语句中的缩进代码。在后者中,
循环开头有一概述性注释,对缩进代码有更详细的注释。这些情况下,缩进格式
提供了注释的逻辑组织线索。这些讨论只适用于顺序的代码段,其中若干段组成
完整操作,一些段从属于其他段。
错误或语言环境独特点都要加注释如果代码有误,这个错误也许没有记录。
即使在什么地方记录过,你在代码中再记录一次也没坏处;假如是未说明的特性,
根据其阐述得知从未在别的地方记录过,你就应该记录在代码里面。
假设你发现库函数 WriteData(data, numItems, blocksize)只要
blocksize不等于500就能正常工作。对于499、501等你试过的所有数都没错;
仅当 blocksize为500时,才会表现某个缺陷。那么在用到 WriteData()的代
码处,请说明你为何要特殊对待 blocksize等于500的情况。正如下面的例子那
样:
Java示例:说明绕过某个错误的方法
blocksize optimalBlocksize( numIt
sizeperItem )
/ The following code is necessary to work around an error in
WriteData() that appears only when the
ecals
d parameter
tant
equals 500. 500' has been replaced with a named constant
for clarity.
if blocksize = WRITEDATA_BROKEN_SIZE
blocksize WRITEDATA
WriteData(file,data, blocksize
代码大全(第2版)

<==========================837end ==============================>
<==========================838start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo..com!仅供试看^
32.5注释技术
801
给出违背良好编程风格的理由如果你不得不违背良好的编程风格,要解释
其原因。以免善意的程序员去改善代码的风格从而破坏你的代码。该解释要说
清你是故意那么做的,而非马虎造成的免得给别人留下不好的印象。
不要注释投机取巧的代码,应重写之下面的注释源于我工作过的某个项目。
+示例:注释“聪明”的代码
1/ VERY IMPORTANT NOTE: to i Pu
11The constructor for this class takes a reference to a Ui Publication.
HORROR
1DatabasePublication object. If it is, the DatabasePublication
11 object will cause the program to die a horrible death.
该例体现了一个盛行而危险的编程说法——注释该用来说明特别“技巧性的
/tricky""”或者“敏感的/sensitive”的代码部分。理由是让人们知道,在那些地方操
作时应小心。
这个想法真可怕!!!
对投机取巧的代码注释是错误的。注释不应帮扶难度大的代码,就像
Kernighan和 Plauger强调的:“不要注释糟糕的代码应重写之。”(1978)
一项研究表明:源代码中有大量注释时,也容易存在许多毛病,并耗费不少
开发精力(Lind and Vairavan1989)。两位作者认定程序员总会对难度大的代码标
HARD DATA注大量注释
当有人说“这些代码富于技巧(tricky)”时,我会认为他们的意思是“这些
代码实在糟糕”。若某事对你来说像是技巧对别人来说会难以理解。甚至某事对
KEY POINT你似乎不算技巧,也许对那些未见过的人来说是不可能解决的。假如你需要问问
自己:“这富于技巧吗?”那么它肯定是富于技巧的。你总会找到不用技巧的方法,
因而请重写代码。将代码完善到没有注释的最好程度,然后添加注释使其更完善。
这个建议主要适用于你首次写代码。如果你在维护程序,不负责重写坏的代
码,那么注释那些技巧性的部分就是好的做法。
代码大全(第2版)

<==========================838end ==============================>
<==========================839start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
802
第32章自说明代码
Commenting Data Declarations
注释数据声明
交叉参考有变量声明的注释应给出变量名未表达出来的各种信息。数据应小心说明,这
关格式化数据
的详细内容,请很关键。至少有一家公司根据自身实践得出结论对数据注释比对使用数据的
参看31.5节中过程做注释更重要(SDC1982)下面是注释数据的指导原则。
的“数据声明的
布局”;关于如
何高效地使用
注释数值单位如果某数值表示长度,请指明长度单位是英寸、英尺、米还
数据,请参看第是千米;如果为时间,应指明是1980年1月1日到此时刻之间的秒数,还是程序
10章至第13启动后到此时刻的毫秒数,等等;如果为坐标,应指明是纬度、经度、海拔高度
章。
中的哪一个,以及是弧度还是角度,是否表示XY坐标系,原点是否位于地球中
心,等等。不要觉得单位是不言自明的新手不知道:工作于系统另一部分的
人也不知道;要是程序经历实质性修改,也难保单位没有改动过。
替代做法是,很多情况可以将单位写进变量名,而不再用注释。表达式
“ distanceToSurface marsLanderAltidude”也许正确,但
aistanceToSurfaceInMeters marslanderp则明显不对
交叉参考说对数值的允许范围给出注释如果变量有一个期望范围,就该说明这个范
明变量分许值围。Ada编程语言有个强大特性,就是能限制数值变量的值应在指定范围内。如
的技术是在子果你的语言不支持这种功能(多数语言都不支持),就应该用注释来说明范围。例
程序首尾处确
保变量的值应
如,如果变量代表以元为单位的钱数,可以指明期望范围是1元到100元;如果
在指定范围内。变量表示电压,则其期望的范围可为105伏到125伏。
详细内容请参
看8.2节“断
注释编码含义如果你的语言支持枚举类型例如C++、 Visual Basic,请
”。
用它表达编码含义;如果不支持枚举类型可用注释来指出各值的含义请用
具名常量表示,而非文字量。比如某变量表示电流类型,应当注释说明1代表交
流电,2是直流电,3是未确定。
下面是注释变量声明的示例,它描述了这三个建议变量的范围信息都通
过注释说明。
代码大全(第2版)

<==========================839end ==============================>
<==========================840start==============================>

该书下载自-书部落-分享计算机经典巨著!--w !--www.shubulo.c.com!仅供试看^
32.5注释技术
803
Visual Basic示例:注释良好的变量声明
Dim cursorX As Integer horizontal curs
ntal cursor position; ranges from 1.. Maw
xCo
s
Dim cursorY As Integer vertical cursor position; ranges from 1. MaxRows
Dim antennaLength As Long 'length of antenna in meters; range is >=2
Dim signalstrength As Integer strength of signal in kilowatts; range
is>=1
Dim characterCode As Integer ASCII character code; ranges from 0..255
DimcharacterAttribute As Integer Plain;l= -Italic;2=bold;3=Bolditalic
Dim charactersize As Integer size of character in points; ranges from
4..127
注释对输入数据的限制数据输入来源包括传入的参数、文件和用户的直接
键入。前一条原则适用于包括子程序参数在内的数据。应将希望输入的值与不希
望的值都说明出来。注释是说明某子程序不愿接收某些数据的一种方法。而
ASSERT是另一种说明有效范围的方法,采用这种方法更能让代码具自检能力。
注释“位标志”若变量用作位域,就应该对每个数据位的含义做出说明。
交叉参考有 Visual Basic示例:说明“位标志”的代码
of the bits in statn
关标志变量命, The meanings of the bits in statusFlags are as follows, from most
请参见11.2节 significant bit to least significant bit:
名的详细内容,
MSB error detected:=yes, =noin-severe.
中的“为状态变1-2 kind of error:0=syntax,=warning,2=severe,3fatal
量命名”。
3 reserved (shoula be 0)
4 printer status:=ready,=not ready
not used (s
should be 0)
LSB 15-32 not used (should be 0)
Dim statusFlags As Integer
如果示例用的是C++,应采取位操作语法,以表明其位意义。
将与变量有关的注释通过变量名关联起来如果注释提到特定的变量,应确
保变量名更改后,该注释也随之更新。要提高这种一致性修改的可能性,就应将
变量名放在注释中。这样,通过字符串查找,就能在搜索变量名时,连同找出含
有变量名的注释。
交叉参考有
注释全局数据如果用了全局数据,要在其声明处做出注释。注释要指出该
使用全局数数据的目的、为何必须是全局数据。在使用此数据的每一处,都突出它是全局数
关
据的详细内容,
请参看13.3节据。好的命名规范是凸现变量全局性的首选办法,如果欠缺这样的规范,则可以
“全局数据。用注释代劳。
代码大全(第2版)

<==========================840end ==============================>
<==========================841start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.c.com!仅供试看^
804
第32章自说明代码
Commenting Control Structures
注释控制结构
交叉参考关
于控制结构的
控制结构前面的位置通常是放置注释的一个天然空间。如果是一个if或者
节,请
考31.3节“布ase语句,你可以提供为什么要进行判断的理由,以及执行结果的一个总结。如
局风格”、31.4果是一个循环结构,你可以指出这个循环的目的是什么。
节“控制结构的
布局”及第14
章至第19章。C++示例:注释一个控制结构的意图
下面循环的目→ copy input field up to comma
的
while((*inputString=)&(*inputString=end_of_STRING)
*field *inputstring;
循环结尾(对
field++;
较长或嵌套的
inputstring++i
循环很有用,} while copy input field
尽管需要这种
注释意味着代*fieldEND_OF_STRING
码过于复杂
了)
if (*inputString ! END_OF_STRING )
这里指出了循
/ read past comma and subsequent blanks to get to the next input field
inputString++.
环的目的。注
释位置清楚标
while((*inputstring==)&(*inputString=end_of_STRING)
明 inputstring
9
inputstring++;
是在为循环做/if-- at end of string
准备的。
这个例子建议了若干原则。
应在每个if、case、循环或者代码段前面加上注释这个位置放注释再合适不
过了,而且这些结构往往需要解释。注释起到阐明控制结构意图的作用。
应在每个控制结构后加上注释注释说明结局如何,举个例子:
}// for clientIndex- process record for each client
长循环或嵌套循环结尾处的注释尤其有用。下面是用注释指明循环结构结束
的Java示例。
java示例:使用注释标明嵌套
for( tableIndex0; tableIndex< tableCount; tableIndex++)
while recordIndex recordCount
if( II1legalRecordNumber( recordIndex))
这些注释指示
}/
结尾是哪个控
}11while
制结构的。
1/ for
该注释技术为代码缩进所给出的逻辑结构补充了视觉线索。对未嵌套的短循环无
须使用这种技术。但当嵌套层次较多,或循环体较长时,这一技术就有用武之地了。
代码大全(第2版)

<==========================841end ==============================>
<==========================842start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo. con!.com!仅供试看^
32.5注释技术
805
将循环结束处的注释看成是代码太复杂的征兆如果循环复杂到要在末尾注
释,就该把后者看作为警告循环体大概得简化。这一原则同样适用于复杂的
if和case语句。
循环结束处的注释提供关于逻辑结构的有用线索,但开始时就加上,之后还
得维护是很令人头痛的事情。避免麻烦的最好办法就是重写代码,使之不再复杂
到需要费劲注释的程度。
Commenting Routines
注释子程序
交叉引用有注释子程序级的代码,是计算机学典型教材给出的最坏建议。许多教科书怂
关格式化子程
序的详细内容,恿人们无视子程序的大小和复杂程度,在每个开头都放置一大堆信息。
请参看31.7节 Visual Basic示例:庞杂累赘的子程序导言
“子程序的布**★★********
★★★★★★★★
局”;关于如何Name: CopyString
创建高质量的
子程序,请参看 Purpose: This routine copies string from the source
第7章“高质量 string(source) to the target string(target
的子程序。
Algorithm: It gets the length of "source" and then copies each
the loop index as an array index into both "source"
and "target" and increments the loop/array index
after each character is copied.
COD
HORROR
Inputs:
e strinato
input The string to be copied
outhe strina to receive the cony ofinnut
Outputs: output The string to receive the copy of "input"
Interface Assumptions: None
Modification History: None
Author:
Dwight K. Coder
Date created: 10/1/04
ssone:
(555)222
2255
SSN:
111-22-3333
Eye Color: Green
Maiden Name: None
Blood Type: AB-
Mother's Maiden Name: None
Favorite Car: Pontiac Aztek
Personalized License Plate: "Tek-ie".
★★★★★★★★★★*★★★★*★★★★★★★★★★★★★★★★
代码大全(第2版)

<==========================842end ==============================>
<==========================843start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
806
第32章自说明代码
真可笑!一想便知 CopyString只是简单的子程序代码可能连5行都不
到。这样的注释完全是喧宾夺主。子程序的意图和算法那两部分只是摆设,因为
对于 CopyString,很难再找到比“复制字符串”和代码本身更详细的解释了。还
有接口假定和修改历史的花俏注释也毫无用处,只是多占了几行空间。标注作者
姓名的要求是多余的,通过版本控制系统可以获得更精确的信息。如果对每个子
程序都要求有这些内容,会导致注释不准确、无法维护,还空耗了许多工作量。
庞大的子程序头还带来另个问题:抑制了好的代码分解过程因为生成
子程序的额外开销太大了,程序员将会(错误地)倾向于少创建子程序,而非多
创建一些。编程规范应鼓励好的做法,而庞大的子程序头则是唱反调
下面是注释子程序的一些指导原则。
注释应靠近其说明的代码子程序不该有庞大的注释头,原因之一是注释头
太大会把注释距其说明的对象较远,不便于随代码一起维护,从而注释和代码开
始不一致,然后某个时候注释就失去了存在的价值。相反,遵循靠近原则,尽可
能地拉近注释和其说明的代码之间的距离,它们就容易得到维护,从而持久发挥
其作用。
后面将介绍子程序头注释的若干组件,可根据需要选用为方便起见,请创
建一个头注释的样板文件。不要以为各种情况下都将所有信息都加进去,只取其
中要紧的东西,其余部分弃之不用即可。
交叉考好
的子程序名字
在子程序上部用一两句话说明之如果不能用一两句话说清楚,有必要考虑
对注释子程序你到底想让程序做什么。要是不便做出简的说明,就意味着设计还嫌不足。
很关键。关于命请回到设计提纲再试试。原则上所有子程序都应附概述性说明,除非已有很简单
名方法的详细
内容,请参见的et/et访问器子程序。
73节“好的子
程序名字
在声明参数处注释这些参数说明输入输出变量的最简便方式,就是把注释
放在各参数声明的后面。
代码大全(第2版)

<==========================843end ==============================>
<==========================844start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看^
32.5注释技术
807
Java示例:在声明输入输出数据时就加以注释良好的实践
public void InsertionSort (
int dataToSort, / elements to sort in locations firstElement.. lastElement
int firstElement, index of first element to sort (>=0)
int lastElement index of last element to sort (< MAX_ELEMENTS)
交叉参考行该做法是“不要用行尾注释”原则的恰当例外,在用来说明输入输出参数的
尾注释在前面时候相当好。这一特定例外也有力说明对于子程序参数清单使用标准缩进,而
其问题”中曾详非行尾缩进的意义——如果采用行尾缩进,将没有空间放入能说清问题的注释,
细讨论过。即使本例采取标准缩进都嫌紧张。从这个示例还可以看出,注释并非说明的唯一
形式。变量名取得足够好就能省掉注释。最后一点是,对输入输出变量标有说明,
可作为避免使用全局数据的充分理由—在哪儿注释它们呢?或许,你会在庞大
的序言中说明全局数据,造成更多的工作,可惜这样实际意味着全局数据没有说
明。那真是太糟了,因为对全局数据的标注量起码不应少于其他东西。
利用诸如 Javadoc之类的代码说明工具假如前一例子实际以va编写,可
以利用Java的文档抽取工具 Javadoc来获得配备代码的额外能力。则“在声
明参数处说明之”就变成:
Java示例:利用 Javadoc标注输入输出数据
*
Cparam dataTosort elements to sort in locations firstElement.. lastElement
*eparam firstlement index of first element to sort (>=0)
@param lastElement index of last element to sort (< MAX_ELEMENTS)
insertionso
public void InsertionSort(
int[ dataTosort,
int firstElement,
int lastElement
有了 Javadoc这样的工具,通过其配置代码以便抽取说明的好处,可以胜过
把参数描述从参数声明中分离的风险。如果你的工作环境不支持说明抽取功能
最好让注释离参数名近些,以免不一致的更动及参数名重复。
代码大全(第2版)

<==========================844end ==============================>
<==========================845start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
808
第32章自说明代码
分清输入和输出数据知道哪个数据作为输入,哪个作为输出是很有用的。
Visual Basic中区分相对容易,因为输出数据以 ByRef关键字打头,输入数据则以
Byva1关键字打头。若所用语言不支持自动区分,就将区分说明放入注释。下面
是一个C++示例:
交叉参考这C++示例:区分输入输出数据
些参数的顺序 void stringCopy(
是按C+子程char*target,
out: string to copy to
有悖于更 const charsource in: string to copy from
的做法。有关细
节请参见75节
中的“按照输入
C++的子程序声明有些玄机,因为某些时候星号(*)表明参数用来输出,更
一修改输出的多时候只是表示变量作为指针,处理起来会比非指针类型容易。通常应将输入和
顺序排列参
数”;关于用命输出参数明确区分开。
名规范区分输
入输出数据的
详细内容,请参
子程序较短,你又能维持对输入输出数据的清晰区分时,大可不必注释数据
见11.4节。的输入输出状态。然而,如果子程序较长,这些注释对读子程序的人会很有用。
交叉参考子
程序接口的其
注释接口假设注释接口假设可被看作其他注释原则的一部分。假如你做了
他考虑可参见变量状态的假设合法和不合法的值、排过序的数组、初始化过的或只包含正
7.5节“如何使确值的数据成员,等等应在子程序前面或数据声明的地方说明。这种注释理
数”要用断言应表现在所有的子程序中。
说明假设,请参
见82节中的
“用断言来注
要确保注释了所有的全局变量。全局变量与其他东西一样,也是子程序的接
解并验证前条口。但它有时看上去不像变量,所以是很危险的。
件和后条件”。
写子程序时,若意识到自己在做接口假设,应立即将其记录下来。
对子程序的局限性作注释如果子程序提供数值结果,请指出结果的精确度;
要是某些条件下的计算没有定义,请标注这些条件;假定子程序碰到麻烦时有默
认行为,请说明此行为;若希望子程序只工作于特定大小的数组或表格,请指出
这一情况;如果你知道对程序做某些修改会损坏此子程序,请说明是哪些修改;
如若开发子程序时想起什么问题,也请注释出来。
代码大全(第2版)

<==========================845end ==============================>
<==========================846start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. --www.shubulo.com.com!仅供试看
32.5注释技术
809
说明子程序的全局效果如果子程序会修改全数据,要确切描述它对全局
数据做了些什么。正如13.3节中“全局数据”提到的那样,改动全局数据至少会
比只读它危险,因此应谨慎对待全局数据的修改。该做的部分工作就是说明要清
晰。若注释变得吃力,照例得重写代码,以减少全局数据。
记录所用算法的来源如果用了从一本书或杂志上得来的算法,请注释其出
处的卷号和页码。如果是自行开发的算法,要指出在何处读者可以找到对其的解
释。
用注释标记程序的各部分有些程序员用注释来标记程序的各部分,从而便
于他们查找之。这一技术在C++和Java中,就是于子程序前面标注如下字符串开
头的注释:
/*★
这样就可以通过查找字符串“**”,在子程序间跳转。如果编辑器能够支持,
则可实现自动跳转。
与此类似的技术是,根据注释说明内容的不同对其使用不同的标记。例如,
C++中可用“@keyword”,其中“ keyword”是用来指示注释种类的编码;“@param
”
指示注释说明的是子程序参数:“@version”指示文件的版本信息;“@throws”指
示子程序抛出的异常。这一技术允许用工具从源文件中抽取各种各样的信息。
比如通过查找@ throws,可取得对程序里所有子程序抛出异常的说明。
cc2e.com/3259
此C++规范基于专为Java程序建立的、完善的接口说明规范 Javadoc规
范(java.sun.com/j2se/javadoc/)。在其他语言里,你可以自定义规范
Commenting Classes, Files, and Programs
注释类、文件和程序
交叉参考有关
布局的细节请参
类、文件和程序的共同特征是它们都包含多个子程序。文件或类应包含彼此
看31.8节“类的相关的一组子程序;程序包含了所有的子程序。各情况下注释的任务就是要对文
布”有关使件、类或程序内容提供有意义的概括说明。
用类的细节请参
看第6章“可以
工作的类”。
代大全(第2版)

<==========================846end ==============================>
<==========================847start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
810
第32章自说明代码
General Guidelines for Class Documentation
标注类的一般原则
对每个类使用注释块来说明类的一般属性。
说明该类的设计方法有的信息通过编码细节“逆向工程”是难以获得的,
如果概述性注释能提供这些信息,将会特别有用。在其中应说明类的设计思路、
总体设计方法、曾考虑过后又放弃的其他方案,等等。
说明局限性、用法假设等类似于子程序,应确保说明类设计的局限性,还
应说明输入输出数据的假设、出错处理的责任划分、全局效果和算法来源,等等。
注释类接口其他程序员不看类实现就能明白类的用法吗?如果不是,类的
封装就有严重问题。类接口应该包含别人使用该类时所需的全部信息。 Javadoc规
范要求为每个参数和返回值都有起码的说明(Sun Microsystems2000), Bloch
呼吁各个类的公用子程序都应该这样做(Bloch2001)
不要在类接口处说明实现细节封装最重要的一个规则是仅公开那些“需要
知道”的信息。若拿不定是否应公开某项信息,就隐藏之因此类接口文件应
当只有类的用法信息,而不应有需要实现或维护类内操作的信息。
General Guidellnes for File Documentation
注释文件的一般原则
在文件开头处用注释块说明文件的内容。
说明各文件的意图和内容文件头注释应说明文件中的类或者子程序。如果
程序的所有子程序都在一个文件里,则该文件的意图就不言而喻了文件就是
整个程序。要是文件包含有某个类,其意图也很明显同名类正是包含在此文
件中。
倘若文件包含多个类,请解释为何这些类需要放到一个文件中
假如将程序划分为多个源文件并非出于模块化的考虑,则对各文件用意的说
明将对修改程序的程序员更有帮助。如果别人要找出做某事的子程序在哪儿,文
件头注释有助于确定该文件含不含此子程序吗?
代码大全(第2版)

<==========================847end ==============================>
<==========================848start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看^
32.5注释技术
811
将姓名、电子邮件及电话号码放到注释块中对于大型项目,源代码中的作
者信息,特别是责任者信息,是很重要的。少于10人的小项目可以采用“协同开
发”的方法例如共享代码所有权—使小组各成员对于全部代码承担均等责
任。而大型系统需要程序员各自专心于不同区域的代码,从而使整个团队共享代
码所有权的做法不可行。
在此情况下,源代码中的作者信息就很重要,后者能够让其他程序员了解编
程风格、联系方式,以便在需要帮助时联系。根据你工作于单个子程序、类还是
程序,请在对应位置加入作者信息。
包含版本控制标记许多版本控制工具会对文件插入版本信息以CVS为例,
字符
//sIas
会自动扩展为
sid: ClassName.java,v1.12004/0/0500:36:43 ismene Exp
从而只要插入“$Id$”初始注释,无需额外操作就可以在文件中维护当前版
本信息。
请在注释块中包含法律通告许多公司喜欢在程序中包含版权声明、保密声
明及其他法律方面的通告。若贵公司也这样,可以将如下所示的行加到注释里。
请与公司的法律顾问协商,决定哪些信息(如果有的话)应包含在文件中。
ava示例:版权声明
/(c) Copyright 1993-2004 Steven C. McConnell. All Rights Reserved.
将文件命名为与其内容相关的名字文件名一般应与其中的公开类的类名有
紧切关系。例如类名为Employee,则文件名就应是 Employee.cpp有些语言特
别是Java,要求文件名和类名相同。
代码大全(第2版)

<==========================848end ==============================>
<==========================849start==============================>

该书下载自-书部落-分享计算机经典巨著!w. ! --www.shubulo.c.com!仅供试看^
812
第32章自说明代码
The Book Paradigm for Program Documentation
程序注释以书本为范例
深入阅读该讨多数有经验的程序员会赞成前面各节所述的注释技术很有用。实际上哪项技
论节选自Oman
和C00k于1990术都少有科学的、确凿的证据,然而,当这些技术组合使用时,则能有力证明其
年写的两篇文章效果。
The Book Para-
digm formprov1990年, Paul Oman和 Curtis Cook发表了有关对注释应“以书本为范例”的
(以书本作为改两个研究成果(1990a、1990b)。们试图找到一种能够支持不同代码阅读方式的
善维护性的范例编程风格,其目标是同时支持自上而下、自下而上和中心搜索另一个目标则是
Style More将程序分成便于记忆的块,而不是铁板一块的长长清单。Oman和Cook希望这个
Than C
版面风格不只风格能同时提供高层次和低层次的代码组织线索。
是装饰)。类似分
析在 Baecker和
他们发现,将代码看作是一类特殊的书籍,并据此进行编排,就能够实现其
Marcus于1990目标。按照书籍的风范,代码及其说明应组织成若干组件,就像一本书的内容分
年所著的( Human
Factors and Typ--为几个部分,可以帮助程序员获得对程序的高层次认识。
ography for More
Readable Progr.
ams》人性因素
“序”为一组常见于文件头的注释,起到介绍程序的作用。它和书的序功能
与更可读的程序相通,提供有关程序的概况。
详细介绍。
“目录”给出顶层文件、类和子程序(即“章”)。它们可以是清单形式,就
如同书本列出章节那样,也可以结构图的形式表示。
“节”,则是子程序内的各单位,例如子程序声明数据声明和可执行语句。
“交叉引用”是代码的“参阅”映射,其中含有行号。
Oman和Cook利用书籍和源代码的相似性,创造出各种低层技术。这些技术
与第31章“布局与风格”和本章提出的技术有异曲同工之处。
为了验证这些组织代码技术的效果,Oman和Cook交给组有经验的专业编
程员一个任务—维护长达1000行的程序。结果发现,程序员维护采用这些技术
HARD DATA的程序时,所花的时间只是维护传统程序清单时的四分之三,而维护质量则平均
高出20%。Oman和Cook于是得出结论:通过注意运用书本设计的编排原则,对
程度的理解将能改善10%到20%。一项由多伦多大学的程序员参与的研究也得到
类似结果(Baecker and Marcus1990)
代码大全(第2版)

<==========================849end ==============================>
<==========================850start==============================>

该书下载自-书部落分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
32.6EEE标准
813
“以书本为范例”强调了对程序组织同时提供高低层说明的重要性。
32.6
IEEE Standards
IEEE标准
对于源代码层以外的说明,IEEE(电子与电器工程师协会)的软件工程标准
是很有价值的信息源。IEEE标准是由一组专注于特定领域的专家和学者协同开发
出来的。每个标准都有其涵盖领域的概述,通常还有在这些领域说明的纲要。
一些国内和国际组织主持标准制定的工作。IEE在定义软件工程的标准化方
面走在前列,其许多标准被ISO(国际标准化组织)、i(电子工业协会)和eC
(国际电工委员会)采纳。
标准的全称由编号、采用年份以及标准名组成。所以“IEEE/EIA Std12207
1997, Information Technology-Software Life Cycle Processes意指标准编号为
12207.2,1997年被IEEE和EA采纳。
对软件项目最有用的(美国)国家标准以及国际标准是:
cc2e.com/3266
顶层标准“IS/IEC Std12207. Information Technology-Software- Life Cycle
Processes",是定义开发和管理软件项目时的生命周期框架的国际标准。它被美国
采纳为“eee/EIA Std12207. Information Technology-Software Life Cycle
Processes”国家标准。
Software-Development Standards
软件开发标准
cc.com327下面是应考虑的一些软件开发标准:
IEEE Std 830-1998, Recommended Practice for Saftware Requirements Specifications
IEEE Std 1233-1998, Guide for Developing System Requirements Specifications
IEEE Std 1016-1998, Recommended Practice for Software Design Descriptions
IEEE Std 828-1998, Standard for Software Configuration Management Plans
IEEE Std163-200, Standard for Software User Documentation
IEEE Std219-1998, Standard for Software Mainterance
代码大全(第2版)

<==========================850end ==============================>
<==========================851start==============================>

该书下载自书部落分享计算机经典巨著!--www. ! --Www.shubulo.com!^ .com!仅供试看^
814
第32章自说明代码
Software Quality-Assurance Standards
软件质量保证标准
cc24.com3280
下面是一些软件质量保证的有关标准:
IEEE Std 730 2002, Standard for Software Quality Assurance Plans
IEEE Std 1028 1997, Standard for Software Reviews
IEEE Std 1008-1987 (R1993), Standard for Software Unit Testing
IEEE Std 829-1998, Standard for Software Test Documentation
IEEE Std 1061-1998, Standard for a Software Qualiry Metrics Methodolog
y
Management Standards
管理标准
com3287下面是一些软件管理方面的标准:
IEEE Std 10581998, Standard for Software Project Management Plans
IEEE Std 1074997. Standard for Developing Software Life Cycle Processes
IEEE Std 1045-1992, Standard for Software Productivity Metrics
IEEE Std 1062-1998, Recommended Practice for Software Acquisition
IEEE Std 1540-2001, Standard for Software Life Cycle Processes -Risk Management
IEEE Std 14490-i998, Guide- Adoption of PMI Standard- Guide to the Project
Management Body of Knowledge
Overview of Standards
标准综述
cc2.com/3294这些地方可以提供标准的综述性信息。
cc2e.com/3201 kieee software engineering standards Collection, 2003 Edition) IEEE
工程标准大全,2003版》 New York,ny Institute of Electrical and Electronics
Engineersee).该书包含了截止2003年40个软件开发标准的最新
版本。每个标准包括提纲、纲要的组件说明,以及各组件的基本原理。这本书包
含了质量保证计划、配置管理计划、测试文档、需求说明书、验证与确认计划、
设计描述、项目管理计划以及用户文档等标准。这本书是数百人专业知识的结晶,
这些人在各自领域里都堪称顶级专家,因而此书可谓是无价之宝。有些标准可以
单独获得所有标准都可以到位于加利福尼亚州 Los Alamitos的eee计算机社区,
或www. www. computer, org/cspress.org/cspress网站获取
Moore, James. Software Engineering Standards: User's' Road Map》(《软
件工程标准:用户路线图》). Los Alamitos,c: IEEE Computer Society Press,1997
Moore在其中概述了EEE软件工程标准
代码大全(第2版)

<==========================851end ==============================>
<==========================852start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
更多资源
815
Additional Resources
更多资源
cc2co/3208除了EEE标准,还有其他许多有关程序说明的资源。
Spinellis, Diomidis. Code Reading: The Open Source Perspective) Boston, MA:
Addison-Wesley-,2003该书探讨了阅读代码的技术,包括如何找到要阅读的代码、
读懂大块代码的技术,以及支持代码阅读的工具,还有许多有益的建议。
cc2.com2 cc2e.com/3215 sourceforge.net..net几十年来有个问题一直困绕着软件开发的教学,即寻找产品
几个大文学家从级规模的完整代码示例给同学们共享许多人通过真实例子进步很快,但大多数真
未别人的作实代码库专有于创作它们的公司。在互联网和开源软件运行汇集一起后,形势发生
画家从未研究别了显著变化。 Source Forge网站提供几千个C、C++、java、 Visual Basic、php、perl
人的笔法?能有
几个名医从不学 Python等语言的程序代码,全都可以免费下载。程序员可以看到比《代码大全(第
习同事的技
能我们希
程序员也能够这2版)》中简短示例大得多的真实代码,从中可获得不少收获没见过什么产品代码
么 Thomas例子的新手会发现这个网站特别有用,因为它提供了各种良莠不齐的代码。
cc2e.com/3222
Sun Microsystems. "How to Write Doc Comments for the Javadoc Tool," 2000.
Available from httg: //java. sun. comj2se/javadoc/writingdoccomments/
该文说明了 Javadoc注释Java程序的用法,还包括如何用“@tag”风格符标记注
释的详细建议,还有许多组织注释的方法细节 Javadoc规范也许是目前代码级说
明标准中发展最为充分的。
下面是软件文档其他话题的信息来源。
McConnell, Steve. Software Project Survival Guide》(软件项目生存指南》)
Redmond,wa: Microsoft Press,1998.这本书说明了中等规模的关键商业项目所要
求的文档说明,相关网站提供了许多相关的文档模板。
cce.com229www. c2e,com/3229  www. construx.  com,.com是我公司的网站,有很多文档模板、编码规范等软件开发
相关资源,包括软件说明资料。
cc2e.com/3236
post,ed.Real Programmers Don't' Use Pascal,(真正的程序员不用 Pascal
语言) Datamation,July1983,pp.263—265.这篇文章开玩笑似地要“昔日重
来”,回到 Fortran编程时代,那时的程序员无需操心诸如可读性之类的恼人问题
代大全(第2版)

<==========================852end ==============================>
<==========================853start==============================>

该书下载自-书部落-分享计算机经典巨-. ! -www.shubulo.com!^com!仅供试看
816
第32章自说明代码
CHECKLIST: Good Commenting Technique
检查表:好的注释技术
cc2com3243一般问题
口别人拿起你的代码就能立刻明白其意吗?
口你的注释是在解释代码用意,或概括代码在做什么,而非简单重复代码
吗?
口采用了伪代码编程法来减少注释时间吗?
口是重写有玄机的代码,而非为其做注释吗?
口你的注释能否同代码一起更新?
口注释清楚正确吗?
你的注释风格便于修改注释吗?
语句和段落
代码避免用行尾注释了吗?
口注释是着力说明为什么而非怎么样吗?
口注释为将要阅读代码的人们做好准备了吗?
口每个注释都其用处吗?删掉抑或改进了多余的、无关紧要的或随意的注
释没有?
口是否注释了代码的非常规之处?
避免使用缩略语了吗?
口主次注释区别明显吗?
口含错代码和未公开的代码特性有注释吗?
数据声明
口对数据声明的注释说明了数值单位吗?
口数值数据的取值范围注释出来了吗?
口注释出了编码含义吗?
口对输入数据的限制有注释吗?
口对位标志做注释了吗?
口在各全局变量声明的地方对其做注释了吗?
各全局变量是通过命名规范、注释(或者两者兼用)来标识其意义吗?
口神秘数值是否以具名常量或变量代替,而非只是标注之?
代码大全(第2版)

<==========================853end ==============================>
<==========================854start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
要点
817
控制结构
口控制语句都注释了吗?
口冗长或者复杂的控制结构结尾处有注释吗?抑或可能的话,简化之从而
省去注释了吗?
子程序
口各子程序的意图都注释出了吗?
口子程序的其他有关情况(诸如输入输出数据、接口假设、局限性、纠错、
全局效果和算法来源)都注释出来了吗?
文件、类和程序
口程序有简短的文档(就像在“以书本为范例”中说明的那样)给出程序
组织的概述吗?
口每个文件的用途都有说明吗?
口作者姓名、 email及电话号码在代码清单中都有吗?
Key Points
要点
该不该注释是个需要认真对待的问题。差劲的注释只会浪费时间,帮倒
忙;好的注释才有价值。
源代码应当含有程序大部分的关键信息。只要程序依然在用,源代码比
其他资料都能保持更新,故而将重要信息融入代码是很有用处的。
好代码本身就是最好的说明。如果代码太糟,需要大量注释,应先试着
改进代码,直至无须过多注释为止。
注释应说出代码无法说出的东西—例如概述或用意等信息。
有的注释风格需要许多重复性劳动,应舍弃之,改用易于维护的注释风
格。
代丹大全(第2版)

<==========================854end ==============================>
<==========================855start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看

<==========================855end ==============================>
<==========================856start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
Personal Character
第33章
个人性格
cc2.com/3313内容
33.1个人性格是否和本书话题无关:第820页
33.2聪明和谦虚:第821页
33.3求知欲:第822页
33.4诚实:第826页
33.5交流与合作:第828页
33.6创造力和纪律:第829页
33.7懒惰:第830页
33.8不如你想象中那样起作用的性格因素:第830页
33.9习惯:第833页
相关章节
软件工艺的话题:第34章
■复杂度:第5.2节和第19.6节
在软件开发过程中,人们很少注意个人性格问题。自从1965年 Edsger Dijkstra
发表具有里程碑意义的文章《 Programming Considered as Human Activity》(《程序开
发是一种人类活动》)以来,对程序员性格的研究成为合理而卓有成效的领域。在计
算机领域,不像“桥梁建设心理学”和“对律师行为的探索试验”之类的话题听起来
很荒唐,“程序设计心理学”、“对程序员行为的探索试验”等却是正统的课题。
每个行业的工程人员都了解其工作用的工具及材料的各种限制。如果是电气
工程师,就该知道各种金属的电导率,以及电压表的上百种用法;如果是建筑工
程师,就该知道木材、混凝土和钢铁的承载量。
假如你是软件工程师,基本的建造材料就是你的聪明才智,主要工具就是你
自己。建筑工程师对建筑物结构进行详细的设计,然后将设计蓝图交给其他人施
工;而你一旦从细节上对软件做好设计后,软件就生成出来了。编程的整个过程
如同建造空中楼阁一样—这是人们能做的纯粹脑力劳动之一。
代码大全(第2版)

<==========================856end ==============================>
<==========================857start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看
820
第33章个人性格
因此,当软件工程师研究其工具和原材料的本质时,会发现其实是在研究人
的智力、性格,这些可不像木材、混凝土和钢材是有形的东西。
如果你想寻求具体的编程技巧,那么本章显得太抽象没多大用途然而一
旦你接受了本书其余部分的专项建议,本章就能向你清楚地说明怎样再进一步改
善编程方法。请看看下一节,再决定要不要跳过本章。
33.个人性格是否利本书话题无关
编程过程非常耗用脑力,这种特性使得个人性格显得很重要。人们都知道聚
精会神地一天工作八小时有多么困难!也许你有过某天精力过分集中,以至于第
二天无精打采的体会,或由于上月过分投入而本月没有一点精神。你可能某天从
上午8点工作到下午2点,就感到累得不行了但你还是坚持下来,又从下午2
点拼命千到5点。之后的一周时间,你却在修改这三小时里写出来的东西。
编程工作本质上是项无法监督的工作,因为没人真正清楚你正在做什么。我
们都经常有这样的经历耗用80%的时间着力于项目的个别地方,而花费20%
的时间来完成其余80%的工作。
老板无法强迫你成为好的程序员,很多时候他甚至无法判断你是否合格。如
果你想有所成就,只能全凭自己,这涉及到你的个人性格。
一旦决心成为出色的程序员,你的发展潜力是很大的。各种研究发现,不同
程序员创建某个程序所需的时间差异可达10:1同时还发现,不同程序员调试
HARD DATA
程序所需的时间、程序实现规模、速度、错误率和检查出的错误数目也能达到10:1
(Sackman, Erikson, and Grant 1968; Curtis 1981; Mills 1983; DeMarco and Lister
1985; Curtis et al. 1986; Card 1987; Valett and McGarry 1989)'.
你无法提升自己的聪明程度,但性格在一定程度上能够改进。事实证明,个
人性格对于造就出程序员高手更具有决定性意义。
译注: Sackman、 Erikson和 Grant于1968年 Curtis于1981年、 Mills于1983年、 DeMarco和 Lister
于1985年、 Curtis于1986年、Card于1987年、 Valett和 McGarry于1989年都做过这些研究
代码大全(第2版)

<==========================857end ==============================>
<==========================858start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
33.2聪明和谦
821
33.2
Intelligence and Humility
聪明和谦虚
经过大量而长期的聪明不像是个人性格的一个方面,也确实不是。碰巧的是,高智商与优秀程
零零碎碎工作,我序员之间并无太密切的联系。
们才成为实践与科
学领域的权威专
家。如果你能满怀
什么?难道不需要智商很高吗?
信心地每天辛勤工
作,早晚有一天会
对,是不需要。没人能同计算机那样迅速敏捷。要充分理解一个普通的程序,
发现自己已成为这你得有很强的吸取细节的能力并同时消化它们。如何专注你的聪明才智,比你有
Wiliam James多聪明更重要。
正如第5章“软件构建中的设计”所提到的, Edsger Dijkstra在1972年的图灵
奖演讲会上宣读了一篇名为《 The Humble Programmer》(《谦卑的程序员》)的文章。
他认为大部分编程工作都旨在弥补我们有限的智力精通编程的人是那些了解自己
头脑有多大局限性的人,都很谦虚。而那些编程糟糕的人,总是拒绝接受自己脑瓜
不能胜任工作的事实,自负使得他们无法成为优秀的程序员承认自己智力有限并
通过学习来弥补,你会成为更好的程序员。你越是谦虚,进步就越快。
很多好的编程做法都能减轻你的大脑灰质细胞(指脑力)的负担。
将系统“分解”,是为了使之易于理解(更多细节请参见第5.2节中的“设
计的层次”)。
■进行审查、评审和测试正是为了减少人为失误。复查技术源于1998年
Weinberg提出的“无我编程(egoless programming)”。如果你从不犯错,
就无须复审自己的软件。但要知道,人的智力是有限的,所以应和他人沟通,
来提高软件质量。
将子程序编写得短小,以减轻大脑负荷。
■基于问题而不是低层实现细节来编程,从而减少工作量。
通过各种各样的规范,将思路从相对繁琐的编程事务中解放出来。
你也许会觉得开发更高的智力方是正途,所以无需这些编程拐棍;你也可能
对利用这些智力拐棍的程序员不屑一顾。然而实际上,研究表明谦虚的程序员善
于弥补其不足之处,所编写的代码让自己和他人都易看懂,其中的错误也较少
满是错误和延误的开发过程才是邪门歪道。
代码大全(第2版)

<==========================858end ==============================>
<==========================859start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
822
第33章个人性格
33.3
Curiosity
求知欲
一旦承认自己的脑袋要理解多数程序还有难度,并意识到有效的编程就是去
追寻改善这一境况的方式时,你就会开始需要付出毕生精力的漫长求索过程。在
成长为高手的过程中,对技术事物的求知欲具有压倒一切的重要性。相关的技术
信息在持续变化。很多Web程序员从不在微软 Windows下编程,很多 Windows
下的程序员也从不与DOS、UNIX、穿孔卡片打交道。技术环境的特定特征每5
到10年就变化一番,如果没有足够的求知欲来跟上这些变化,你就面临落伍的威
胁。
程序员都是大忙人,常常没有时间去考虑怎样改进自己的工作。如果你是这
种情况,你并不孤独,很多人和你一样。下面是一些培养求知欲和把学习当做第
一要务的特定方法。
交叉参考有
关软件开发过
在开发过程中建立自我意识你越了解软件开发过程,无论通过阅读还是通
程的重要性,会过自己对软件开发的观察,你就越能理解变化,使团队朝着正确的方向发展。
在34.2节“精
选开发过程”充如果分配给你的工作净是些不能提高自身技能的短期任务,你理应表示不满。
分讨论。
如果正处于竞争激烈的软件市场,则目前工作用到的一半知识将在三年后过时。
假如不持续学习,你就会落伍。
其实你这样的人很受欢迎,没有必要花时间去为管理层干些不感兴趣的工作。
尽管就业形势跌宕起伏,有些就业岗位转向国外,但从2002到2012年,美国平
HARD DATA均软件从业职位数目将显著增长。系统分析师的工作机会有望增加约60%,软件
工程师增长50%。将所有计算机岗位加在一起,能够将现有的300万个职位再增
加100万个(Hecker2001BLS2004)。如果在工作中学不到什么,就找一份新
工作吧。
交叉参考有
关试验这一思
试验对编程和开发过程做试验,是学习编程的有效途径之一。如果不了解
路涉及到若干所用语言的某一特性是怎么回事,可编写一个小程序来检验,看看它是如何工作
关键的方面。其的。请在调试器中观察程序的执行情况。用个小程序来检验某一概念,总比编写
细节请参看
349节中的“试大程序时运用不太了解的特性要好。
验”。
代码大全(第2版)

<==========================859end ==============================>
<==========================860start==============================>

该书下载自书部落分享计算机经典 .! -www.shubulo.com!.coml供试看
33.3求知欲
823
如果小程序表现的特性与你的设想不一样,怎么办呢?那正是你要研究的问
题。最好通过小程序找出答案,而不要用大程序。有效编程的关键之一就是要学
会迅速制造错误,并且每次都能从中有所收获。犯错不是罪过,从中学不到什么
才是罪过。
课入阅读
阅读解决问题的有关方法解决问题是软件创作过程中的核心行为。 Herbert
James Adams
的( Conceptwal Simon报告了关于人类解决问题的一系列试验,发现人们并不总能自行找出解决
《BbodbusngSimon1996《问题的巧妙办法,即使这些办法很容易传授给他们(Simon1996)换句话说,就算
是一本讲述解
决问题方法的你想再发明个车轮,也不会注定成功,你发明的也许是方车轮。
很出色的书
(2001)。
在行动之前做分析和计划在分析和行动之间有着矛盾关系。有时必须停止
收集数据马上行动,然而多数程序员的问题不在于分析过度。钟摆现在距离弧的
那个“行动”半边还比较远,至少可以等到它快到中央时,你再担心别总呆在“分
析停滞”的位置上。
cc2c320学习成功项目的开发经验学习编程的一个特别好的途径是研究高手的程
序。 Jon Bentley认为你应该坐下来,准备一杯白兰地,点一根上好的雪茄,像看
优秀小说那样来阅读程序。实际做起来可能不会这么惬意。大部分人不愿意花休
息时间深究长达500页的源程序,但是许多人乐意研究高层设计,并有选择地去
研究某些地方的细节源代码。
软件工程领域里利用成败的先例相当有限制如果对建筑学感兴趣,你会研
究 Louis Sullivan、 Frank Lloyd Wright和贝聿铭的设计图,参观他们设计的建筑物
如果对结构工程感兴趣,你会研究 Brooklyn大桥、 Tacoma Narrows大桥等混凝土、
钢铁和木材建筑。你会学习所在行业中成败的各种例子。
Thomas Kuhn指出,凡是成熟的学科都是从解决问题发展起来的。这些问题
不仅被作为本行业卓越成就的例子,而且还是继往开来的榜样(Kuhn1996)软件
工程刚刚只能能达到这种成熟程度。计算机科学和技术委员会(Computer Science
and Technology Board)总结道,软件工程行业鲜有成败案例的文献可供研究(sTB
1990)
Communications of the ACM》的一篇文章主张人们对别人的编程问题案例
进行研究(Linn and Clancy1992)。这一主张的提出具有深远意义。另外,该杂志最
受欢迎的计算机专栏“编程珠玑(Programming Pearls)”专门研究编程中
代大全(第2版)

<==========================860end ==============================>
<==========================861start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看^
824
第33章个人性格
出现的问题案例,也具有启发作用。《《heMythicaIMan-Mothb《-month》(《人月神话》)2
书因其讲的是对IBM公司OS/360项目中编程管理的案例研究,而成为软件工程
行业最热门的书籍之一。
不管有没有关于编程案例研究的书,你都应找些高手编的代码读读。看看你
敬佩的程序员的代码,再看看你不喜欢的程序员的代码,比较它们之间的异同,
比比你的代码,有什么差异?为什么会有差异?哪个更好?为什么?
不仅要阅读别人的代码,还应渴望了解专家对你的代码的看法。找一些一流
程序员评论你的代码,滤除其言语中的主观成分,注重解决切中要害的问题,从
而改善编程质量。
阅读文档程序员普遍有文档恐惧症。计算机文档通常写得很差,组织得也
糟糕。尽管有这些问题,只要克服过度的恐惧,还是能从屏幕或纸质文档受益匪
浅。文档中有许多有用的东西,值得花时间去看要是忽视其中显而易见的信息,
会在新闻组和BBS上得到“RTFM!”这样的缩略语,意指“去读那该死的手册
(Read the#**@ Manual!)”
现代语言产品一般都带有大量函数库,很有必要投入时间去浏览其说明。通
常提供产品的公司都生成了许多你用得着的类,如果是这样,应确信你了解这些
类,每两个月翻翻其文档。
交叉参考有
阅读其他书本期刊你愿意阅读本书就很值得称赞。你已经学到了比软件业
关个人读书计中多数人都更多的知识,因为大部分程序员一年下来还看不完一本书(DeMarco
请参看35.4节 and Lister1999)。只要稍稍看一些书就会使你的专业知识又迈进一步。如果每两
“软件开发者月能看一本计算机好书,大约每周35页过不了多久,你就能把握本行业的脉搏,
的阅读计划”
并脱颖而出。
同专业人士交往和希望提高其软件开发技能的人为伍。参加某个交流会,
加入某个用户群,或者参与网上讨论。
2译注:《人月神话》是1975年出版的一本论文集,后多次再版发行。因其中有一篇文章叫“The
Mythical Man-Month-作者 Brooks以此作为书名 Brooks有“IBM大型机之父”之称,他在1956
年到1965年领导IBM360大型计算机的开发计划,包括硬件结构及OS360操作系统。由于OS/360
由一千多位程序员参与开发,使他深刻体会到大型软件开发在技术和管理上所面临的种种困难和挑
战。于是,他将其领导开发OS/360的经验心得收集在这本书里。
人们常拿Man- Month(多少人做多少个月)计算软件工作量,但 Brooks发现软件开发需要人们
密切沟通,使得设计工作不易分割,故而以Man-monb为单位只是神话的(mythical)计算方法,也
就得出著名的 Brooks法则“对于进度已落后的软体开发计划而言,若再增加人力,只会让其更
加落后(Adding manpower to late software project makes it later)这就是该书名称的涵义。
代码大全(第2版)

<==========================861end ==============================>
<==========================862start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!仅供试看^
33.3求知欲
825
深入阅读关于向专业开发看齐好的程序员总是不断寻找机会来提高自己。下面是我公司
程序员水平的其等多家企业采用的专业开发阶梯。
他讨论,可参看
专业软件开发
Som Prcession-al第一级:入门级入门者会利用某语言的基本功能,能够编写类、子程序、
velo
pment )>(McCo-
循环和条件语句,会使用语言的许多特性。
nnell2 2004)第16
司的公第二级:中级中级的程序员已经度过入门期,能利用多种语言的基本功能,
的专业开发规
并会得心应手地使用至少一种语言。
程on -strux'-'s
Professional
Procelopment第三级:熟练级熟练级的程序员对语言或环境(或两者兼具)有着专业技
gram。
能。这一级的程序员也许精通J2EE的盘根错节,或者对《J2BE《AnrotedcC++++
Reference Manual》如数家珍。这些程序员都是所在公司的活宝,很多程序
员再也不能超越该层次。
第四级:技术带头人级技术带头人具有第三级的专业才学,并明白编程工
作中只有15%用来和计算机交互,其余都是与人打交道的。程序员一般只花
30%的时间单独工作,与计算机交互的时间则更少(McCue1978)技术带头
人会为人写代码,而非为机器。真正高手所写的代码,像水晶一样晶莹剔透,
还配有文档。他们可不会浪费其宝贵的脑力,去重新组织用一句注释就能说
清楚的某块代码逻辑。
再厉害的编码者若不重视可读性的,通常只能呆在第三级,但这并不常见。
依据我的经验,有人之所以写出难以看懂的代码,主要还是因为其代码质量太差,
他们不会自言自语道:“我的代码不好,所以我得让它们不好懂。”他们只是没有
了解透所写的代码,自然无法使之易读,从而将自己困在较低的级别。
我曾见过最糟糕的代码,其作者不让任何人看懂她的程序。最后,她的上可
威胁要解雇她,如果她还不合作的话。她的代码没有注释,变量名尽是些x、xx、
xx、xx1和xx2之类的东西,而且都是全局变量。上司的老板却以为她是个高手,
因为她能很快改正错误。其实正是其低劣的代码质量给了她表现纠错能力的大量
机会。
当初学者或中级程序员不是错,当熟练级程序员而非技术带头人也无可厚非
但如果知道自己该如何改进后,还总是在初学者或者中级程序员阶段徘徊,就是
你的不对了。
代大全(第2版)

<==========================862end ==============================>
<==========================863start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww ! --www.shub ^.com!仅供试看^
826
第33章个人性格
33.4
Intellectual Honesty
诚实
编程生涯成熟的部分标志就是发展出一种不屈不挠的诚实感。通常表现为以
下几个方面:
不是高手时不假装是高手。
乐于承认错误。
力图理解编译器的警告,而非弃之不理。
透彻理解自己的程序,而不要只是编译看看能否运行。
提供实际的状况报告。
■提供现实的进度方案,在上司面前坚持自己的意见。
前两项承认你“不知道”或“是你的错与前面讨论的“谦虚”遥相
呼应。如果你不懂装懂,还怎么学习新东西呢?最好还是装作自己啥都不懂,听听
别人咋说,从他们那里学到新内容,并能了解他们是否真的清楚所讨论的东西。
经常考量自己对某些问题的确定程度。如果总是毋庸置疑,那可是个不妙的
信号。
拒绝认错是一个让人特别讨厌的习惯。如果 Sally不愿认错,她显然以为这么
误辩护,而多数傻
瓜也确实这么做。做别人就相信她不错。但事实正好相反每个人都知道她有错。复杂的智力活动
Dale Camegie有潮起潮落,因此错误有情可原。只要她不熟视无睹,没人会抓住错误不放的。
卡耐基
要是她不愿认错,到头来她只会骗自己。别人都会知道她是个不诚实的、高
傲的程序员。与小小的错误相比,给人们这种印象可要糟多了。如果你犯了错误,
应立即主动承认。
对编译器给出的消息不懂装懂是另一个常见盲点。如果你不明白某个编译器警
告,或者自认为已经搞懂了但时间紧迫无法核实猜猜时间实际浪费到哪儿了?最
终你可能为了解决问题而从头检查一遍,而编译器早已把解决方案给出来了。一些
人曾在调试方面向我求助。我问他们编译有没有问题,他们回答说没有,然后解释
问题的症状。于是我说:“嗯,看来像是指针没有初始化,编译器应该有警告信息
代码大全(第2版)

<==========================863end ==============================>
<==========================864start==============================>

该书下载自-书部落-分享计算机经典巨著!www. !--www.shubulo. ^.com!仅供试看
33.4诚实
827
呀?”他们这才说:“噢,对…编译器是给了警告信息,我们还以为指其他意思
呢。”你犯的错误很难骗他人,更难愚弄计算机,所以不要浪费时间做这样的事
与此类似的还有,当你对自己的程序并不很了解时,就“先编译看看能否运
行再说”。一个例子是对于该用“<”还是“<”通过运行程序来决定。这种情况
下,程序能否运行并没有太大意义,因为你并不理解它能工作的原因。要知道,
测试只能找出错误,不能确保“不存在错误”。要是不理解程序,就不能彻底测试。
“先编译看看程序会干什么”的想法是个警告信号,也许意味着你该回到规划阶
段,或者你在着手编程时还不清楚要做什么。请确保在将程序丢给编译器之前,
你已对其有了较大的把握。
前90%代码值
得占用前90%
状态报告也是令人反感的领域。如果程序员声称项目“已经完成了90%”,而
的开发时间;剩实际进度还有50%,那么他们就会声名狼藉。如果问题在于你对自己的进度缺乏
下的10%代码
同样值得另外感觉,那么可以通过加强对工作的了解来解决。但如果是为了取悦上司而不说出
占用90%的开想说的话,性质就完全不同了。上司通常愿意得到对项目状态的真实汇报,即使
发时间。
-Tom Cargill那可能并非他们想听到的内容。如果你的汇报经过深思熟虑,应尽量冷静地在私
下说出来。管理者需要准确的信息,以便协调开发活动,充分地配合是必要的。
cc2e.com3341
与不准确的状态报告相关的问题是不准确的估计。典型情况是这样:经理要
Bert算算开发某个新的数据库产品需要投入多少人力。Bert和几个程序员碰一下
头,算了几个数,认为需要8个程序员花6个月时间。经理说:“这可不行,能否
少用几个程序员花更短时间搞定?”Bert想了想,决定取消培训时间和假期,再
让大家稍微加点班来实现这个目标。于是他估计需要6个程序员、4个月时间。
经理说:“很好,这是个优先级较低的项目,所以尽量准时完成,不要拖延,因为
预算不允许。”
Bert错在他未意识到评估是无法协商的。他可以让估计更精确,但和上司商
量并不会改变开发软件项目需要的时间。IBM公司的 Bill Weimer说:“我们发现,
技术人员大都能很好地估计项目需求和进度。但问题是他们不会坚持自己的决定,
需要学习如何坚守其立场。”(Weimer in Metzger and Boddie 119)rt许诺在4
代大全(第2版

<==========================864end ==============================>
<==========================865start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor.com!仅供试看
828
第33章个人性格
个月完成项目却花了6个月,肯定不会让上可高兴。妥协让他失去信用,而坚持
自己的估计会赢得尊敬。
如果上司施压要你改变估计,你应明白是他最终决定要不要做这个项目。你
可以说:“瞧,该项目的费用就是这么多。我不能说这对公司是否值得,因为是你
说了算。但我可以告诉你开发软件需要的时间,这是我份内的事。我无法跟你‘商
量’项目该花多少时间,就像不能商量确定一英里有几码一样,自然规律是不能
商量的。不过,我们可以协商影响项目进度的其他方面,重新评估进度。我们
以少一些特性,降低性能,分阶段开发项目少些人但时间延长一些,或者多些
人手时间短些。”
我听到过的最引起恐慌的交流之一是在一场关于软件项目管理的演讲上。演
讲者是一本畅销的软件项目管理书籍的作者。一位听众问到:“让你评估某项目,
你明知道如果给出准确的估计,上司会觉得成本太高而放弃,你会怎么办呢?”
这位演讲者回答道,那得耍点花招,你必须先对成本估计偏低,来让上司投入该
项目。他说,一旦他们开始对项目有投入,就得不断追加投入直到项目结束。
这是完全错误的回答!管理者是负责整个公司运营的。如果某个软件给公司
带来25万元的价值,而你估计需要75万元来开发,公司就不该开发此软件。管
理者有责任做出这样的决定。上面这位演讲人隐满项目成本,告诉管理者需要比
实际少的成本,他是在损害管理者的权威。如果你对某项目感兴趣,或者将为公
司带来突破,或者能提供有价值的锻炼,就应该将这些想法说出来,管理者会权
衡这些因素。但哄骗上司做出错误决定,将使公司蒙受损失。如果你因而丢了饭
碗,那纯粹是活该。
33.5
Communication and Cooperation
交流与合作
真正优秀的程序员知道怎样同别人融地工作和娱乐。代码便于看懂是对团
队成员的要求之一。计算机可能和别人一样频繁地读你的代码,但是它读质量差
的程序可比人强多了。作为一项可读性原则,应该把修改你代码的人记在心上。
编程首先是与人交流,其次才是与计算机交流。
代码大全(第2版)

<==========================865end ==============================>
<==========================866start==============================>

该书下载自-书部落-分享计算机经典巨著!-w. ! --www.shubulo.com!^ .com!仅供试看
33.6创造力和纪律
829
33.6
Creativity and Discipline
创造力和纪律
我走出校园时,自以为是世上最好的程序员。我可以使用5种计算机语言写
出无与伦比的三连棋游戏,还能编写长达1000行的可用程序(真的!)我进了
Real World公司,第一个任务是就阅读并理解用 Fortran语言编写的20万行程序,
再设法将其运行速度提高1倍。任何真正的程序员会告诉你,世界上所有的结构
化编程技术都无助于解决这样的问题它需要的是天分。
-Ed Post
向刚毕业的计算机科学学生很难解释为何需要规范和工程纪律当我还没毕
业时,我写过的最长程序也就500行的可执行代码。作为专业程序员,我也编过
不少500行以下的实用工具,但是一般项目的长度都在5000到25000行之间。
我还参与过长达50万行代码以上的某些项目开发工作。这类工作需要的技能不仅
是规模大些而已,而是一套全新的技巧。
一些有创新精神的程序员将各种标准和规范的纪律看成束缚其创造力的东
西,事实正好相反。难道网站的每个网页采用不同字体、颜色、对齐方式、图形
风格及导航条,效果会好吗?效果只会是一片乱七八糟,而非有创意。大型项目
若没有标准和规范,完成都有困难,更谈不上创新了。不要将创造力花到无关紧
要的事物上,在非关键之处建立规范,从而在重要地方倾力发挥你的创造性。
McGarry和 Pajerski对其在美国宇航局(ASA)软件工程试验室工作的15
年时间做了回顾,说强调纪律的方法和工具非常有效果(McGarry and Pajerski
1990)。许多有很强创造力的人都极其遵守纪律,正如俗话所说:“Form is liberating
(形式就是解放)”。建筑大师总是在材料物理性能、时间和成本的可承受范围内
工作,艺术大师同样如此。看过 Leonardo da Vinci(达芬奇作品的人,都会
钦佩他在细节上遵守约定; Michelangelo(开朗基罗)设计西斯廷教堂的顶篷
时,将其划分为各种对称几何形状,如三角形、圆形和正方形。他将顶篷分成三
个区域,对应柏拉图哲学的三个阶段。如果没有自我的结构和约束意识,三百个
人物的排列将会混乱不堪,不可能成为内涵丰富的艺术瑰宝。
精致的程序作品也要求许多约束。如果编程之前不分析需求也不设计,编写
代码的过程中你会发现要了解许多东西。你的工作成果与其说是艺术品,不如说
是幼儿画。
3译注 Leonardo da Vinci:达·芬奇(1452-1519),意大利文艺复兴时期伟大画家、雕刻家、建筑学家。
4译注: Michelangelo:米开朗基罗(14751564),大利文艺复兴时期成就卓著的科学家、艺术家。
代码大全(第2版)

<==========================866end ==============================>
<==========================867start==============================>

该书下载自书部落-分享计算机经典巨著--www. !-www.shubulo.com!^.com!仅供试看
830
第33章个人性格
33.7
Laziness
懒惰
惰这种品性能偷懒表现在以下方面
促使你努力减少
整体花销使你拖延不喜欢的任务。
编写节省劳力的
别人也会迅速做完不喜欢的任务,以摆脱之。
觉得这些程序有
用;使你编些说编写某个工具来完成不喜欢的任务,以便再也不用做这样的事情了。
明,免得人们老
是问你。
有的偷懒表现形式较好。第一种表现没有任何益处。你可能有过这样经历:
-Larry Wall
为了不必做一些琐事,你可能宁愿花几个钟头做一些其实不必要的工作。“我讨厌
输入数据,而很多程序需要少量的数据输入。大家都知道我在某个程序上已经拖
延了数天,仅仅是不想用手输入几页数字。”——这样的习惯叫“实在懒”编译
某个类看看其是否工作,省得整理一下思绪,这显然也是偷懒的表现。
琐事并不像看上去的那样麻烦。如果养成立即把它做完的习惯,你就能避免
这种偷懒,于是就成为第二种偷懒形式叫做“开明懒”尽管仍是偷懒,但毕
竟用最少时间做完不喜欢的事情,解决了问题。
第三种形式是编写某个工具来完成烦人的任务,这是“一劳永逸的懒”,无疑
是最具产值的偷懒形式(如果这个工具最终节省了时间)由此可以看到,某种程
度的懒惰还是有好处的。
在你不通过有色玻璃看问题时,你就看到了懒惰的另一面。“硬干”或者“苦干”
并没有带着光环。“硬干”是种徒劳的、大可不必的努力,只会说明你急切但并不是
在完成工作。人们容易混淆行动与进展,混忙碌与多产。有效编程中最重要的工作
是思考,而人思考时通常不会看上去很忙。如果和我共事的程序员总是忙个不停,我
会认为他并非优秀的程序员,因为他没用最有价值的工具自己的脑袋
Characteristics That Don't Matter As Much As
33.8 xou Mieh hink
不如你想象中那样起作用的性格因素
“硬”并不是在生活的其他方面备受推崇,而在软件开发中失灵的唯一性格
因素。
代码大全(第2版)

<==========================867end ==============================>
<==========================868start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shuby.com!仅供试看
33.8不如你想象中那样起作用的性格因素
831
Persistence
坚持
根据环境的不同,坚持可能是财富,也可能是负担。和大部分的中性词一样,
依据你的褒贬意图而有不同的意思。如果你想表达贬意,可以说是“固执己见”
或“顽固不化”;如果你要表达褒意,可以说是“坚韧不拔”或“持之以恒”
多数时候软件开发中的坚持其实就是没有好处的“固执”。当在某段新代码上
卡壳时,坚持很难让人称道。不妨另辟蹊径,尝试重新设计类,或者绕过去,以
后回头再试。当一种办法行不通时,正好可以换个办法试试(Pirsig1 1974)
交叉参考有
关调试时的坚
调试时,花四个小时干掉某一错误肯定会很有满足感;但通常最好只要有
持问题,其详细段时间没有进展,比如说15分钟,就该放排错过程,让潜意识仔细品品想个
讨论请参看其他法子将问题绕开:从头编写有麻烦的代码段:理清思绪后再来做。和计算机
23.2节“寻找缺
陷”。
错误斗气是不明智的,更好的方法是避开它们。
知道何时放弃很难,但这是必须面对的问题当你遭受挫折时,提出此问题
正是时候。提出并不是说这时就放弃,而是该为目前的行为设置底牌了:“要是这
种方法三十分钟之内还不解决问题,我就会花十分钟想些其他办法,再用一个钟
头尝试最可行的办法。”
Experience
经验
与其他行业相比,软件开发行业的经验比书本知识价值要小,这有几个原因
在其他许多行业里,基础知识变化得很慢。即便晚你10年毕业的人,他所学的基
础知识还和你那时学的一模一样;而软件开发,即使基础知识也变化很快,晚于
你10年毕业的人所学的有效编程技术,其数量有可能是你的两倍。一些老程序员
往往被看作另类,不仅是因为从未接触某些专项技术,还因为他们没有用过从学
校毕业之后出名的基本编程概念。
在其他行业中,今天工作中的收获很可能有助于明天的工作;在软件行业中,
如果不改掉使用先前编程语言时的思维模式,或者不放弃在旧机器上能用的代码
性能优化技术,你的经验将还不如没有好。很多软件开发者花时间去准备应付上
代码大全(第2版

<==========================868end ==============================>
<==========================869start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com! ^^.com!仅供试看
832
第33章个人性格
一次战争,却不花时间去准备下一次战争。如果你不能与时俱进,经验不但不会
有所帮助,反而是个累赘。
抛开软件开发中的迅速变化不谈,人们还常常依据经验得出错误结论。要客
观评价自己的人生很难。忽视经验中的一些关键因素与否,你可能会得出迥然不
同的结论。读读其他程序员的研究材料是有好处的,因为这些材料展示了其他人
的经验它们都经过充分的提炼,可供你客观地检验。
人们还荒唐地强调程序员有多少经验。“我们需要有五年以上C语言编程经
验的程序员”就是愚蠢的说法。如果程序员过了前一两年还没有学好C语言,那
么再加三年也没什么意义。这种“经验”和工作效能关系不大。
程序开发中的信息快速更新,导致“经验”也跟着高速变化。在很多行业中,
有成就的专业人士可以度假、休息,尽享成功带米的荣誉;而在软件开发行业,
任何人放松下来就很快跟不上形势。为了让自己仍然有用,你必须紧跟潮流。对
于求知欲强的年轻程序员来说,这会是他们的优势;而老程序员常常自认为有资
历,讨厌年复一年地证明自己的能力。
最后一个问题是:如果你工作10年,你会得到10年经验还是1年经验的10
次重复?必须检讨自己的行为,才能获得真正的经验。只有坚持不懈地学习,才
能获取经验:如果不这样做,就无法得到经验,无论你工作多少年。
Gonzo Programming
编程狂人
如果你还没有对某个程序花费至少一个月的时间一天工作16小时,其余
8小时也睡得不安稳,老是梦到它,为解决“最后错误”连熬几夜你就算没有
编过真正复杂的程序,你也不会感受到编程中激动人心的东西
Edward Yourdon
这种对编程的痴迷简直是胡闹,几乎注定会失败。彻夜编程让你感觉像是世
上最好的程序员,却要花几个星期去纠正你在短暂辉煌时埋下的失误。可以热爱
编程,但热情不能代替熟练的能力,请想明白什么更重要。
代码大全(第2版)

<==========================869end ==============================>
<==========================870start==============================>

该书下载自-书部落-分享计算机经典巨著!--www ! --www.shub.com!仅供试看^
33.9习惯
833
33.9
Habits
习惯
我们的精神品德既非与生俱来,也非逆于天性其发展归因于习惯…我
们要学的任何东西都通过实际做的过程学到…如果人们建的房子好,他们就成
为好的建设者;而造的房子不好时,他们就是差的建设者…所以小时候形成了
怎样的习惯关系很大一—正是它会造成天壤之别,或者说就是世上所有差异之源。
亚里士多德
好习惯很重要,因为程序员做的大部分事情都是无意识完成的。例如,你曾
想过该如何格式化缩进的循环体,但现在每当写新的循环体时就不再去想了,而
以习惯的方式来做。对程序格式的方方面面儿乎都是如此。你上次质疑编排风格
是什么时候?如果你有五年编程经验,最后一次提出这个问题可能是在四年半之
前,其余时间都是按习惯编程的。
交叉参考有
关赋值语句的
人在很多方面都有习惯。程序员倾向于仔细检查循环下标,而对赋值语句并
错误,请参看节不在意,以致于赋值语句中的错误比循环下标中的更难发现(Gould1 1975);你对
22.4节中的“错别人的批评以友好或不友好的方式回应;总是或从不想办法让代码更易读或更快;
误的分类”。
如果经常要在速度和易读性之间做出选择,你的决定总是一样,实际上你并未选
择,而是在习惯性地做出反映。
我们要学习源于亚里士多德5“精神品德”的“编程品德”他指出人们并非
天生好或坏,而是设定的道路使人成为或优或劣的程序员。你做得好坏主要靠你
的所作所为。建筑师要通过建筑,程序员则要通过编程。行为养成习惯,年复日
久这些好坏习惯就决定了你作为程序员的优劣。
比尔·盖茨说,任何日后出色的程序员前几年就做得很好。从那以后,程序
员好坏就定型了(《Lammers1986《)。在你搞编程颇有些年头后,很难会突然说“怎
样才能使这个循环再快些呢?”或者“如何让这段代码更好看懂呢?”优秀的程
序员早就养成了这些习惯。
初涉某事时,就应端正态度来学。开始做事情时,你还会积极思考,轻松决
定做得好坏。干了一段时间后,就会习以为常,习惯的力量”开始起作用。请确
保这些习惯是你所希望的东西。
5译注: Aristotle亚里士多德(公元前384一公元前22年)古希腊大哲学家、科学家。其著作涉
及逻辑学、形而上学、伦理学、自然科学、政治学和诗学,对西方思想产生了深远影响。
代大全(第2版)

<==========================870end ==============================>
<==========================871start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
834
第33章个人性格
如果没养成最有效的习惯,该怎么办呢?如何改掉坏习惯?如果有明确的答
案,我就能在夜晚的电视节目上兜售自助录影带了。不过我有少许答案不能
用“没有习惯”来代替“坏习惯”—这就是人们骤然停止抽烟、停止咒骂或者
停止多食时会很难受的原因,除非有了替代方法,如嚼口香糖。以新习惯来代替
老习惯,要比干脆戒除老习惯容易。对于编程,要试着养成有用的新习惯。举个
例子,要培养先以伪代码编写类再改用实际代码,以及编译前认真检查代码的习
惯。不必为失去坏习惯而多虑,有了新习惯,坏习惯自然就会消失
Additional Resources
更多资源
cc2e.com/3327
关于软件开发的人为因素,还有更多资源可供参考。
cc.co333 cc2e.com/3334 edsger dijkstra The Humble Programmer), Communi-的图灵奖发言稿《TheHumbleprogrammer》,登载于《Communi
cations of the ACM》15,no.10(October1972):59866.这一经典论文拉开了探
究程序员心理与计算机编程之间到底有多大关系的研究序幕 Dijkstra一直强调,
编程的本质任务就是驾驭计算机科学的极端复杂性。他认为编程是唯一要求掌握
最底层到最高层的9个数量级上细节差异的人类活动。由于其历史意义,这篇文
章值得读读,而且几十年后,其很多提法仍令人耳目一新。该文还展现了在计算
机科学发展早期程序员的一些情况。
Weinberg, Gerald.《 The Psychology of Computer Programming: Silver
Anniversary Edition. New York,ny: Dorset House,1998.这本经典著作谈了“无我
编程”的思想,以及编程时人的因素的方方面面此书还包含了很多轶闻趣事,是
有关软件开发的最通俗易读的书本之一
Pirsig, Robert M. Zen and the Art of Motorcycle Maintenance: An Inquiry into
Values. William Morrow,1974. Pirsig借摩托车维护展开讨论了“质量”。 Pirsig写这
本书的时候正是一位软件技术作家,其非凡见识既适用于摩托车维护,也对软件
项目心理学成立。
Curtis,ill,ed.《 Tutorial: Human Factors in Software Development》.los
Angeles,ca: IEEE Computer Society Press,195.该书是一部很好的论文集,收录
了许多谈论编程中人的因素的论文。其45篇论文依据心理模型分为若干节,有编
程知识、编程指导、问题解决和设计、设计表现的影响、语言特性、错误诊断以
代码大全(第2版)

<==========================871end ==============================>
<==========================872start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!仅供试看^
要点
835
及方法论。如果说编程是人类面临的最难的一项智力挑战,那么对人类心理容限
多加了解是努力成功的关键。这些关于心理因素的文章也有助你调整心态,了解
自己应该如何更有效地编程。
McConnell, Steve. (Professional Software Development). Boston, MA: Addison-
Wesley,2004其第7章“Orphans Preferred”仔细谈论了程序员的个性及其作用
Key Points
要点
人的个性对其编程能力有直接影响。
最有关系的性格为:谦虚、求知欲、诚实、创造性和纪律,以及高明的偷懒。
程序员高手的性格与天分无关,而任何事都与个人发展相关。
出乎意料的是,小聪明、经验、坚持和疯狂既有助也有害。
很多程序员不愿主动吸收新知识和技术,只依靠工作时偶尔接触新的信息。
如果你能抽出少量时间阅读和学习编程知识,要不了多久就能鹤立鸡群。
好性格与培养正确的习惯关系甚大。要成为杰出的程序员,先要养成良好习
惯,其他自然水到渠成。
代码大全(第2版)

<==========================872end ==============================>
<==========================873start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !-www.shubulo..com!仅供试看^

<==========================873end ==============================>
<==========================874start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.cor!.com!仅供试看
Themes in Software
Craftsmanshfp
第34章
软件工艺的话题
ccm344内容
34.1征服复杂性:第837页
34.2精选开发过程:第839页
34.3首先为人写程序,其次才是为机器:第841页
34.4深入一门语言去编程,不浮于表面:第843页
34.5借助规范集中注意力:第844页
34.6基于问题域编程:第845页
34.7当心落石:第848页
34.8迭代,反反复复,一次又一次:第850页
34.9汝当分离软件与信仰:第851页
相关章节
本书全部内容
本书着重于软件构建的细节:高质量的类、变量命名、循环、源代码布局、
系统集成等。对抽象的话题谈得不多,以便突出具体的内容。
一旦你对本书前面的具体话题有所了解,要想领会有关抽象概念,只需从各
章选取主题并摸清它们的关联。本章将这些抽象话题明确化复杂性、抽象、
过程、可读性、迭代,等等。这些内容对软件的塑造有着相当大的影响。
Conquer Complexity
34.征服复杂性
交叉参考关于致力于降低复杂度是软件开发的核心。第5章“软件构建中的设计”说明了
征服复杂性的态
度有多重要,其细管理复杂度是软件的首要技术使命。尽管谁都希望成为英雄,自如地应对各种计
节请参看33.2节算机问题,但没有人的大脑真正有能力跨越9个数量级的细节。计算机科学和软
“聪明和谦虚”。
件工程已经开发了许多智力工具,来处理这种复杂性,本书谈到的其他话题里也
代码大全(第2版)

<==========================874end ==============================>
<==========================875start==============================>

该书下载自-书部落-分享计算机经典巨著!www. !--www.shubulo..com!仅供试看
838
第34章软件工艺的话题
曾触及过其中的一些。
在架构层将系统划分为多个子系统,以便让思绪在某段时间内能专注于系统
的一小部分。
仔细定义类接口,从而可以忽略类内部的工作机理。
保持类接口的抽象性,从而不必记住不必要的细节。
避免全局变量,因为它会大大增加总是需要兼顾的代码比例。
避免深层次的继承,因为这样会耗费很大精力。
避免深度嵌套的循环或条件判断,因为它们都能用简单的控制结构取代,后
者占用较少的大脑资源。
别用goto,因为它们引入了非顺序执行,多数人都不容易弄懂
小心定义错误处理的方法,不要滥用不同的错误处理技术。
以系统的观点对待内置的异常机制,后者会成为非线性的控制结构异常如
果不受约束地使用,会和goto一样难以理解。
不要让类过度膨胀,以致于占据整个程序。
■子程序应保持短小。
使用清楚、不言自明的变量名,从而大脑不必费力记住诸如“i代表账号下
标,代表顾客下标,还是另有它意?”之类的细节。
传递给子程序的参数数目应尽量少。更重要的是,只传递保持子程序接口抽
象所必需的参数。
用规范和约定来使大脑从记忆不同代码段的随意性、偶然性差异中解脱出
来。
只要有可能,一般情况下应避免第5章所说的“偶然性困难”。
如果将复杂的测试代码放入布尔函数,并将其意图概括出来,就可以降低代
码的复杂程度。用查找表代替繁琐的逻辑链,也能达到同样目的。如果采用定义
代码大全(第2版)

<==========================875end ==============================>
<==========================876start==============================>

该书下载自-书部落分享计算机经典巨著--www. ! --www.shubulo. com!^ ^.com!仅供试看
34.2精选开发过程
839
良好的一致的类接口,你就无须操心类的实现细节,从而整体上简化自己的工作。
采用编码规范主要也是为了降低复杂度。如果在格式编排、循环、变量命名、
建模表示法等方面有统一的考虑,就能将精力集中于更具挑战性的编码问题上。
有人声称规范存在争议性,既限制了审美方面的选择,又颇为武断。人们总是对
规范的细枝末节有着热烈争论。规范最有用之处在于它们能免于你做出任意决定,
省却了为之辩解的麻烦。要是它们在更有意义的地方反而成为桎梏,就没那么有
用了。
各种形式的抽象对于管理复杂度都是很强大的工具。通过增强程序组件的抽
象性,编程领域已经取得了很大的进步。 Fred Brook指出计算机的科学最了不
起的成就,就是从机器语言跃进到高级语言,解放了程序员后者不用再操心
某种特定的硬件细节,而能够专心于编程(Brooks1995)子程序的想法则是另一
个巨大的进步,随后的重要进步是类和程序包。
」
以其功能对变量命名,说明问题是什么,而非其怎样实现,能提升其抽象层
次。如果你说:“这是弹出栈,意味着我在取最近雇员的信息”,那么抽象使你可
以省掉记住“弹出栈”的脑力步骤,你只需简单地说“我在取最近雇员的信息。”
这一长进是微不足道的,但当你要减少从1到10这么大范围的复杂度时,任何
措施都是值得的。采用具名常量而非文字量也能提高抽象级别。面向对象的编程
方法提供同时适用于算法和数据的抽象层,单靠功能分解做不到这一点。
总而言之,软件设计与构建的主要目标就是征服复杂性。许多编程实践背后
的动机正是为了降低程序的复杂度。降低复杂度乎是衡量程序员成果的最重要
依据。
34.2
Pick Your Process
精选开发过程
本书第二个主要思路就是软件开发与其过程有着很大关系。对于小的项目,
程序员的个人才能对软件质量影响最大。程序员成功与否部分取决于其对开发过
程的选择。
代大全(第2版)

<==========================876end ==============================>
<==========================877start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看
840
第34章软件工艺的话题
对于多个程序员参与的项目,组织性的重要程度超过了个人技能。即便你有
一个庞大的团队,其合力并不等于每个人能力的简单相加。人们一起工作时的方
式将决定其能力是珠联璧合还是相互抵消。某个成员对其他人的工作是支持还是
拖后腿,取决于团队采取的开发过程。
交叉参考有关把
关于开发过程的重要性,一个明显的例子是看看在需求还未确定就开始设计
需求稳定下来的
详情,请参看34和编码的后果。如果不知道要构建什么,就无法为其设计出最佳的方案。要是软
“需求的先决条件在开发过程中需要改动需求,进而导致设计跟着变化,代码也就必须更改,这
法的若干变通形样会带来降低系统质量的风险。
式,可参见3.2节
“辨明你所从事
的软件的类型”。
“说的不错,”你会说,“但现实情况中,需求不可能稳定,所以这和软件质
量不相干。”再次重申,你所用的过程将决定需要的稳定程度,以及它能承受怎样
的不稳定。如果你需要让需求更具灵活性,可以采取增量开发方法,分几次发布
功能渐强的软件,而不是将其一次统统做完。这在过程中要注意把握,而所用开
发过程将最终决定项目的成败。从3.1节中的表31能清楚地看出,需求失误导
致的成本远高于建构错误,所以注重过程的这一部分也将影响成本和进度。
我想对严肃的程
对过程的有意识掌控同理也适用于设计。在盖房子之前要打牢地基。如果地
序员说的话就是:
要花工作时间的基还没完工就匆忙建造,系统架构中的基础改动起来将变得困难。人们只好再在
一部分来检讨和设计上费神,因为他们已经为之写了代码。你开始盖房子后就很难摆脱糟糕的地
提炼自己的方法。
即使程序员总是基了。
奋力赶进度,或者
满足最后期限的
要求,对方法的抽
开发过程之所以重要,主要原因是软件开发中,质量开始就要逐步建立起
象是更明智的长来。这与那种先拼凑代码,再通过测试剔除缺陷的思路相悖。后者是完全错误的。
远投资。
bey测试仅说明软件所用的特定方法有缺陷,并不能让软件更有用、更快、更可读
或更有扩展性。
不成熟的优化是另一个过程性错误。行之有效的开发过程是在开始时粗调
后来再进行精调。如果你是个雕刻匠,应在打磨细节前就将大致的轮廓刻画出来
过早优化浪费时间,因为你会花时间去精雕细琢原本不必做的代码段。你可能会
打磨本已足够短小足够快速的代码段:你可能会色日后将要丢弃的代码;也许
你舍不得扔掉某些坏代码,因为你已花费了时间推敲它们。应该总是想想“我这
样做,顺序合适吗?次序改变影响大吗?”从而有意识地沿用好的开发过程。
代码大全(第2版)

<==========================877end ==============================>
<==========================878start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
34.3首先为人写程序,其次才是为机器
841
交叉参考有低层的过程也很重要。如果遵照写伪代码再对其填充代码的步骤,就能享受
关迭代的细节,到自上而下的设计好处。你也应确保向代码中加入注释,而不是以后再添加进去。
请参看本章
面的34.8节选
代,反反复复
关注大型过程和小型过程,意味着应暂停一下去留意自己构建软件的方式,
一次又一次”。这是值得花时间的。那种“真正重要的是代码,应当关注代码质量,而不是某个
抽象过程。”的说法是鼠目寸光,无视实验和实际中的无数与之相悖的证据。软件
开发是创造性的活动,如果不理解这一创造性的过程,就无法利用最主要的工具
大脑来创建软件。坏的过程只会损耗脑力,好的过程则能将脑力充分发
挥到极致。
Write Programs for People First,
34.3 computers Second
首先为人写程序,其次才是为机器
你的程序(名词)好似迷宫一样令人摸不清方向,夹杂着各种花招和无关
注释。对比:我的程序
我的程序(名词)算法精准,结构紧凑,性能好,注释清晰得体对比:
你的程序
Stan Kelly-Bootle
另一个贯穿本书的主题是强调代码可读性。暗含于 Holy Grail“自说明代码”
背后的动机正是出于同别人交流的需要。
计算机不关心你的代码是否好读。它更善于读二进制指令,而非高级语言的
代码。编写可读性好的代码,是为了便于别人看懂。可读性对程序的以下方面都
有正面影响:
可理解性
容易复查
错误率
■调试
■可修改性
开发时间一上述因素之综合
外在质量上述因素之综合
代大全(第2版)

<==========================878end ==============================>
<==========================879start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. --www.shubulo.com.com!仅供试看
842
第34章软件工艺的话题
在编程的早些年程可读的代码写起来并不比含糊的代码多花时间,运行时至少不比后者慢。如
序被看作是程序员
的个人财产。未经邀
果你能轻松阅读自己写的代码,确保该代码能工作也会更容易,这就是应该写可
请,人们是不会读同读性好的代码的充分理由。不仅如此,代码在复审过程中也要阅读它;你或别人
代码的就修改错误时也要读:改动代码时还要读;当别人利用你代码的一部分编写类似的
就像不会
看别人情书一样
而程序本质上是程程序时也要读。
序员写给硬件的情
书充满了只有配偶
使代码可读性好并非是开发过程中的可有可无部分,为了节省编写代码的时
因此,程序里尽是些间而不顾阅读它的时间,是不经济的你应该努力写好代码,这可以一次做到的
昵称和口语表达法,这远比你努力去读坏代码划算,因为那不得不一次次地反复做。
只有处于热恋的、以
为世界只有他们两
个的爱侣之间才能
“如果我写代码只是自己用,还需这样做吗?我有必要让它可读性好吗?”
看懂这样的程序对因为一两周后你要进行下个程序了。“嘿!我上个星期刚写了这个类,只要放入一
于外界来说简直就些经过测试的、调好的代码,就能节约时间。”如果代码不容易看懂,那就祝你好
是天书。
Michael Marcotty运吧!
因为只有你一人在干某个项目就去编写不易读的代码的想法,开了一个危险
的先例。母亲过去常常说:“你咋老是僵在这种表情”父亲则说:“习惯成自然。”
习惯影响着人的所有活动,你不能随意地支配它,所以要确保每一件事的做法就
是你想成为习惯的那种做法。专业的程序员总是写可读性好的代码。
还要认识到,“某段代码专属于你”这一说法也有歧义。 Douglas Comer对私
用和公用程序提出了相当有用的区分(Comer1981):“私用程序”是程序员自用
的程序,别人不用,也不会修改,甚至不知道这些程序存在。通常这些程序很小,
很少有异议。“公用程序”则是供作者之外的人修改和使用的程序。
公用程序和私用程序的标准可以有所不同。私用程序可以写得邋遢,充满了
限制。不过这些限制都是针对作者本人而非别人的。公用程序则一定要小心编写,
对它的限制应当有说明,它应当可靠、容易修改。要当心私用程序经常会变成
公用的,这时该对其有所转换,其中部分工作就是使其可读。
即使你觉得只有自己才会读自己的代码,现实生活中,经常还可能有人需要
修改你的代码。一项研究发现,程序在重写前平均要经过10代维护程序员的修改
HARD DATAThomas1984)维护程序员要花其50%到60%的时间,去搞懂他们要维护的代
码的含义(Parikh and Zvegintzov1983)。如果你能在代码中加入说明,他们会感
激涕零的。
代码大全(第2版)

<==========================879end ==============================>
<==========================880start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
34.4深入一门语言去编程,不浮于表面
843
本书前些章提出了一些技术,它们可以帮助你提高可读性:好的类名(及子
程序名、变量名)、精心的布局、短小的子程序;将复杂的逻辑测试隐藏在布尔函
数中;把中间结果赋值给变量,以使复杂运算清晰化等等。任何单一的技术对程
序可读性的改善都是些许的,但许多微小的改进迭加起来,就能使程序面貌一新
倘若你还是觉得无需把代码写得可读,因为别人从来不会看,那么请确信你
没有本末倒置。
34.4
Program into Your Language, Not in It
深入一门语言去编程,不浮于表面
不要将编程思路局限到所用语言能自动支持的范围。杰出的程序员会考虑他
们要干什么,然后才是怎样用手头的工具去实现他们的目标。
如果某个类的子程序成员与类的抽象不一致,你会为图省事用它,而不用更
一致的子程序吗?应以尽量保持类接口抽象的方式写代码。不必因为语言支持全
局数据和goto,就使用它们。要避免用这些有危险的编程特性,而代之以编程规
范来弥补语言的弱项。编程要使用所用语言里最显而易见的方式。这等于说是“如
果 Freddie从桥上跳下来,难道你也愿意跳吗?”认真考虑你的技术目标,然后确
定如何用你的语言最好地实现这些目标。
你的语言不支持断言?那就编写自己的 assert()子程序,也许功能上与内置
的 assert()不完全一样,但你仍能实现其大部分用处。你的语言不支持枚举类型
或具名常量?不碍事,可以按一定方式用全局变量定义自己的枚举或具名常量,
只要有清楚的命名规范。
在一些极端情况下,特别是在新技术环境中,工具也许会原始到你不得不对
所期望的编程方法有重大改变。这时,所用语言可能使你难以采用自己期望的方
法,这时你可能不得不在愿望与方法之间求得某种折中。但即便是这种情况,仍
能受益于编程规范,利用它帮助你理清环境中的危险特性。更常见的情况是,你
想做的事与工具的稳定支持差距不大,你只需对环境做出一些较小让步即可。
代大全(第2版)

<==========================880end ==============================>
<==========================881start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo..com!仅供试看^
844
第34章软件工艺的话题
34.5
Focus Your Attention with the Help of Conventions
借助规范集中注意力
交叉参考关
于规范有什么
规范是一套用于管理复杂度的智力工具。前面有些章谈到了专门的规范。本
用的分析,请参节将通过例子罗列出规范有哪些好处。
看31.1节中的
“好布局有什
么用”和“良好
许多编程细节都有定程度的随意性。循环体中该缩进几个空格?怎样格式
布局的目标”。
化注释?如何排列类的子程序?这些问题多数都有若干种正确答案。每次回答同
样内容比起只是回答正确更重要。规范能够节省程序员回答同一问题的麻烦
应该总是重复使用同样的方案。当许多程序员工作于一个项目时,使用规范能避
免各程序员随意决定导致的理解困难。
规范能够精确地传达重要信息。采用命名规范后,区区一个字符就可以区分
局部变量、类变量和全局变量;大小写字母能精确区别类型、具名常量和变量
对齐规范能够精确指示出语句间的关系。
规范可以使你免除各种风险。通过建立禁止使用危险做法的规范,可以在需
要用它们时限制这些做法,或者防范它们可能的危险例如,通过禁止全局变量
或在一行里写多条语句,避免这些危险的用法。通过要求对复杂表达式加括号、
在指针被删除后要置空以防误用,防范可能的危险。
规范增加了对低层工作的可预见性。对存储器请求、错误、输入输出和类接
口有规范的处理,能够为代码加入有意义的结构便于其他程序员弄懂你的程序
一只要他们知道你的规范。止如前面章节提到的那样,消除全局变量的最大好
处就是没有了各类和子系统之间潜在的交互。看程序的人能大致了解局部数据和
类数据被用于做什么,但很难搞清楚改变全局变量会影响到多个子系统。全局变
量让读者变得没有把握。有了好的规范,你和你的读者就有了更好的默契,就能
减少必须消化的细节数量,反过来又进一步加深了对程序的理解。
规范能够弥补语言的不足之处。对于不支持具名常量的语言(例如Python、
代码大全(第2版)

<==========================881end ==============================>
<==========================882start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com!^^.com!仅供试看
34.6基于问题域编程
845
Perl、ni的shel脚本等),规范可以区分用来读写的变量和用于只读的常量。
限用全局变量和指针的规范则是以规范弥补语言缺点的另一个例子。
在大型项目工作中,有时程序员们会规范过了头由于设立许多规范和原则
光是记住这些东西都颇花时间。但小型项目的程序员常常缺少规范,则是因为没
有充分体会到自觉遵守规范时的好处。应理解其真正价值,并充分利用规范;使
用规范以提供所需的结构。
34.6
Program in Terms of the Problem Domain
基于问题域编程
另一个处理复杂性的特殊方式就是尽可能工作于最高的抽象层次。其中一种
方法就是针对编程所要解决的问题来工作,而非针对计算机科学的解决方案
顶层代码不应充斥与文件、栈、队列、数组、字符有关的细节,程序员总不
能除了i、j、k之类外实在想不出有意义的名字。顶层代码要说明想解决的问题,
应当包括描述性的类名和确切说明干什么的子程序调用,不应有“将文件以只
读’方式打开”之类的细节。顶层代码不要包含诸如“变量i在这儿表示雇员文
件中某记录的索引号,稍后则用来表示顾客账户的索引号”之类的注释。
那是个蠢笨的编程做法。在程序的顶层,无须知道雇员数据以记录形式访问,
或者以文件形式存储。细节层的信息应隐藏起来。最高层不必关心数据如何保存,
也无须读某个注释,靠后者解释i的含义及其两个用处。对这两个用途应该分别
使用变量,例如employeeIndex和 client Index两个截然不同的变量名
Separating a Program into Levels of Abstraction
将程序划分为不同层次的抽象
显然,你必须在某些层次上按照实现层的概念去工作,但是你可以隔离开工
作在实现层次的程序部分和工作在问题域的部分。在设计程序时,应考虑图34-1
给出的那些抽象层次
代码大全(第2版)

<==========================882end ==============================>
<==========================883start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看^
846
第34章软件工艺的话题
4
高层问题域
3
低层问题域
2
低层实现结构
编程语言结构和工具
0
操作系统的操作和机器指令
图34-1程序可划分为多个抽象层。好的设计使你可以把很多时间集中在较高层,而
忽略较低层的细节
Level 0: Operating-System Operations and Machine Instructions
第0层:操作系统的操作和机器指令
若是使用高级语言,你就不必操心最底层——所用语言会自动替你打理好;
如果你用的是低级语言,就需要自己试着创建一些较高的抽象层次,以便在其上
工作,尽管许多程序员不这么做。
Level 1: Programming-Language Structures and Tools
第1层:编程语言结构和工具
编程语言结构即该语言的基础数据类型、控制结构等。大多数常见语言多数
还提供了一些库文件、对操作系统调用的访问等。使用这些结构和工具是很自然
的,因为你编程时不能没有它们。许多程序员从不会超越此抽象层工作,所以常
常活得挺累,其实完全不必如此。
Level 2: Low-Level Implementation Structures
第2层:低层实现结构
与编程语言相比,低层实现结构就是更高层次的结构。它们通常为你在大学
课程里学到的算法和数据结构栈、队列、链表、树、索引文件、顺序文件、
排序算法、查找算法,等等。如果你的程序完全以这一层的代码组成,你仍要处
理太多的细节,以征服复杂性。
Level 3: Low-Level Problem-Domain Terms
第3层:低层问题域
在这一层次上,已经有与问题域相关的原语可用。它是下面的计算机科学结
构与上层问题域代码之间的粘接层。要写这一层的代码,需要构思出解决问题的
代码大全(第2版)

<==========================883end ==============================>
<==========================884start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. --www.shubulo.com.com!仅供试看
34.6基于问题域编程
847
方法,并创建用以解决问题的各种基本构件许多应用程序中,这一层就是业务
对象层或服务层。位于该层的类提供基本词汇表和构件。这些类也许太基本,不
易直接用于解决问题,但它们为用于构造解决方案的更高层的类提供框架。
Level 4: High-Level Problem-Domain Terms
第4层:高层问题域
这一层基于问题域的术语提供了对问题工作的抽象能力本层代码对于非计
算机专业的人员一可能是你的非技术用户一—在某种程度上应是可以看懂的。
它并不怎么依赖编程语言的某些特性,因为你已经自己创建了一套处理问题的工
具。故而这一层上的代码更依赖于你在第3层创建的工具,而非你所用语言提供
的那些功能。
实现细节应隐藏在其下第两层一在计算机科学结构层,从而使硬件或操作
」
系统的变化对其不会有任何影响。这一层要包含用户的视角,因为程序变动时,
该层也会随用户视角而改变。问题域的变化会对这层影响很大,但是通过在下
层编制问题域的基本构件,这种影响应该是容易应付的。
除了这些概念层,许多程序员发现将程序分解成其他一些“层”也很有用
这些“层”有可能穿过前面说明的层。例如,典型的三层结构就穿过这里提出的
层次,还提供了进一步的工具,使设计和代码都便于管理。
Low-Level Techniques for Working in the Problem Domair
问题域的低层技术
即使没有完整的、构架性的方法用于问题域你仍可以使用本书中提出的许
多技术来解决实际问题(非计算机科学问题)。
在问题域使用类,来实现有实际意义的结构。
隐藏低层数据类型及其实现细节的信息
使用具名常量来说明字符串和文字量的意义
对中间计算结果使用中问变量。
用布尔函数使复杂逻辑判断更清晰。
代码大全(第2版)

<==========================884end ==============================>
<==========================885start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
848
第34章软件工艺的话题
34.7当心落石
Watch for Falling Rocks
编程既非完全的艺术也非完全的科学。通常实践中,它是介于二者之间的“工
艺/craft”。编程至多也就是艺术与科学相互融合产生的一个工程学科(McConncll
2004)。不管是艺术、科学、手艺,或是工程,在创建软件产品的过程中,它仍
需要大量的个人判断。程序编制时,要有好的判断力,需要对程序细微问题的警
告信息做出反应。编程中的警告信息能提醒程序中可能的错误,但它们一般不会
像路标“当心落石”那样显眼。
当你或其他人说“这段代码暗藏玄机”时,这是个危险的征兆,通常说明代
码编得不好。“玄机代码”意味着“差劲代码。如果你觉得代码有玄机( tricky
富于技巧),就应考虑重写之。
类中含有比平均数目更多的错误也是个危险信号。少数容易出错的类通常是
程序最费精力的部分。如果哪个类有比通常情况更多的错误,则很可能以后还会
这样,应考虑重写之。
如果说编程是门科学,每个警告信号就暗示着一个专门的、明确定义的纠正
动作。但由于编程仍然是一门工艺,警告信号只是指出你需要考虑某个问题,你
也不是非得重写玄机代码,或者必须去改进易于出错的类。
只有当类中有超乎寻常数量的缺陷时,才表明其质量很次:程序中有异常多
的缺陷时也会说明编程过程有问题。好的过程不可能开发出易错的代码。编程过
程还应包括对架构进行检查和平衡之后进行的复查,设计之后应该有设计评审,
编码之后应进行代码评审(复查)。到测试代码阶段,大多数错误应当消除。出
色的性能源于巧干加实。对项目的过多调试意味着大家的工作不是很巧天
写了一大堆代码,之后花了两个星期去调试决不是巧妙的干活方法。
设计度量也可作为一种警告。多数设计度量都对设计质量颇有启发性:成员
多于七个的类并不一定就意味着设计得不好,但能说明类有些复杂。同样,子程
序中有多于十个的判断点、三层以上的逻辑嵌套、过多的变量,或者与其他类联
系过于紧密,或者内部代码内聚性不强…都警告标志所有这些虽不等于类
设计不当,但应引起你的怀疑。
代码大全(第2版)

<==========================885end ==============================>
<==========================886start==============================>

该书下载自-书部落-分享计算机经典巨著-www. !--www.shubulo.cor ^.com!仅供试看
34.7当心落右
849
任何警告信号都应让你质疑程序的质量。正如 Charles Saunders Peirce说的那
样,“怀疑使我们不舒服而且不满意,所以我们总想努力摆脱之,达到放心的境
界”。将警告信息看成是“质疑之源”,将促使你去寻求更满意的解决之道。
如果发现自己的代码有重复,或者在若干做的修改很相似,你也应觉得“不
自在和不惬意”,而去质疑子程序或类中的控制是否得当。倘若发现不能很方便地
单独使用某个类,很难为其创建测试脚手架,就应质疑该类是否和其他类耦合过
紧。要是因为某些类缺乏独立性而不能重用至其他程序,这也是类耦合过紧的警
告信号。
深入一个程序时,应注意那些指示程序中某些地方设计欠佳的警告信息。不
容易写注释,不容易命名变量,不容易将问题分解成接口清晰的几个类,都说明
编码前还需要再考虑设计。无聊的命名或者无法在注释中精确地描述一段代码的
意思,同样是不好的信号。到你对设计胸有成竹时,低层的细节代码就会如泉
而来。
警惕程序出现难以理解的迹象。任何不安都是暗示。是连你都觉得难,以
后的程序员就更不用提了。如果你能费神地改进程序,他们会感激你的。不是看
懂代码,而是靠猜测来理解代码,同样也说明代码太复杂有难度就说明有问题,
所以应设法简化之。
要想充分利用警告信息,可在编程时创建自己的错误警告。这很有用,因为
ha即使你知道警告是什么意思,也很容易忽视它们 Glenford Myers曾做过有关纠错
的研究。他发现,找不到错误的最常见原因仅仅是因为忽视,这些错误在测试输
出中能够看到,却没人注意( Myers1 1978)
应该在编程时使问题难以遁形。例如,释放指针后将其置为空,从而使误用
会导致糟糕的问题。指针释放后仍可能指向有效的存储单元,将其置空以指向无
效位置,可避免错误被忽视。
编译警告是文字警告,易被忽视。如果程序出现警告或错误,决不能对其睁
一只眼闭一只眼。连明明白白的“WARNING”都视而不见你就不大可能注意
到其他细微的错误。
代码大全(第2版)

<==========================886end ==============================>
<==========================887start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo..com!仅供试看
850
第34章软件工艺的话题
软件开发中,为什么注意警告信息这般重要呢?因为考虑程序的缜密程度会
对程序质量有决定性作用,所以关注警告信息与也直接影响到最终产品的质量
34.8选代,反反复复,一次次
在许多软件开发活动中,迭代是正常现象开始规划系统时,要和用商讨
若干需求方案,直到大家达成一致为止,这就是一个代过程;为了获取更好的
灵活性,以累积方式逐步建构和交付系统,也是个迭代过程在形成最终产品前,
以原型方法快速开发出几种替代解决方案,还是一种迭代过程。对需求的反复至
少与软件开发过程的其他方面一样重要。如果局限于某种解决方案,不考虑替代
方案,项目就可能失败。生成产品前的反复是加深了解产品的一种途径。
正如第28章“管理构建”指出的那样,在项目初始规划时,依据所用方法的
不同,评估出的进度会有很大差别。使用反复方法评估能够比单一方法来得精确。
软件设计是一个逐步精化的过程,和其他类似过一样,需要经过反复修正
和改进。软件往往要通过实证而不是证明,这意味着它就得反复测试和开发,直
至能正确解决问题为止。高层和低层设计都需反复。首次尝试的方案可能行得通,
但往往不会一下子达到完美。通过几次重复和不同的方法,能得到有关问题的由
单一方法无法得到的认识。
迭代法对代码调整同样有益。一旦软件能够工作对少部分代码精雕细琢就
能显著改善整个系统的性能。然而,许多优化尝试也可能只会帮倒忙。这个过程
并不是凭直觉就能把握的。有些方法看起来会使系统变小、运行变快,实则让系
统史大更慢。优化效果的不确定性要求调整、测量再调整的反复过程。如果某
处是系统性能提高的瓶颈,就要对代码反复调整,多试几次可能比头次的效果
更好。
复审使开发过程少走弯路,它在编码的任意阶段中引入迭代。复审旨在检查
特定位置的工作质量,如果复审通不过,就要返工;否则就不需要迭代了。
代码大全(第2版)

<==========================887end ==============================>
<==========================888start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看
34.9汝当分离软件与信仰
851
工程学的一个任务,就是要事半功倍。最后开发阶段的反复,就如同别人只用
一元钱就能做的事,你却要用两元钱。 Fred Brooks说“你要做一个而后扔掉,总归
你会扔掉一个,无论如何”(Brooks1995)。软件工程的诀窍在于,在早期开发阶段
的迭代过程中,需要快速地构建尽量多的东西,之后丢弃之也不会花费多大代价。
34.9
Thou Shalt Rend Software and Religion Asunder
汝当分离软件与信仰
“宗教信仰”在软件开发中有着多种表现形式一非要坚持某种设计方法,笃信
特定的布同或注释风格,极力避免全局数据。不管是哪种情况,都是不合适的。
Software Oracles
软件先知
交叉参考管理
者如何处理编程
糟糕的是,一些专业优秀人员往往更容易偏执。革新方法需要公开,才能让
“信仰的细节别人尝试。尝试这些方法后才能充分证实或反驳之。研究结果向实践者的传播称
请参看28.5节中为“技术转移”,对于推动软件开发的实践水平有重要作用然而,传播新方法和
的“信仰问题”。兜售狗皮膏药是不同的概念。对于后者,兜售者只是不懈地让你确信他们的方法
如何灵验、如何放至四海而皆准。他们要你忘掉所学的一切,因为新方法如此伟
大,能在任何方面将你的效率提高100%。
不要盲目跟风,而应使用一种混合的方法。可用激动人心的最新方法做做试
验,但仍扎根于传统的可靠的方法。
Eclecticism
折中主义
交叉参考关要对编程问题找出最有效的解决方案时,盲目迷信某种方法只会缩小你的选
于确定式和启择余地。要是软件开发是确定的精确过程就能按固定的套路解决问题:但软件
发式方法的不
同点,请参看开发并非确定过程,是需要逐步细化的,因而生硬的过程是不合适的,很难指望
2.2节“如何使会成功。例如,设计中有时自顶向下分解法行得通,有时面向对象的方法、自底
用软件隐”。
有关设计的挑向上综合法或数据结构法会更好些你应有意识地尝试几种途径,明知这些方法
选之道,请参看中有的可能成功、有的可能失败,但只有通过实践才能知道哪些好使。你必须采
5.4节中的“选
代”。
取折中的态度。
代码大全(第2版)

<==========================888end ==============================>
<==========================889start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看
852
第34章软件工艺的话题
一味坚持某种方法,还会将问题强行塞到其解决方案中如果没有充分了解
问题就定下解决方法,说明你还不够成熟。受限于所坚持的思路,你很可能与最
有效的方法失之交臂。
刚开始接触任何新方法时,人们会感到不自在。而建议你不要有编程“信仰”,
并不是说用新方法解决问题遇到麻烦时就马上停用新方法。对新方法有个合适的
定位,但同样也要对老方法有合适定位。
交叉参考有
关工具箱的比
对于本书展示的技术,和其他途径所给出的技术一样,折中主义都是一种有
喻,请参看2.3益的态度。这里对若干问题的讨论提供了许多可以相互替代的高级方法,但毕竟
节中的“应用软不能同时用。对于每个特定问题,你需要选择这种或者那种方法。你应该将这些
件技术:智慧工
具箱”
方法视为工具箱中的工具,工作时自己判断挑选最好的工具。多数时候工具的选
择关系不大,你可以选择老虎钳或者尖嘴钳。但有些场合,工具选择至关重要,
故而要仔细做出取舍。工程学的规则之一就是权衡各种技术。如果早早将自己的
选择限制在单一工具上,就无法做出权衡。
由于“工具箱”形象地比喻出抽象的折中思想,所以这个比喻很有用。设想
你是个机械师,你的伙伴 Simple Simon老爱用老虎钳,假如他不愿使用其他种类
的钳子,你可能会觉得这家伙真稀奇,因为他不会用给他配的那么多工具软件
开发中的道理也是一样。在高层会有几种可用的设计方法;在较细化的层次,可
以选择若干数据类型中的一种,来实现给定设计:再细化,可对布局方案、代码
注释、变量命名、定义类接口和传递子程序参数方面有多种选择。
顽固的态度与软件创建中的可选择工具箱方法背道而驰,也不是创建高质量
软件所应持的态度。
Experimentation
试验
折中主义和试验之间有着密切联系。试验应贯穿整个开发过程,但固执会
妨碍你这么做。要想有效地试验,应能基于试验结果改变思路;否则试验只会白
白浪费时间。
软件开发中许多顽固的方法源于对错误的畏惧心理。“试图没有错误”是最大
的错误。设计正是仔细地规划小错误以避免大错误的过程。软件开发中的试验是
为了验证某种方法是否可行一只要它解决了问题,就算成功了。
代码大全(第2版)

<==========================889end ==============================>
<==========================890start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo..com!仅供试看^
要点
853
试验可以用在许多层次上,和折中主义一样。每一层上,当你要做出选择时,
就要搞个相应的试验,看看哪个方法最佳。在架构设计层,试验可以是对软件结
构的勾勒(使用三种不同方法);在详细设计层,试验也许是对上层结构指示的遵
循(对应使用三种不同的低层设计方法);在编程语言层,试验是能够编个简短的
测试程序,以验证自己不太熟悉的语言特性。试验还包括调整代码,并测量其效
率,看程序是否真变短变快了。在软件开发过程的整体层上,可能通过试验收集
质量和效率数据,以了解正式检查是不是比走查找出的错误更多
关键是对软件开发的各方面,你都应保待开放的心态。这样才能从开发过程
和产品中有所收获。开放性的试验和顽固坚持某种方法可完全是两码事。
Key Points
要点
编程的主要目的之一是管理复杂性。
编程过程对最终产品有深远影响。
合作开发要求团队成员之间进行广泛沟通,甚于同计算机的交互;而单人开
发则是自我交流,其次才是与计算机。
编程规范一旦滥用,只会雪上加霜;使用得当则能为开发环境带来良好机制,
有助于管理复杂性和相互沟通。
编程应基于问题域而非解决方案,这样便于复杂性管理
注意警告信息,将其作为编程的疑点,因为程几乎是纯粹的智力活动。
开发时迭代次数越多,产品的质量越好。
墨守成规的方法有悖于高质量的软件开发。将编程工具箱中填满各种编程
工具,不断提高自己挑选合适工具的能力。
代码大全(第2版)

<==========================890end ==============================>
<==========================891start==============================>

该书下载自-书部落-分享计算机经典巨著!w. ! --www.shubulo.c.com!仅供试看^

<==========================891end ==============================>
<==========================892start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com! ^^.com!l仅供试看^个
Where to Find More
Information
第35章
何处有更多信息
cc2eco/350内容
35.1关于软件构建的信息:第856页
35.2构建之外的话题:第857页
35.3期刊:第859页
35.4软件开发者的阅读计划:第860页
35.5参加专业组织:第862页
相关章节
Web资源:www.cc2e.com.cn
读到这儿时,你应已对行之有效的软件开发实践有了不少了解。实际上你还
能获取比这些多得多的信息。你犯的错误别人早已犯过,要是不想自讨苦吃,就
读读他们的书吧,这样能够避免再走弯路,并找出解决问题的新方法。
由于本书提到过软件开发的几百本书籍(或文章),很难说该先读哪一本。软
件开发资料库由几类信息构成:一类核心书籍解释有效编程的基础概念;相关的
书籍解释编程技术管理及知识背景;还有关于编程语言、操作系统、环境和硬件
等面向特定主题的参考书等。
ccec/3581最后一类书通常都有着与一个项目相同的生命期,它们多多少少都只是暂时
的,我们不再予以讨论。而对于其他类书籍,你有必要拥有一套核心书籍,能深
入讨论各种主要的软件开发活动,即关于需求、设计、构建、管理和测试等方面
的书籍。本章后面几节将说明有深度的构建资源,而后列出其他软件知识领域的
综述性资料。35.4节把这些资源组织成井然有序的清单,作为软件开发人员的阅
读计划。
代码大全(第2版)

<==========================892end ==============================>
<==========================893start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
856
第35章何处有更多信息
35.
Information About Software Construction
关于软件构建的信息
cc2c/3588我写这本书的最初原因是当时还没有一本透彻讨论软件构建的书。自从发表
了本书的第一版后,市面上有了一些好书。
《 Pragmatic Programmer》(《实用主义程序员)(Hunt and Thomas2000)首眼
于与编码紧密相关的活动,包括测试、调试、断言的用法等等。该书对代码本身
并没有深入,但包含了许多关于生成优质代码的原则。
Jon Bentley Programming Pearls》,2ded.Bentley2000)以小程序为背景讨论
了软件设计的艺术和科学。该书由许多短文组成。这些短文写得很好,表现出对有效
构建技术的深邃眼光和真挚热情。我几乎每天都能从 Bently的短文中有所收获。
交叉引用关于极 Kent Beck的《 Extreme Programming Explained: Embrace Change》(Beck2000)
限编程和敏捷编程对软件开发提出了以构建为中心的方法。正如3.1节(“前期准备的重要性”)中
的经济性,请参看
c2co05解释的那样,极限编程的经济性并未被产业研究所证实,但其许多建议都有益于
构建过程,不管开发团队采用极限编程还是别的什么方法。
Steve Maguire Writing Solid Code -Microsoft's Techniquesfor. Developing
Bug -Free- Software》(Maguire1993)是一本较专门的书籍。它注重商用级应用软
件的生产实践,大部分基于作者开发 Office软件的专业知识该书的技术是在C
语言下用的,基本上不关心面向对象编程方面的问题,但其提及的话题可适用于
有关的各种环境。
Brian Kernighan和 Rob Pike合著的《 The Practice of Programming》(Kernighan
and Pike1999)则是另一本较专门的书籍。它着重于编程的本质和实践方面,架起
了连接计算机科学理论与动手实践的桥梁。该书包括有编程风格讨论、设计、调
试和测试,其读者应熟悉C、C++
cc2e.com/3549
尽管已经绝版,很难寻觅, Susan Lammers的《 Programmers at Work》Lammers
1986)仍值得一看。书中有对业界最顶尖的程序员的采访记录。这些采访揭示了他们
的个性、工作习惯和编程哲学。受访者有 Bill Gates( Microsoft公司创始人)john
Wamock( Adobe公司创始人)、 Andy Hertzfeld Macintosh操作系统的主要开发者)
Butler Lampson(原dec高级工程师,现为 Microsoft效力)、 Wayne Ratliff(dBase
的发明者)、 Dan Bricklin(VisiCalc的发明者)诸多人士。
代码大全(第2版)

<==========================893end ==============================>
<==========================894start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com!^.com!仅供试看^
35.2构建之外的话题
857
35.2构建之外的话题
Topics Beyond Construction
除了上一节提到的核心书籍,有些书还涉及软件构建之外的话题。
Overview Material
综述资料
cc2e.com/3595
下列书籍从各种角度给出了软件开发的总体说明。
Robert L. GlassFacts and Fallacies of Software Engineering)(Glass 2003)
介绍传统软件开发的规则与戒律。该书研究透彻,并给出了附带资源的链接。
我自己的《 Professional Sofware Development》(《专业软件开发》)(McConnell
2004)探讨了软件开发领域的现状,以及如果还按老模式发展,现在会是什么样
子。
KSwebok: Guide to the Software Engineering Body of Knowledge)(Abran 2001)
(Swebok:软件工程知识体指南)详细分析了软件工程的知识,并深入到软件生
成方面的细节。该指南揭示了此领域知识的丰厚积蕴。
Gerald Weinberg《 The Psychology of Computer ProgrammingWeinberg》(1998)
充满了编程的轶闻趣事。它涉及的面很宽,因为编撰该书的时候,人们把任何关
于软件的事都看成是“程序开发”。在 KACM《 Cumputing Reviews》杂志上有对该
书的评论,即便现在,对该书的赞许仍不减当年。
每个程序员的上司都该有一本,应当认真读读用心去记,按其中的训行
事;放在办公桌上供其程序员去偷。但他仍要继续再放一本,直到没人拿为止。
Weiss于1972年
如果你找不到《程序开发心理学》,就去找《 The Mythical Man-Month-》(Brooks
1995),或《 People Ware》(DeMarco and Lister199)两本书都极力主张编程压倒
一切的是人之间的活动,其次才涉及计算机。
最后要推荐的优秀软件开发综述类书籍,《 KSoftware Creativiry(Glass1995)
该书如同《人件》对于软件开发团队一样,堪称是软件创新性的突破性书籍 Glass
探讨比较了创新与规矩、理论与实践、启发与方法论、过程与结果等许多软件领
域的事物两面。我和手下的程序员经过几年的讨论,认为该书的难度在于其中的
代大全(第2版)

<==========================894end ==============================>
<==========================895start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!仅供试看
858
第35章何处有更多信息
短文是 Glass收集编纂的,而非他所写。对于有些读者,此书好像意犹未尽。尽
管如此,我仍要求公司里的每个开发人员都看这本书。该书已经绝版,很难找到,
但要是能找到,也不会杜费你的辛劳。
Software-Engineering Overviews
软件工程综述
计算机程序员和软件工程师都该有一本关于软件工程的高级读本。这种书应是对
方法的综览,而非描述特定的细节。它们提供有软件工程的概括,并总结特定的软
件工程技术。综述没有详尽到训练你使用某个技术,否则,单单一本书就有几千页厚。
这些书提供足够的信息,供你了解技术间的关联,可以有选择地深究某些技术。
Roger S. Pressman (Software Engineering: A Practitioner's Approach) 6th ed.
(Pressman2004)恰当处理了软件需求、设计、质量验证和管理等方面。其长达900
页的内容很少涉及编程实践,但这是微不足道的问题,尤其在你已经有了类似本
书的软件构建书籍后。
Ian Sommerville的《 Software Engineering》第6版(Sommerville2000与
Pressman的书内容类似,除此之外还提供了软件开发过程的高层综述
Other Annotated Bibliographies
其他注释过的参考书目
cc2e.com/3502
好的计算机参考文献汇编很少。这里列出的书值得努力获取。
KACM Computing Reviews》是美国计算机协会(Association for Computing
Machinery,ACM)的专题出版物,致力于评价所有计算机和编程方面的图书。该书
依据一个广泛的分类方案组织信息,你很容易就能找到所在领域中感兴趣的书籍。
有关该出版物的信息,以及如何成为ACM会员,请参看ww.acm.org网站
cc20.com/3509 construx  (construx Software's Professional Development软件专业开发阶梯(Constoftware'sproesionalevelomen
ladder), www.construx. com/ladder/ .)其网址wwwconsux.omader它有许多推荐的程序,可供软件开
发人员、测试人员和管理人员阅读。
代码大全(第2版)

<==========================895end ==============================>
<==========================896start==============================>

该书下载自书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^ ^.com!仅供试看
35.3期刊
859
35.3
Periodicals
期刊
Lowbrow Programmer Magazines
初阶程序员技术杂志
以下杂志在当地书报亭有售。
cc2e.com3516 cc2e.com/3516 software development), www. sdmagazine. como》,其网址为ww.sdmagazine.com该杂志专注于编
程问题,除了主要涉及专业程序员的一般性问题外,还有一些特定环境的技巧
文章的质量相当好,也有一些对软件产品的评论。
cc2.com3523《 cc2e,com/3523 dr. dobb's journal, www. ddj. com.》,其网址为ww.dj.com该杂志面向铁杆程序员。其
文章多是处理细节问题,还提供大量的源代码。
如果不能在当地书报亭买到,许多出版商可以免费赠送你一份,很多文章还
能够在网上找到。
Highbrow Programmer Journals
高阶程序员学术期刊
这类杂志一般不通过书报亭零售,可去大学图书馆查询或订阅
cc2.com35 cc2e.com/3530 ieee software ),  www. computer, org/ software/.》其网址为wwwcomuter.org/software/.该双月刊关注
软件之构造、管理、需求、设计以及其他前卫的软件话题。其任务是“建设软件
带头人的社区”。1993年,我发表的文章提到它是“程序员该订阅的最有价值的
杂志”。从那时起,我成了该杂志的主编。到现在我还认为对于严肃的软件实践者,
它是最好的期刊。
cc28.com/3537
kieee computer), www. computer. org/computer/.,其网址为ww.computer.org/computer.该双月刊是
电子与电气工程师协会(Institute of Electrical and Electronics Engineers计
算机社区(Computer Society)的权威出版物。它发表的文章涉及广泛的计算机话
题,对所发表的文章有严格的审核标准以保证其质量。由于其广度你感兴趣的
文章可能会比《《IEEESgjhware>《》少。
cc.com3544 ce20.com/3544  communications of the acm acm. org/cacm/ .其网址为wwacm.org/cacm/该杂志是最
久远最受尊敬的计算机出版物之一,具有发表深度和广度的计算机科学文章的优
势。计算机科学是一个远比几年前浩瀚的话题。同《《IEEComputer《》类似,由于
它涉猎广泛,你可能会发现许多文章是在你感兴趣的领域之外。这本杂志有学术
味道,这既是好事也是坏事。坏的方面是某些作者的学术文章有点海涩;好的方
面是能包含领先潮流的信息,这些信息往往数年之后才会出现在初阶杂志上。
代大全(第2版)

<==========================896end ==============================>
<==========================897start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
860
第35章何处有更多信息
Special-Interest Publications
专题出版物
若干出版物能够深度涵盖一些专门的话题。
Professional Publications
专业出版物
cc2.com355 cc2e.com/3551  ieee computer society出版专题期刊,涉及软件工程、安全与隐私、计算机
图形学与动画、互联网开发、多媒体、智能系统、计算史等方面。可访问
www. www.computer. org ..org了解更多信息。
cc2com/35acm也有专门的出版物,探讨人工智能、计算机与人的交互、数据库、嵌入
式系统、图形学、编程语言、数学软件、网络、软件工程等话题,可访问www.acm.org
了解更多信息。
Popular-Market Publications
通俗出版物
cc2e.com/3565下列杂志涵盖的领域已由其名称指明:
杂志名
网址
the c/c++ users journal www.cuj. com
java developer's  journal  www. sys-con. com/java/
embedded systems programming  www. embedded. com
Linux Journal
www.linuxjournal.com
Unix Review
www. unixreview. com
windows developer's network www. wd-mag. com
35.4
A Software Developer's Reading Plan
软件开发者的阅读计划
cc2e.com/3507
在我们 Construx软件公司,软件开发人员要站稳脚跟,必须历经一个阅读大
纲,本节就来说明之。该规划只是想要成为职业软件人的一般性底线。我们那富
有人情味的大纲也会依据个人兴趣,提供量体裁衣的深入计划。在 Construx内部,
还辅以培训和直接的专业实习。
Introductory Level
入门级
在 Construx,要迈过“入门级”,开发人员必须看以下书籍。
Adams, James L. KConceptual Blockbusting: A Guide to Better Ideas ) 4th ed.
Cambridge, MA: Perseus Publishing, 2001
代码大全(第2版)

<==========================897end ==============================>
<==========================898start==============================>

该书下载自书部落分享计算机经典巨著!--www. !--www.shubulo.com!^^.com!仅供试看^
35.4软件开发者的阅读计划
861
Bentley, Jon. Programming Pearls), 2d ed. Reading, MA: Addison-Wesley, 2000.
Glass, Robert L. Facts and Fallacies of Software Engineering). Boston, MA:
Addison-Wesley, 2003.
McConnell, Steve. Software Project Survival Guide). Redmond, WA: Microsoft
Press, 1998.
McConnell, Steve. Code Complete, 2d ed. Redmond, WA: Microsoft Press, 2004.
Practitioner Level
熟练级
要达到“中级”水平,程序员需要阅读以下材料。
Berczuk, Stephen P. and Brad Appleton. Software Configuration Management
Patterns: Efective Teamwork, Practical Integration Boston, MA: Addison-Wesley, 2003
Fowler, Martin. KUML Distilled: A Brief Guide to the Standard Object Modeling
Language), 3d ed. Boston, MA: Addison-Wesley, 2003.
Glass, Robert L. Software Creativity). Reading, MA: Addison-Wesley, 1995.
Kaner, Cem, Jack Falk, Hung Q. Nguyen. <Testing Computer Software), 2d ed. New
York, NY: John Wiley Sons, 1999.
Larman, Craig. KApplying UML and Patterns: An Introduction to Object-Oriented
Analysis and Design and the Unified Process), 2d ed. Englewood Cliffs, NJ: Prentice Hall
2001.
McConnell, Steve. KRapid Development). Redmond, WA: Microsoft Press, 1996.
Wiegers, Karl. Software Requirements), 2d ed. Redmond WA: Microsoft Press.
cc28.com/3514 manager's handbook for  software Development," NASA Goddard Space Flight
Center. Downloadable from sel.gsfcnasa. gov/website/documents/
online-doc. htmo
Professional Level
专业级
在 Construx,软件开发者要读了下列资料才能达到专业级水平(领导阶层)。
除了对开发者有一般性要求外;对各人还有特定要求本节说明一般要求
Bass,len, Paul Clements, and Rick Kazman.《 Software Architecture in Practice》
2d ed. Boston, MA: Addison-Wesley, 2003
Fowler, Martin.《 Refactoring: Improving the Design of Existing Code》. Reading
MA: Addison-Wesley, 1999
Gamma,Erich, et al. Design Patterns). Reading, MA: Addison-Wesley, 1995
代大全(第2版)

<==========================898end ==============================>
<==========================899start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
862
第35章何处有更多信息
Gilb, Tom. Principles of Software Engineering Management). Wokingham.
England: Addison-Wesley, 1988.
Maguire, Steve. Writing Solid Code), Redmond, WA: Microsoft Press, 1993.
Meyer, Bertrand. Object-Oriented Software Construction), 2d ed. New York,
NY: Prentice Hall PTR, 1997.
cc2e.com/3521
"Software Measurement Guidebook," NASA Goddard Space Flight Center. Available
from sel.gsfc. nasa. gov/website/documents/online-doc. htm
cc2e.com/3528要了解此专业发展计划及阅读清单的最新更新情况,请访问我们的专业开发
网站www. www. construx.  com/professionaldev/..com/professionaldev/.
35.5参加专业组织
Joining a Professional Organization
cc2e.com/3535
了解编程的最好途径是与其他程序员交往。当地专门的硬件和编程语言用户
群就是其中的一种团体,另外还有国家或国际的专业机构。最好的面向实践者的
组织是EEE计算机社区。它办有《EEEComuter》和《EEB《IEEEComputer《IBSgfare》期刊
有关其入会信息,请访问www. , www. computer. org..org.
c.c/3542美国计算机协会一度是最本源的专业组织,现办有《ACM通讯》及许多专题
杂志。它比IEEE计算机社区倾向于学术研究。有关其入会信息,请访问
www. acm.orgo
代码大全(第2版)

<==========================899end ==============================>