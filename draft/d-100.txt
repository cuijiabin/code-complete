<==========================6start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--www.shul.com!仅供试看
译序
这本书讲什么
《代码大全》这本书的原名叫《《CodeCompIete)codecomIee《,那么codecomplete在这里是何含义
呢?首先,它不代表现代集成开发环境(IE)中的代码自动补全功能,本书也不打算向
您讲解 Eclipse或 Visual Studio2005中的代码自动补全功能是如何实现的。其次,code
complete也不是真正的软件源代码“大全”的意思,这本书既没有列出连接各种数据库
的代码、也没有列出网页中常用的各种 JavaScript代码书中的代码示例恐怕也不能直接
copy&paste代码到您自己的项目中
那么 code complete到底是什么意思?中译本为什么又要取名为“代码大全”呢?虽然
从网上讨论的情况看,各位网友对书名含义的理解有出入,但是译者有充分的理由相信,
code complete是“编码完成”的意思,是一个软件项目开发过程中的重要里程碑( milestone)
软件项目进行到这里,表明已经完成了所有的编码工作,即将开始系统测试。
这本书讲的正是为了到达“编码完成”这一重要里程碑所必需的软件构建技术,确切
地说,就是如何编写高质量的代码。作者认为,应该首先为人编写代码,其次才是为机器
(第34.3节);代码主要是供人阅读的。遍布全书的提高代码质量的实实在在的技术和诀
窍,是本书最有价值的部分。事实上,我们认为第6、7、10至19章这300多页的内容是
本书的精华内容,在其他书里恐怕很难找到如此详尽的对变量、语句、子程序等编程基本
要素的讨论。
十多年前,本书第1版以《代码大全》为名翻译出版在过去的10余年中,这本书影
响了整整一代程序员,“代码大全”四个字己成为一个响当当的名字。鉴于此,本书第2
版决定保留这个无伤大雅的“错误”,沿用“代码大全”作为书名,也借此向原书第1版各
位译者、修订者们的辛勤劳动表示我们的敬意。无论如何,对 code complete的理解不会影
响对整本书的理解。
本书除了讲如何构建高质量的软件,还讲如何成为一名优秀的程序员(第33章“个人
性格”、第4.3节“你在技术浪潮中的位置”、第4.4节“深入一门语言去编程”)。
代大全(第2版

<==========================6end ==============================>
<==========================7start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
i
译序
这本书适合谁看,该怎么看
任何想写出好程序的人,或者想带领一群程序员写出好软件的人,都不应该错过这本
好书。作者在前言中指明了本书的读者群(包括经验丰富的程序员、技术带头人、自学的
程序员、学生等),请您参阅。
这是一本800多页的大部头,从头到尾阅读要花不少时间,谁都希望能尽快找到对白
已有用的内容。译者大致针对不同的读者群提点阅读建议,仅供参考。
初级程序员,请先看第18章“表驱动法”:将复杂的逻辑判断转换为查表,从而简化
代码的编写与维护。另外,本章中的一个示例说明了,面向对象设计并不只要因为它
是“面向对象”,就一定会好于其他的设计。
高级程序员,请先看第4章“关键的‘构建’决策”本章关注的焦点是程序员和技
术带头人个人必须(直接或间接)负责的项目准备工作。
项目经理,请先看第33章“个人性格”,程序设计是一项纯粹的脑力劳动,本章对挑
选和培养优秀程序员提出了建议。事实证明,相对于聪明程度(智商),个人性格(情
商)对于造就出程序员高手更具有决定性的意义。
低年级学生,请先看第11章“变量名的力量”这本书用了整整一章(30多页)的篇
幅来讲解“为变量命名”这一编程中最常见的活动,这里提供的建议在别的书里是很
难见到的。
高年级学生,请先看第8章“防御式编程”,本章讲述如何面对严酷的充斥非法数据
的真实世界,在遇到“绝不会发生”的事件和其他程序员犯下的错误时如何保护自己。
对于那些正在从学术环境转向专业开发环境的学生来说,这是必备的一课
■制定编码标准的人,请先看第32章“自说明代码”本章中有一段关于注释的精彩对
话,它可能会改变您在制定编码标准时对注释的要求。
自学编程的人,请先看第7章“高质量的子程序”本章详细讨论了子程序的命名和
参数选择等问题,其中对子程序最佳长度的讨论颇有借鉴意义。
■喜欢参与网上争论的人,请先看第13.3节“全局数据”和第17.3节“goto语句”,听
听学术界在这些问题上的争论也挺有意思。
当然,这整本书都非常值得一读,准确地说,值得反复阅读。书中不仅有实实在在的数
据和论述,也有一些有趣的比喻,作者偶尔还开开玩笑,读起来一点也不枯燥。
另外需要说明的一点是,书中出现的诸如“Yourdon1986b)”表示的是参考文献,可
以从第863页起的参考文献列表中查到文献的原名和出处,例如,(Yourdon1986b)代表的
代码大全(第2版)

<==========================7end ==============================>
<==========================8start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubu.com!仅供试看^
译序
是EdwardYurdon《ationsutRisk(2000写的《Nationsatisk》一书。如果只出现“200”字样,那么请您从
上下文中推断出作者姓名。
配套网站
这本书英文版的配套网站是1ltp:w.c2eom,书中左侧出现的类似
cc2e.com/1234的标志的含义请参阅前言中的说明。本书中文版的配套网站是
http: //www.cc2e. com. cn, cc2e.com/1234凡是书中出现的cc2ecom/1234均可对应访问
cc2e.com.cn/1234.
本书已经根据原书截2006年2月初的勘误表进行了修订,译者发现的原书疏漏也已
用译注标明。就像写程序做不到 bug free一样翻译书难免也会有错,如果您在阅读中发
现任何疑问,欢迎来本书配套网站与译者交流这个网站还提供最新的勘误表和其他一些
信息(例如我们把 routine翻译为“子程序”的理由对书中观点的讨论、书评等)
致谢
本书的翻译工作由4名译者共同完成,各人负责章节如下:金戈翻译前言和第1、2、
5~9章,汤凌翻第10~26章,陈硕翻译第3、4、27~30章,张菲翻译第31~35章。北京
大学的裘宗燕教授审校了全部书稿,对稿做了大量的修订并提出相当多的指导意见。在
此我们对裘老师表示衷心的感谢,他的辛勤劳动使本书的翻译质量上了一个大台阶。全书
最后由陈硕统稿。译者汤凌特别要感谢同事雷程炜工程师,他为汤凌复查了大部分初译版
本文字。另外,本书部分翻译工作基于杨哈达和郑毅帆的初译稿,在此也一并致谢。
译者特别感谢本书编辑团队中负责全书统筹工作的陈玉女士和负责本书配套网站建
设的余广先生以及编辑团队的其他人员。
最后,祝读者能借助本书提高自己的编程功力,成为优秀的软件开发人才。谢谢!
译者
2006年2月初
代码大全(第2版)

<==========================8end ==============================>
<==========================9start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看^
谨以此书献给我的妻子 Ashlie尽管她并没有干过什么计算机
编程,但做了数不清的事情来使我的生活丰富多彩。
代码大全(第2版)

<==========================9end ==============================>
<==========================10start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shub.com!仅供试看
一切皆有可能
一出版人感言一
2003年夏天,博文视点刚成立不久,一次,我和孟岩在msn上聊天,孟岩说:“周
老师,有本绝好的书刚刚出了第2版,不知现在版权还在不在?”我向来深信孟大侠
的眼光,让他赶紧告诉我,原来是《代码大全》孟岩还告诉我,该书第1版是十多
年前问世的,很多人都在找这本书,未果。
我当即请电子社版权部的同事向微软出版社洽询《代码大全》(第2版)的翻译
版权事宜,但版权部多次积极联络,对方的回复总是“在查询中”后来和孟岩谈及,
我们俩感到,很可能这本书的翻译版权已花落他家,多半没戏了。但既然对方没肯定
说版权已经授予因内其他出版社,那么始终笃信“一切皆有可能”的我,就不会放弃
申请。
2004年的某个阶段,微软出版社因某种原因,暂停与中国出版社的版权贸易。
向来办事效率极高的电子社版权部经多方打听,了解到微软出版社与国内出版社暂停
合作的原因,提出了电子社和微软出版社率先启动合作的具体方案,并请博文视点参
与同微软出版社的合作谈判,我两次在北京出席与微软出版社代表的面谈每次面谈,
我都要求博文的外版编辑在申请合作的书目上,首先列出《代码大全》(第2版),而
对方也总是不能给予正式的回复。隐隐中,感觉这本书的翻译版权似乎离博文视点有
些遥远…
然而,电子社是幸运的,博文视点是幸运的,我是幸运的由于电子社版权部
办事效率极高,赢得了微软出版社的信任,200年12月,对方发来了授权文件,其
中就有《代码大全》(第2版)。得知这个消息,博文视点的外版编辑方舟有些不敢相
信,还问我,会不会是微软出版社弄错了。方舟是个怀疑派,所以当初我要求他把这
本书列入申请名单时,他略微嘟囔了几句,大意是说我们这些瞎猫想逮活耗子,云云。
接下来寻找译者也不易,所幸我没看错我的朋友金戈,他在翻译过程中,几次遇
到困难:翻译团队中途换人,由他领衔主持的国家级项目,时间要求也非常紧,但他
咬牙坚持下来了。也非常感谢裘宗燕老师一向对我工作的支持,裘老师答应担任这本
书的审校工作,让我感到幸运而踏实。
这本书也凝聚了我的同事陈元玉无数个日夜的心血,她以高度负责的态度赢得了
代丹大全(第2版)

<==========================10end ==============================>
<==========================11start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
一切皆有可能
全体译者的赞誉。方舟编辑,也从怀疑变为狂喜,在他眼里,这本书是“绝色佳人”
因此,美术基础不错的他亲自为这本书设计了封面博文的市场经理余广是网页设计
爱好者,和编辑张昊一起为《代码大全》(第版)精心打造了中文版配套网站
(http: / /www.cc2e. com. cn)
当年慧眼指路的孟岩,已经是《程序员》杂志的技术主编,他在2006年第3期
《程序员》杂志上为这本书组织了15个版面的专题报道,这是空前的,也是“绝色
佳人”才有的待遇。
出版人的快乐,莫不来自于与好书结缘。回顾一年多为这本书付出的辛劳,过往
的一切都显得那么美好。我自己,更是感到特别的幸运我能和这样一群优秀的伙
伴在一个团队里工作,能在我的职业生涯里和这样一本“绝色佳人”级别的好书结缘,
惟有感恩!
希望这本书,能带给读者真正的帮助,也恳请读者朋友随时指出我们应该改进的
地方。
博文视点,愿与所有向上的心合作,共同成长!
周筠
2006年3月于武汉
代码大全(第2版)

<==========================11end ==============================>
<==========================12start==============================>

该书下载自书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
Preface
前言
普通的软件工程实践与最优秀的软件实践差距巨大多半比其他工程学科中
的这种差距都要大。因此,传播优秀实践经验的工具是十分重要的。
Fred Brooks
我写这本书的首要目的,就是希望缩小本行业中一般商业实践与大师级人物及专
家们之间的知识差距。许多强大的编程技术在被编程领域的大众接触之前,都已在学
术论文和期刊里尘封了多年。
虽然近年来前卫的软件开发实践迅速发展,但普通的实践手段并没有太大变化。
很多程序的开发仍然是漏洞百出、迟于交付并且超出预算,还有很多根本就无法满足
用户的需求。软件业界以及学术界的研究人员已经发现了不少行之有效的实践经验,
足以解决自20世纪70年代以来编程领域中日益蔓延的大多数问题。可是这些实践经
验很少在高度专业化的技术期刊之外对外发表,所以时至今日大多数编程的机构和组
织还没能用上这些技术。有研究表明,一项研发成果从其诞生之日起,到进入商业实
践阶段,通常要经历5到15年甚至更长的时间(Raghavan and Chand1989 Rogers
1995 Parnas1999)。这本手册就是想缩短这一漫长的过程,让那些关键性的研发成
果现在就能为更多编程人员所用。
Who Should Read This Book
谁应当阅读本书
本书中所汇集的研究成果和编程经验,将帮助你创建更高质量的软件,使你能更快
速地进行开发,遇到的问题更少。本书将帮你弄明白过去为什么会遇到那些问题,并告
诉你如何在将来避免它们。这里所描述的编程实践将帮助你掌控更大型的项目,还能在
项目的需求发生变动时帮助你成功地维护并修改已经开发出来的软件。
Experienced Programmers
经验丰富的程序员
对于经验丰富的程序员而言,本书正是他们想要的一本翔实、易用的软件开发指南。
本书关注的是“构建(construction)”,即整个软件生命周期中最为人熟知的部分;本书
把强大的软件开发技术写得让自学的程序员和参加过正规训练的程序员都能读懂。
代码大全(第2版)

<==========================12end ==============================>
<==========================13start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
XX
前言
Technical Leads
技术领导
许多技术领导(或者说是技术带头人)都曾在他们的团队中使用《代码大全》(第
1版)培训经验不足的程序员。当然,本书也可以用来填补你自己的知识缺陷。如果
你是一位经验丰富的程序员,你不一定会同意我给出的所有结论(如果不是这样,我
倒会觉得奇怪)。但如果你阅读本书并思索其中的每一个问题之后,那么几乎不会有
人再能提出什么你未曾思考过的软件构建方面的问题了。
Self-Taught Programmers
自学的程序员
如果你没有受过太多的正规训练,本书正是你的良伴。每年约有5000个新手
进入这专业领域(BL2004, Hecker2004),但每年却只有35000个人获得与软件
相关的学位(NCES2002)。从这些数据中我们可以很快得出一个结论很多程序
员并没有接受过软件开发方面的正规教育。在许多新兴的专业人员社群中都可以看到
自学的编程人员工程师、会计师、科学家、教师以及小公司的老板们;编程序是
他们工作的一部分,但他们并不一定把自己看作是程序员。无论你在编程方面受过何
种程度的教育,本手册都会让你能对各种行之有效的编程实践有深入的了解。
Students
学生
与有经验但缺之正规培训的程序员对应的,是那些刚刚毕业的大学生新近毕业
的学生大多拥有丰富的理论知识,但却缺乏创建产品级的程序(production programs
的实践技术。关于编写优秀代码的实践知识,像部落里祭祀仪式上的舞蹈一样,只
能慢慢地从软件架构师、项目负责人、分析师以及更有经验的程序员那里传承下来。
更多的时候,这些知识就是程序员个人反复的尝试和犯错后的结晶本书则是这些缓
慢、传统智慧传承方式的一种替代方案,它汇集了以往只能从他人经验中猎取和收集
的大量实用的经验技巧和有效的开发策略。对于那些正在从学术环境转向专业环境的
学生来说,这是一本必备的读物。
Where Else Can You Find This Information
还能从何处找到这些信息
本书综合整理了来自四面八方的多种软件构建技术这些技术是软件构建领域长
年累月积聚下来的智慧财富,它们不仅分散而且其中大部分素材常年散落于纸面之
外(Hildebrand1989, McConnell1997a)。其实,内行的程序员们所用的那些强大有
效的编程技术并不神秘。但是这些内行人士面对手头日复一日紧张冲刺的项目,几乎
没有谁花些时间和大家分享他们所学到的知识和技能。因此,程序员们可能很难找到
代码大全(第2版)

<==========================13end ==============================>
<==========================14start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.co.com!仅供试看
前咅
xxi
很好的关于编程的信息来源。
而本书所描述的技术则填补了入门图书和高级编程图书之间的空白。当你读过了
《Java编程入门》、《高级Java编程》和《高高级Java编程》之后,如果你还想学更多
的编程知识,那还能读点什么呢?你可以阅读 Intel或 Motorola的硬件参考手册,阅读
Microsoft Windows或 Linux操作系统的函数手册,至是去阅读讲另外一门编程语言
的书籍你确实无法在个缺乏这种详细参考资料的环境中使用语言或者程序。但
本书是为数不多的探究编程本质的书籍之一。无论你在何种环境下、用何种语言编写
程序,书中某些最有益处的编程技术都能派上用场。其他的书一般都忽略了这些实践
知识,而这也正是本书专注于这些知识的原因。
本书中的信息是从许多来源中提炼出来的,如下图所示。想完全获得在本书中看
到的这些信息的另外途径只有一条,那就是通读堆积如山的书籍和成百上千本技术期
刊,还得再加上大量的实际经验。即便你把这些事情都做到了,本书仍然会对你很有
益处,因为它把所有这些资料都集于…处,便于查阅。
专业经验
其他软件著作
编程语言书籍
构建
杂志上的文章
技木参考资料
Key Benefits of This Handbook
阅读本书的收益
无论你是何种背景,本书都能助你在更短的时间内写出更棒的程序,还不会那么
头疼。
全面的软件构建参考本书讨论了软件构建活动的方方面面,比如说软件的质
量,还有编程的思维方式。它还会深入阐述构建活动中的重要细节,如创建一个类的
步骤,使用数据和控制结构时的各种事项,还有调试、重构、代码调优的技术与策略
等。你无须逐通读所有主题。本书可以让你很容易就能找到感兴趣的特定话题。
随时备用的核对表本书包括了大量的核对表(checklist),你可以用它来评估软
件架构、设计方法、类和子程序的质量、变量命名、控制结构、代码格式、测试用例,
等等。
代码大全(第2版)

<==========================14end ==============================>
<==========================15start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^.com!仅供试看
xxii
前言
与时俱进的信息本书介绍了一些当今最为时兴的技术,其中有许多还未被广泛
采用。正因为本书撷取了实践与研究两者的精髓,它所介绍的这些技术将经久不衰,
受用多年。
以更广的视角检视软件开发本书将给你一个机会,让你凌驾于日复一日、忙于
救火的混乱场面之上,看看到底什么是可行的而什么又是不可行的。实践中的程序
员们很少有时间去阅读数以百计的书籍与期刊,而本手册萃取了其中的精华本书所
汇集的理论研究与实践经验将活跃你的思维,激励你对自己项目的思考,使你的行动
更有策略,避免反复陷入完全一样的战斗。
绝不注水有些软件书籍,其中精髓部分的净重也就1克,却注入了重达10克
的水分。本书则会公平地探讨每项技术的优劣关于你自己项目的特定需求,你了解
得要比任何人都清楚。因此本书仅是给你公正客观的信息,让你能够具体情况具体分
析,做出正确的决策。
有关概念适用于大多数常见的语言本书中介绍的技术能让你可以更好地利用
你的编程语言,无论是C++、C#、Java、 Visual Basic,还是其他类似语言。
丰富的代码示例本书中收集了近500个用于展现优、劣代码之差异的示例。之
所以给出这么多示例也是出于个人的偏好。因为从示例中我最能学到东西,我想其他
程序员也该可以通过这种方式学得更好吧。
这些示例是用了多种不同的语言所写成的,为学习并掌握不止一门语言通常是
专业程序员职业生涯中的分水岭。一旦一名程序员意识到编程原则是超越特定语言语
法的东西时,通往能够实质地改善编程质量并提高工作效率的知识的大门也就向他敞
开了。
为了避免以多种语言写成的例子成为读者的负担,我会尽量避免使用各语言中那
些深奥的特性除非当时就是需要探讨它。为了弄懂一个代码片段要表达的问题,
你无须完全理解所有的细枝末节。如果你集中关示例所展示的问题,那么无论它是
用什么语言写成的,你都能读懂。为让你更容易理解这些示例,我还给其中的关键部
分加了注解。
引用其他信息来源本书汇集了为数众多关于软件构建方面的可用信息,但这并
不算完。在本书所有的章节中,“更多资源”一节都会介绍其他一些书籍和文章,你
希望进一步深入了解感兴趣的话题时可以阅读它们。
代码大全(第2版)

<==========================15end ==============================>
<==========================16start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubu.com!仅供试看^
前言
xxiii
cc2e.com/1234 cc2e.com/1234配套网站在本书的配套网站cce.com上会提供更新的核对表、参考书目、杂
志文章、网页链接等内容。要访问《代码大全》(第2版)中的相关信息,请如本段
文字左侧所示,在浏览器中输入“cc2e.cm”,后跟一个四位阿拉伯数字即可。这样
的网址参考链接在本书中会有很多。
Why This Handbook Was Written
为什么要写这本手册
在软件工程界,人们都清楚地认识到,应该把软件开发中行之有效的实践知识归
纳、编撰成一本开发手册。计算机科学与技术委员会(Computer Science and Technology
Board)的一份报告指出,要想大幅提高软件开发的质量和工作效率,需要把已知的
行之有效的软件开发实践知识归纳、统一并广为传播(stB1990, McConnell 1997a)
该委员会还指出,传播这些知识的策略应建立在软件工程手册这个概念的基础之上
The Topic of Construction Has Been Neglected
软件构建的话题常被忽视
曾几何时,软件开发和编写代码被认为是同一件事情但随着软件开发周期中的
各个活动被人们逐渐认识,该领域中一些最棒的头头脑脑们就开始花更多时间去分析
和争论诸如项目管理方法、需求、设计、测试等问题了在这场学习研究新兴领域的
浪潮中,代码构建这个与软件开发骨肉相连的环节反而被忽视了。
关于软件构建的讨论之所以步履蹒跚,也是因为有人认为,如果将构建活动视作
软件开发中的一项特定活动,就暗示着也必须把它视作其中的一个特定阶段。然而实
际上,软件开发中的各项活动和各个阶段无须以特定的关系一一对应起来;而且无论
其他的软件活动是分阶段(phase)进行、还是迭代式(interation)进行,或者以某种
其他方式进行,都不妨碍我们探讨“构建活动”。
Construction Is Important
构建活动是重要的
构建活动被学者和作者所忽略的另一个原因是源于一个错误的观念,他们认为与
其他软件开发活动相比,构建是一个相对机械化的过程,并没有太多可改进的机会。
然而事实并非如此。
“代码构建”一般占据了小型项目65%的工作量,而在中型项目上也达到了50%
同时,“构建”也要为小型项目中75%的错误负责,在中到大型项目上这一比例为50%
代码大全(第2版)

<==========================16end ==============================>
<==========================17start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
xxiv
前言
到75%。任何一个要为50%到75%的错误负责的活动环节显然都是应该加以改善的。
(第27章中对这些统计数据有更多详细的探讨。)
也有一些评论家指出,虽然构建阶段发生的错误在所有错误中占有很大的比
例,但修正这些错误的代价往往比“修正那些由于需求和架构所导致的错误”要低
很多,这也就暗示着构建活动因此不那么重要诚然,修正由构建活动所导致的错
误的代价比较低这一说法是正确的,但它也引起了误导因为如果不修正这些错
误,代价反而会高得令人难以置信。研究人员发现,软件中一些代价最为昂贵的错
误,其罪魁祸首常常是一些小范围的代码错误,其代价其至可以飙至上亿美元的程
度( Weinberg1983,SEN1990)。可以用较低代价修正的错误,并不意味着这些错
误的修正不重要。
人们忽视构建活动的另一种原因则颇具讽刺意味就因为它是软件开发中唯
一一项肯定能完成的活动。对于需求,人们可以自以为是而不去潜心分析;对于架构,
人们可以偷工减料而不去精心设计;对于测试,人们可以短斤少两甚至跳过不做,而
不去整体计划并付诸实施。但只要写出来的是程序,总归要进行构建活动,这也说明,
只要改进软件构建这环节,就一定对软件开发实践有好处。
No Comparable Book Is Available
没有可媲美的同类书籍
既然看到构建活动有着如此清晰的重要性,我曾相信,当我构思此书时已有人写
过关于有效的软件构建实践的书籍了。对这样本介绍如何有效地进行编程的书籍的
需求是显而易见的,但是我却只找到很少几本关于软件构建这一题材的书,而且那些
书也仅是涉及到这个话题的一部分罢了。有些书写于15年前,还是和一些深奥的语
言如 ALGOL、PI、 Ratfor以 Smalltalk等紧密相关的有些则是出自力
当艺术评论家不实际编写产品代码的教授之手。教授们写出来的技术内容对于学生们的项目而言还
聚在一起的时行得通,但他们通常不知道如何在完整规模的开发环境中施展这些技术;还有些书是
的都是关于版为了宣传作者最新钟情的某种方法论,却忽略了那些被时间反复证明是行之有效的成
式、结构以及熟实践技术的巨大宝库。
意蕴之类的话
题;而当真正
的艺术家聚在
简而言之,我没有找到哪怕是一本试图归纳总结来自专家经验、业界研究以及学
一起的时候,术成果的实践编程技术的书籍。关于这个话题的讨论要能和现今的编程语言、面向对
他们谈论的则象编程技术以及前沿的开发实践紧密结合。很明显需要有人写出一本这样的书出来,
是到哪儿才能
买到更便宜的而他必须了解当今的理论发展水平同时也编写过足够多的能反映实践状况的产品级
松节油。
Pable Piasso代码。我把本书构思成关于代码构建活动的完整探讨一个程序员给其他程序员写
(毕加索)的书。
代码大全(第2版)

<==========================17end ==============================>
<==========================18start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! -www.shubulo.com!仅供试看
前言
XXV
Author Note
作者注
欢迎您对本书中所探讨的话题进行质询,例如您的勘误报告,或其他相关的内容。
请发邮件与我联系,我的邮箱是 , stevemmc@construx.com :@cnstrux.com,也可以访问我的网站:
www.SteveMcConnell.coma
Bellevue, Washington
Memorial Day, 2004
Microsoft Learning Technical Support
Every effort has been made to ensure the accuracy of this book. Microsoft Press
provides corrections for books through the World Wide Web at the following address:
http://www.microsoft. com/earning/support/
To connect directly to the Microsoft Knowledge Base and enter a query regarding a
question or issue that you may have, go to:
http://www.microsoft. com/learning/support/search. asp
If you have comments, questions, or ideas regarding this book, please send them to
Microsoft Press using either of the following methods:
Postal Mail:
Microsoft Press
Attn: Code Complete 2E Editor
One Microsoft Way
Redmond, WA 98052-6399
E-mail:
mspinput@microsoft.com
代码大全(第2版)

<==========================18end ==============================>
<==========================19start==============================>

该书下载自-书部落-分享计算机经典巨著!- !  --www.shubulo.com! ^.com!仅供试看
Contents at a Glance
目录一览
第1章欢迎进入软件构建的世界
第2章用隐喻来更充分地理解软件开
………
9
第3章三思而后行:前期准
第4章关键的“构建”决策
第5章软件构建中计
….73
第6章可以12
第7章高质量的子程序
……161
第8章防御编18
第9章伪代码编程过
……215
……
第10章使用变量的一般事
第11章变量名的力量
.259
第12章基本数据类…
21
第13章不常见的数据类型
319
第14章组织直线型3
第15章使用条件语
355
第16章控制循36
第17章不常见的控制
第18章表动.1
第19章一般控制题
第20章软件质量概述
……
……
第21章协同
……479
第22章开发都测
499
第23章调试
….535
第24章重
………
563
代丹大全(第2版)

<==========================19end ==============================>
<==========================20start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shub.com!仅供试看
目录一览
第25章代码调整策略
587
第26章代码调整技术……………609
第27章程序规模对构建的影
649
第28章管理构
6
第29帝集6
第30章编程70
……
第31章布局与7
第32章自说明代码
…777
第33章个人格
89
第34章软件工艺的话…3
第35章何处有更信多信息
855
参考
………86
索引
…
……885
代码大全(第2版)

<==========================20end ==============================>
<==========================21start==============================>

该书下载自书部落-分享计算机经典巨著!-www. ! --www.shubulo. com!^ .com!仅供试看^
Table of Contents
目录
…xi
........................................................
核对表目…
表目
图目录
第1部分打好基础
第1章欢迎进入软件构建的世界
1.1什么是软件构建…
…3
……
1.2软件构建为何如此
1.3如何阅读本
8
第2章用隐喻来更充分地理解软件开
2.1隐喻的重要性
2.2如何使用软隐喻1
2.3常见的软件隐喻
…13
第3章三思而后行:前期准
3.1前期准备的重要性
3.2辨明你所从事的软件类
3.3问题定义的先决
3.4需求的先决条件
………
3.5架构的先
3.6花费在前期准备上的时间
第4章关键的构建”
4.1选择编程语言
4.2编程约
….66
4.3你在技术浪潮
4.4选择主要的构建实践方
….6
代码大全(第2版)

<==========================21end ==============================>
<==========================22start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubu.com!仅供试看
xii
目录
第2部分创建高质量的代码
第5章软件构建中的设计
.73
5.1设计中的挑战
4
5.2关键的设计概
5.3设计构造块:启发方法7
5.4计1
5.5对流行的设计方法评论
第6章可以工作的
6.1类的基础:抽象数据类型(AD12
6.2良好的类接
6.3有关设计和实现问
6.4创建类的原
6.5与具体编程语言相问
6.6超越类:包15
第7章高质量的子程
…16
7.1创建子程序的正当理16
7.2在子程序层上计计
168
7.3好的子程序名字
7.4子程序可以写…17
7.5如何使用子程参7
7.6使用函数时要特别考虑问题
……
7.7宏子程序和内联程
第8章防御式编程
…17
8.1保护程序免遭非法输入数据的破
8.2断
…
…
8.3错课处1
8.4异
198
8.5隔离程序,使之包容由错误造成的203
8.6辅助调试的代码
05
8.7确定在产品代码中该保留多少防御式代20
8.8对防御式编程采取防御姿10
第9章伪代码编程过程
…2
9.1创建类和子程序的步骤概
…216
代码大全(第2版)

<==========================22end ==============================>
<==========================23start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
目录
xiii
9.2代21
9.3通过伪代码编程过程创建程22
9.4伪代码编程过程的替代
….22
第3部分变量
第10章使用变量的一般事
10.1数据认
10.2轻松掌握变量定29
10.3变量初始化原则
…
10.4作用域
10.5持续性
25
10.6绑定时…
……252
………
10.7数据类型和控制结构之间的关25
10.8为变量指定单一用途
25
第11章变量名的力2
11.1选择好变量名的注惠
11.2为特定类型数据
….264
10.3命名规则量
270
11.4非正式名规
…22
11.5标准
……2
11.6创建具备可读性的名
11.7应该避免
第12章基本数据类
12.1数值概论
292
12.2整
293
12.3浮点
12.4字符和字符
……
9
12.5布尔
………
12.6枚举型
…
12.7名常
…30
…
12.8
…
…310
12.9创建你自己的类型(类型别)
…….31
第13章不常见的数据类型
…
.319
13.1纳构
31
代码大全(第2版)

<==========================23end ==============================>
<==========================24start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubr ^ ^.com!仅供试看^
xiv
目录
13.2指针
.323
13.3全局数据
35
第4部分语句
第14章组织直线型代码
34
14.1必须有明确顺语
3
14.2顺序无关的语.35
第15章使用条
…….35
15.1语句
………………………
15.2case语句
6
第16章控制循
367
16.1选择循环的种类.36
16.2循环控制
16.3轻松创建循环由内而
16.4循环和数组的关8
第17章不常见的控制
17.1子程序中的多处3
17.2递归
…393
17.3o
17.4针对不常见控制结构40
第18章表驱动法
18.1表驱动法使用
18.2直接访问
43
18.3索张
18.4阶梯访问表426
18.5表查询的其他
…42
第19章一般控制问
1
………
19.1布尔达式
19.2复合语句(语句块
19.3空语句
….4
19.4驯服危险的深层嵌
19.5编程基础:结构编5
19.6控制结构与6
代码大全(第2版)

<==========================24end ==============================>
<==========================25start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! -www.shubulo ^^.com!仅供试看^
目录
XV
第5部分代码改善
第20章软件质量概
.463
20.1软件质量特性
20.2改善软件质量术6
20.3不同质量保障技术的相效
20.4什么时候进行质量保证
…
20.5软件质量的普遍原
474
第21章同
…479
……
21.1协同开发实践概
480
21.2结对编程
43
……
21.3正检
21.4其他类型的协同开发
第22章开发测9
22.1开发者测试在软件质量50
22.2开发者测试的推荐
…
22.3测试技锦
22.4典型错误
517
22.5测试支持
22.6改善测试
……
22.7保留测试记
52
第23章调试
23.1调试
23.2找
540
23.3修正陷
.55
23.4调试中的心理
23.5调试工具明显的和不那明5
第24章重构
563
24.1软件演化的类型
24.2重简
5
24.3特定重
571
24.4安全重
579
24.5重构策略
.582
代码大全(第2版)

<==========================25end ==============================>
<==========================26start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shub.com!仅供试看^
xvi
目录
第25章代码调整.8
25.1性能概
8
25.2代码调整简
591
25.3蜜糖和哥斯拉
.5
25.4性能测
….
…
25.5反复调整
606
25.6代码调整方法总结
第26章代码调整
6.11…61
26.2循环6
26.3数据62
26.4达630
26.5程
26.6用低级语言重写代6
26.7变得越多,事情反而越没变
.6
第6部分系统考虑
第27章程序规模对构建的影6
27.1交流和规6
27.2项目规模的范围.6
27.3项目规模对错误影6
27.4项目规模对生产率的影响
.63
27.5项目规模对开发活动影
第28章管理构
28.1鼓励良好的编码66
28.2配置管理66
28.3评估构建进6
28.467
28.5把程序员当人
28.6管理你的管理6
第29章集成
29.1集成方式的重要
68
29.2集成频率阶段式集成还是增量集成
.69
29.3增量集成的策略
9
代码大全(第2版)

<==========================26end ==============================>
<==========================27start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubu com!^.com!仅供试看^
目录
xvii
29.4 Daily Build与冒烟测.70
第30章编
30.1设计工具
7
30.2源代码
30.3可执行码工具
7
……
30.4工具导的
…720
30.5打造你自己的编程2
30.6工…
….72
第7部分软件工艺
第31章布局与风格
729
31.1基本
31.2布局
31.3局格
31.4控制结构布
74
………
31.5单条语句1
31.6注7
31.7子程7
31.8类布7
第32章自说明代77
32.1部77
32.2编程风格
……78
…
32.3注释或注
….781
32.4高效注释之
32.5注释术
32.6EE标准
81
第33章个人性
33.1个人性格是否和本书话题无
……
33.2聪明谦
……821
33.3求知欲2
33.4诚82
33.5交流与
…8
33.6创造力租纪
…29
33.7懒惰
……
8
代码大全(第2版)

<==========================27end ==============================>
<==========================28start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
xviii
目录
33.8不如你想象中那样起作用的性格
33.9习惯
…
…….
第34章软件工艺的话题
34.1征服复杂性
837
34.2精选开发过程……
……839
34.3首先为人写程序,其次才是为机器
34.4深入一门语言去编程,不浮表843
34.5借助规范集中注意力.8
34.6基于问题域编
34.7当心落8
34.8迭代,反反复复,一次又一次…85
34.9汝当分离软件与信
第35章何处有更多信息…
55
35.1关于软件构建的信息……8
35.2构建之外题
.857
……
35.3期刊
.859
35.4软件开发者的阅计划
6
35.5参加专业组织
002
参考
….86
索引
…85
代码大全(第2版)

<==========================28end ==============================>
<==========================29start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看^
Checklists
核对表目录
核对表:需求
核对:
核对表:前期准备…………9
::
核对表:主要的构建实践69
核对表:软件构造中计计
122
核对表:类的质量157
核对表:高质量的子程序…
…185
核对表:防御式编程…21
核对表:伪代码编程过2
核对表:使用数据的一般事……
2
核对表:变量
288
::
核对表:基本数据类3
核对表:使用不常见数据类型的注意事项…33
核对表:组织直线型代3
核对表:使用条件语句
6
核对表:
8
38
核对表:不常见的控制410
核对表:表驱动法
…
核对表
:::
控制结构相关事宜
核对表:质量保证计划…
…476
核对表:有效的结对编程
.484
核对表:有效的详4
核对表:测试用.3
核对表:关于试55
代丹大全(第2版)

<==========================29end ==============================>
<==========================30start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !-Www.shubulo.com!^  ^.com!仅供试看^
XXX
核对表目录
核对表:重构的理.570
核对表:重总
.57
核对表:安全
…584
核对表:代码调整60
核对表:代码调整方法
…642
核对表:配置管.669
核对表:集成…….707
核对表:编程
核对表:布局…7
核对表:自说明代码
………780
核对表:好的注释术8
代码大全(第2版)

<==========================30end ==============================>
<==========================31start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
Tables
表目录
表3-1修复缺陷的平均成本与引入缺陷的时间和检测到该缺陷的时间之间的关系29
表3-2三种常见的软件项目种类,及其典型的良好实践
31
表3-3跳过前期准备对于采用序列式开发法的项目和迭代式开发法的
项目的(不同)影
33
表3-4关注前期准备工作对于采用序列式开发法的项目和迭代式开发法的项目的影响
……………34
表4-1高级语言的语句与等效的C代码语句行数之比6
表5-1常见设计模式
表5-2设计文档的正规化以及所需的纸
表6-1继承而来的子程序的几形式…145
表8-1支持几种流行的编程语言的表达式
表11-1更多变量名的例子,其中有好的也有261
表11-2变量名太长、太短或刚好合适的22
表11-3C++和Java的命名规则示例
27
表11-4C的命名规则示例
….27
表11-5 Visual Basic的命名规则示例
……278
表11-6用于文字处理程序的UDT示例
表11-7语前
…280
表12-1不同类型整数的取值范围
……….294
……
表13-1直接访问全局数据和通过访问器子程序访问全局数341
表13-2对复杂数据一致和不一3
表16-1循环的种
……6
表19-1狄摩根定理的逻辑表达式的转换法
436
表19-2计算子程序中决策点数量的技术
…458
代(第2版)

<==========================31end ==============================>
<==========================32start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--Www.shubulo.com!^ .com!仅供试看
xxxii
表目录
表20-1各个小组在每个目标上排6
表20-2缺陷检测率470
表20-3极限编程的缺陷检出率估
……472
表21-1协同构建技术的比95
表23-1变量名之间的心理距离5
表25-1编程语言的相对执行时间
….60
表25-2常见操作所用时
表27-1项目规模和典型的错误密度
……….652
……
表27-2项目规模和生产率
….653
表28-1影响软件项目工作量素
………674
表28-2有用的软件开发的度量环67
表28-3有关程序员如何分配时间的一种点
…68
代码大全(第2版)

<==========================32end ==============================>
<==========================33start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.com.com!仅供试看
Figures of Contents
图目录
图1-1构建活动用灰色的椭圆表示。构建活动主要关注于编码与调试,但也包含
详细设计、单元测试、集成测试以及其他一些活动…
图1-2本书大致以图示的比例关注编码与调试、详细设计、规划构建、单元测试、
集成、集成测试以及其他活动……
图2-1文字写作这一隐喻暗示着软件开发过程是一种代价昂贵的
试错(trial and error)过程,而非仔细的规划和计
.4
图2-2很难将耕作这隐喻恰当地引申到软件开发领域
…….15
图2-3在简单结构上犯下错误,其惩罚也不过是一点时间,或是些许尬1
图24更复杂的结构需要更加仔细地规划
…18
图3-1修复缺陷的成本随着“从引入缺陷到检测该缺陷之间的时间”变长而急剧增
加。无论项目是高度序列化(sequential)的预先完成100%的需求和设计),
还是高度迭代型(预先完成5%的需求和设计)的,这些都成30
图3-2对于绝大部分的项目(即便是高度序列化的项目)来说,
各种活动会在一定程度上有所重……
图3-3对于其他的项目,各种活动在项目开发期间会重叠起来。成功“构建”的
关键之,就是理解前期准备工作的完成程度,并据此调整你的开发方法35
图34“问题定义”为随后的开发过程打下基础
……3
图3-5在射击之前,确信你瞄准了正确的目标
38
图3-6如果没有好的需求,你可能对问题有总体的把握,但却没有击中问题的
特定方面
.39
图3-7离开了良好的软件架构,你可能瞄准了正确的问题,但却使用了错误的
解决方案。也许完全不可能有成功的构建
.44
大全(第版)

<==========================33end ==============================>
<==========================34start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com.com!仅供试看
xxxiv
图目录
图5-5-1《acomaNarrows大桥一个险恶问题的实例
..75
图5-2一个程序中的设计层次。系统①首先被组织为子系统②。子系统被
进一步分解为类③,然后类又被分解为子程序和数据④。每个子程
序的内部也需要进行设计⑤
…82
图5-3一个有六个子系统的系统示例
……83
图54当子系统之间的通信没有任何限制时就会像这个样
83
图5-5施加若干通信规则后,子系统之间的交互得以显著地简化
84
图5-6收费系统由四种主要的对象构成,这些对象在本例中进行了一定的简8
图5-7抽象可以让你用一种简化的观点来考虑复的.0
图5-8封装是说,不只是让你能用简化的视图来看复杂的概念,同时还不能让你
看到复杂概念的任何细节。你能看得到的就是你能全部得到的91
图5-9好的类接口就像是冰山的尖儿一样,让类的大部分内容都不会暴露出来93
图5-10G波利亚在数学领域发展的一套解决问题的方法,它同样可以用于解决
软件设计中的问题(Polya1957
109
图8-1西雅图90号州际浮桥的一部分在一场风暴中沉没了,原因是未遮盖浮箱,
而在风暴中进水,使得桥体过重而无法继续漂浮。在建设时要防范一些小
事情,它们的严重性往往会超过你的预
图8-2让软件的某些部分处理“不干净的”数据,而让另一些部分处理“干净的”
数据,即可让大部分代码无须再担负检查错误数据的职
204
图9-1一个类的创建过程可以千变万化,但基本上会以本图所示的顺序发.216
图9-2这些是创建一个子程序所需经历的主要活动,常是以图示的顺进行217
图9-3在构建程序的时候,你将实施所有这些步骤,但不一定要按照
任何特定的顺序
225
图10-1“长存活时间”意味着一个变量历经了许多语句,而“短存活时间”意味着
它只历经很少的语句。“跨度”则表明了对一个变量引用的集中程.24
图10-2序列型数据就是按照一种确定顺序处理数
…254
图10-3选择型数据允许你使用这一项或者那一项,但不会同时使用两者
25
图10-4迭代型数据是重复性的
……….255
代码大全(第2版)

<==========================34end ==============================>
<==========================35start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubul.com!仅供试看^
图目录
图13-1各数据类型所用的内存量用双线框表……3
图13-2能帮助我们考虑指针链接步骤的示例图
329
图14-1如果代码组织良好,那么围绕各段的方框就不应该交叠,但有可能嵌套35
图14-2如果代码组织不良好,那么围绕各段代码的方框就会5
图17-1递归式是对付复杂事物的很有价值的工具—在用于对付适当问题的时候.394
图18-1如图名所示,直接访问表允许你访问感兴趣素41
图18-2信息并不是按照特定顺序存储的,每条消息用标识
417
图18-3除了消息之外,每种消息有其自己的格式
…41
图18-4索引表不是直接访问,而是经过居间的索引去访问
425
图18-5阶梯方法通过确定每项命中的阶梯层次确定其归类,它命中的“台阶
确定
426
图19-1一个用数轴顺序做布尔判断的例子
….440
图20-1强调软件的某个外在特性,可能会对另一些特性产生正面或者负面的影响,
也可能没有任何影
.466
图20-2既不是最快的,也不是最慢的开发方法生产出的软件缺陷最多
475
图22-1随着项目规模的增大,开发者测试所耗费的开发时间百分比会更少。程序
规模对测试的影响将在第27章“程序规模对构建的影响”做出详细描502
图22-2随着项目规模的增长,在构建期间产生的错误所占的比例会下降,然而
即使是在巨型项目里面,构建错误也会占全部错误的45%至75%521
图23-1尝试用多种方法重现错误以准确判定错误原因
.545
图24-1相对于大规模修改,小的改动更容易出错 Weinberg1983).58
图24-2真实世界混乱不堪并不等于你的代码也得同样糟糕。将你的系统看做理想
代码、混乱的真实世界,以及从前者到后者的接口结
583
图24-3改善产品代码的策略之一就是在拿到拙劣的遗产代码时对其重构,
由此使其告别混乱不堪的真实界
584
图27-1交流路径的数量与项目成员数量的平方大致
…….650
图27-2随着项目规模的增大,通常需求和设计犯的错误会更多。有些时候,
错误仍然主要来自构建(Boehm1981, Grady987,ones1998)65
代大(第

<==========================35end ==============================>
<==========================36start==============================>

该书下载自-书部落分享计算机经典巨著!-ww. ! --www.shubuld.com!仅供试看
图目录
图27-3小项目以构建活动为主。更大的项目需要做更多的架构、集成工作和
系统测试工作才能成功。图中并未显示“需求工作”,因为其工作量并
不(像其他活动那样)直接是程序大小的函数(Albrecht1979 Glass 11982
Boehm, Gray and Seewaldt 1984; Boddie 1987 Card 1987; McGarry,
Waligora and McDermott 1989; Brooks 1995: Jones 1998; Jones 2000;
Boehm et al. 2000)...
654
图27-4软件构建的工作量与项目大小呈近似线性的关系。其他活动的工作量随
项目规模扩大而非线性地增加
….655
图28-1本章讲述与构建相关的软件管理话题
.661
图28-2项目早期的评估结果注定不会很准确。随着项目推进,评估的准确度会
越来越高。在项目进行过程中要定期地重新评估,用你在每一项活动中学
到的知识去改进你对下一项活动的评
…673
图29-1华盛顿大学的露天足球场坍塌了,因为它在建造时不能支撑自己的重量。
很可能在完工后它会足够牢固,但是它的建造顺序是错的这是一个
“集成”错误
690
图29-2阶段式集成也称为大爆炸集成,其理由很充分
…….691
图29-3增量集成有助于项目增长,就像雪球从山上滚下来时那样
….692
图294在阶段式集成中,你一次集成许多组件,很难知道错误在哪。错误既可能
位于其中任何一个组件,也可能位于组件之间的连接处。在增量集成中,
错误通常要么是在新的组件中,要么是位于新组件和系统之间的连接.693
图29-5在自顶向下的集成中,首先加入顶部的类,最后加入底部的类
695
图29-6除了严格的自顶向下进行集成,你也可以在各个竖直划分的功能块中
自上而下地进行集成
.696
图29-7在自底向上集成中,先集成底部的类,后集成顶部的类
697
图29-8除了按纯粹的自底向上的步骤进行集成,你也可以分块进行这种集成
这样做模糊了自底向上集成和功能导向的集成(本章稍后将描述)
之间的界
698
代码大全(第2版)

<==========================36end ==============================>
<==========================37start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo..com!仅供试看^
图目录
图29-9在三明治集成中,首先集成顶层类和广泛使用的底层类,然后集成
中间层类…
698
图29-10在风险导向集成中,首先集成你认为最棘手的类,然后实现较容易的类699
图29-11在功能导向的集成中,以一组“构成一项可确认的功能”的类为
单位进行集成一通常(但不总是)一次集成个
700
图29-12在T型集成中,你建造并集成系统的一个直插到底层的块,以验证架构
的假设,然后建造并集成系统的挑大梁部件为开发余下的功能提供一
个框架
..701
图34-1程序可划分为多个抽象层。好的设计使你可以把很多时间集中在较高层,
而忽略较低层的细
846
代码大全(第2版)

<==========================37end ==============================>
<==========================38start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!.com!仅供试看^
第1部分
Laying the Foundation
打好基础
本部分内容
■第1章欢迎进入软件构建的世界…
■第2章用隐喻来更充分地理解软件开发
第3章三思而后行:前期准备
.23
第4章关键的“构建”决策
.61
代码大全(第2版)

<==========================38end ==============================>
<==========================39start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看

<==========================39end ==============================>
<==========================40start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
Welcome to Software
Construction
第
章
欢迎进入软件构建的世界
c2ecom/0178内容
1.1什么是软件构建:第3页
1.2软件构建为何如此重要:第6页
1.3如何阅读本书:第8页
相关章节
谁应当阅读本书:前言
■阅读本书的收益:前言
为什么要写这本手册:前言
你一定知道“构建( construction)”一词在软件开发领域之外的含义。“构建”
就是“建筑工人(construction workers)”在建设一栋房屋、一所学校、乃至一座
摩天大楼时所做的工作。在你年轻时,可能也曾用“硬纸板( construction paper
构建过什么东西。按照一般的用法,“构建”是指建设的过程。构建过程可能包含
有计划、设计、检查工作的一些方面,但在多数时候,“构建”就是指创建事物过
程中动手的那些部分。
What Is Software Construction
什么是软件构建
开发计算机软件已是一个复杂的过程。在过去25年间,研究者已经认识到在
软件开发过程中的各种不同的活动(activity):
定义问题(problem definition)
需求分析(requirements development)
规划构建(construction planning)
软件架构( software architecture),或高层设计(high--level design)
详细设计(detailed design)
编码与调试(coding and debugging
单元测试(《unitsting《)
代码大全(第2版)

<==========================40end ==============================>
<==========================41start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
第1章欢迎进入软件构建的世界
集成测试(integration testing)
集成(《integration《
系统测试(system testing)
保障维护( corrective maintenance
如果你曾在非正式的项目中工作过,你可能会想这张表代表了很多的红头
文件(官样文章)。如果你曾在十分正式的项目中工作过,你一定知道这张表代表
了很多的红头文件!在太不正规和太正规之间找一个平衡点是不容易的,我们将
在本书后面再来讨论这个问题。
如果你是自学编程,或者主要做一些不太正规的项目,你可能都无法在软件
开发过程中分辨出这么多活动。在你心里,这些活动很可能都被归为“编程
(programming)”了。当你在做不太正规的项目时你考虑创建软件的问题时所
想到的那项主要活动,很可能就是研究者们称之为“构建”的活动。
这个直觉上对“构建”的认知是相当准确的但它还缺乏一点深度。把构建
活动放在由其他活动构成的环境中讨论,有助于在“构建”期间集中注意正确的
任务,也有助于恰当强调那些重要的“非构建活动(nonconstruction activity)”图
1-1显示了构建活动相对于其他软件开发活动的地位。
定义问题
保障维护
详细设计
需求分析
集成
规划构建
编码与调试
集成测试
单元测试
软件架构
系统测试
图1-1构建活动用灰色的椭圆表示。构建活动主要关注于编码与调试,但也包含详细
设计、单元测试、集成测试以及其他一些活动
代码大全(第2版)

<==========================41end ==============================>
<==========================42start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co! ^.com!仅供试看^
1.1什么是软件构建
如图所示,构建活动主要是编码与调试,但也涉及详细设计、规划构建、单
元测试、集成、集成测试等其他活动。如果这是一本探讨软件开发中的方方面面
的书,那么它会以恰好平衡的篇幅来探讨软件开发中所有的活动。然而,因为本
书是一本关于软件构建技术的手册,它会重点关注构建活动以及与之相关的话题。
假如这本书是一条小犬的话,那么它会亲切地嗅着构建,而冲着设计和测试摇尾
巴,并对着其他开发活动汪汪叫。
构建有时也被认为是“编码(coding)”或“编程(programming)”。“编
码”算不上是最贴切的词,因为它有一种“把已经存在的设计机械化地翻译成计
算机语言”的意味;而构建并不都是这么机械化的,需要可观的创造力和判断力
在全书中,我也常常用“编程”代替“构建”。
图1-1是一张软件开发的平面图,图1-2给出了本书的立体视图。
定义问题
详细设计
保障维护
需求分析
编码与调试
集成
规划构建
集成测试
软件架构
单元测试
系统测试
图1-2本书大致以图示的比例关注编码与调试、详细设计、规划构建、单元测试、集
成、集成测试以及其他活动
图1-1和图1-2都是关于构建活动的高层次视图,但细节是什么?这里列出一
些构建活动中的具体任务(task)
验证有关的基础工作已经完成,因此构建活动可以顺利地进行下去。
确定如何测试所写的代码。
代码大全(第2版)

<==========================42end ==============================>
<==========================43start==============================>

该书下载自书部落-分享计算机经典-www. !--www.shubulo.com!^.com!仅供试看
6
第1章欢迎进入软件构建的世界
设计并编写类(class)和程序( routine)
创建并命名变量(variable)和具名常量( named constant)
选择控制结构( control structure),组织语句块。
对你的代码进行单元测试和集成测试,并排除其中的错误。
评审开发团队其他成员的底层设计和代码并让他们评审你的工作。
润饰代码,仔细进行代码的格式化和注释。
将单独开发的多个软件组件集成为一体。
调整代码( tuning code),让它更快、更省资源
要想获得一份构建活动的完整列表,请看一遍目录中各章节的标题吧。
既然“构建”中包含这么多的活动,你也许会说,“OK,伙计,还有哪些活
动不是“构建”的一部分呢?”这是个好问题。一些重要的非构建活动包括管理
(management)、需求分析、软件架构设计、用户界面设计、系统测试,以及维护
以上每一项活动都像构建活动一样最终影响着项目的成败至少能影响任何有
不止一两个人参与、超过几周时间才能完成的项目的成败。关于其中每一项活动,
你都可以找到相关的书籍:本书各章中的“更多资源”一节已经列出了很多这种
书籍,还有最后的第35章“何处有更多信息”。
Why Is Software Construction Important
软件构建为何如此重要
既然您正在阅读本书,你多半已经认同,提高软件的质量和开发者的生产率
都是十分重要的。当今世界上许多最激动人心的项目中都大量使用了软件。互联
网、电影特技、医疗中的生命维持系统、太空计划、航空、高速金融分析,以及
科学研究,等等,这还只不过是小部分例子。这些项目,乃至一些更常见的项
目,都将从软件开发实践的改进中受益,因为它们的基础很大程度上是一样的。
如果您也认为一般而言,改进软件的开发过程十分重要,作为本书读者的您
就会问:为什么构建活动如此重要呢?
代码大全(第2版)

<==========================43end ==============================>
<==========================44start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. --www.shubulo.con.com!仅供试看
1.2软件构建为何如此重要
7
原因如下。
交叉参考关于构建活动是软件开发的主要组成部分根据项目规模的不同,构建活动在整
项目规模与“构建
活动耗时的百分个软件开发活动总时间中所占的比例一般在30%至80%之间。在整个项目中占有
比”之间的关系,这么多时间的活动必然会影响到项目的成败。
请参考第27.5节
中的“活动比例和
项目规模”。
构建活动是软件开发中的核心活动需求分析和架构设计都是在构建活动开
始之前就完成的基础工作,它们可以让你更有效地进行构建:系统测试(严格意
义上的独立测试)则是构建活动的后续工作用以验证构建的正确性。显然,构
建活动位于软件开发过程的核心位置。
交叉参考关于
程序员能力差异
把主要精力集中于构建活动,可以大大提高程序员的生产率一项由
的具体数据,见 Sackman、 Erikson和 Grant进行的经典研究表明:在构建活动期间,不同程序员
第28.5节中的
“个体差异”的生产率(productivity)的差异可达10到20倍(1968)。这一结果随后被大量
其他的研究所证实(Cutis1981《MiIIs1983;Curtisea986;Card1987aValet;mills1983;curtisetal.1986;card1987:valett
and McGarry 11989 DeMarco and Lister1999: Boehm et al.2000)本书将帮助所
有的程序员学习那些最优秀的程序员已在使用的技术。
构建活动的产物源代码—往往是对软件的唯一精确描述在很多项目
中,程序员可以得到的唯一文档就是源代码本身需求规格书和设计文档可能过
时,但源代码总是最新的。因此,源代码就必须具有尽可能高的质量。统一地运
用各种技术来改进源代码的质量,将决定得到的结果是 Rube Goldberg所造的古怪
产品,还是一个详细、正确且信息丰富的程序。这些技术在构建活动中能得到最
有效的应用。
构建活动是唯一一项确保会完成的工作一个理想的软件项目在进行构建之
前,都要经过谨慎的需求分析和架构设计。一个理想的项目在构建完成之后,也
KY POINT要经历全面的、统计意义上受控制statistically controlled)系统测试然而现
实中不那么完美的软件项目,往往跳过需求和设计的阶段而直接跃入构建环节。
之后又由于有太多的错误要修正而时间又不够测试环节也被抛到一边了。但是,
无论一个项目的计划有多匆忙、多糟糕,它都不可能扔下构建活动这是不可
或缺的环节。因此,对构建活动进行改进,是改进软件开发过程的一种有效途径。
1译注: Rube Goldberg是一个漫画中的人物,他以制造结构复杂但功能简单的产品而闻名,因此人
们常把那些费力不讨好的产品冠以其名号以示讽刺。
代码大全(第2版)

<==========================44end ==============================>
<==========================45start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.cor.com!仅供试看^
8
第1章欢迎进入软件构建的世界
1.3
How to Read This Book
如何阅读本书
这本书有意设计成使你既可以从头到尾阅读,也可以按主题阅读。如果你想
从头到尾阅读,那么你可以直接从第2章“用隐喻来更充分地理解软件开发”开
始钻研。如果你想学习特定的编程技巧,那么你可以从第6章“可以工作的类”
开始,然后根据交叉引用的提示去寻找你感兴趣的主题。如果你不确定哪种阅读
方式更适合你,那么你可以从3.2节“辨明你所从事的软件的类型”开始。
Key Points
要点
软件构建是软件开发的核心活动;构建活动是每个项目中唯一项必不可少
的工作。
软件构建的主要活动包括:详细设计、编码调试、集成、开发者测试
(developer testing)(包括单元测试和集成测试)
构建也常被称作“编码”和“编程”
构建活动的质量对软件的质量有着实质性的影响。
最后,你对“如何进行构建”的理解程度,决定了你这名程序员的优秀程度
这就是本书其余部分的主题了。
代码大全(第2版

<==========================45end ==============================>
<==========================46start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看^
Metaphors for a Richer Understanding
of Software Development
第2章
用隐喻来更充分地理解软件开发
cc2ecom/0278内容
2.1隐喻的重要性:第9页
2.2如何使用软件隐喻:第11页
2.3常见的软件隐喻:第13页
相关章节
设计中的试探法:第5.1节中的“设计是一个启发式过程”
计算机科学领域中有着所有学科中最为丰富多彩的语言。你走进一间安全严
密、温度精确控制在20℃的房间,并在里面发现了病毒( virus)特洛伊木马( Trojan
horse)、蠕虫(worm)、臭虫(bug)、逻辑炸弹(bomb)、崩溃(crash)论坛口
水战( flame)、双绞线转换头(twisted sex changer)、还有致命错误( fatal error)
在其他领域中,你能遇得到这些吗?
这些形象的隐喻(比喻)描述了软件领域中各种特定的现象和事物。像这样
生动活泼的隐喻还能够描述更加广泛的现象。借助这些隐喻,我们能更深刻地理
解软件开发的过程。
本书其他章节的内容并不直接依赖在这一章中讨论的隐喻。因此,如果想直
接学习实践方面的知识,你可以跳过本章不读;而如果你想更清楚地理解软件开
发的过程,请读读这一章吧。
The Importance of Metaphors
隐喻的重要性
重要的研发成果常常产自类比(analogy)。通过把你不太理解的东西和一些你
较为理解、且十分类似的东西做比较,你可以对这些不太理解的东西产生更深刻
的理解。这种使用隐喻的方法叫做“建模( modeling)”。
科学史中到处都可以看到借助隐喻的力量而产生的新发现。化学家凯库勒曾
梦见一条蛇咬着自己的尾巴,醒来后他意识到类似的环状分子结构正好能够解释
苯的各种特性。后来的进一步实验证实了他的这一假说(Barbour1966)
代码大全(第2版)

<==========================46end ==============================>
<==========================47start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubr.com!仅供试看^
10
第2章用隐前来更充分地理解软件开发
气体的分子运动理论则是基于一种所谓的“球( billiard--ball)”模型,它把
气体分子想象成有质量且彼此之间发生弹性碰撞的小球,就像撞球一样。有很多
有用的理论就是基于这个模型提出来的。
而光的波动理论则主要是在研究光和声音之间相似性的基础上发展起来的。
光和声音都有振幅(亮度、响度)、频率(颜色、音调)和其他一些共有属性。对
声波理论和光波理论进行对比研究的成果丰富,科学家们甚至付诸大量的努力,
想寻找一种能在真空中传播光波的介质(像声波能在空气介质中传播一样),并
将这种介质命名为“以太(ether)”但他们从未能找到过这种介质。虽然类比
催生了丰盛的成果,这一次它却把人们引入了歧途。
不过总的来说,模型的威力就在于其生动性让你能够把握整个概念。它能
隐隐地暗示各种属性(properties)关系relationships)以及需要补充查证的部分
( additional areas of inquiry)。不过有时候,当隐喻的概念被过度引申时,模型也
会误导人们。当科学家们寻求“以太”的时候,他们就是过度地引申了模型。
正如你所预期的那样,有些隐喻比其他一些更贴切一个好的隐喻应该是简
单的,它与另一些相关的隐喻联系密切,且能够解释大部分实验证据及其他已观
测到的现象。
来考虑一下这个例子:把一块沉重的石头绑在细绳上让它来回摆动。在伽利
略之前,信奉亚里士多德学说的人们看到这个现象时,想到的是重物体自然地从
高处坠落,落向低处并静止下来。他们会想,下落的石头遇到了阻碍。而伽利略
在看到这个现象的时候却想到了钟摆(pendulum)他认为,那块石头实际上是在
不断地重复着几乎完全相同的运动。
这两种模型的启发能力是完全不一样的。亚里士多德学派的人将来回摆动的
石头看作是正在下落的物体,因此会去观察石头的重量、石头被拉起的高度,以
及它到达静止状态时所需要的时间。而在伽利略的钟摆模型中的要素就完全不同
了。伽利略观注石头的重量、钟摆的半径、角位移以及每次摆动所花的时间。伽
利略之所以能够发现亚里士多德学派的人所不能发现的单摆定律,正是因为他们
所用的模型不同,这使得他们看到了不同的现象,提出了不同的问题。
隐喻在帮助人们更好地理解软件开发问题方面所做的贡献,与它帮助人们更
好地理解科学问题所做的贡献一样。在173年图灵奖的演讲中, Charles
Bachman讲到了由盛行的地心说到日心说的转变。托勒密的地心说模型持续了
1400年而没有受到严重挑战,直到1543年哥白尼提出了以太阳为中心的理论,
这个理论认为宇宙的中心是太阳而不是地球。这一个认知模型的改变最终帮助人
们发现了新的行星,并将月亮重新界定为地球的卫星而不是一颗独立的行星,它
也使人们对人类在宇宙中的地位有了一个完全不同的理解。
代码大全(第2版

<==========================47end ==============================>
<==========================48start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
2.2如何使用软件隐前
11
隐喻的价值绝不应 Bachman曾经把天文学中托勒密到哥白尼的转变,与20世纪70年代早期计
低估隐喻的优点在
于其可预期的效果:算机编程方面的变化做了比较。当1973年 Bachman做这个比较时,数据处理正
能被所有的人理解在从“以计算机为中心( computer-centered-)”的观点向“以数据库为中心
不必要的沟通和误(database-centered)观点转变、 Bachman指出,过去的数据处理是把所有数据
学习与教授更为快看作流经计算机( flowing through computer)的连续卡片流( stream of cards)(以
速实际上隐喻是计算机为中心的观点),现在则转变为把焦点放到数据池(pool of data)上,而计
算机偶尔涉足其中(以数据库为中心的观点)。
抽象(abstracting
的一种途径,它让人
今天,我们已经很难想象还有谁会认为太阳是在绕着地球旋转的。类似地,
们在更高的层面上我们也很难想象程序员还会认为所有的数据应被看作是一个连续卡片流。在这两
思考问题,从而避免个例子里,旧的理论被抛弃后,我们都觉得难以置信居然还有人曾经相信过
低层次的错误。这些理论?更有意思的是,当人们正在相信旧理论时,也同样会认为新理论是那
. Corbato么地荒谬,正如今天我们对旧理论的看法一样。
在更好的理论出现之前,天文学家因为墨守地心说而屡屡受阻。在计算机世
界里面也有类似的情况,以计算机为中心的观点也让坚持它的计算机科学家步履
蹒跚,直到以数据库为中心的理论出现。
人们常常轻视隐喻的力量。对前面的每一个例子而言,很自然地有人会说:
“嗯,恰当的隐喻当然是更有用,但其他隐喻都是错的!”虽然这是一种很自然的
反应,实际远非如此简单。科学发展的历史并不是一系列从“错误”的隐喻到“止
确”的隐喻的转变,而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变,
也是从不是很贴切的隐喻到史贴切的隐喻的转变还是从在一个方面暗示人们到
在另一个方面暗示人们的转变。
事实上,那些被更好的新模型所替代的旧模型也依然是很有用的。工程师们
依旧在使用牛顿力学来解决大部分的工程问题虽然从理论上说,牛顿力学已
经被爱因斯坦的理论所取代。
相对于其他学科而言,软件开发还是一门很年轻的学科,它还没有成熟到拥
有一套标准隐喻的程度。因此必然存在许多或相互补充、或相互抵触的隐喻。某
些隐喻相对好一些,而另一些则比较糟糕。你对隐喻有多理解,也就决定了你对
软件开发有多理解。
2.2
How to Use Software Metaphors
如何使用软件隐喻
与其说一个软件隐喻像是一张路线图,还不如说它是一盏探照灯。它不会告
诉你到哪里去寻找答案,而仅是告诉你该如何去寻找答案。隐喻的作用更像启示
KEY POINT
heuristic,启发、试探法),而不是算法(algorithm)
算法是一套定义明确的指令,使你能完成某个特定的任务。算法是可预测的
(predictable)、确定性的( deterministic、不易变化的( not subject to chance
代码大全(第2版)

<==========================48end ==============================>
<==========================49start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
12
第2章用隐前来更充分地理解软件开发
个告诉你如何从A点到达B点的算法,不会让你绕路,不会让你额外地经过D、
E、F等地方,更不会让你停下来闻闻玫瑰花或喝杯咖啡。
而启发式方法(试探法)是一种帮你寻求答案的技术,但它给出的答案是具
有偶然性的( subject to chance),因为启发式方法仅告诉你该如何去找,而没有
告诉你要找什么。它并不告诉你该如何直接从A点到达B点,它至可能连A点
和B点在哪里都不知道。实际上,启发式方法是穿着小丑儿外套的算法:它的结
果不太好预测,也有趣,但不会给你什么30天无效退款的保证。
驾驶汽车到达某人的家,写成算法是这样的:沿167号高速公路往南行至
Puyallup从 South Hill Mall出口出来后往山上开4.5英里;在一个杂物店旁边的
红绿灯路口右转,接着在第一个路口左转;从左边褐色大房子的车道进去,就是
North Cedar路714号
交叉参考关于在
设计软件时使用启
用启发式方法来描述则可能是这样:找出上一次我们寄给你的信,照着信上
发式方法(试探法)面的寄出地址开车到这个镇;到了之后你问一下我们的房子在哪里。这里每个人
的具体做法,见第都认识我们肯定有人会很愿意帮助你的;如果你找不到人,那就找个公共电
5.1节中的“设计是
一个启发式过程”。话亭给我们打电话,我们会出来接你。
算法和启发式方法之间的差别很微妙,两个术语的意思也有一些重叠。就本
书的目的而言,它们之间的差别就在于其距离最终解决办法的间接程度:算法
接给你解决问题的指导,而启发式方法则告诉你该如何发现这些指导信息,或者
至少到哪里去寻找它们。
如果有一些能明确指导你该如何解决编程问题的信息,编程当然会更容易,结
果也更易预见。但编程这门学科还没那么先进,或许永远也不可能那么先进。对于
编程来说,最大的挑战还是将问题概念化(conceptualizing),编程中的很多错误都
是概念性的错误。正因为每一个问题在概念上都是独特的,所以要找到一套能解决
所有问题的一通百通的指导规则是很难的、甚至是不太可能的。如此看来,能一般
性地知道大致如何解决问题,至少也和知道如何解决特定问题一样有价值了。
那么该如何使用软件中的隐喻呢?应该用它来提高你对编程问题和编程过程
的洞察力:用它来帮助你思考编程过程中的活动,想象出更好的做事情的方法。
你不可能看到一行代码并说它违反了本章所描述的某个隐喻。但随着时间的流逝,
人们会发现,相对于不善运用隐喻的人来说,那些使用隐喻来照亮自己的软件开
发过程的人,他对于编程的理解会更好,并且能够更快地写出更好的代码。
代码大全(第2版)

<==========================49end ==============================>
<==========================50start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo.com! ^^.com!仅供试看
2.3常见的软件隐前
13
2.3
Common Software Metaphors
常见的软件隐喻
围绕着软件开发的令人困惑的隐喻越来越多。 David Gries说编写软件是一门
科学( science)(1981)而 Donald Knuth说它是艺术(an art)(1998); Watts
Humphrey则它是个过程 process(199)j. Plauger和 Kent Beck都说它
就像是驾驶汽车( driving car)——可他们两个却儿乎得出了完全相反的结论
(Plauger1993,Beck2000) Alistair Cockburn说它是一场游戏( game)(2002)
Eric Raymond又说它就如同是一个集市(bazaar)(2000): Andy Hunt和 Dave Thomas
说它就像园艺(gardening)一样; Paul Heckel则说它就像是拍摄《白雪公主和七个小
矮人》(1994)而 Fred Brooks说它像耕田、像捕猎、或像是跟恐龙一起淹死在“焦
油坑”里面(1995)到底哪一个隐喻最好呢?
Software Penmanship: Writing Code
软件中的书法:写作代码
关于软件开发的最原始的隐喻是从“写作()代码”这个说法发展出
来的,这一隐喻暗示着开发一个程序就像写一封有缘由的信一样坐下来,拿
它写出来就是从头写到尾就完了。这时不需要正规地做计划,你想到什么东西把
许多的想法就是从写作这个隐喻衍生而来的比如 Jon Bentley说,你应该可
以坐在火炉边上,品一杯白兰地或抽一口上好的雪茄,边上坐着你心爱的猎犬,
去品味一段“深奥的程序”,就像面对的是一本出色的小说那样。 Brian Kernighan
和PJ. Plauger参考一本关于写作体裁的书文体的要素》(《 KThe Elements of Style》
Strunk and White2000,将他们关于编程风格(programming style)的书命名为
《编程风格的要素》(《 Elements of Programming Style》1978)程序员们也经
常会讨论“程序的可读性(readability)”
对于个人规模的工作乃至小型的项目来说,这种写信的隐喻已经足够了,然
而对于其他场合而言,这个隐喻还远远不够它没有完整、充分地刻画软件开
HARD DATA
发工作。书写通常只是个人的活动,而一个软件项目多半会涉及承担许多不同职
责的很多人。在你写完一封信之后,你只要把它塞进信封然后寄出去就完了,你
再也不能修改它一从任何程度和目的上看,这件事情都已经结束了。而软件的
修改没那么难,也很难说有真正完全结束的时候。典型的软件系统在其首次发布
之后的工作量,可能达到整个工作量的9%,典型情况下也有三分之二之多
(Pigoski1997)对写作而言,最重要的是其原创性。但是对于软件构建来说,“努
力创造真正的原创成果”的开发效率,往往低于专注于重用( reuse)以往项目的
一些设计思想、代码以及测试用例(test case)的开发效率。总之,写作这一隐喻
所暗示的软件开发过程太过简单、太过呆板了。
译注:这本书1959年出第1版,1972年出第2,1979年出第3版,2000年出第4版
代码大全(第2版)

<==========================50end ==============================>
<==========================51start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co!^.com!仅供试看^
14
第2章用隐喻来更充分地理解软件开发
Plan to throw然而不幸的是,这种用文字(信件)写作所做的隐喻通过一本在软件领域最
one away, you
为流行的著作之一— Fred Brooks的《人月神话》(《 Mythical Man-Month-》
Fred Brooks Brooks1995)而变成了不朽的思想 Brooks说:“要计划抛弃一个,你必定会那
如果你计划抛弃样,无论如何。”这个咒语给了我们一幅如图2-1所示的景象:被扔进纸篓里的成
一个,那么你将堆的半成品草稿。
会抛弃两个。
-Craig Zerouni
拖
图2-1文字写作这一隐喻暗示着软件开发过程是一种代价昂贵的试错(trial and
error)过程,而非仔细的规划和设计
在给你叔叔写一封“最近好吗”这样的礼节性问候信时,“计划扔掉一张草
稿”也许还比较实际。但如果将“书写软件”这个隐喻引申为“计划扔掉一个
(软件)”,则不是一个好的建议——尤其是在软件的主要系统就已经花费了相
当于一栋十层高的办公楼或一艘远洋客轮这么多成本时。要想中奖不难,只要
你能忍受坐在你钟情的旋转木马上转上无数圈就行。诀窍在于当作第一次尝试
的时候就让它成功—或者在成本最低的时候多试几次。其他一些隐喻更好地阐
明了达到这个目标的途径。
Software Farming: Growing a System
软件的耕作法:培植系统
相对于前面那个呆板的用写作所做的隐喻,一些软件开发人员则认为应当将
创造软件想象成类似播种和耕作的情形。你一次设计系统的一小部分、写出一段
代码、做一点测试,并将成果一点点添加到整个系统中。通过这种小步前进,你
可以把每次可能遇到的麻烦减到最小。
KEY POINT
有时候人们会用很糟的隐喻去描述一种很好的技术,此时需要保全这一技术,
深入阅读如
并去寻找更好的隐喻。这个例子里的增量技术是很有价值的,但把它比作播种和
果想看另一个关耕作却非常糟糕。
软件方面的“每次做一点”这个主意可能在某些方面与农作物生长类似,但把软件开发
阅读 Rethinking类比为耕作就很不贴切,也没有太多意义,而且我们很容易用下面即将介绍的更
Systems Analysis好的隐喻替代它。人们也很难把耕作这个隐喻引申到“一次做一点事情”之外。
and Design
198如果你认同耕作这种隐喻,就请想象一下图2-2的情况:你会发现自己谈论的是:
书中"On the Origins
of Designer Intuition对系统计划施肥、对细节设计疏果,并通过有效的管理土地来增加代码的产量,
(论设计直觉的最终取得代码大丰收。你还会说“轮种C++和大麦”,或者让土地闲置一年以增加
源泉”这一章。
硬盘里面氮肥的供应量。
代码大全(第2版)

<==========================51end ==============================>
<==========================52start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
2.3常见的软件隐喻
15
软件耕作这一隐喻的弱点在于它暗示了人们将无法对开发软件的过程和方式
进行任何直接的控制。你在春天播下代码的种子然后按照农历节气向土地佬儿
许几个愿,你将会在秋天收获到丰盛的代码。
1olosrir
图2-2很难将耕作这一隐喻恰当地引申到软件开发领域
Software Oyster Farming: System Accretion
软件的牡蛎养殖观点:系统生长
在谈论培育(growing)软件的时候,有时人们实际上是指软件的生长
( accretion),这两种隐喻是紧密相关的,而软件生长是一幅更发人深省的景象。
看到“生长”这个词,就算手头没有字典,我们也都能明白它指的是通过外在
的增加或吸收而逐渐地生长或变大。“生长”这个词描述了牡蛎制造珍珠的过程,
逐渐地增添微量的碳酸钙。在地质学里,“accretion”一词的意思是“冲积层”,
指的是水流中夹带的沉淀物的冲积而不断扩大的陆地。在正式的术语中,“冲积
层”是指海岸沿线的陆地因受到水流冲击,水中夹带的物质不断沉积而形成的
增长。
交叉参考关于在
这里并不是说要你学会如何从水流中夹带的沉积物中提炼出代码来,而是说
代策略的具体做法,你需要学会如何一次为软件系统增加一个小部分。跟“生长”密切相关的另一些
率阶段式集成词语有:“增量的(《incrementaJ《itcaivevadaptive)”“迭代的(iterative)、“自适应的(adaptive)”
还是增量集成”。以及“演进的evolutionary)”。以增量方进行设计、编译和测试,都是目前已
知的最强有力的软件开发概念。
在进行增量式开发时,我们先做出软件系统的一个尽可能简单、但能运行的
版本。它不必接受真实的输入,也无须对数据进行真正的处理,更不用产生真实
的输出——它仅仅需要构成一个足够强壮的骨架支撑起未来将要开发的真实系
统。对于你标志出的每一项基本功能,可能仅需要调用虚假的类(dummy classes
这个最基本的起点,就像牡蛎开始孕育珍珠的那颗细小沙粒。
在骨架形成之后,你要一点点地在其上附着肌肉和皮肤:把每个虚假的类替
换为真正的类;不再假装接受输入,而是把接收真实输入的代码替换进去;不再
代码大全(第2版)

<==========================52end ==============================>
<==========================53start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
16
第2章用隐来更充分地理解软件开发
假装产生输出,而是把产生真实输出的代码替换进去。你一次增加一小部分代码,
直到得到一个完全可以工作的系统。
支持这一方法的一件逸事或曰证据令人印象深刻。那位在1975年建议我们建
造一份(软件)以备扔掉( building one to throw away)的Fred Brooks说,在他写
完了里程碑式的著作《人月神话》之后的十年间,没有什么能像增量式开发那样
彻底地改变了他个人的开发习惯及其效力(1995) Tom Gilb在他突破性的著作《软
件工程管理原理》(The Principles of Software Engineering Management,1988)中
也同样指出了这一点,该书介绍了演进式交付( Delivery),它在很大
程度上奠定了如今敏捷编程( agile programming)方法的基础。眼下不少方法论都
是基于这一理念(Beck2000: Cockburn2002 Highsmith2002 Reifer2002 Martin
2003: Larman2004)
作为一个隐喻而言,增量式开发的优势在于未做过度的承诺。比起耕作那个
隐喻来,对它作不恰当地引申要更困难些牡蛎孕育珍珠的图景也很好地刻画
了增量式开发(或说生长)的情形。
Software Construction: Building Software
软件构建:建造软件
与“写作( writing)”软件或者“培育(growing)”软件而言,“建造( building)”
软件的图景就更加有用了。它和软件生长的概念是相通的,且提供了更详细的指
KGYPOINT
引。建造软件这一说法暗示了软件开发中存在着诸多阶段,如计划、准备及执行
等,根据所建造软件的不同,这些阶段的种类和程度可能会发生变化。进一步研
究这一隐喻时,你还会发现许多其他方面的相似之处。
要搭一座四足的塔(《fourfottwerh《),你要有一双稳健的手,要找一个平坦的
表面,以及来个完好无损的啤酒罐。而要搭一座比它大100倍的塔,光是多100
倍的啤酒罐还不够,还需要同时采用完全不同的计划方法和建造方法才行。
如果你要盖一个简单的建筑物比如一个狗屋你先开车到木材店买些
木头和钉子。临近傍晚时分,你的爱犬Fid就有新窝了。如果你像图2-3那样忘
了弄个门,或是犯了其他什么错误,那也没什么大不了的,修改一下或者干脆从
头再来就是了。你的损失最多也就是一个下午的时间。这种宽松的方式对于小型
的项目来说也还算合适。如果你写1000行的代码时采用了错误的设计,你还可以
重构甚至从头再来,不会损失太多。
代码大全(第2版)

<==========================53end ==============================>
<==========================54start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看^
2.3常见的软件隐喻
17
FIDO
图2-3在简单结构上犯下错误,其惩罚也不过是一点时间,或是些许尴尬
如果你是在建一栋房子,那么这个建造过程就会复杂得多,而糟糕的设计所
引发的后果也更严重。首先你要决定准备建一个什么类型的房子在软件开发
里的类似事项称为问题定义(problem definition)接下来,你必须和某个建筑师
(architect)探讨这一总体设计,并得到批准。这跟软件架构设计(architectural
design)十分相似。然后你画出详细的蓝图,雇一个承包人。就像软件的详细设计。
再然后,你要准备好建造地点,打好地基,搭建房屋框架,砌好边墙,盖好房顶,
通好水、电、煤气等。这就如同是软件的构建(construction)一样在房子大部
分完成之后,庭院设计师、油漆匠和装修工还要来把你新盖的家以及里面的家什
美化一番。这就好比软件的优化(oprimization)过程。在整个过程中,还会有各
种监查人员来检查工地、地基、框架、布线以及其他需要检查的地方。这相当于
软件复查(评审, reviews)和审查(inspections)
在这两种活动中,更高的复杂度和更大的规模都会带来更多的结论。盖房子
的时候,建材多少也是有些昂贵,但主要的开销还是在人力上。把一栋墙推倒然
后移动半尺是很昂贵的,倒不在于浪费多少钉子,而是因为你要付给工人们更多
的工钱,移动这堵墙耗费了额外的工时。你只有尽可能地把房子设计好,就像图
2-4那样,这样你才不用浪费时间去修正那些本来可以避免的错误。在开发一个软
件产品时,原材料甚至更加廉价,但劳动力上的花销也更昂贵。变更一份报表的
格式所要付出的代价,和移动房间里的一堵墙一样高昂,因为两者的主要成本构
成部分都是花费人的时间。
代码大全(第2版)

<==========================54end ==============================>
<==========================55start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看^
18
第2章用隐喻来更充分地理解软件开发
图24更复杂的结构需要更加仔细地规划
除此之外,这两种活动还有什么相似之处呢建造一个房子的时候,你不会
去试着建造那些能买得到的现成的东西。你会买洗衣机、烘干机、洗碗机、电冰
箱以及冷藏柜。除非你是机电方面的巫师,否则你是不会考虑自己动手弄这些东
西的。你还会购买预先造好的橱柜、餐桌、门窗以及浴具,等等。当开发软件时,
你也会这么做的。你会大量使用高级语言所提供的功能,而不会自己去编写操作
系统层次的代码。你可能还要用些现成的程序库,比如说一些容器类(container
classes、科学计算函数、用户界面组件、数据库访问组件,等等。总之,自己编
写那些能买得到的现成的代码通常是没有意义的。
但如果你要建造一间拥有一流家具的高档住宅,那你可能需要特别订制的橱
柜,还可能需要能和这些橱柜相搭配的洗碗机、冰箱和冷藏柜等,也可能需要以
特殊的形状和特别尺寸订制的窗户。在软件开发中也有和这种订制相似的情况。
如果你要开发一款一流的软件产品,你可能会自己编写科学计算函数以便获得更
快的速度和更高的精度。你还可能需要自己编写容器类、用户界面组件以及数据
库访问组件等,这样做可以让产品的各个部分无缝拼接,拥有一致的外观和体验。
适当的多层次的规划对于建造建筑物和构建软件都有好处。如果你按错误的
顺序构建软件,那么编码、测试和调试都会更难。需要花更长的时间才能完成,
甚至整个项目干脆就分崩离析了由于每个人的工作都过于复杂,所有成果组
合在一起的时候就变得混乱不堪了。
精心计划,并非意味着事无巨细的计划或者过度的计划。你可以把房屋结构
性的支撑( structural support)规划清楚,而在日后再决定是用木地板还是地毯,
代码大全(第2版)

<==========================55end ==============================>
<==========================56start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubulo...com!仅供试看^
2.3常见的软件隐
19
墙面漆成什么颜色,屋顶使用什么材料,等等。一项规划得当的项目能够提升你
“在后期改变细节(设计)”的能力。你对同类软件的开发经验越丰富,(在开发
新软件时)就能认准更多的细节。你只需要保证已经做了足够的计划,不会到后
来因为计划上不足而引发重大问题。
用建筑房屋来类比软件构建,还有助于解释为什么不同的软件项目能从不同
的开发方法中获益。建筑业中,盖间仓库或者工具房,或是一座医院或者核反应
站,你在规划、设计及质量保证方面所需达到的程度是不一样的。盖一座学校、
一幢摩天大楼,或一座三居室的小别墅,所用的方法也不会相同同理,在软件
开发中,通常你只需要用灵活的、轻量级的( lightweight)方法,但有时你就必须
得用严格的、重量级的开发方法,以达到所需的安全性目标或其他什么目标。
软件的变动在建筑领域也有类似事物。把一堵承重墙移动半尺所需花费的成
本,肯定要比仅仅移动一面隔墙更高。同样,对软件进行结构性的修改所需花费
的成本,肯定也比仅仅增删一些周边功能更高。
最后,建筑这一隐喻让人们对超大型的软件项目的认识更加深刻。超大型的
结构一旦出现问题,后果将非常严重,因此有必要对这样的结构进行超出常规的
规划与建设(over-engineered-)。建筑人员需要非常小心地制定并核查设计规划,
在建设时留有余地以保障安全:宁可多花10%的成本买更坚固的材料,也比摩天
大楼倒下来要划算得多。还需要特别关注工作的时间。在建造帝国大厦(The
Empire Building)的时候,每辆运料车运输时都留有15分钟的余地。如果某辆车
没能在指定时间到位,则整个工期就会延误。
同理,对于超大型的软件项目,就需要比一般规模的项目有更高级别的规划
设计。 Capers Jones发表的报告称,一套100万行代码的软件系统,平均需要69
种文档(1998)。其需求规格文档一般有四五千长,而设计文档常常是需求的两
三倍长。不太可能有哪一个人能完全理解这种规模的项目的所有设计细节甚
至只是通读一遍都不那么容易。因此,更充分的准备工作也就理所应当了。
如果需要创造在经济规模上可以匹敌帝国大厦的庞大的软件项目,那么与之
相当水准的技术与管理控制也是必需的。
深入阅读关于
“构建隐喻的引
按房屋建筑所作的这一隐喻,可以向许多其他方向引申这也是隐喻这一
申,请见“是什么方法如此强有力的一个原因。有很多常见的软件开发术语都是从建筑这一隐喻中
撑起了天花板
atsuppts行生出来的:软件架构(建筑学《Pzarchitcure《,)支撑性测试代码(脚手架,
scaffolding)构建(建设, construction基础类( foundation classes)以及分离
(Starr 2003).
代码( tearing code apart)。你可能还听说过更多这一类的词语。
代大全(第2版)

<==========================56end ==============================>
<==========================57start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubul.com!仅供试看^
20
第2章用隐来更充分地理解软件开发
Applying Software Techniques: The Intellectual Toolbox
应用软件技术:智慧工具箱
能有效地开发高质量软件的人们,在长年累月中积累了大量的技术、技巧和
诀窍。技术并不是规矩(rule),它只是分析工具(analytical tools)好的工匠知道
KEYPO完成某项工作要用哪样工具,也知道该怎样正确地使用程序员也该这样。编程
方面的知识学得越多,你脑中的工具箱中就会有更多的分析工具,也会知道该在
在设计中选择并何时用这些工具,以及怎样正确地使用它们。
组合各种方法,见
第5.3节“设计构在软件领域里,专业的咨询人员有时会让你专用某种软件开发方法而远离其他方
造块:启发式方法。这样并不妥当,因为当你百分之百地依赖于某一方法论时,你就只会用一种方法
法
去看世界了。某些情况下,对于你所面临的问题还有其他更好的方法,你可能错失良
机。这种“工具箱隐喻”能够帮助你把所有的方法、技术以及技巧留在脑海中合
适的时候即可拿来就用。
Combining Metaphors
组合各个隐喻
因为隐喻是一种启发式方法而不是算法,因此它们彼此并不排斥。你可以同
时使用生长 accretion)和建筑( construction)这两个隐喻。你如果想用“写作”
隐喻也行,你还可以把“写作”同“驾驶”、“狩猎狼人(werewolf)”、“与恐龙一
KEY POINT起在焦油坑中淹死”等隐喻组合到一起。你可以选用任何一种隐喻或是一些隐喻
的组合,只要它能激发你的思维灵感,并让你和团队其他成员更好地沟通。
使用隐喻又是件说不清楚的事情(fuzzy business)你需要适当地引中它的含
义,才能从其蕴含的深刻启发中受益。但若你过分地或者在错误的方向上引申了
它的含义,它也会误导你。正如人们会误用任何强大的工具一样,你也可能误用
隐喻,但它的强大的功效,还会成为你智慧工具箱中的一个宝贵部分
Additional Resources
更多资源
cc2e.com/0285
在关于隐喻、模型( model)以及范型(paradigm方面的众多书籍中,Thomas
Kuhn写的那本是试金石。
uhn, Thomas.《科学变革的结构》(第三版(The Structure of Scientifi
Revolutions,3ded. Chicago,il: The University of Chicago Press,1996.)kuhn关于
在一个达尔文周期中,科学理论如何相对于其他理论而诞生、发展并消亡的书,
于1962年首次发布,奠定了科学哲学的基础。该书短小精悍,列举了大量科学中
隐喻、模型以及范型间此消彼长的有趣示例。
Floyd, Robert.“编程范型(The Paradigms of Programming.”1978年
图灵奖的颁奖演讲)《Communications of the ACM》《ACM通讯》), August1 1979,
pp.455460.这是一篇令人神往的关于软件开发中的模型的讨论, Floyd将Kuhn
代码大全(第2版

<==========================57end ==============================>
<==========================58start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubr ^.com!仅供试看^
要点
21
的理念应用到了编程上。
Key Points
要点
隐喻是启示而不是算法。因此它们往往有一点随意(sloopy)。
隐喻把软件开发过程与其他你熟系的活动联系在一起,帮助你更好地理解。
有些隐喻比其他一些隐喻更贴切。
通过把软件的构建过程比作是房屋的建设过程,我们可以发现,仔细的准备
是必要的,而人型项目和小型项目之间也是有差异的。
通过把软件开发中的实践比作是智慧工具箱中的工具,我们又发现,每位程
序员都有许多工具,但并不存在任何一个能适用于所有工作的工具,因地制
宜地选择正确工具是成为能有效编程的程序员的关键。
不同的隐喻彼此并不排斥,应当使用对你最有益处的某种隐喻组合。
代大全(第2版)

<==========================58end ==============================>
<==========================59start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^

<==========================59end ==============================>
<==========================60start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
Measure Twice, Cut Once:
Upstream Prerequisites
第章
三思而后行:前期准备
cc2com/0309内容
3.1前期准备的重要性:第24页
3.2辨明你所从事的软件的类型:第31页
3.3问题定义的先决条件:第36页
3.4需求的先决条件:第38页
3.5架构的先决条件:第43页
3.6花费在前期准备上的时间长度:第55页
相关章节
关键的“构建”决策:第4章
项目规模对“构建”及前期准备的影响:第27章
质量目标与构建活动之间的关系:第20章
管理构建:第28章
设计:第5章
在开始建造房子之前,施工人员会审视蓝图包含所有细节信息的设计详图)
查看是否获得了全部(建筑)许可证,并测量房屋的地基。施工人员建造摩天大
楼用一种方法,建造普通住宅用另一种方法,建造犬舍用第三种方法。无论何种
项目,都会对“准备工作”进行剪裁,使之符合项目的特定需要;在构建活动开
始之前,准备工作要做周全。
本章描述软件构建必须做的准备工作。就像修建建筑物一样,项目的成败很
大程度上在构建活动开始之前就已经注定了。如果地基没打好,或者计划不充分,
那么你在构建期间能做的无非是尽量让损害最小罢了。
木匠的谚语“瞄两次,切一次”( Measure twice, cut once/三思而后行)与软件
开发中的构建部分有密切联系,构建活动差不多占整个项目成本的65%最糟糕
代码大全(第2版)

<==========================60end ==============================>
<==========================61start==============================>

该书下载自-书部落-分享计算机经典巨著!- !--www.shubulo..com!仅供试看
24
第3章三思而后行:前期准备
的软件项目最终会进行两三次(甚至更多)构建将项目中最昂贵的部分执行两
遍,这无论在软件行业还是在其他行业都是愚蠢的主意。
虽然本章是为成功的软件构建打地基,但是并没有直接讨论构建活动。如果
你觉得自己是食肉动物,或者已经精通软件工程的生命周期,那么请径直翻到第
5章“软件构建中的设计”这块肥肉。如果你不打算动“为构建活动做前期准备”
这个念头,那么请复习第3.2节“辨明你所从事的软件的类型”,认识一下如何将
前期准备应用到你所处的情形。然后再关注一下第3.1节中的数据,这些数据描
述了不做前期准备将会付出的代价。
Importance of Prerequisites
前期准备的重要性
交叉引用关注使用高质量的实践方法是那些能创造高质量软件的程序员的共性。这些高质
质量就是提高生量的实践方法在项目的初期、中期、末期都强调质量。
产力的最佳途
径。更多细节请
参见第20.5节
如果你在项目的末期强调质量,那么你会强调系统测试。当提到软件质量保
“软件质量的普证的时候,许多人都会想到测试。但是测试只是完整的质量保证策略的一部分,
遍原则”v
而且不是最有影响的部分。测试是不可能检查出诸如“制造了一个错误的产品”,
或者“使用错误的方法制造正确的产品”之类的缺陷的。这样的缺陷必须在测试
之前解决更确切地说是在构建活动之前。
8
如果你在项目中期强调质量,那么你会强调构建实践。这些实践是本书绝大
部分篇幅的关注点。
KEY POINT
如果你在项目的开始阶段强调质量,那么你就会计划、要求并且设计一个高质
量的产品。如果你用为 Pontiac Aztek做的设计来开始整个生产过程,那么你可以想
尽办法来测试,它也绝对不会变成劳斯莱斯。也许你能造出最好的 Aztek,但如果
想要的是一辆劳斯莱斯,那么你就得从头开始做计划。在软件开发中,你也需要在
定义问题、定下解决方案的规格,以及设计解决方案的时候做出这种计划
由于构建活动是软件项目的中间阶段,在你开始构建的时候,项目前期T作
已经或多或少为这个项目的成功或失败打下了基础然而,在构建过程中,你至
少应该能辨明当时的形势如何,如果你看到失败的乌云已经出现在地平线上时,
就退回到项目的前期工作吧。本章的其余部分将仔细讲述为什么合适的准备工作
是非常重要的,并且告诉你如何判定“是否已经准备好开始构建工作了”。
注 Pontia Aztek款非常雅看的小轿车位 cartalk网站全球大最丑车”排行榜首位
劳斯莱斯则是世界顶级的豪华轿车
代码大全(第2版)

<==========================61end ==============================>
<==========================62start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
3.1前期准备的重要性
25
Do Prerequisites Apply to Modern Software Projects
前期准备适用于现代软件项目吗
方法论应该选用有些人断言,诸如架构、设计及项目规划等前期工作对于现代软件项目来说
最新最好的,而不
应该无知地做出是毫无用处的。总体来说,没有哪项研究(无论过去还是现在)支持这断言,
选择。当然也应该最近的数据也不支持这一断言(具体请看本章的其余部分)。反对前期准备的人
公平地对待“旧且通常会给出一些前期准备做得很糟糕的例子,然后指出这种工作毫无作用。但无
可靠的方法”
Harlan Mills论如何,前期准备也可以做得非常好;并且从20世纪70年代开始至今的业界数
据显示,如果在开始构建活动之前认真地进行适当的准备活动,那么项目将会运
作得极好。
准备工作的中心目标就是降低风险:一个好的项目规划者能够尽可能早地将
主要的风险清除掉,以使项目的大部分工作能够尽可能平稳地进行。目前,软件
KEY POINT开发中最常见的项目风险是糟糕的需求分析和糟糕的项目计划,因此准备工作就
倾向于集中改进需求分析和项目规划。
构建活动的准备工作不是一门精密科学,要根据每一个项目的特点来选择特
定的降低风险的方法。具体细节随项目的不同,会有非常大的变化。更多的信息
请参阅第3.2节
Causes of Incomplete Preparation
准备不周全的诱因
你可能会认为,所有的专业程序员都知道准备工作的重要性,并且在跃入构
建活动之前会检查确认所有先决条件都已经满足了。很不幸,这不是事实。
深入读
Professional
造成准备工作不充分的一个常见原因是,那些分配去做前期准备活动的开发
Software Devel人员并不具备完成这一任务的专业技能项目规划、创作引人注目的商业案例、
apment(专业分析出全面而准确的需求、创建高质量的架构等活动都需要一定的技能,这些技
软件开发,
MoConnel200)能不是轻而易举就能获得的。但是绝大多数开发人员都没有接受过针对这些活动
第16章描述了的训练。当开发人员不知道如何进行这些前期工作的时候,建议“做更多的前期
一项能培养这些
技能的专业培养工作”就完全没有用:如果不能首先把这项工作做好,那么做再多也没有意义!
计划。
说明如何进行这些活动已经超出了本书的范围不过在本章最后的“更多资源”
ccco316中,提供了许多获取这些专业技能的途径。
有一些程序员确实知道如何进行前期工作,但是他们并没有做,因为他们
不能够抵抗“尽快开始编码”的欲望。如果你也是这样,我有两条建议:第一,
代全(第2版)

<==========================62end ==============================>
<==========================63start==============================>

该书下载自-书部落分享计算机经典巨著!-ww. ! --www.shubuld.com!仅供试看
26
第3章三思而后行:前期准备
阅读下一节中的争论,它也许能告诉你一些你以前没有想到的问题;第二,注意
一下你经历过的问题。只需要做几个大项目,你就能够体会到:事先做好计划能
避免很多压力。让你自己的经验来引导你吧。
程序员不做准备工作的最后一个原因是,管理者们对那些“花时间进行构建
活动的前期准备的程序员”的冷漠已经到了人神共愤的程度。 Barry Boehm、 Grady
Booch及 Karl Wiegers等人25年来一直在擂响需求和设计的战鼓,因此你可以期
望,管理者们应该已经开始明白:软件开发不仅仅是写代码。
入阅读有关这然而,就在几年前,我参与美国国防部的一个项目。当这个项目正集中精力做
一主题的更多愉快
的变奏,请阅需求分析的时候,负责这个项目的那位军方将领来视察我们告诉他止在开发需求,
请
Geraid Weinberg主要包括和客户沟通、捕捉需求,以及勾勒出设计的轮廓。但是他坚持无论如何要
的经典著作The
Psychology of Co看到代码。我们告诉他现在没有代码,但是他还是在一个100人的工作区里面走来
mputer Program走去,试图抓出一个正在编程的人来看到这么多人要么不在桌子前,要么正在做
1998)。2
需求分析和设计,他感到非常的沮丧。最后这个腆着大肚子的家伙指着坐在我旁边
的一个工程师,扯着喉咙咆哮道:“他在干什么?他肯定在写代码!”事实上这个
工程师正在做一个文档格式化的工具,但是这位将军想要找代码,觉得这个像是代
码,并且希望这位工程师是在写代码,于是我们告诉他这就是代码。
这种现象被称为 WISCA综合症或者WIMP综合症: Why Isn't' Sam Coding
Anything?(为什么Sam不在写代码?)或者 Why Isn't' Mary Programing?(为什么
Mary不在编程?)
如果你的项目经理装成陆军将的样子,命令你立刻开始写代码,你可以轻
易地说:“遵命!”(这有什么可怕的?老手当然知道他在说什么)这种回答
很糟糕,你可以有几种更好的替代方案。首先,你可以断然拒绝以这种无效的命
令,假如你和老板的关系不错,而且你银行账户的钱数也支持你这么做的话,祝
你好运。
第二个不太靠得住的方案是假装在写代码,而事实上不是。在你的桌角上放
一份旧的程序代码清单,然后投入需求和架构的开发中,同时不用去理会老板同
不同意。你将能够更快地完成项目,并得到更高的质量。有些人会觉得这种方法
不合乎伦理,但是从你老板的视角来看,无知是福。
第三种方法是,你可以教育你的老板,告诉他技术项目的微妙之处。这是一
个好办法,因为它能增加世界上脱盲的老板的人数。下面的小节将继续讲述“在
构建活动之前花时间做前期准备”的根本原因。
2译注:中译本《程序开发心理学》,清华大学出版社
代码大全(第2版)

<==========================63end ==============================>
<==========================64start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubulo. ^.com!仅供试看^
3.1前期准备的重要性
27
最后一个方案是,你可以另外找一份工作。虽然经济景气程度时高时低,但
是优秀的程序员永远是紧缺的(BLS2002)。人生苦短,当有大量更好的选择摆在
你面前的时候,在一个荒蛮的软件企业中工作是不明智的。
Utterly Compelling and Foolproof Argument for Doing
Prerequisites Before Construction
关于开始构建之前要做前期准备的绝对有力且简明的论据
设想你已经到过“问题定义”之山,与名为“需求”之人同行数里在“架
构”之泉面前脱下脏兮兮的外套,然后在“前期准备”之纯净水中沐浴。那么你
就会知道,在实现一个系统之前,你需要理解“这个系统应该做什么”,以及“它
该如何做到这些”。
作为技术雇员,你的一部分工作就是培训周围的非技术人员,讲解开发过程
本节将有助你应对那些“尚未觉悟的管理者和老板”。这里有支持“在开始编码、
测试、调试之前进行需求分析和架构设计才能保证关键的方面都做正确”这
KEY POINT一观点的大量论据。学习这些论据,然后与老板一同坐下来,进行一次有关开发
过程的恳谈。
Appeal to Logic
诉诸逻辑
进行有效编程的要领之一是:准备工作很重要在开始做一个大项目之前,
应该为这个项目制订计划,这是很有意义的。大的项目需要做更多的计划,而小
项目则可以少些。从管理的角度看,做计划意味着确定项目所需要用的时间、人
数以及计算机台数。从技术角度讲,做计划意味着弄清楚你想要建造的是什么,
以防止浪费钱去建造错误的东西。有时候用户在一开始并不完全确定自己想要的
是什么,因此值得花费比理想情况下更多的力气,找出他们真正想要的东西。但
这至少比“先做一个错误的东西出来,然后扔掉,并从头来过”的成本要低廉。
在开始动手制作这个系统之前,先好好思考打算如何去做,这也非常重要。
你总不希望花费很多的时间和金钱,却毫无必要地走进死胡同(尤其当这样做会
增加成本的时候)。
Appeal to Analogy
诉诸类比
建造软件系统跟其他任何花费人力财力的项目是相似的。如果打算建造一座
房屋,你需要在开始钉钉子之前准备好手绘草图(表达设计概念)和蓝图(即设
计详图,包含所有细节信息)。在浇注混凝土之前必须审核蓝图并获得批准。在软
件领域做技术规划也包含同样多的事情。
代大全(第2版)

<==========================64end ==============================>
<==========================65start==============================>

该书下载自-书部落-分享计算机经典巨著-w. ! --www.shubulo.com!^.com!仅供试看
28
第3章三而后行:前期准备
在把圣诞树立起来之前,你不会对它做装饰;在打开烟囱之前,你不会生火;
你不会在车子的油箱是空的时候上路去长途旅行;你不会在洗完澡之前就穿戴
整齐,也不会在穿袜子之前就穿鞋。在做软件时,你也必须按正确的顺序去做
事情。
程序员是软件食物链的最后一环。架构师吃掉需求,设计师吃掉架构,而程
序员则消化设计。
我们用真实的食物链来比喻软件食物链。在健康的生态环境中,海鸥吃新
鲜的鲑鱼。这对海鸥是营养丰富的大餐,因为鮭鱼吃的是新鲜的青鱼,而青鱼
吃的是新鲜的水蝽。这是一条健康的食物链。在软件开发中,如果食物链的每
一级都有健康的食物,那么最终就会获得由快乐的程序员编写出的健康的代
码。
在受到污染的环境中,水蝽在核废料中游泳,青鱼被聚氯联二苯(PCB)污染,
而吃青鱼的鲑鱼又在泄漏的原油中游荡。3海鸥很不幸,它位于食物链的最后一
环,因此它吃下去的不仅仅是不健康的鲑鱼体内的原油,还有青鱼体内的聚氯联
二苯和水蝽体内的核废料。在软件开发中,如果需求被污染了,那么它就会污染
架构,而架构又会污染构建。这样会导致程序员脾气暴躁、营养失调开发出的
软件具有放射性污染,而且周身都是缺陷。
如果你正为某个高度代的项目做计划,那么在开始构建活动之前,你需要
针对将要构造的每一片段,先弄清哪些是最关键的需求和架构要素。建造住宅小
区的施工人员,在开始建造第一栋房子之前并不需要知道小区里面每一栋房子
的每一个细节。但他会调查施工场所,制定下水道和电线的走向等。如果施工人
员准备不充分,那么建造过程很可能会因为“需要在某所已经造好的房子的地下
挖一条下水道”而延误。
Appeal to Data
诉诸数据
过去25年来的研究确凿地证明了,在一开始就把事情做好是最合算的。进行
非必要的改动的代价是高昂的。
3译注:聚联二苯是一种环境污染物质,积聚在动物组织中,能导致其发病和产生畸形。
代码大全(第2版)

<==========================65end ==============================>
<==========================66start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !-www.shubulo.c.com!仅供试看^
3.1前期准备的重要性
29
惠普、IBM、休斯飞机公司、TRW以及其他组织的研究人员发现,在构建活
动开始之前清除一个错误,那么返工的成本仅仅是“在开发过程的最后阶段(在
HARD DATA系统测试期间或者发布之后)做同样事情”的十分之一到百分之一。(Fagan1976
Humphrey, Snyder, and Willis 1991; Leffingwell 1997; Willis et al. 1998; Grady 1999;
Shull et al.2002; Boehm and Turner2004.)
一般而言,这里的原则是:发现错误的时间要尽可能接近引入该错误的时间。
缺陷在软件食物链里面呆的时间越长,它对食物链的后级造成损害就越严重。由
于需求是首先要完成的事情,需求的缺陷就有可能在系统中潜伏更长的时间,代
价也更加昂贵。在软件开发过程的上游引入的缺陷通常比那些在下游引入的缺陷
具有更广泛的影响力。这也使得早期的缺陷代价更加高昂。
表3-1展示了“引入缺陷的时间和找到缺陷的时间”与“修复缺陷的费用”
之间的关系。
HARD DATA
表3-1修复缺陷的平均成本与引入缺陷的时间和检测到该缺陷的时间之间的关系
检测到缺陷的时间
引入缺陷的时间需求架构构建
系统测试发布之后
需求
1
31
5-10
10
10100
架松
10
15
25-100
构建
1
10
10—25
来源:改写自“Design and Code Inspections to Reduce Errors in Program Development
(Fagan1976),《 KSoftware Defect Removal》(dunn1984),“Software
rove
Improvement at Hughes Aircraft"(Humphrey, Snyder, and Willis 1
Return on Investment from More Effective Re
1997), "Hughes Aircraft's Widespread Deployment of a C
Software Process"(Willis et al. 1998), "An Economic Rele
into Software Project Management"(Grady 1999), "What We Hay
Fighting Defects"(Shull et al. 2002), and Balancing Agility and D
the Perplexed) (Boehm and Turner 2004).
表3-1的数据显示,例如,假设在创建架构的期间修复某个架构缺陷需要花
1000美元,那么在系统测试期间修复这一缺陷,将要花费15000美元图3-1解
释了同样的现象。
代码大全(第2版)

<==========================66end ==============================>
<==========================67start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubu.com!仅供试看^
30
第3章三思而后行:前期准备
在哪个阶段引入的缺陷
Cost
需求
架构
构建
需求架构构建系统测试发布之后
在哪个阶段检测到缺陷
图3-1修复缺陷的成本随着“从引入缺陷到检测该缺陷之间的时间”变长而急剧增
加。无论项目是高度序列化(sequential)的(预先完成100%的需求和设计),
还是高度迭代型(预先完成5%的需求和设计)的,这些都成立
平均水平的项目仍然把绝大部分的缺陷修正工作放到图3-1的右侧进行,这
也就意味着“调试连同相应的返工”在典型的软件开发周期中会占据大约50%的
HARD DATA时间。(Mills 11983; Boehm1987; Cooper and Mullen1993; Fishman1996; Haley
1996; Wheeler, Brykczynski, and Meeson 1996; Jones 1998; Shull et al. 2002; Wiegers
2002。)许多公司发现,只需在项目中尽早集中纠正缺陷,就能将开发的成本和
时间减半(甚至更多)(《McConeI124Tc《)。所以你应该尽早查找并修正错误。
Boss-Readiness Test
“老板就绪”测试
如果你觉得你的老板已经明白了“在开始构建之前进行前期准备”的重要性,
那么试试以下的测试,以确保他确实明白了。
下面的句子哪些是自我实现的预言(sf-f-fulfilling prophecies)?
■我们最好立刻开始编码,因为将会有很多的调试工作需要做。
■我们并没有为测试安排太多的时间,因为将来不会发现多少缺陷。
4译注:自我实现的预言,是指当你对未来的行为或事件预测时,就会对你行为的互动改变很大,以
至于产生预期的结果。
代码大全(第2版)

<==========================67end ==============================>
<==========================68start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com!^^.com!仅供试看^
3.2辨明你所从事的软件的类型
31
我们已经非常详细地研究了需求和设计,我想不出在编码和调试期间还会遇
到什么大问题。
上面这些陈述都是自我实现的预言。要瞄准最后那个。
如果你仍然不能确信前期准备适用于你的项目,下面一节将帮助你做出决定。
3.2
Determine the Kind of Software You're Working On
辨明你所从事的软件的类型
Caper Jones Software Productivity Research(软件生产率研究)的首席科学
家,他回顾20年的软件研究,指出他和同事见过不止700种不同的编程语言,以
及40种收集需求的方法、50种进行软件设计的方法、30种针对项目的测试方法
(Jones 2003).
不同种类的软件项目,需要在“准备工作”和“构建活动”之间做出不同的
平衡。每一个项目都是独特的,但是项目可以归入干种开发风格。表3-2列出
了三种最常见的软件项目种类,并且列出了各种项目最适合的典型实践
表3-2三种常见的软件项目种类,及其典型的良好实践
软件种类
商业系统
使命攸关的系统性命攸关的嵌入式系统
Internet站点
嵌入式软件
航空软件
Intranet站点
游戏
嵌入式软件
典型应用库存管理
Internet站点
医疗设备
游戏
盒装软件
操作系统
管理信息系统(MIS)软件工具
盒装软件
工资系统
Web services
敏捷开发(极限编程、分阶段交付分阶段交付
生命周期 Scrum、time-box
渐进交付
螺旋型开发
模型
开发等等)
螺旋型开发
渐进交付
渐进原型(prototyping)
代码大全(第2版)

<==========================68end ==============================>
<==========================69start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co!.com!仅供试看^
32
第3章三思而后行:前期准备
续表
软件种类
商业系统
使命攸关的系统性命攸关的嵌入式系统
增量式项目计划
基本的预先计划充分的预先计划
计划与管随需测试与QA计划基本的测试计划充分的测试计划
理
非正式的变更控制随需QA计划
充分的QA计划
正式的变更控制严格的变更控制
非形式化的需求规格半形式化的需求形式化的需求规格
需求
规格
形式化的需求检查
随需的需求评审
设计与编码是结合的架构设计
架构设计
设计
非形式化的详细形式化的架构检查
设计
形式化的详细设计
随需的设计评审形式化的详细设计检查
结对编程或独立编码结对编程或独立结对编程或独立编码
非正式的 check--in手续编码
正式的 check-in手续
构建或没有 check-icheck--in手续非正式的-in正式的代码检查
手续
随需代码评审
开发者测试自己的代开发者测试自己开发者测试自己的代码
码
的代码
测试先行开发
测试与QA测试先行开发
测试先行开发单独的测试小
很少或没有测试(由单单独的测试小组单独的QA小组
独的测试小组来做)
部署非正式的部署过程正式的部署过程正式的部署过程
在真实项目中,你会找到表中所列这三种主调的无数种变奏;无论如何,表
中已经列举了它们的共性。开发商业系统的项目往往受益于高度迭代的开发法,
这种方法的“计划、需求、架构”活动与“构建、系统测试、质量保证”活动交
代码大全(第2版)

<==========================69end ==============================>
<==========================70start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!.com!仅供试看^
3.2辨明你所从事的软件的类型
33
织在一起。性命攸关的系统往往要求采用更加序列式的方法“需求稳定”是
确保“超高等级的可靠性”的必备条件之一。
Iterative Approaches' Effect on Prerequisites
迭代开发法对前期准备的影响
有些作者断言,使用迭代技术的项目基本无须关注前期准备,但这种观点是
错的。迭代方法往往能够减少“前期准备不足”造成的负面影响,但是它不能完
全消除此影响。让我们看一下表3-3所示的例子,这两个项目都没有关注前期准
备工作。第一个项目按序列式开发法运作,并且仅仅依赖于测试来发现缺陷。第
二个项目则按迭代方式运作,并且随着项目的进展不断找出错误。第一个方法将
绝大部分缺陷修正工作推迟到项目快结束的时候进行,使得成本较高(正如表3-1
所述)。而迭代式开发法在项目进行过程中一点点地吸收消化返工,这样使得总
体成本较低。这个表中的数据和下一个表中的数据仅仅是为了举例说明,但是这
两种通常的开发方法的成本的这种相对关系,是受到本章前面部分提到的那些研
究支持的。
表3-3跳过前期准备对于采用序列式开发法的项目和迭代式开发法的项目的(不同)
影响
方法1:序列式开发法
方法2:迭代式开发法
(无前期准备)
(无前期准备)
项目完成度工作成本
返工成本工作成本
返工成本
20%
$100000$0
$100000
$75000
40%
$100000$
$100000
$75000
60%
$100000$
$100000
$75000
80%
$100000$
$100000
$75000
100%
$100000$
$100000
$75000
项目末期返工$O
$500000
$
总计
$500000$500000
$500000
$375000
总数之和
$1000000
$875000
那些简化或取消了前期准备工作的迭代型项目与采用同样做法的序列型项
目相比,有两点不同。首先,平均的缺陷修正成本低一些,因为发现缺陷的时
间往往更接近引入该缺陷的时间。然而,每一轮迭代仍然要到最后才能检测到
缺陷,为了修正这些缺陷,需要对软件的某些部分进行重新设计、重新编码并
重新测试—这使得修正缺陷的成本高于实际需要。
代码大全(第2版)

<==========================70end ==============================>
<==========================71start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor ^.com!仅供试看
34
第3章三思而后行:前期准备
其次,使用迭代式开发法,成本将会在整个项目过程当中分次支付,而不会
聚集到项目末尾一次性支付。整个项目尘埃落定之后,实际的总成本是相似的,
但是看起来却没有那么高,因为开发费用是在整个项目进行过程中分期支付的,
而不是在项目最后一次性结账。
如表3-4所示,无论你使用的是迭代式开发法还是序列式开发法,只要进行
前期准备,就可以减少成本。“迭代式开发法通常是更好的选择”这一观点有很多
的理由支持。但是忽略前期准备的迭代式开发法,最终明显会比“密切关注前期
准备工作的序列式开发法”付出更高的代价。
表3-4关注前期准备工作对于采用序列式开发法的项目和迭代式开发法的项目的影响
方法3:序列式开发法
方法4:迭代式开发法
(有前期准备)
(有前期准备
项目完成度工作成本返工成本工作成本
返工成本
20%
$1000000000
$100000
$10000
40%
00000$2000000000
$10000
60%
$100000$20000
$100000
$10000
80%
$10000020000$00000
$10000
100%
10000$20000$10000
$10000
项目末期返工$O
$
$
总计
$50000000000$500000
$50000
总数之和
$600000
$550000
正如表3-4所暗示的,绝大多数的项目都不会完全使用序列式开发法或者完
全使用迭代式开发法。预先详细说明100%的需求和设计是不切实际的,不过对绝
KEY POINT大多数项目来说,“尽早把哪些是最关键的需求要素和架构要素确定下来”是很有
价值的。
交叉参考关条很有用的经验规则是计划好预先对大约80%的需求做出详细说明,并
于具体如何使
你的开发方法给“稍后再进行详细说明的额外需求”分配一定的时间。然后在项目进行过程中,
适应不同规模实施系统化的变更控制措施——只接受那些最有价值的新需求。另一种替代方案
的程序,见第
27章“程序规是,预先只对最重要的20%的需求做出详细说明,并且计划以小幅增量开发软件
模对构建的影
响”
的剩余部分,随着项目的进行,对额外的需求和设计做出详细说明。图3-2和图
3-3展示了这两种不同的方法。
代码大全(第2版)

<==========================71end ==============================>
<==========================72start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
3.2辨明你所从事的软件的类型
35
需求
架构
详细设计
构建
质量保证/系统测试
时间
图3-2对于绝大部分的项目(即便是高度序列化的项目)来说,各种活动会在一定
程度上有所重叠
需求
架构
详细设计
构建
质量保证/系统测试
时间一
图3-3对于其他的项目,各种活动在项目开发期间会重叠起来。成功“构建”的关
键之一,就是理解前期准备工作的完成程度,并据此调整你的开发方法
Choosing Between Iterative and Sequential Approaches
在序列式开发法和迭代式开发法之间做出选择
前期准备预先要满足哪些条件,会随表3-2所列出的不同项目种类、项目的
正式程度、技术环境、员工能力以及项目的商业目标变化而变化。你可能因为下
列原因选择一个更加序列化的方法。
■需求相当稳定。
设计直截了当,而且理解透彻。
开发团队对于这一应用领域非常熟悉。
代码大全(第2版)

<==========================72end ==============================>
<==========================73start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看
36
第3章三思而后行:前期准备
项目的风险很小。
“长期可预测性”很重要。
后期改变需求、设计和编码的代价很可能较昂贵。
你可能因为下列原因选择一个更加迭代(as-you-go,走着瞧)的方法。
需求并没有被理解透彻,或者出于其他理由你认为它是不稳定的。
设计很复杂,或者有挑战性,或者两者兼具。
开发团队对于这一应用领域不熟悉。
项目包含许多风险。
“长期可预测性”不重要。
后期改变需求、设计和编码的代价很可能较低。
事实上,在软件开发中,适用迭代式开发法的情况比适用序列式开发法的情
况多得多。你可以使前期准备适应某个特定项目,办法是调整其正式程度和完备
程度,到你觉得合适为止。大型项目和小型项目有不同的开发方法(也称为正式
项目和非正式项目有不同的开发方法),关于这点具体讨论请阅读第27章。
你应该首先确定哪些前期准备活动适合你的项目有些项目在前期准备上面
花的时间太少了,结果使得在构建活动中遇到大量不必要的反复修改,同时阻碍
了项目的稳步前进。有些项目则预先做了太多的事情,固执地坚持原有的需求和
计划,后来事实证明这些需求和计划是无效的,这同样阻止了构建活动的顺利进
既然你已经研究过表3-2,并且确定了何种前期准备适合你的项目,那么本章
接下来将要讨论的是:如何判断每一项特定的前期准备工作是否到位。
3.3
Problem-Definition Prerequisite
问题定义的先决条件
如件的边界,做出清楚的陈述。这有时称为“产品设想/product vision”、“设想陈述/vision
果“框框”是约
束和
在开始构建之前,首先要满足的一项先决条件是对这个系统要解决的问题
那么诀窍在于找到
这个“框框 statement"、“任务陈述mission statement”或者“产品定义/product definition”这
不要在“框框”之里将它称为“问题定义problem definition”由于这本书是关于软件构建的,本节
外思考——找到这
个“框框”。不打算告诉你如何去写问题定义,而是告诉你如何辨认是否已经写好了问题定义,
Andy Hunt和
Dave Thomas
以及它能否成为构建活动的良好基础。
代码大全(第2版)

<==========================73end ==============================>
<==========================74start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! --www.shubulo.com!^.com!仅供试看
3.3问题定义的先决条件
37
“问题定义”只定义了“问题是什么”,而不涉及任何可能的解决方案。它
是一个很简单的陈述,可能只有一到两页,并且听起来应该像一个问题。像“我
们跟不上 Gigatron的订单了”这样的句子听起来像是个问题,而且确实是一个很
好的问题定义。而“我们需要优化数据自动采集系统使之跟上 Gigatron的订单
这种句子是糟糕的问题定义。它听起来不像问题,倒像解决方案。
如图3-4所示,问题定义在具体的需求分析工作之前,而需求分析是对所定
义的问题的深入调查。
将来的改进
系统测试
构建
架构
需求
问题定义
图3-4“问题定义”为随后的开发过程打下基础
问题定义应该用客户的语言来书写,而且应该从客户的角度来描述问题。通
常不应该用计算机的专业术语叙述。最好的解决方案未必是一个计算机程序。假
定你需要一份展示年度利润的报表。你已经用电脑制作了季度报表。如果你受困
于程序员的思维方式,那么你会推断:在已经能生成季度报表的系统中添加生成
年度报表的功能应该不难。然后吩咐某个程序员花许多时间去编写并调试一个计
算年度利润的程序。但是如果你没有受限于程序员的思维方式,你会吩咐你的秘
书去制作年度报表。她只需花一分钟时间,用袖珍计算器将四个季度的数据加到
一起,就能完成任务。
这条规则也有例外,那就是需要解决的就是与计算机本身相关的问题:编译
时间太长,或者开发工具bug太多。在这种情况下使用计算机术语或程序员术语
来陈述问题是恰当的。
如图3-5所示,如果没有一个良好的问题定义你努力解决的可能是一个错
误的问题。
代码大全(第2版)

<==========================74end ==============================>
<==========================75start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^ .com!仅供试看^
38
第3章三思而后行:前期准备
☆
图3-5在射击之前,确信你瞄准了正确的目标
“未能定义问题”的处罚是,你浪费了大量时间去解决错误的问题。这是双
KEY POINT重处罚,因为你也没有解决正确的问题。
3.4
Requirements Prerequisite
需求的先决条件
“需求”详细描述软件系统应该做什么,这是达成解决方案的第一步。“需求
活动”也称为“需求开发/requirements development、“需求分析/requirements
analysis、“分析/analysis、“需求定义/requirements definition、“软件需求/software
requirements"、“规格书specification、“功能规格书functional spec、“规格/spec”。
Why Have Official Requirements
为什么要有正式的需求
要求一套明确的需求,这点很重要,理由很多。
明确的需求有助于确保是用户(而不是程序员)驾驭系统的功能。如果需求
明确,那么用户就可以自行评审,并进行核准。否则,程序员就常常会在编程期
间自行决定需求。明确的需求免得你去猜测用户想要的是什么。
明确的需求还有助于避免争论。在开始编程之前,先把系统的范围( scope)
确定下来。如果你和另外一个程序员对于“程序应该做什么”意见不一致,你们
可以查看书面的需求,以解决分歧。
重视需求有助于减少开始编程开发之后的系统变更情况。如果你在编码过程
中发现了一个代码上的错误,你只需要修改几行的代码,然后就能继续工作。但
KEY POINT
是如果你在编码的时候发现了一个需求错误,那你就得改变设计,使之符合更改
后的需求。你可能需要扔掉部分旧的设计,并且因为要与已经写好的代码相适应,
可能导致新的设计,与在项目之初进行同样的设计相比,花费更长的时间。此外,
代码大全(第2版)

<==========================75end ==============================>
<==========================76start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo. con.com!仅供试看
3.4需求的先决条件
39
还需要废弃那些受此次需求变更影响的代码和测试用例,还需要编写新的代码和
测试用例。即便是未受影响的代码也需要重新测试以确保其他地方的改变没有
引入任何新的错误。
如表3-1报告的那样,来自众多组织的数据显示,在大型项目中,如果在架
构阶段检测到需求错误,那么修复它的成本通常是“在需求阶段检测并修复该错
HARD DATA误”的成本的3倍。如果在编码阶段检测到需求错误,修复成本是5至10倍;在
系统测试阶段,成本是10倍;在发布之后,成本陡增为10至100倍(以在需求
分析阶段检测并修复错误的成本为基数)对于小型项目,管理成本较低,那么发
布之后的修复成本倍数更接近5~10,比100得多(Boehm and Turner2004)无
论哪种情况,你都不愿意拿自己的薪水来支付这些成本。
充分详尽地描述(specify)需求,是项目成功的关键,它甚至很可能比有效的构
建技术更重要(见图3-6)。关于如何清楚地描述(specify)需求,已经有了很多优秀
书籍。因此,下面几节不打算讲解如何把“详细描述需求”这件事做好,而打算
讲述如何判断是否已经很好地完成了需求分析,以及如何充分利用已有的需求。
图3-6如果没有好的需求,你可能对问题有总体的把握,但却没有击中问题的特定
方面
The Myth of Stable Requirements
稳定需求的神话
需求像水。如果冻稳定的需求是软件开发的圣杯。一旦需求稳定,项目就能以有序的、可预测
结了,就容易在上
面开展建设。的、平稳的方式,完成从架构到设计到编码到测试等一系列工作。这是软件的天
一无名氏
堂!你能预测开支,而且根本无须担心实现某项特性的开销增大为原先计划的100
倍因为在你完成调试之前,用户根本没有想到这项特性。
5译注:“圣杯”一词通常代表众人追求的最高目标,而它的另外一层含义则暗示渺茫希望。
代码大全(第2版)

<==========================76end ==============================>
<==========================77start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
40
第3章三思而后行:前期准备
“一旦客户接受了一份需求文档,就再也不做更改”是一个美好的愿望然而,
对一个典型的项目来说,在编写代码之前,客户无法可靠地描述他们想要的是什么。
问题并不在于客户是低级生物。就如同你做这个项目的时间越长,对这个项目的理
解也就越深入一样,客户参与项目的时间越长,他们对项目的理解也就越深入。开
发过程能够帮助客户更好地理解自己的需求,这是需求变更的主要来源(Curtis
Krasner, and Iscoe1988 Jones1998; Wiegers2003)计划严格依照需求行事,实际上
就是计划不对客户的要求做出回应。
典型情况下需求会有多少改动?IBM和其他公司的研究发现,平均水平的
项目在开发过程中,需求会有25%的变化Boehm198, Jones1994, Jones2000)
HARD DATA在典型的项目中,需求变更导致的返工占到返工总量的75%到85%(Leffingwell
1997, Wiegers 2003).
也许你会认为 Pontiac Aztek是至今制造的最伟大的汽车6,也许你属于地平协
会(Flat Earth Society),并且每四年要到外星人降落的地点———新墨西哥州的
、 Roswell-朝圣一次。假如你真的是这样,千吧,并坚信项目的需求永不改变。
反过来,如果你不再信仰圣诞老人和牙齿仙女,或者至少不再承认它,那么你就
可以采取一些步骤来使需求变更的负面影响最小化8
Handling Requirements Changes During Construction
在构建期间处理需求变更
在构建期间,要最好地应对需求变更,有以下一些可以采用的方式。
使用本节末尾的需求核对表来评估你的需求的质量如果你的需求不够好,
KEY POINT那么就停止工作,退回去,先把它做好,再继续前进。当然,因为在此期间你会
停止编码,所以感觉似乎进度会落后。不过,假设你正开车从芝加哥到洛杉矶,
突然看到纽约的路牌,那么停下来查看路线图是浪费时间吗?当然不是,如果没
有对准正确的方向,那就要停下来检查一下路线
确保每一个人都知道需求变更的代价客户只要想到一个新功能就会很兴
奋。在兴奋时血液会涌向大脑,人会晕头晕脑,他会把所有你们开过的讨论需求
的会议、签字仪式,以及已经完成的需求文档统统抛诸脑后。最简单的对付这种
新功能中毒症患者的办法是说:“咦,这听起来是一个很不错的主意。不过由于它
6译注:见第24页对 Pontiac Aztek的介绍4
7译注:该协会现在仍坚持地是平的,还说地中央是欧洲,其他的洲散于四边,非洲则有一部分在地
平线处翻了下去。
8译注:美国文化中有一位名叫 Tooth Fairy的仙女(牙齿仙女),专门收集小孩子换牙时掉落的牙齿
9译注:洛杉矶在美国西岸,纽约在东岸,芝加哥在中北部。
代码大全(第2版)

<==========================77end ==============================>
<==========================78start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
3.4需求的先决条件
41
不是需求文档里的内容,我会整理一份修订过的进度表和成本估计表,这样你可
以决定是现在实施,还是过一阵子再说。”“进度”和“成本”这两个字眼比咖啡
和洗冷水澡都要提神,许多“必须要有/must haves”很快会变成“有就最好/ nice to
haves。
假如你的组织对于“先做需求分析”的重要性并不敏感,那你就指出在需求
阶段进行修改,要比之后进行修改的代价低得多。使用本章“关于构建之前要做
前期准备的绝对有力且简明的论据”
建立一套变更控制程序如果你的客户激情不减,那就要考虑建立一个正式
代码变更的细节,的变更控制委员会,评审提交上来的更改方案。客户改变他们的想法,认识到他
请参见第28.2节们需要更多的功能,这不是坏事。问题是他们提出更改方案太频繁了,让你跟不
“配置管理”。
上进度。如果有一套固定的变更控制程序,那么大家都会很愉快你知道自己
只需在特定时候处理变更;而客户知道你打算处理他们的提议。
交叉参考关于
迭代式开发法的
使用能适应变更的开发方法某些开发方法让你“对需求变更做出响应”的
细节,见第5.4节能力最大化.演进原型(evolutionary prototyping)法能让你在投入全部精力建造系统
“迭代”和第29.3之前,先探索系统的需求。演进交付(evolutionary delivery)是一种分阶段交付系统
节“增量集成的
略”。
的方法。你可以建造一小块、从用户获得一点反馈、调整一点设计、做少量改动
再多建造一小块。关键在于缩短开发周期,以便更快地响应用户的要求。
入阅读关于放弃这个项目如果需求特别糟糕,或者极不稳定,而上面的建议没有一条
那些支持灵活的
需求的开发方法能奏效,那就取消这个项目。即使你无法真的取消这个项目,也设想一下取消它
的细节,见Rapid之后会是怎样的情况。在取消它之前想想它有可能会变得多糟糕。假如在某种情
Development
on1下可以放弃这个项目,那么至少也要问问自己,目前的情况和你所设想的那
种情况有多大距离。
交叉参考关于
正式项目与非正
注意项目的商业案例在提到实施这个项目的商业理由的时候,许多需求事
式项目的区别(通项就会从你眼前消失。有些需求作为功能特色来看是不错的想法,但是当你评估
常由项目规模不“增加的商业价值”时就会觉得它是个糟透了的主意。那些记得“考虑自己的决
同所致见第27
章“程序规模对构定所带来的商业影响”的程序员的身价与黄金相当不过我更乐意为此建议获
建的影响”
得现金报酬。
代大全(第2版)

<==========================78end ==============================>
<==========================79start==============================>

该书下载自书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
42
3章三思而后行:前期准备
Checklist: Requirements
cc2e.com/032303核对表:需求
这张需求核对表包含了一系列的问题—问问自己项目的需求工作做得如
何。本书并不会告诉你如何做出好的需求分析,所以列表里面也不会有这样的问
题。在开始构建之前,用这份列表做一次“心智健全”检查,看看你的地基到底
有多坚固用“需求甲氏震级”来衡量。
并不是核对表中所有的问题都适用于你的项目。如果你做的是一个非正式项
目,那么你会发现有些东西根本就不需要考虑你还会发现一些问题你需要考志,
但不需要做出正式的回答。如果你在做一个大型的、正式的项目,你也许就要逐
条考虑了。
针对功能需求
口是否详细定义了系统的全部输入,包括其来源、精度、取值范围、出现频
率等?
口是否详细定义了系统的全部输出,包括目的地、精度、取值范围、出现频
率、格式等?
口是否详细定义了所有输出格式(Web页面、报表,等等)?
口是否详细定义了所有硬件及软件的外部接口?
口是否详细定义了全部外部通信接口,包括握手协议、纠错协议、通信协议
等?
口是否列出了用户想要做的全部事情?
口是否详细定义了每个任务所用的数据,以及每个任务得到的数据?
针对非功能需求(质量需求)
口是否为全部必要的操作,从用户的视角,详细描述了期望响应时间?
口是否详细描述了其他与计时有关的考虑例如处理时间、数据传输率、系
统吞吐量?
是否详细定义了安全级别?
口是否详细定义了可靠性,包括软件失灵的后果、发生故障时需要保护的至
关重要的信息、错误检测与恢复的策略等?
口是否详细定义了机器内存和剩余磁盘空间的最小值?
是否详细定义了系统的可维护性,包括适应特定功能的变更、操作环境的
变更、与其他软件的接口的变更能力?
口是否包含对“成功”的定义?“失败”的定义呢?
代码大全(第2版)

<==========================79end ==============================>
<==========================80start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
3.5架构的先决条件
43
需求的质量
口需求是用用户的语言书写的吗?用户也这么认为吗?
口每条需求都不与其他需求冲突吗?
是否详细定义了相互竞争的特性之间的权衡例如,健壮性与正确性之
间的权衡?
是否避免在需求中规定设计(方案)?
口需求是否在详细程度上保持相当一致的水平?有些需求应该更详细地描
述吗?有些需求应该更粗略地描述吗?
口需求是否足够清晰,即使转交给一个独立的小组去构建,他们也能理解
吗?开发者也这么想吗?
口每个条款都与待解决的问题及其解决方案相关吗?能从每个条款上溯到
它在问题域中对应的根源吗?
口是否每条需求都是可测试的?是否可能进行独立的测试,以检验满不满足
各项需求?
口是否详细描述了所有可能的对需求的改动,包括各项改动的可能性?
需求的完备性
口对于在开始开发之前无法获得的信息,是否详细描述了信息不完全的区
域?
口需求的完备度是否能达到这种程度:如果产品满足所有需求,那么它就是
可接受的?
口你对全部需求都感到很舒服吗?你是否已经去掉了那些不可能实现的需
求那些只是为了安抚客户和老板的东西?
3.5
Architecture Prerequisite
架构的先决条件
交叉参考关于
在各个层次进行
软件架构( software architecture)是软件设计的高层部分,是用于支撑更细节
设计的细节,见
的设计的框架(Buschman et al.1996; Fowler2002; Bass Clements, Kazman2003
第5至9章。 Clements et al.2003)。架构也称为“系统架构/system architecture、“高层设计
high--level design”或“顶层设计top-level- design”通常会用一份独立的文档描述
架构,这份文档称为“架构规格书/architecture specification”或者“顶层设计”
有些人对“架构”和“高层设计”加以区分架构指的是适用于整个系统范围
代大全(第2版)

<==========================80end ==============================>
<==========================81start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
44
第3章三思而后行:前期准备
的设计约束,而高层设计指的是适用于子系统层次或多个类的层次上的设计约束
(但不是整个系统范围的设计)。
由于本书是关于软件构建的,因此本节不会告诉你如何开发一个软件的架构;
它关注的是如何确定一个业已存在的架构的质量。因为架构比需求离构建活动又
近了一步,所以对架构的讨论也会比对需求的讨论更详细一些。
为什么要把架构作为前期准备呢?因为架构的质量决定了系统的“概念完
整性”。后者继而决定了系统的最终质量。一个经过慎重考虑的架构为“从顶层
KEY POINT到底层维护系统的概念完整性”提供了必备的结构和体系,它为程序员提供了
指引—其细节程度与程序员的技能和手边的工作相配。它将工作分为几个部分,
使多个开发者或者多个开发团队可以独立工作。
好的架构使得构建活动变得更容易。糟糕的架构则使构建活动几乎寸步难行。
图3-7显示了糟糕的架构的另一个问题。
图3-7离开了良好的软件架构,你可能瞄准了正确的问题,但却使用了错误的解决
方案也许完全不可能有成功的构建
在构建期间或者更晚的时候进行架构变更,代价也是高昂的。修复软件架构
中的错误所需的时间与修复需求错误所需的时间处于同一数量级即,多于修
HARD DATA复编码错误所需的时间Basili and Perricone984 4, Willis 191998构变更如同需
求变更一样,看起来一个很小的改动,影响也许是非常深远的。无论为了修正错
误还是改进设计而引发架构变更,越早识别出变更越好。
代码大全(第2版)

<==========================81end ==============================>
<==========================82start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
3.5架构的先决条件
45
Typical Architectural Components
架构的典型组成部分
交叉参考关于很多组成部分是优秀的系统架构所共有的。如果你自己构建整个系统,那么
程序的低层设计
的具体情况,见第
在架构工作会与更详细的设计工作有重叠部分。在这种情况下,你至少应该思考
5至9章。架构的每个组成部分。如果你目前从事的系统的架构是别人做的,你应该能够不
费力地找出其中重要的组成部分(无须戴上猎鹿帽、牵着猎犬、手拿放大镜)。在
这两种情况中,你都需要考虑以下的架构组成部分。
Program Organization
程序组织
如果你不能向一
系统架构首先要以概括的形式对有关系统做一个综述。如果没有这种综述,
某件事,那么你要想将成千的局部图片(或十多个单独的类)拼成一幅完整的图画是相当伤脑筋
自己就没有真正的。如果系统是小小的只有12块的智力拼图玩具,你那一岁的小孩也能在眨眼功
理解它
Albert Einstain解决它。不过把12个子系统拼到一起要困难一些,而且如果你不能将它们拼起
(爱因斯坦)来,那么就无法理解你正在开发的那个类对系统有何贡献。
在架构中,你应该能发现对那些曾经考虑过的最终组织结构的替代方案的记
叙,找到之所以选用最终的组织结构,而不用其他替代方案的理由。如果对某个
类在系统中的角色没有一个清晰的构思,那么编写这个类就是一件令人灰心丧气
的工作。描述其他组织结构,才能说明架构最后选定的这种系统组织结构的缘由,
并且表明各个类都是慎重考虑过的。有一份对设计实践的综述发现,“维护设计
的缘由”至少与“维护设计本身”一样重要(Rombach1990)。
交叉参考关
于设计中不同
架构应该定义程序的主要构造块( building blocks)根据程序规模不同,各
大小的构造块,个构造块可能是单个类,也可能是由许多类组成的一个子系统。每个构造块无论
见第5.2节“设是一个类还是一组协同工作的类和子程序,它们共同实现一种高层功能,诸如与
计的层次”
用户交互、显示Web页面、解释命令、封装业务规则、访问数据,等等。每条列
在需求中的功能特性(feature)都至少应该有一个构造块覆盖它。如果两个或多个构
造块声称实现同一项功能,那么它们就应该相互配合而不会冲突。
交叉引用使
每个构造块
应该明确定义各个构造块的责任。每个构造块应该负责某一个区域的事情,
知道其他构造并且对其他构造块负责的区域知道得越少越好。通过使各个构造块对其他构造块
块越少越好”是的了解达到最小,你能将设计的信息局限于各个构造块之内
信息隐藏的关
键成分。见第
5.3节中的“隐
藏秘密(信息康
藏)”。
代大全(第2版)

<==========================82end ==============================>
<==========================83start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubylo..com!仅供试看
46
第3章三思而后行:前期准备
应该明确定义每个构造块的通信规则。对于每个构造块,架构应该描述它能
直接使用哪些构造块,能间接使用哪些构造块,不能使用哪些构造块。
Major Classes
主要的类
交叉引用关架构应该详细定义所用的主要的类。它应该指出每个主要的类的责任,以及
于类设计的细该类如何与其他类交互。它应该包含对类的继承体系、状态转换、对象持久化等
节,请参见第6
童“可以工作的的描述。如果系统足够大,它应该描述如何将这些类组织成一个个子系统。
类”
架构应该记述曾经考虑过的其他类设计方案,并给出选用当前的组织结构的
理由。架构无须详细说明系统中的每一个类。瞄准80/20法则:对那些构成系统
80%的行为的20%的类进行详细说明( Jacobsen, Booch, and Rumbaugh1999
Kruchten 2000)
Data Design
数据设计
叉参考关
架构应该描述所用到的主要文件和数据表的设计它应该描述曾经考虑过的
使用变量的其他方案,并说明做出选择的理由。如果应用程序要维护一个客户ID的列表,而
细节,见第10
至13章。
架构师决定使用顺序访问的列表(sequential-access- list)来表示该I表,那么文档就
应该解释为什么顺序访问的列表比随机访问的列表random-access- list)堆栈、散
列表要好。在构建期间,这些信息让你能洞察架构师的思想。在维护阶段,这种
洞察力是无价之宝。离开它,你就像看一部没有字幕的外语片。
数据通常只应该由一个子系统或一个类直接访问;例外的情况就是透过访
问器类( access class)或访问器子程序(access routine)—以受控且抽象的方
式来访问数据。详细的解释请看第5.3节中的“隐藏秘密(信息隐藏)”
架构应该详细定义所用数据库的高层组织结构和内容。架构应该解释为什么
单个数据库比多个数据库要好(反之亦然),解释为什么不用平坦的文件而要用数
据库,指出与其他访问同一数据的程序的可能交互方式,说明会创建哪些数据视
图(view),等等
Business Rules
业务规则
如果架构依赖于特定的业务规则,那么它就应该详细描述这些规则,并描述
这些规则对系统设计的影响。例如,假定要求系统遵循这样一条业务规则:客户
代码大全(第2版)

<==========================83end ==============================>
<==========================84start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
3.5架构的先决条件
47
信息过时的时间不能超过30秒。在此情况下,架构就应该描述这条规则对架构采
用的“保持客户信息及时更新且同步”的方法的影响。
User Interface Design
用户界面设计
用户界面常常在需求阶段进行详细说明。如果没有,就应该在软件架构中进
行详细说明。架构应该详细定义Web页面格式GUI、命令行接口(command line
interface)等的主要元素。精心设计的用户界面架构决定了最终做出来的是“人见
人爱的程序”还是“没人爱用的程序”。
架构应该模块化,以便在替换为新用户界面时不影响业务规则和程序的输出
部分。例如,架构应该使我们很容易地做到砍掉交互式界面的类,插入一组命
令行的类。这种替换能力常常很有用,尤其因为命令行界面便于单元级别和子系
统级别的软件测试。
cc2e.com393用户界面设计值得用整本书的篇幅来讨论,不过这超出了本书的范围。
Resource Management
资源管理
架构应该描述份管理稀缺资源的计划。稀缺资源包括数据库连接、线程、
句柄(handle)等。在内存受限的应用领域,如驱动程序开发和嵌入式系统中,内存
管理是架构应该认真对待的另一个重要领域。架构应该估算在正常情况和极端情
况下的资源使用量。在简单的情况下,估算数据应该说明:预期的实现环境(运
行环境)有能力提供所需的资源。在更复杂的情况中,也许会要求应用程序更主
动地管理其拥有的资源。如果是这样,那么“资源管理器resource manager应该
和系统的其他部分样进行认真的架构设计。
Security
cc2e.com330安全性
深入阅读关于
软件安全的精彩
架构应该描述实现设计层面和代码层面的安全性的方法。如果先前尚未建立
讨论,见(tin威胁模型(threat model),那么就应该在架构阶段建立威胁模型。在制定编码规范的
Secure Code第时候应该把安全性牢记在心,包括处理缓冲区的方法、处理非受信(untrudted)数据
二版(Howard
and
LeBlanc
(用户输入的数据、 cookies、配置数据(文件)和其他外部接口输入的数据)的
2003,(EEE规、加密、错误消息的细致程度、保护内存中的秘密数据,以及其他事项。
Software 2002
年一月号。
代丹大全(第2版)

<==========================84end ==============================>
<==========================85start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com!^!仅供试看
48
第3章三思而后行:前期准备
Performance
性能
入阅读关于如果需要关注性能,就应该在需求中详细定义性能目标。性能目标可以包括
设计高性能系统资源的使用,这时,性能目标也应该详细定义资源(速度、内存、成本)之间的
的额外信息,见
优先顺序。
Connie Smith的
Performance
Engineering of
架构应该提供估计的数据,并解释为什么架构师相信能达到性能目标。如果
Software Syst-某些部分存在达不到性能目标的风险,那么架构也应该指出来。如果为了满足性
m)(1990能目标,需要在某些部分使用特定的算法或数据类型,架构也应该说清楚。架构
中也可以包括各个类或各个对象的空间和时间预算
Scalability
可伸缩性
可伸缩性是指系统增长以满足未来需求的能力架构应该描述系统如何应对
用户数量、服务器数量、网络节点数量、数据库记录数、数据库记录的长度、交
易量等的增长。如果预计系统不会增长,而且可伸缩性不是问题,那么架构应该
明确地列出这一假设。
Interoperability
互用性
如果预计这个系统会与其他软件或硬件共享数据或资源,架构应该描述如何
完成这一任务。
Internationalization/Localization
国际化/本地化
“国际化”是一项“准备让程序支持多个locales(地域/文化”的技术活动
国际化常常称为“I18n”,因为国际化的英文单词Internationalization”首尾两个
字符“I”和“N”之间一共有18个字母。“本地化 Localization”(称为“Ln”,
理由同上)活动是翻译一个程序,以支持当地特定的语言的工作。
对交互系统,国际化问题值得在架构中关注。大多数交互式系统包含几十上百
条提示、状态显示、帮助信息、错误信息,等等。应该估算这些字符串所用的资源。
如果这是一个在商业中使用的程序,架构应该表现出已经考虑过典型的字符串问题
和字符集问题,包括所用的字符集(ASCII、Dbcs、 EBCDIC、BCS、 Unicode、iso
8859等),所用的字符串类型(C字符串、 Visual Basic字符串等),如何无须更改代码
就能维护这些字符串,如何将这些字符串翻译为另一种语言而又尽量不影响代码和
用户界面。架构可以决定,在需要的时候,是在代码中直接嵌入字符串;还是将这
些字符串封入某个类,并透过类的接口来使用它或者将这些字符串存入资源文件
架构应该说明选用的是哪种方案,并解释其原因。
代码大全(第2版)

<==========================85end ==============================>
<==========================86start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww ! --www.shubu.com!仅供试看
5架构的先决条件
49
Input/Output
输入输出
输入输出(IO)是架构中值得注意的另一个领域。架构应该详细定义读取策略
(reading scheme)是先做(look -ahcad-)后做( look-behind)还是即时做(just-in-time)
而且应该描述在哪一层检测O错误:在字段记录、流,或者文件的层次。
Error Processing
错误处理
错误处理已被证实为现代计算机科学中最棘手的问题之一,你不能武断地处
理它。有人估计程序中高达90%的代码是用来处理异常情况、进行错误处理、或
HARD DATA做簿记housekeeping)工作,意味着只有10%的代码是用来处理常规的情况(Shaw in
Bentley1982)。既然这么多代码致力于处理错误,那么在架构中就应该清楚地说明
种“一致地处理错误”的策略。
错误处理常被视为是“代码约定层次/coding-convention-lev--”的事情一如
果真有人注意它的话。但是因为错误处理牵连到整个系统,因此最好在架构层次
上对待它。下面是些需要考虑的问题。
错误处理是进行纠正还是仅仅进行检测?如果是纠正,程序可以尝试从错误
中恢复过来。如果仅仅是检测,那么程序可以像“没有发生任何事”一样继
续运行,也可以退出。无论哪一种情况,都应该通知用户说检测到一个错误
错误检测是主动的还是被动的?系统可以主动地预测错误例如,通过
检查用户输入的有效性也可以在不能避免错误的时候,被动地响应错
误例如,当用户输入的组合产生了一个数值溢出错误时。前者可以扫清
障碍,后者可以清除混乱。同样,无论采用哪种方案,都与用户界面有影响。
程序如何传播错误?程序一旦检测到错误它可以立刻丢引发该错误的数
据;也可以把这个错误当成一个错误,并进入错误处理状态;或者可以等到
所有处理完成,再通知用户说在某个地方发现了错误。
错误消息的处理有什么约定?如果架构没有详细定义一个一致的处理策略,
那用户界面看起来就像“令人困惑的乱七八糟的抽象拼贴画”,由程序的不
同部分的各种界面拼接而成。要避免这种外观体验,架构应该建立一套有关
错误消息的约定。
如何处理异常(exceptions)?架构应该规定代码何时能够抛出异常,在什么地
方捕获异常,如何记录(log)这些异常,以及如何在文档中描述异常,等等
代码大全(第2版)

<==========================86end ==============================>
<==========================87start==============================>

该书下载自-书部落-分享计算机经典巨著--www. --www.shubulo.com!^^.com!仅供试看
50
第3章三思而后行:前期准备
交叉参考“有害在程序中,在什么层次上处理错误?你可以在发现错误的地方处理,可以将
的参数(bad
parameters)的一
错误传递到专门处理错误的类进行处理,或者沿着函数调用链往上传递错
致处理方法”是错
误。
误处理策略的另一
个方面,应该在架每个类在验证其输入数据的有效性方面需要负何种责任?是每个类负责验
构中加以说明。见
证自己的数据的有效性,还是有一组类负责验证整个系统的数据的有效性?
第8章“防御式编
程”举的例子。
某个层次上的类是否能假设它接收的数据是干净的(clean,即,没有错误)?
你是希望用运行环境中内建的错误处理机制还是想建立自己的一套机制?
事实上,运行环境所拥有的某种特定的错误处理方法,并不一定是符合你的
需求的最佳方法。
Fault Tolerance
容错性
进步阅读(EEE架构还应该详细定义所期望的容错种类容错是增强系统可靠性的一组技术
Software2001年
7月号有一篇介绍
包括检测错误;如果可能的话从错误中恢复;如果不能从错误中恢复,则包容其
容错性的优秀文不利影响。
章。这篇文章除了
介绍写得好,还引举个例子:为了计算某数的平方根,系统的容错策略有以下几种。
用了许多有关这一
主题的关键书籍和系统在检测到错误的时候退回去,再试一次如果第一次的结果是错误的
关键文章。
那么系统可以退回到之前一切正常的时刻,然后从该点继续运行。
系统拥有一套辅助代码,以备在主代码出错的时候使用。在本例中,如果发
现第一次的答案似乎有错,系统就切换到另一个计算平方根的子程序,以取
而代之。
系统使用一种表决算法。它可以有三个计算平方根的类,每一个都使用不同
的计算方法。每个类分别计算平方根,然后系统对结果进行比较。根据系统
内建的容错机制的种类,系统可以以三个结果的均值、中值、或众数作为最
终结果。
系统使用某个不会对系统其余部分产生危害的虚假值(phony value)代替这个
错误的值。
其他容错方法包括,在遇到错误的时候,让系统转入某种“部分运转partial
operation的状态,或者转入某种“功能退化degraded functionality的状态。系
统可以自动关闭或重启。这些例子经过了必要的简化。容错是一个吸引人的复杂
主题可惜,它超出了本书的范围
代码大全(第2版)

<==========================87end ==============================>
<==========================88start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com.com!仅供试看
3.5架构的先决条件
51
Architectural Feasibility
架构的可行性
设计师多半会关注系统的各种能力,例如是否达到性能目标,能够在有限的
资源下运转,实现环境(运行环境)是否有足够的支持。架构应该论证系统的技
术可行性。如果在任何一个方面不可行都会导致项目无法实施,那么架构应该说
明“这些问题是如何经过研究的”通过验证概念的原型(proof-of-concept-
prototype)、研究、或其他手段。必须在全面开展构建之前解决掉这些风险。
Overengineering
过度工程
健壮性(robustness)是指“系统在检测到错误后继续运行”的能力。通常架构
详细描述的系统会比需求详细描述的系统更健壮。理由之是,如果组成系统的
各个部分都只能在最低限度上满足健壮性要求,那么系统整体上是达不到所要求
的健壮程度的。在软件中,链条的强度不是取决于最薄弱的一环,而是等于所有
薄弱环节的乘积。架构应该清楚地指出程序员应该“为了谨慎起见宁可进行过度
工程(overengineering)”,还是应该做出最简单的能工作的东西。
详细定义一种过度工程(裕度工程)的方法尤其重要,因为许多程序员会出
于专业门豪感,对自己编写的类做过度工程通过在架构中明确地设立期望目标,
就能避免出现“某些类异常健壮,而其他类勉强够健壮”的现象。
Buy-vs.-Build Decisions
关于“买”还是“造”的决策
交叉参考第
最激进的构建软件的解决方案是根本不去构建它购买软件,或者免费下
30.3节中的“程载开源的软件。你能买到GUI控件、数据库管理器、图像处理程序、图形与图标
序库”列出了各
种可以买到的组件、 Internet通信组件、安全与加密组件、电子表格工具、文本处理具
软件组件和程个列表几乎无穷无尽。在现代的GU环境中编程的最大好处之一大量功能都
序库。
能自动实现:图形类(graphics class)对话框管理器、键盘与鼠标的事件处理函
数、能自动与任何打印机或显示器打交道的代码等等。
如果架构不采用现货供应的组件,那么就应该说明“自定制的件应该在
哪些方面胜过现成的程序库和组件”。
代大全(第2版)

<==========================88end ==============================>
<==========================89start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
52
第3章三思而后行:前期准备
Reuse Decisions
关于复用的决策
如果开发计划提倡使用业已存在的软件、测试用例、数据格式或其他原料,
架构应该说明:如何对复用的软件进行加工,使之符合其他架构目标如果需
要使之符合的话。
Change Strategy
变更策略
交叉参考关于因为对于程序员和用户来说,构建软件产品都是一个学习过程,所以在开发
有系统地处理变过程中产品很可能会发生变化。这些变更来自不稳定的数据类型和文件格式、功
第28.2节“配置能需求的变更、新的功能特性,等等。这些变更可能是计划增加的新功能,也可
管理”。
能是没有添加到系统的第一个版本中的功能。因此软件架构师面临的一个主要
挑战是,让架构足够灵活,能够适应可能出现的变化。
设计中的bug常常架构应当清楚地描述处理变史的策略。架构应该列出已经考虑过的有可能会有
不易发现;随着演
化的进行,系统不所增强的功能,并说明“最有可能增强的功能同样也是最容易实现的”。如果变史
断增加新的功能特很可能出现在输入输出格式、用户交互的风格、需求的处理等方面,那么架构就应
性和用途,早期的该说明:这些变更已经被预料到了,并且任何单一的变更都只会影响少数几个类。
记,这时设计中的架构应对变更的计划可以很简单,比如在数据文件中放入版本号、保留一些供将来
bug就会现身。使用的字段、或者将文件设计成能够添加新的表格。如果使用了代码生成器,那么
-Femando
J. Corbato
架构应该说明,可预见的变更都不会超出该代码生成器的能力范围
交叉引用关于
延迟提交的完整
架构应该指出“延迟提交/delay commitment”所用的策略比如说,架构
描述,见第5.3节也许规定使用表驱动(abl--driven)技术而不使用硬编码的if语句)。它也许还规
中的“有意识地选定“表”中的数据是保存在外部文件中,而非直接写在程序代码中,这样就能做
择绑定时间”
到在不重新编译的情况下修改程序。
General Architectural Quality
架构的总体质量
交叉引用关于
优秀的架构规格书的特点在于,讨论了系统中的类、讨论了每个类背后的隐
“质量特性相互藏信息、讨论了“采纳或排斥所有可能的设计替代方案”的根本理由。
影响”的更多信
息,见第20.1节
“软件质量的特
架构应该是带有少许特别附加物的精炼且完整的概念体系。曾经最流行的软
性”
件工程书籍《人月神话》的中心论题,说的就是大型系统的本质问题是维持其“概
念完整性”(Brooks1995)。好的架构设计应该与待解决的问题和谐一致。在查看
架构的时候,你应该很愉快,因为它给出的解决方案看上去既自然又容易。而不
应该看起来像是用胶带把架构和待解决的问题硬到一起
10译注:延迟提交是指推迟某些因素的确定时间,做晚绑定,以增强灵活性
代码大全(第2版)

<==========================89end ==============================>
<==========================90start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
3.5架构的先决条件
53
你也许知道在架构的开发过程中的多种变更方式。每一项变更都应该干净地
融入整体概念。架构不应该看起来像是美国国会的政府年度预算案一样,由各议
员为自家选民所争取的地方建设经费拼凑而成。
架构的目标应该清楚地表述。以系统的可更改性(modifiability)为首要目标的
设计,与以性能方面决不妥协为首要目标的设计肯定是不同的即便两个系统
的功能一样。
架构应该描述所有主要决策的动机。谨防“我们向来这么做”这种自认为有
理的说法。有一个这样的故事,Beth想按照她丈夫家祖传的广受好评的炖肉菜谱
来做一锅炖肉。她丈夫 Adbul说,他母亲是这样教他的:先撒上盐和胡椒,然后
去头去尾,最后放到平底锅里盖上盖子炖。Beth就问了:“为什么要去头去尾呢?”
Abdul回答说:“我不知道,我向来这么做。这得问下我母亲。”他打电话给母
亲,母亲说:“我不知道,我向来这么做。这得问一下你祖母。”他母亲打电话问
祖母,祖母回答说:“我不知道你为什么要去头去尾我这么做是因为我的锅太小
了装不下。”
优秀的软件架构很大程度上是与机器和编程语言关的不可否认的是,你
不能忽视构建的环境。无论如何,要尽可能地独立于环境,这样你就能抵抗对系
统进行过度架构(overarchitect)的诱惑,也避免提前去做那些放到构建设计期间能
做得更好的工作。如果程序的用途就是去试验某种特定的机器或者语言,那么这
一条指导原则就不适用了。
架构应该踏在对系统“欠描述/underspecifying和“过度描述overspecifying
之间的那条分界线上。没有哪一部分架构应该得到比实际需要更多的关注,也不
应该过度设计(overdesigned)。设计者不应该将注意力放在某个部件上,而损害其
他部件。架构应该处理所有的需求,同时又不去镀金(不包含不需要的元素)
架构应该明确地指出有风险的区域。它应该解释为什么这些区域是有风险的,
并说明已经采取了哪些步骤以使风险最小化。
架构应该包含多个视角(视图)。房屋的设计图包括正视图、平面图、结构图、
电路布线图及其他视图。软件架构的描述也能从“提供系统的不同视图”中受益,
包括暴露隐藏的错误和不一致的情况,以及帮助程序员完整地理解系统的设计
(Kruchten 1995).
最后,你不应该担忧架构的任何部分。架构不应该包含任何仅仅为了取悦老
板的东西。它不应该包含任何对你而言很难理解的东西。你就是那个实现架构的
人如果你自己都弄不懂,那怎么实现它?
代丹大全(第2版)

<==========================90end ==============================>
<==========================91start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com! ^.com!仅供试看
54
第3章三思而后行:前期准备
Checklist: Architecture
c2.co07核对表:架构
以下是一份问题列表,优秀的架构应该关注这些问题。这张核对表的意图并
非用做一份有关如何做架构的完全指南,而是作为一种实用的评估手段,用来评
估软件食物链到了程序员这头还有多少营养成分。这张核对表可用做你自己的
核对表的出发点。就像“需求”的核对表一样,如果你从事的是非止式项目,那
么你会发现其中某些条款甚至都不用去想如果你从事的是更大型的项目,那么
大多数条款都会是很有用的。
针对各架构主题
口程序的整体组织结构是否清晰?是否包含一个良好的架构全观(及其理
由)?
口是否明确定义了主要的构造块(包括每个构造块的职责范围及与其他构造
块的接口)?
口是否明显涵盖了“需求”中列出的所有功能(每个功能对应的构造块不太
多也不太少)?
口是否描述并论证了那些最关键的类?
口是否描述并论证了数据设计?
口是否详细定义了数据库的组织结构和内容?
口是否指出了所用关键的业务规则,并描述其对系统的影响?
口是否描述了用户界面设计的策略?
口是否将用户界面模块化,使界面的变更不会影响程序其余部分?
口是否描述并论证了处理1O的策略?
口是否估算了稀缺资源(如线程、数据库连接、句柄、网络带宽等)的使用
量,是否描述并论证了资源管理的策略?
是否描述了架构的安全需求?
口架构是否为每个类、每个子系统、或每个功能域( functionality area)提出空间
与时间预算?
口架构是否描述了如何达到可伸缩性?
口架构是否关注互操作性?
口是否描述了国际化/本地化的策略?
口是否提供了一套内聚的错误处理策略?
口是否规定了容错的办法(如果需要)?
代码大全(第2版)

<==========================91end ==============================>
<==========================92start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul ^.com!仅供试看
3.6花费在前期准备上的时间长度
55
口是否证实了系统各个部分的技术可行性?
口是否详细描述了过度工程(overengineering)的方法?
口是否包含了必要的“买vs.造”的决策?
口架构是否描述了如何加工被复用的代码,使之符合其他架构目标?
口是否将架构设计得能够适应很可能出现的变更?
架构的总体质量
口架构是否解决了全部需求?
口有没有哪个部分是“过度架构/overarchitected”或“欠架构/underarchitected?
是否明确宣布了在这方面的预期指标?
整个架构是否在概念上协调一致?
口顶层设计是否独立于用作实现它的机器和语言?
口是否说明了所有主要的决策的动机?
口你,作为一名实现该系统的程序员,是否对这个架构感觉良好?
3.6
Amount of Time to Spend on Upstream Prerequisites
花费在前期准备上的时间长度
交叉参考花
花费在问题定义、需求分析、软件架构上的时间,依据项目的需要而变化。
的时间取决于般说米,一个运作良好的项目会在需求、架构以及其他前期计划方面投入
项目的规模关10%~20%的工作量和20%~30%的时间(McConnel1998, Kruchten2000)。这些数
于“让前期准备
适合你的特定字不包括详细设计的时间一—那是构建活动的一部分。
项目”的具体办
法,参见本章前
面第3.2节“辨
如果需求不稳定,同时你从事的是一个大型的正式项目,那你就很可能需要
明你所从事的与需求分析帅合作,以解决构建活动早期指出的需求问题。你要为“与需求分析
软件的类型”。
师协商”预留一些时间,还应预留时间给需求分析师修订需求,这样你才能得到
一份可行的需求。
如果需求不稳定,同时你从事的是一个小型的非正式的项目,那你很可能需
要自己解决需求方面的问题。要预留足够的时间,将需求定义足够清晰,让需求
的不稳定性对构建活动的负面影响降至最低。
代丹大全(第2版)

<==========================92end ==============================>
<==========================93start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! --www.shubulo.com!仅供试看
56
第3章三思而后行:前期准备
交叉参考关如果需求在任何项目上都不稳定无论正式项目或非正式项目—那就将需
于处理需求变求分析工作视为独立的项目来做。在完成需求之后,估计项目余下的部分要花多少时
更的方法,见本
章前面第3.4节间。这是明智的办法,因为在弄清楚要做的是什么之前,没人相信你能估算出合理的
中的“在构建期进度表。这就好比你是一名承包商有人请你建栋房子。客户问你:“完成这项工
间处理需求变
更”
作要花多少钱?”你会合理地询问:“你想要我做什么?”客户说:“我不能告诉你,
不过我想知道需要花费多少钱?”你该明智地感谢他浪费了你的时间,然后转身回家。
对于建筑物而言,如果客户在告诉你要造什么样的建筑之前要求你给出报价,
这很明显是毫无道理的。而你的客户也不会希望在建筑师完成蓝图之前,你就摆出
木料、榔头和钉子开始忙活,并开始花费他们的金钱然而,人们对于软件开发的
解,往往不如对于建筑用的木条或石膏板的理解;因此你的客户可能无法立刻理
解,为什么你打算将需求分析立为单独的项目。你可能需要向他们解释你的理由。
在为软件架构分配时间的时候,要使用与需求分析类似的方法。如果软件是你以
前没有做过的类型,应当为“在新的领域中做设计”的不确定性预留更多时间。你要
确保创建良好架构所需要的时间,不会被“为做好其他方面工作所需要的时间”所挤
占。如果有必要,将架构工作也作为独立的项目来对待。
Additional Resources
更多资源
c2.com/04以下是关于“需求”方面的更多资源。
Requirements
cce.com/0351需求
以下是几本深入讨论需求分析的书籍。
Wiegers, Karl. Software Requirements), 2d ed. Redmond, WA: Microsoft Press,
2003.这是一本实用的、面向从业者的书籍,它描述了“需求”活动的具体细节,
包括需求启发(requirements elicitation)需求分析(requirements analysis)、需求规格
requirements specification)需求验证(requirements validation)需求管理(requirements
Robertson, Suzanne and James Robertson. KMastering the Requirements Process).
Reading MA: Addison-Wesley-,1999.这是一本面向更高阶的“需求”从业人员的书
是 Wiegers书的很好替代品2。
gilb,tom. Competitive Engineering》. Reading,: Addison-Wesley-,2004.这本
书描述了Gilb的“需求”语言,称为“Planguage”。这本书涵盖了gilb做下面这些事
cc2.com035的特有方法:需求工程( cc2e.com/0358  (requirements engineering))设计和设计演化、渐进式项目管理
(evolutionary project management).
这本书可以从Gilb的网站下载(www.gilb.com)
1译注:中译本《软件需求(第2版)》,清华大学出版社。
12译注:中译本《掌握需求过程》
人民邮电出版社。
代码大全(第2版)

<==========================93end ==============================>
<==========================94start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shul ^.com!仅供试看
更多资源
57
IEEE Std 830-1998. <IEEE Recommended Practice for Software Requirements
Specifications. Los Alamitos,ca: IEEE Computer Society Press.这份文档是编写软件
需求规格书的IEEE-ANSI指南。它描述了需求规格书应该包含哪些东西。
Abra, Alain, et al. KSwebok: Guide to the Sofrware Engineering Body of Knowledge)
Los Alamitos, CA IEEE Computer Society Pres,2001.这本书详细描述了软件需求的
cc2e.com0365主要知识它也可以从www. cc2e.com/365www.swebok.org..org下载
其他不错的可供选择的还有如下书籍。
Lauesen, Soren. (Software Requirements: Styles and Techniques). Boston, MA:
Addison-Wesley, 2002.13
Kovitz, Benjamin L. Practical Software Requirements: A Marual of Content and Style).
Manning Publications Company,1998.14
Cockbum, Alistair. Writing Efective Use Cases ) Boston, MA: Addison-Wesley, 2000.5
Software Architecture
cc2e.cm/0372软件架构
过去几年里出版了很多关于软件架构的书。以下是其中最好的几本
Bass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice)), 2d
ed. Boston, MA: Addison-Wesley, 2003. 16
Buschman, Frank, et al. (Pattern-Oriented Software Architecture, Volume 1: System
of Patterns). New York, NY: John Wiley Sons, 1996. 17
Clements, Paul, ed. Documenting Software Architectures: Views and Beyond). Boston,
MA: Addison-Wesley, 2003.
18
Clements, Paul, Rick Kazman, and Mark Klein. KEvaluating Software Architectures.
Methods and Case Studies). Boston, MA: Addison-Wesley, 2002.19
Fowler, Martin. Patterns of Enterprise Application Architecture ) Boston, MA:
Addison-Wesley, 2002.20
Jacobson, Ivar, Grady Booch, and James Rumbaugh. The Unified Software Development
Process). Reading, MA: Addison-Wesley, 199921
IEEE Std 1471-2000. Recommended Practice for Architectural Description of
Sofiware-Intensive Systems Los Alamitos, CA IEEE Computer Society Press.这份文档是编
写软件需求规格书的IEEE-ANSI指南。
13译注:中译本《软件需求》,电子工业出版社。
1译注:中译本《实用软件需求》,机械工业出版社
15译注:影印版《编写有效用例(英文版)》,中译本《编写有效用例》,机械工业出版社。
16译注:影印版《软件构架实践(彩印版第2版)》中译本《软件构架实践》清华大学出版社
1译注:中译本《面向模式的软件体系结构卷1:模式系统》,机械工业出版社。
18译注:影印版《软件构架编档(影印版)》,中译本《软件构架编档》,清华大学出版社
19译注:影印版《软件构架评估(英文影印版)中译本《软件构架评估》,清华大学出版社
20译注:影印版《企业应用架构模式(影印版)》,中国电力出版社;中译本《企业应用架构模式》,机
械工业出版社。
21译注:影印版《统一软件开发过程(英文影印版》,清华大学出版社;中译本《统一软件开发过程》
机械工业出版社。
代码大全(第2版)

<==========================94end ==============================>
<==========================95start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^.com!仅供试看^
58
第3章三思而后行:前期准备
General Software-Development Approaches
cc2.com/0379常规的软件开发方法
有很多书制订了各种不同的指导软件项目开发的方法。有一些偏重序列式开
发,另一些则更偏重迭代式开发。
McConnell, Steve. Software Project Survival Guide). Redmond, WA: Microsoft Press,
1998.这本书展示了一种指导项目开发的特定方。该方法强调深思熟虑的预先计划、
需求开发、架构设计工作,然后仔细地完成项目。该方法达到“对成本和开发进度进
行长期预测”、高质量,以及适度的灵活性。
Kruchten, Philippe. The Rational Unified Process An Introduction), 2d ed. Reading.
ma: Addison-Wesley-,2000.这本书展示了一种“以架构为中心,以用例驱动”的项目
开发方法。与《 Software Project Survival Guide》类似,它注重前期工作提供对
成本和进度的长期可预见性、高质量,以及适度的灵活性。这本书描述的方法,与
Software Project Survival GuideExtreme》和《 Programming Explained: Embrace
Change》中描述的方法相比,需要更多的专门操作技能。22
Jacobson, Ivar, Grady Booch, and James Rumbaugh. The Unified Software
Development Process. Reading,ma: Addison-Wesley-,1999这本书更加深入地探讨
了《Rational Unified Process: An Introduction(2ded)一书所覆盖的主题。23
Beck, Kent. (Extreme Programming Explained: Embrace Change>. Reading, MA:
Addison-Wesley-,2000.Beck描述了一种高度迭代的开发法,注重迭代地开发需求
和设计,同时结合构建。极限编程法几乎不提供长期的可预见性,但它提供了高
度的灵活性。24
Gilb, Tom, Principles of Software Engineering Management. Wokingham,
England: Addison-Wesley-,1988.gilb的方法讲究在项目早期探究关键的计划、需
求、架构问题,然后随着项目进展,持续地改变项目计划,使之不断地适应新的
情况。该方法融合了长期可预见性、高质量和高度灵活性。与《 Software Project
Survival Guide》和《 Extreme Programming Explaine: Embrace Change》中描述的方法
相比,该方法需要更多的专门操作技能。
McConnell, Steve. KRapid Development). Redmond, WA: Microsoft Press, 1996.
这本书展示了一种进行项目计划的工具箱式(toolbox)方法一个有经验的项目计
划人员能够使用书中展现的工具,来创作一份高度适应特定项目的独特需求的项
目计划。25
Bochm, Barry and Richard Tumer. (Balancing Agility and Discipline: A Guide for
the Perplexed Boston, MA Addison--wse,200这本书探索了敏捷开发和计划
22译注:影印版Rational统一过程引论(第二版影印版》,中国电力出版社;中译本《RUP导论(原
书第3版)》《 KRational统一过程引论(原书第2版)》,机械工业出版社
23译注:影印版《统一软件开发过程(英文影印版),清华大学出版社;中译本《统一软件开发过程》,
机械工业出版社
24译注:影印版《解析极限编程:拥抱变化(影印版》中国电力出版社;中译本《解析极限编
程拥抱变化》人民邮电出版社
25译注:影印版《快速软件开发(英文版)》,机械工业出版社;中译本《快速软件开发有效控制
与完成进度计划》,电子工业出版社。
代码大全(第2版)

<==========================95end ==============================>
<==========================96start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
要点
59
驱动(plan--driven)的开发在风格上的对比。第3章有4个特别有启发性的小节:“A
Typical Day using PSP/TSP","A Typical Day using Extreme Programming""A Crisis
Day using PSPTSP" Crisis Day using Extreme Programming第5章讲述利用
风险来平衡敏捷程度(agility),为“选择敏捷方法还是计划驱动的方法”提供了一
针见血的指导。第6章“Conclusions”也相当平衡,并具备深邃的洞察力。附录E
是敏捷实践的经验数据的一座金矿。26
Larman, Craig. KAgile and Iterative Development: A Manager's Guide). Boston,
MA: Addison Wesley,2004.这本书介绍了多种灵活的、渐进的开发风格。它评述
了 Scrum、 Extreme Programming、 Unified Process、Evo等开发方法。
Checklist: Upstream Prerequisites
cc2e.com0386:03核对表:前期准备
口你是否辨明了自己所从事的软件的类型,并对所用的开发方法做出相应的
剪裁?
口是否充分明确地定义了需求?而且需求足够稳定,能开始构建了?(详见
需求核对表。)
口是否充分明确地定义了架构,以便开始构建(详见架构核对表。)
口是否已经指出你的(当前)项目中独有的风险(以避免构建活动面临不必
要的风险)?
Key Points
要点
构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降
低风险,而非增加风险。
如果你想开发高质量的软件,软件开发过程必须由始至终关注质量。在项目
初期关注质量,对产品质量的正面影响比在项目末期关注质量的影响要大。
程序员的一部分工作是教育老板和合作者,告诉他们软件开发过程,包括在
开始编程之前进行充分准备的重要性。
你所从事的软件项目的类型对构建活动的前期准备有重大影响许多项
目应该是高度迭代式的,某些应该是序列式的。
如果没有明确的问题定义,那么你可能会在构建期间解决错误的问题。
26译注:影印版《平衡敏捷和纪律》,中国电力出版社;中译本《平衡敏捷与规范》,清华大学出版社
27译注:中译本《敏捷选代开发:管理者指南》,中国电力出版社。
代大全(第2版)

<==========================96end ==============================>
<==========================97start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^ ^.com!仅供试看
60
第3章三思而后行:前期准备
如果没有做完良好的需求分析工作,你可能没能察觉待解决的问题的重要细节。
如果需求变更发生在构建之后的阶段,其代价是“在项目早期更改需求”的20
至100倍。因此在开始编程之前,你要确认“需求”已经到位了。
如果没有做完良好的架构设计,你可能会在构建期间用错误的方法解决正确的
问题。架构变更的代价随着“为错误的架构编写的代码数量”增加而增加,因
此,也要确认“架构”已经到位。
理解项目的前期准备所采用的方法,并相应地选择构建方法。
代码大全(第2版)

<==========================97end ==============================>
<==========================98start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor!.com!仅供试看^
Key Construction Decisions
第4章
关键的“构建”决策
cc2e.com/0489/0489内容
4.1选择编程语言:第61页
4.2编程约定:第66页
4.3你在技术浪潮中的位置:第66页
4.4选择主要的构建实践方法:第69页
相关章节
前期准备:第3章
辨明你所从事的软件的类型:第3.2节
■程序规模对构建的影响:第27章
管理构建:第28章
软件设计:第5章、第6章至第9章
一旦你能确定“构建”的基础已经打好,那么准备工作就转变为针对特定“构
建”的决策了。第3章“三思而后行:前期准备”讨论了设计蓝图和建筑许可证
在软件业里的等价物。你可能对那些准备工作没有多少发言权,所以第3章关注
的焦点是确定“当构建开始后你需要做什么本章关注的焦点是程序员和技术带
头人个人必须(直接或间接)负责的准备工作在向工地进发之前,如何选择适
用的工具别在你的腰带上,你的手推车里该装哪些东西?本章讨论的就是这些事
务在软件中的等价物。
如果你觉得在“有关‘构建’的准备工作”方面已经读得很多了,那么就可
以跳到第5章“软件构建中的设计”
Choice of Programming Language
选择编程语言
一套好的符号系统能把大脑从所有非必要的工作中解脱出来,集中精力
去对付更高级的问题,从功效上看,能够有效地提高人类的智力。在引入阿
拉伯数字之前计算乘法是困难的,除法(即便只是整数除法)更需要发挥全
代码大全(第2版)

<==========================98end ==============================>
<==========================99start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看
62
第4章关键的“构建”决策
部的数学才能。在当代社会中,最让一位希腊数学家感到吃惊的或许是下面
的事实:绝大部分西欧人都能完成大整数的除法。在他看来这几乎是完全不
可能的……我们现在具有轻易进行小数计算的能力,这完全是逐步发现了完
美的表示法的令人惊叹的结果。
怀德海1
用来实现系统的编程语言与你的切身利益密切相关,因为从“构建”的开始
到结束你都要“沉浸”在这种语言中
研究表明,编程语言的选择从多个方面影响生产率和代码质量。
程序员使用熟悉的语言时,生产率比使用不熟悉的语言时要高 Cocomo估
计模型的数据表明,当程序员用“使用了三年以上的语言”编写代码时,生产率
比“同等经验但使用新语言的程序员”高30%(Boehm et al.2000)更早在IBM进
行的一项研究发现,对编程语言有相当丰富经验的程序员的生产率比几乎没有经
验的程序员高3倍(Walston and Felix1977)(CocomoⅡ更加仔细地分离了各个
作用因素的独立效果,这就解释了这两项研究结果的不同。)
使用高级语言的程序员能比使用较低级的语言的程序员达到更好的生产率和
质量。人们相信,高级语言(high--level language)如C++、java、 Smalltalk、Visual
Basic等比低级语言(low--level language,如汇编和C语言)在生产率、可靠性、
简洁性、易理解性等方面高5至15倍(Brooks 1987, Jones1998, Boehm2000)你
没必要每当“一条C语句实现了它应有的功能”就举行颁奖典礼,因此能节约不
少时间。另外,高级语言比低级语言的表达力更强。每行代码能表达更多的含义。
表4-1列出了几种高级语言的每一行源代码与等效的C语言代码行数之比(的典
型值)。更高比率表示该语言的一行代码比一行语言代码能完成更多的工作。
表4-1高级语言的语句与等效的C代码语句行数之比
语言
相对于C语言的等级
C
C++
1222666
2.5
Fortran 95
Java
2.5
Perl
Pyth
Python
Smalltalk
Microsoft Visual Basic
4.5
来源:改编自《Estimating Software Costs》(Jones998)、《Software Cost Estimation with
Cocomo In) (Boehm 2000) "An Empirical Comparison of Seven Programming Languages
(对7种编程语言的实验比较)”(Prechelt2 2000)
1译注:A. Whitehead(1861-1947),英国数学家、哲学家,与罗素合著有《数学原理》一书。
代码大全(第2版)

<==========================99end ==============================>