<==========================600start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com!仅供试看^
Refactoring
第24章
重构
ccec/2436内容
24.1软件演化的类型:第564页
24.2重构简介:第565页
24.3特定的重构:第571页
24.4安全的重构:第579页
24.5重构策略:第582页
相关章节
修正缺陷的技巧:第23.3节
代码调整方法:第25.6节
软件构建中的设计:第5章
可以工作的类:第6章
高质量的子程序:第7章
协同构建:第21章
开发者测试:第22章
很可能变化的区域:第5.3节中的“找出容易改变的区域”
所有成功的软件
神话:一个管理很完善的软件项目,应该首先以系统化的方法进行需求开发,
都经历过改变。定义一份严谨的列表来描述程序的功能。设计完全遵循需求,并且完成得相当仔
-Fred Brooks
细,这样就让程序员的代码编写工作能够从头至尾直线型地工作。这也表明绝大
多数代码首次编写后就已完美,测试通过即可被抛到脑后。如果这样的神话是真
的,那么代码被修改的唯一时机就是在软件维护阶段,而这一阶段只会在系统的
最初版本交付用户之后。
现实情况:在初始开发阶段,代码会有实质性的进化。在初始的代码编写过
程中,就会出现很多剧烈的改变,如同在代码维护阶段可以看到的那样。根据项
目的规模不同,典型的项目花在编码、调试和单元测试上的时间会占到整个项目
的30%到65%不等(请阅第27章“程序规模对构建的影响”)。如果代码编写和
单元测试能够一帆风顺,这两个阶段所占整个项目时间的比例不会超过20%到30%即
使是管理完善的项目,每个月都有大约1/4的需求发生变化(Jones2000)需求的变
化将不可避免地导致相关代码的改变——有时是实质性的代码改变。
代码大全(第2版)

<==========================600end ==============================>
<==========================601start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. --www.shubulo.co.com!仅供试看^
564
第24章重构
另一个事实:现在的开发方法增强了代码在构造阶段中改变的潜力。在旧式的软
件生命周期中,项目成功与否的关键在于能否避免代码的改变。越来越多的现代开发
KEY POINT方法已经放弃了对代码的前瞻性如今的开发方法更多地以代码为中心在整个项目
生命周期中代码都会不断地演化。你可以期望代码的演化比以往任何时候更频繁。
24.1
Kinds of Software Evolution
软件演化的类型
软件演化就像生物进化一样,有些突变对物种是有益的,另外一些则是有害
的。良性的软件演化使代码得到了发展,就如猴子进化到穴居人冉进化到我们这
样身份高贵的软件工程师。然而,有时演化的力量也会以另一种方式打击你的程
序,甚全将它送入不断退化的螺旋形轨道。
区分软件演化类型的关键,就是程序的质量在这一过程中是提高了还是降低
了。如果采用逻辑除尘带或是迷信式的方法修正错误,程序质量就会降低。而如
果将修改看做是对程序原始设计的升华程序质量则会提高。如果发现程序质量
OINT
正在降低,如同我之前提到过的煤矿坑道中停止歌唱的金丝雀,你就应该意识到,
这是程序朝着错误方向演化的警告。
区分软件演化类型的第二个标准,就是这样的演化是源于程序构建过程中的
修改,还是维护过程中的修改。这两种演化在很多方面都有所不同。构建中的修
改通常是由最初的开发人员完成,在这一阶段程序还没有被人们彻底遗忘。这时
系统也未上线待售,因此,完成修正压力仅仅来自于时间表绝不会有500个
愤怒的用户质问你为什么他们的系统会崩溃。出于同样的原因,构建期间的修改
常常是随心所欲之作—系统处于高度动态阶段,出现错误的代价较小。这样的
环境孕育着与维护期不同的软件演化风格。
Philosophy of Software Evolution
软件演化的哲学
再庞大复杂的代
码都可以通过重
程序员在参与到软件演化时有一个普遍的弱点这就是将其作为一种并非有
构加以改善
意而为的过程。如果你能在开发过程中认识到软件演化是无法避免且具有重要意
-Gerald Weinberg义的现象,并对其细加谋划,就可能使这一过程有益于你的开发。
演化一开始就充满危险,但同时也是使你的软件开发接近完美的天赐良机。
当你迫不得已需要对代码进行改变时,就努力对代码进行改进,这样未来在开发
中调整就会更容易。在刚开始编写程序时,你绝对不会对程序有深入的理解。
旦有机会重新审视你的程序,就要用自己的全部所学去改进它。要考虑你原来的
代码和现在的改变在将来可能如何变化。
代码大全(第2版)

<==========================601end ==============================>
<==========================602start==============================>

该书下载自-书部落-分享计算机经典巨著--www ! --www.shubu.com!仅供试看^
24.2重构简介
565
软件演化的基本准则就是,演化应当提升程序的内在质量下面几节将讲述
yp如何实现这一目标
24.2
Introduction to Refactoring
重构简介
要实现软件演化基本准则,最关键的策略就是重构, Martin Fowler将其定义
为“在不改变软件外部行为的前提下,对其内部结构进行改变,使之更容易理解
并便于修改”(Fowler1999)。在现代编程理论中,“重构(refactoring)”一词源
自 Larry Constantine在结构化程序设计中首次使用的“factoring”当时指尽可能
地将一个程序分解为多个组成部分。
Reasons to Refactor
重构的理由
有时,代码在维护过程中质量会降低,而有时代码在最初诞生的时候就先
不良。无论是哪种情况,都会有一些警告信号,这些信号有时称为“臭味( smells)”
(Fowler1999)这些信号标志着程序需要重构
代码重复重复的代码几乎总是代表着对最初设计里彻底分解方面的一个失
误。无论何时,如果需要对某个地方进行修改你都不得不在另一个地方完成同
样的修改重复代码总会将你置于一种两线作战的尴尬境地。重复的代码同样
违背了 Andrew Hunt和 Dave Thomas所提出的DRY原则”:不要重复自己Don't
Repeat Yourself(Hunt and Thomas2000)我想还是 David Parnas说得最为精
辟:“复制粘贴即设计之谬。”(McConnell1998b)
冗长的子程序在面向对象的编程中,很少会需要用到长度超过一个屏幕的
子程序。这样的子程序通常暗示程序员是在把一个结构化程序的脚进一只面向
对象的鞋子里。
我的一位客户曾接手一个任务,分解某个旧系统中最长的子程序,这个子程序超
过了12000行。费了九牛二虎之力,他总算把这个最长的子程序缩减到了400行。
改善系统的方法之一就是提升其模块性——增加定义完善、命名准确的子程
序,让它们各自集中力量做好一件事情。如果对代码的修改需要重新检查某段代
码,就该利用这个机会看看这段代码是否已经模块化了。如果把子程序的一部分
提出来作为另一个独立的手程序,能让这一部分代码更为清晰,那么就创建个
独立的子程序。
循环过长或嵌套过深循环内部的复杂代码常常具备转换为子程序的潜质,
这样的改动将有助于对代码的分解,并减少循环的复杂性。
代码大全(第2版

<==========================602end ==============================>
<==========================603start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
566
第24章重构
内聚性太差的类如果看到有某个类大包大揽了许多彼此无关的任务,那么
这个类就该被拆分成多个类,每个类负责一组具有内在的相互关联的任务。
类的接口未能提供层次一致的抽象即使是那些从诞生之日起就具有内聚接
口的类也可能渐渐失去最初的一致性。为了维护接口的完整性,程序员常常会在
一怒之下对类动手,这样的草率修改会使得类随着时间的推移不断地发生变化。
最终,类的接口会变成维护的法兰肯斯坦(Frankensteinian,寓人造怪物)恶魔,
对程序的可管理性毫无裨益。
拥有太多参数的参数列表如果一个程序被分解得很好,那么它的子程序应
当小巧、定义精确,且不需要庞大的参数列表。长长的参数列表是在警告程序员
的子程序接口抽象未经斟酌。
类的内部修改往往被局限于某个部分有时一个类会有这两种或更多独立的
功能。如果你发现自己要么修改类里的这部分要么修改另一部分,但极少的
修改会同时影响类中的两个部分,这就表明该类应该根据相互独立的功能被拆分
为多个类。
变化导致对多个类的相同修改我曾经遇到过一个项目,只要在程序中加入
一种新的输出类型,检查表上就会有15个类需要修改。如果发现自己常常对同一
组类进行修改,这表明这些类中的代码应当被重新组织,使修改仅影响到其中的
一个类。根据我的经验,这往往是一个难于实现的理想,但仍不失为你努力的目
标。
对继承体系的同样修改每次为某个类添加派生类时,都会发现自己不得不
对另一个类做同样的操作。这就是一种特殊的相同修改,应该避免这种情况。
case语句需要做相同的修改尽管使用cae语句本身不是坏事,但如果不得
不在程序的多个部分里对类似的一组case语句做出相同的修改,那么就应当问问
自己,使用继承是否更明智的选择。
同时使用的相关数据并未以类的方式进行组织如果看到自己常常对同样一
组数据进行操作,你也应当问问自己是否该将这些数据及其操作组织到一个类
面。
成员函数使用其他类的特征比使用自身类的特征还要多这一状况暗示着这
子程序应该被放到另一个类中,然后在原来的类里调用。
代码大全(第2版)

<==========================603end ==============================>
<==========================604start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
24.2重构简介
567
过多使用基本数据类型基本数据类型可用于表示真实世界中实体的任意数
量。如果程序中使用了整型这样的基本数据类型表示某种常见的实体,如货币,
请考虑创建一个简单的 Money类,这样编译器就可以对 Money变量执行类型检查,
你也可以对赋给 Money的值添加安全检查等功能。如果 Money和 Temperature
都是整型,那么编译器就不会在你错误地使用 bankBalance=
recordLowTemperature这样的赋值语句时提出警告。
某个类无所事事有时,代码的重构会导致某个已有的类无事可做。如果一
个类看起来名不符实,那么问问自己能否将该类的功能转交给其他的类,然后将
这个类彻底去掉。
一系列传递流浪数据的子程序看看自己的代码把数据传递给某个子程序,
是否仅仅就为了让该子程序把数据转交给另一个子程序。这样传来传去的数据被
称为“流浪数据/tramp data”(Page- Jones1988)这样做也不是不行,但要问问自
己,如此传递特定数据,是否与每个子程序接口所表示的抽象概念一致。如果这
些子程序接口的抽象概念相同,那么在它们之间传递数据并无不妥。如果不是这
样,那么就想些其他的办法让各子程序的接口更加一致。
中间人对象无事可做如果看到某个类中的绝大部分代码只是去调用其他类
中的成员函数,请考虑是否应该把这样的中间人(middleman)去掉,转而直接调
用其他的类。
某个类同其他类关系过于亲密如果需要使程序具备更强的可管理性,并最
大限度地减少更改代码对周围的连带影响,那么封装(信息隐藏)可能是最强有
力的工具了。只要发现某个类对另一个类的了解超过了应该的程度包括派生
类了解了基类中过多的东西,那么宁可让代码因较强的封装而出错,也不要减弱
封装。
子程序命名不恰当如果一个子程序的名字取得不好,请改变其定义的名字,
并对所有调用该子程序的地方做相应的修改,然后重新编译。现在做这件事情或
许有点麻烦,但如果拖到以后来做会更让你心烦。因此只要看到某个子程序名有
问题,就应该立刻着手修改。
数据成员被设置为公用在我眼中,把数据成员设置为公用(public)绝对是一
个糟糕的主意。这样会模糊接口和实现之间的界限,其本身也违背了封装的原则,
限制了类在未来可以发挥的灵活性。因此,请认真考虑把 public数据成员藏在访问
器子程序背后。
某个派生类仅使用了基类的很少一部分成员函数通常,这样的情况表明,
这一派生类的创建仅仅是由于基类碰巧有了该类所需要的子程序,而不是出于逻
辑上的派生关系。因此应当考虑进行更完善的封装:把派生类相对于基类的关系
代大全(第2版

<==========================604end ==============================>
<==========================605start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
568
第24章重构
从“is-a”转变为“has-a”。即把基类转换成原来的派生类的数据成员,然后仅仅
为原来的派生类提供所需要的成员函数。
注释被用于解释难懂的代码注释在程序中扮演了重要的角色,但它不应当被
用来为拙劣代码的存在而辩护。有箴言为证:“不要为拙劣的代码编写文档应
当重写代码”(Kernighan and Plauger1978)
交叉参考第使用了全局变量当你再度遇到某段使用了全局变量的代码时,请花点时间
据”中给出了全来重新检查一下这些代码。或许自从上次看到这段代码之后,你已经想到过一种
局变量的使用指方法来避免使用全局变量。但问题在于与最初编写代码的时候相比,现在你对这
南;第5.3节解些代码已经感到有些陌生了,因此你会发现全局变量把你的思维搅乱了,你更愿
类数据的差别。意找一种清晰的方法。你应该知道如何将全局变量隔离出来,通过访问器子程序
来调用这些数据,你更清楚如果不这样做以后会遇到多大的麻烦。因此,请咬
紧牙关坚持一下,完成这些对整个程序有益的修改。与最初编码阶段间隔的时间
应足够长,以便你能用更客观的眼光审视它们;另一方面,也要保证你能回忆起
所需的大部分东西,保证修改能正确进行。因此,早期修订阶段是提升代码质量
的最佳时机。
在子程序调用前使用了设置代码( setup code)或在调用后使用了收尾代码
(takedown code)这样的代码应当看作是一种警告:
C++示例:子程序调用前后的设置代码和收尾代码糟糕的做法
这种“设置"代ithdrawalTransaction withdrawal
码是一种警告 withdrawal. SetCustomerId( customerId);
witharawal. Set Balance( balance)i
withdrawal. SetWithdrawalAmount( withdrawalAmount
Lwithdrawal. SetWithdrawalDate( withdrawalDate
Processwithdrawal withdrawal )
tomerra()
是另一种警告。 balance withdrawal. GetBalance();
withdrawalAmount= withdrawal. GetWithdra()
LwithdrawalDate withdrawal. GetwithdrawalDate()
另外一个类似的警告是你发现自己为 withdrawalTransaction创建了一个
特殊的构造函数,完成一系列简单的数据初始化。你的代码可能像下面这样:
C++示例:成员函数调用前后的设置代码和收尾代码糟糕的做法
withdrawal= new WithdrawalTransacti customerid, balance
withdrawalAmount, withdrawalDate);
withdrawal. ProcessWithdrawal();
thd
delete withdrawal;
代码大全(第2版)

<==========================605end ==============================>
<==========================606start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo...com!仅供试看^
24.2重构简介
569
只要发现在一个子程序调用之前使用了设置代码或者在调用后使用收尾代
码,就应该问问自己,这个子程序的接口是否体现了正确的抽象。在本例中,
ProcessWithdrawa1的参数列表或许应当做如下修改:
C++示例:无需设置代码和收尾代码的子程序一良好的做法
ProcessWithdrawal( customerId balance, withdrawalAmount,
withdrawalDate
请注意,如果情况与上例相反,类似的问题同样存在。如果发现自己拥有了
一个WithdrawalTransaction对象之后,还常常需要传递该对象的多个值去调
用一个子程序,就像这里的例子一样,你就应该考虑对 Processwithdrawa1接口
进行重构,使该接口传递 WithdrawalTransaction对象,而非单独的对象成员。
++示例:需要若干成员函数调用的子程序
ProcessWithdrawal withdrawal. GetCustomerId(),
withdrawal. GetBalance(),
withdrawal. GetWithdrawalAmount()
withdrawal. GetWithdrawalDate())
这些方法有可能是对的,也有可能是错的—这要看 Processwithdrawal()
的接口抽象:子程序调用是需要四个单独的数据,还是需要一个
WithdrawalTransaction对象
程序中的一些代码似乎是在将来的某个时候才会用到的在猜测程序将来有
哪些功能可能被用到这方面,程序员已经声名狼藉了。“超前设计(Designing
ahead)”常常会遭遇很多可预见的问题。
对这些“超前设计”的代码而言,需求不可能定义得很完备。这就意味着程
序员对于未来需求的猜测很可能是错误的。因此,程序员所进行的“超前编
码”的工作最终将会被丢弃。
即使程序员对未来需求的前瞻几近完全准确,他也不可能广泛预见未来需求
所有的复杂脉络。这些错综复杂的关系将会埋葬程序员的基本设计构思,也
就是说“超前设计”的工作也将不得不抛弃。
■那些使用“超前设计”代码的未来程序员们并不知道自己手中的代码原本是
经过“超前设计”的,或许他们会期望这些代码能比实际情况表现得更好。
他们假设这些代码的编码、测试和检查与其他代码进行得同样完美。这些程
序员耗费了大量时间来让这些所谓的“超前设计”的代码工作起来,到最后
却发现这些代码根本没什么用。
“超前设计”的代码是画蛇添足,增加了程序的复杂性,带来了额外的测试、
修补缺陷等工作量。其整体效应就是拖了项目的后腿。
代码大全(第2版)

<==========================606end ==============================>
<==========================607start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
570
第24章重构
专家们认为,对未来需求有所准备的办法并不是去编写空中楼阁式的代码,
而是尽可能将满足当前需求的代码清晰直白地表现出来,使未来的程序员理解这
些代码到底完成了什么功能,没有完成什么功能,从而根据他们的需要进行修改。
CHECKLIST: Reasons to Refactor
cc2.com/2443:核对表:重构的理由
口代码重复。
口子程序太长。
口循环太长或者嵌套太深
口类的内聚性太差。
口类的接口的抽象层次不一致。
口参数表中参数太多。
口类的内部修改往往局限于某个部分。
口需要对多个类进行并行修改。
口对继承体系的并行修改。
口需要对多个case语句进行并行修改。
口相关的数据项只是被放在一起,没有组织到类中。
口成员函数更多地使用了其他类的功能,而非自身类的。
口过于依赖基本数据类型。
口一个类不做什么事。
口连串传递流浪数据的子程序。
口中间人对象什么也不干。
口某个类同其他类关系过于密切
口子程序的命名太差。
口数据成员被设置为公用。
口派生类仅仅使用了基类的一小部分成员函数。
口用注释来掩饰拙劣的代码。
口使用了全局变量。
口在子程序调用前使用设置代码,调用后使用收尾代码。
口程序包含的某些代码似乎在将来某个时候才会被用到。
代码大全(第2版)

<==========================607end ==============================>
<==========================608start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
24.3特定的重构
571
Reasons Not to Refactor
拒绝重构的理由
在日常的讨论中,“重构”一词更多被用来指那些弥补缺陷、增加功能、修
改设计等工作,全然成为了对代码做了任何修改的同义词。这一术语的深刻内涵
已惨遭稀释。修改身并不是什么了不得的好事,但如果是程序员深思熟虑而为
之,且遵循规范恰如其分,那么在不断的维护下这样的修改必将成为代码质量
稳步提升之关键,且能避免如今随处可见的代码因质量不断下降而最终灭亡的趋
势。
24.3
Specific Refactorings
特定的重构
在本部分,我将列出一份重构目录,其中很多都是总结自《,《Rqgucorig《Fowlet》fowle
1999)中的详尽描述。但是我无意使这份目录将各重构全部包容。为便于理解,本
书的每一个例子都给出了一个“拙劣代码”的例子,而“优秀代码”的例子则可被读
者在重构中借鉴。由于篇幅所限,我将重点关注自己认为最为有用的重构方法。
Data-Level Refactorings
数据级的重构
以下的重构方法可用于改进变量和其他数据类型的使用。
用具名常量替代神秘数值如果使用了数字或字符表示形式,例如3.14,那
么请将这样的字符使用具名常量来替代,例如P。
使变量的名字更为清晰且传递更多信息如果一个变量的名字容易让人对其
产生误解,就换个好点的名字。当然,这条建议同样适用于常量、类、子程序。
将表达式内联化把一个中间变量换成给它赋值的那个表达式本身。
用函数来代替表达式用一个函数来代替表达式(这样一米,表达式就不会
在代码中重复出现了)
引入中间变量将表达式的值赋给中间变量,要记住,给这个中问变量的命
名应能准确概括表达式的用途。
用多个单一用途变量代替某个多用途变量如果某个变量身兼数职通常
是i、j、temp、x—请用多个变量来让它们各司其职吧,各个变量还应该具有
更为准确的变量名。
在局部用途中使用局部变量而不是参数如果个被用做输入的子程序参数
在其内部又被用作局部变量,那么请直接创建一个局部变量来代替它。
代大全(第2版)

<==========================608end ==============================>
<==========================609start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看^
572
第24章重构
将基础数据类型转化为类如果一个基础数据类型需要额外的功能(例如更
为严格的类型检查)或额外的数据,那么就把该数据转换为一个对象,然后再添
加你所需要的类行为。这条建议适用于类似 Money和 Temperature这样的简单数
值类型。当然,类似于 color、 Shape、 Country和 OutputType这样的枚举类型
也同样适用。
将一组类型码( type codes)转化为类或枚举类型在董程序中,下面这样
的用法随处可见:
const int SCREEN;
const int PRINTER 1;
const int FILE 2;
与其定义这些单独的常量,不如定义一个类,这样你就可以享受严格类型检查所
带来的好处,同时,如果需要,你还可以对 output进行更为详细的命名。
有时也可以用一个枚举类型替代这样的类。
将一组类型码转换为一个基类及其相应派生类如果与不同类型相关联的不
同代码片段有着不一样的功能,请考虑为该类型创建一个基类,然后针对每个类
型码创建派生类例如对 output Type基类,就可以创建 Screen、 Printer和file
这样的派生类。
将数组转换为对象如果正在使用一个数组,其中的不同元素具有不同的类
型,那么就应该用一个对象来替代它。将数组中的各个元素转化为该类的各个成
员。
把群集( collection)封装起来如果一个类返回一个群集,到处散布的多个
群集实例将会带来同步问题。请让你的类返回一个只读群集,并且提供相应的为
群集添加和删除元素的子程序。
用数据类来代替传统记录建立一个包含记录成员的类。这样你可以集中完
成对记录的错误检查、持久化和其他与该记录相关的操作。
Statement-Level Refactorings
语句级的重构
下面的重构方法可用于改善单个语句的使用。
分解布尔表达式通过引入命名准确的中间变量来简化复杂的布尔表达式
通过变量名更好地说明表达式的含义。
将复杂布尔表达式转换成命名准确的布尔函数如果表达式过于复杂,那么
这项重构可以提高可读性。如果表达式被多次使用,重构还能减少并行修改的需
要,并降低使用该表达式的出错几率。
代码大全(第2版)

<==========================609end ==============================>
<==========================610start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! -www.shubulo.c.com!仅供试看
24.3特定的重构
573
合井条件语句不同部分中的重复代码片段如果你有完全相同的代码同时出
现在一个条件语句的if语句块和else语句块中,那么就应将这段代码移到整个
if-then-else语句块的后面。
使用 break或 return而不是循环控制变量如果在循环中用到了一个类似done
这样控制循环的变量,请用 break或 return来代替它。
在嵌套的if-then-else语句中一旦知道答案就立即返回,而不是去赋一个返回
值一旦知道返回值就迅速退出子程序,这样的代码最容易分析,也不容易出错。
如果设置一个返回值,再通过啰嗦的逻辑判断退出循环,你的代码就会难于理解。
用多态来替代条件语句(尤其是重复的case语句)结构化程序里很多的case
语句中的逻辑都可以被放到继承关系中,通过多态函数调用实现。
创建和使用null对象而不是去检测空值有时null对象可以有一些相关的
通用功能或数据,诸如引用一个不知名字的 resident对象时把它作为“occupant”。
遇到这种情况,应该把处理null值的功能从客户代码中提出来,放到相应的类中。
做法如下:设计一个 Customer类,在 resident知时将其定义为“occupant”;而
不是让 Customer类的客户代码反复检测对象的名字是否已知,并在未知时用
“occupant”代替它。
Routine-Level Refactorings
子程序级重构
下面的重构方法可以用于改善单个子程序一级的代码。
提取子程序或者方法把内嵌的代码(inline code从一个子程序中提取出来,
并将其提炼为单独的子程序。
将子程序的代码内联化如果子程序的程序体很简单,且含义不言自明,那
么就在使用的时候直接使用这些代码。
将冗长的子程序转换为类如果子程序太长,可以将其转换为类,然后进一
步对之前的子程序进行分解,通过所得到的多个子程序来改善该代码的可读性。
用简单算法替代复杂算法用更为简单的算法来替代复杂的算法。
增加参数如果子程序需要从调用方获得更多的信息,可以增加它的参数从
而为其提供信息。
删除参数如果子程序已经不再使用某个参数,就删掉它。
代码大全(第2版)

<==========================610end ==============================>
<==========================611start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^^.com!仅供试看
574
第24章重构
将查询操作从修改操作中独立出来通常,查询操作并不改变对象的状态。
因此,一旦有类似Get Totals()的操作改变了对象的状态,就应该将查询功能从
状态改变功能中独立出来,提供两个独立的子程序。
合并相似的子程序,通过参数区分它们的功能两个相似子程序的唯区别
或许只是其中用到的常量值不同。请把它们合并到一起,然后将常量值通过参数
传入。
将行为取决于参数的子程序拆分开来如果一个子程序根据输入参数的值执
行了不同的代码,请考虑将它拆分成可几个以被单独调用的、无须传递特定参数
的子程序。
传递整个对象而非特定成员如果发现有同对象的多个值被传递给了一个
子程序,考虑是否可修改其接口使之接收整个对象。
传递特定成员而非整个对象如果发现创建对象的唯一理由只是你需要将它
传入某个子程序,那么就考虑一下是否可以修改这个子程序,使之接收特定数据
成员而非整个对象。
包装向下转型的操作通常当子程序返回一个对象时,应当返回其已知的最
精确的对象类型。这尤其适用于返回迭代器、群集、群集元素等的情况。
Class Implementation Refactorings
类实现的重构
下面的方法可用于类一级的重构。
将值对象转化为引用对象如果发现自己创建并维护着多个一模一样的大型
复杂对象,请改变对这些对象的使用方式。即仅仅保存一份主拷贝(值对象),然
后其他地方使用对该对象的引用(引用对象)
将引用对象转化为值对象如果看到自己对某个小型的简单对象进行了多次
引用操作,请将这些对象都设置为值对象。
用数据初始化替代虚函数如果有组派生类,差别仅仅是虚函数返回的常
量不同。与其在派生类中覆盖成员函数,不如让派生类在初始化时设定适当的常
量值,然后使用基类中的通用代码处理这些值。
代码大全(第2版)

<==========================611end ==============================>
<==========================612start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo.com!仅供试看
24.3特定的重构
575
改变成员函数或成员数据的位置请考虑对类的继承体系做出修改。这些修
改通常可以减少派生类的重复工作:
将子程序上移到基类中。
将成员上移到基类中。
将构造函数中的部分代码上移到基类中
下面这些改变则可以用来对派生类进行特殊化:
将子程序下移到派生类中
将成员下移派生类中。
将构造函数下移到派生类中。
将特殊代码提取为派生类如果某类里的一部分代码仅仅被其部分实例所使
用,应该把这部分特殊的代码放到其派生类中。
将相似的代码结合起来放置到基类中如果两个派生类有相似的代码,将这
些代码结合起来并放到基类中。
Class Interface Refactorings
类接口的重构
下面的重构方法可以为你带来更好的类接口
将成员函数放到另一个类中在目标类中创建一个新的成员函数,然后从原
类中将函数体移到目标类中。然后在旧的成员函数中调用新的成员函数。
将一个类变成两个如果一个类同时具备了两种或更多的截然不同的功能,
请把这样的类转化为多个类,使得每个类完成一种明确定义的功能。
删除类如果某个类无所事事,就应该把该类的代码放到与所完成功能关系
更为密切的另一个类中,然后把这个类删掉。
去除委托关系有时类A调用了类B和类C,而实际上类A只应该调用类B,
而B类应该调用类C。在这种情况下就应当考虑对B的接口抽象是否合适。如
果应该由B负责调用C,那么就应该只有B调用C
去掉中间人如果存在类A调用类B,类B调用类C的情况,有时让类A直
接调用类C会更好。是否应当去掉类B,取决于怎么做才能最好地维护类B接口
的完整性。
代大全(第2版)

<==========================612end ==============================>
<==========================613start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
576
第24章重构
用委托代替继承如果某类需要用到另一个类,但又打算获取对该类接口更
多的控制权,那么可以让基类成为原派生类的一个成员,并公开它的一组成员函
数,以完成一种内聚的抽象。
用继承代替委托如果某个类公开了委托类(成员类)所有的成员函数,那
么该类应该从委托类继承而,而不是使用该类。
引入外部的成员函数如果一个客户类需要被调用类的某个额外的成员函
数,而你又无法去修改被调用类,那么可以通过在客户类(client class)中创建新
成员函数的方式来提供此功能。
引入扩展类如果一个类需要多个额外的成员函数,你同样无法修改该类,
你可以创建一个新类。该类包括了原类的功能以及新增加的功能。要实现这点,
你既可通过从原类派生新类然后添加新的成员函数,也可以将原类进行包装,使
新类调用所需要的成员函数。
对暴露在外的成员变量进行封装如果数据成员是公用的,请将其改为私用,
然后通过成员函数来访问该数据成员的值。
对于不能修改的类成员,删除相关的Set(成员函数如果某个成员在对象创
建之时被设值,之后便不能修改,那么就应该在对象的构造函数中对该成员初始
化,而不是使用可能产生误导的Set()成员函数。
隐藏那些不会在类之外被用到的成员函数如果没有某个成员函数,类的接
口更能呈现出内聚性,那就应该隐藏这个成员函数。
封装不使用的成员函数如果发现自己往往只使用类接口的一部分,那么就
为类创建新的接口,仅仅把那些必须的成员函数暴露给类的外部。需要注意,新
的接口应该为类提供一致的抽象。
合并那些实现非常类似的基类和派生类如果派生类并未提供更多的特殊
化,那么就应该把它合并回基类中。
System-Level Refactorings
系统级重构
这里的重构方法可以在整个系统一级改善代码。
为无法控制的数据创建明确的索引源有时,你需要让特定系统来维护数据,
而在其他需要使用该数据的对象中,你却无法方便或一致地访问这些数据。常见
的例子如在GUI控件中维护的数据。在这样的情况下,你需要创建一个类,由该
类里映射GUI控件中的数据,然后让GUI控件和其他代码将此类作为该数据的明
确来源。
代码大全(第2版)

<==========================613end ==============================>
<==========================614start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !-www.shubulo.co.com!仅供试看
24.3特定的重构
577
将单向的类联系改为双向的类联系如果你有两个类,且它们各自需要用到
对方的功能,但仅有一个类能访问另一个类。这时就应该将对两个类进行修改,
使其能互相调用。
将双向的类联系改为单向的类联系如果有两个类,彼此都知道到对方,但
实际上只有一个类需要访问另一个类。这时就应该只让那个有实际需要的类能访
问另一个类,而另一个类无法访问该类。
用 Factory Method模式而不是简单地构造函数在需要基于类型码创建对象,
或者希望使用引用对象而非值对象的时候,应当使用 Factory Method(函数)
用异常取代错误处理代码,或者做相反方向的变换这取决于你的错误处理
策略,请确保代码使用了标准的处理方法。
CHECKLIST: Summary of Refactorings
ccecom50核对表:重构总结
数据级的重构
口用具名常量来代替神秘数值。
用更明确或更具信息量的名字来重命名变量。
口将表达式内联化
口用函数来代替表达式。
口引入中间变量。
口将多用途变量转换为多个单一用途变量。
口使用局部变量实现局部用途而不是使用参数。
口将基础数据类型转化为类。
口将一组类型码转化为类或是枚举类型。
口将一组类型码转化为含派生类的类。
口将数组转化为对象。
封装群集。
用数据类替代传统记录。
语句级的重构
口分解布尔表达式
口将复杂的的布尔表达式转换为命名精确的布尔函数。
代大全(第2版)

<==========================614end ==============================>
<==========================615start==============================>

该书下载自-书部落-分享计算机经典E-ww. ! --www.shubulo.com!.coml仅供试看
578
第24章重构
口将条件语句中不同部分中的重复代码合并。
口使用 break或 return而不是循环控制变量。
口在嵌套的if- f-then-else语句中一旦知道结果就立刻退出,而不是仪仅赋
个返回值。
口用多态来代替条件语句(尤其是重复的case语句)。
口创建并使用空对象代替对空值的检测。
子程序级的重构
提取子程序。
口将子程序代码内联化。
口将冗长的子程序转化为类。
口用简单的算法替代复杂算法。
口增加参数。
口减少参数。
口将查询操作同修改操作区分开米。
口合并功能相似的子程序,并用参数来区分他们。
口通过传递不同的参数使子程序体现不同的功能。
传递整个对象非特定成员。
口传递特定成员而非整个对象
封装向下转型操作。
类实现的重构
口将值对象改为引用对象。
口将引用对象改为值对象。
口用数据初始化来代替虚函数。
口改变成员函数或数据的位置。
口将特定代码提出生成派生类。
口将相似的代码合并起来放到基类中。
代码大全(第2版)

<==========================615end ==============================>
<==========================616start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo.com!^.com!仅供试看^
24.4安全的重构
579
类接口的重构
口将某成员子程序放到另一个类中。
口将一个类转化成两个。
删除某个类。
口隐藏委托关系。
口去掉中间人。
用委托代替继承。
用继承代替委托。
口引入外部子程序。
口引入扩展类。
口封装暴露在外的成员变量。
口对不能修改的成员去掉set()函数
口隐藏在类的外部不会使用的成员函数。
封装不会用到的成员函数
口如果基类和派生类的代码实现相似,将二者合并。
系统级的重构
口为无法控制的数据创建明确的索引源。
口将单向类联系改为双向类联系。
口将双向的类联系改为单向类联系。
口使用工厂函数而非简单的构造函数。
用异常代替错误代码,或者反其道而行之。
24.4
Refactoring Safely
安全的重构
与其将分解一个正
常工作的系统比做
重构是一种改善代码质量的强有力的技术。但正如所有功能强大的工具一样,
替换水槽里面的塞如果使用不当,重构给你带来的麻烦会比它所带来的好处还要多。下面一些简短
子倒不如把它看成的建议能够让你避免错误地使用重构。
是替换大脑中的一
根神经如果我们把保存初始代码在开始重构之前,要保证你还能回到代码的初始状态。用
软件维护称为“软件你的版本控制系统保存一个初始版本,或是把最初正确的文件复制到备份目录
脑部外科手术”,工
作起来会不会要轻中去。
松一些?
-Gerald Weinberg
代大(第2版)

<==========================616end ==============================>
<==========================617start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo..com!仅供试看^
580
第24章重构
重构的步伐请小些有的重构的步法比其他重构更大,到底什么能算成是一
次重构并不明确。因此请把重构的步伐放小些,这样才能理解所做修改对程序的
全部影响。关于这点,在详细论述重构的 Refactoring(Fowler1999)书中有很多
非常好的例子。
同一时间只做一项重构有的重构会比其他的重构更为复杂。除非是对付那
些最为简单的重构,否则请在同一时间只做一项重构,在进入下一项重构之前,
对代码重新编译并测试。
把要做的事情一条条列出来伪代码编程过程的自然延伸就是列出一份重构
列表,然后你应当按照这份列表从A点一步步走到B点写出一份重构列表能够
让你在修改时保持思路连贯。
设置一个停车场在某次重构的路途中,你可能会发现你需要进行另一次重
构。正在着手这次新的重构时,或许又会发现第三个重构将会给程序带来很多好
处。为了处理这些并不需要立即对付的修改工作,你最好设置一个“停车场”
把你需要在未来某个时间进行而现在可以先放在一边的修改工作列出来
多使用检查点在重构的时候,很容易出现代码没有按照设想正常运行的情
况。除了保存初始代码外,在重构中还应在多个地方设置检查点。这样一来,即
使你编码时钻进了死胡同,你仍然可以让程序回到正常工作的状态。
利用编译器警告信息要让一些小错误逃过编译器的目光很容易。你最好把
编译器的警告级别设置为尽可能苛刻,一旦输入中有这些小错误,编译器就能立
即把它们找出来。
重新测试应该把重新测试作为检查所修改代码工作的补充。当然,这点要
取决于从一开始你是否就有一套优秀的测试用例。在第22章“开发者测试”中有
关于回归测试和其他的测试主题的详细介绍。
增加测试用例除了重新运行过去做过的那些测试,还应该增加新的单元测
试来检验新引入的代码。如果重构使得一些测试用例已经过时,那么就删除这些
用例。
交叉如果想
检查对代码的修改如果说在第一次运行程序的时候检查代码是必需的,那
了解关于详细检查么在接下来的修改工作中,时刻关注代码则更为重要。 Ed Yourdon的研究表明,
代码的更多信息,
请参阅第21章协程序员在对代码尝试第一次修改的时候,有超过50%的可能性出错。有趣的是,
同构建
如果程序员处理一大部分代码而不是区区几行,那么他们的修改是正确的几率则
代码大全(第2版)

<==========================617end ==============================>
<==========================618start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
24.4安全的重构
581
会有所提高,如图24-1所示。特殊的情况是,当代码修改行数从1增加到5的时
候,改错的可能性大大增加。在这之后,随着行数的增加,出错的几率开始逐渐
降低了。
100
出错的机会
0%
0
10
15
20
改动的代码
图24-1相对于大规模修改,小的改动更容易出错(Weinberg1983)
程序员们对于很小的修改常常不以为然。他们不会用纸和笔来推敲程序,也
不会让其他人来检查代码。有时甚至根本不会运行这些代码来验证修改工作的正
确性。
事情很简单:应该把简单的修改当做复杂修改加以对待。有一家企业,在引
入对单行代码修改的检查之前,修改发生错误的几率是55%,而在引入之后,错
HARD DATA误几率降低到了2%(Freedman and Weinberg1982)一家电信企业在引入代码检
查后,程序的正确率从86%上升到了86%996%《Perrot004w)
根据重构风险级别来调整重构方法有一些重构实施起来会比其他重构更为
危险。而类似于“用具名常量替代神秘数值”一类的重构则几乎不会出现什么问
题。涉及到类、成员函数接口、数据库构架等改变,或是对布尔判断等进行修改
的重构则极具风险。对于简单的重构而言,你只需要简化整个重构过程,然后简
单地对代码重新测试,而不用一次只去完成一个重构,也不用进行正式的检查工
作。
对于那些有一定风险的重构,谨慎才能避免出错。务必一次只处理一项重构。
除了完成通常要做的编译检查和单元测试之外还应该让其他人来检查你的重构
工作,或是针对重构采用结对编程。
代码大全(第2版)

<==========================618end ==============================>
<==========================619start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
582
第24章重构
Bad Times to Refactor
不宜重构的情况
不要只实现一部重构是一剂良药,但不是保治百病的灵丹妙药。它也有被滥用的可能性
分功能,并指望
将来的重构能完
不要把重构当做先写后改的代名词重构最大的问题在于被滥用。程序员们
成它
-John Manzo
有时会说自己是在重构,而实际上他们所完成的工作仅仅是对无法运行的代码修
修补补,希望能让程序跑起来。重构的含义是在不影响程序行为的前提下改进可
运行的代码。那些修补破烂代码的程序员们不是在重构,而是在拼凑代码
(hacking).
大规模的重构孕
避免用重构代替重写有时,代码所需要的不是细微修改,而是直接一脚踢
育着灾难。出门外,这样你就可以全部重新开始。如果发现自己处于大规模的重构之中,就
-Kent Beck
应该问问自己是否应该把这部分代码推倒重来,重新设计,重新开发。
24.5
Refactoring Strategies
重构策略
对任何特定程序都能带来好处的重构方法本应是无穷无尽的。和其他的编程
行为一样,重构同样受制于收益递减定律,同样也符合80/20法则在斟酌哪种
重构方法最为重要的时候,不妨考虑一下下面这些建议。
在增加子程序时进行重构在增加子程序时,检查一下相关的子程序是否都
被合理地组织起来了。如果没有,那么就重构这些子程序。
在添加类的时候进行重构添加一个类往往会使已有代码中的问题浮出水
面。应当借此机会对其他的类进行重构,使其与你所添加的类结合得更为紧密。
在修补缺陷的时候进行重构如果你在修补缺陷中有了一些心得体会,请把
它运用到改善其他易于产生相似错误的代码上。
交叉参考要了
关注易于出错的模块有的模块更容易出错,健壮性远逊于其他模块。程序
解关于易于出错里面是不是有一部分代码让你和开发团队的其他人都觉得烫手?这很可能就是容
代码的更多信
息,请参阅第易出错的模块了。尽管绝大部分人对这部分富于挑战性代码的自然反应都会是敬
22.4节中的“哪而远之,但集中处理这样的代码将是最为有效的重构策略。
些类包含最多的
错误”
代码大全(第2版)

<==========================619end ==============================>
<==========================620start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
24.5重构策略
583
关注高度复杂的模块另外一种方法就是关注最为复杂的模块(第19.6节中
的“如何度量复杂度”详细叙述了复杂度的度量)一项经典研究表明,当做维护
的程序员们把改善代码的精力集中放在那些最为复杂的模块上时,程序的质量会
有显著提升(Henry and Kafura1984)
在维护环境下,改善你手中正在处理的代码未予修改的代码是没有必要进
行重构的。但如果你正在维护某部分代码,请确保代码在离开你的时候比来之前
更健康。
定义清楚干净代码和拙劣代码之间的边界然后尝试把代码移过这条边界
“现实世界”通常会比你想象的更加混乱。这种状态或是源于复杂的业务规则,或
是来自软硬件接口。对那些古董系统而言,常见的麻烦就是人们会要求那些拙劣编
写的产品代码自始自终都能工作下去。
让古董系统产品重新焕发青春的有效方法,就是让一些代码待在混乱不堪的
真实世界里,让另一些驻扎在理想中的新世界里,让一些代码居于两者之间。图
24-2描述了这样的思想。
的直实世界
混乱的真实世界
↑↓
面向混乱的真空世界的接口
↑↓↑↓↑↓↑↓↑↓↑↓↑↓↑↓↑↓↑↑↓↓↑↑↓↓↑↓↑↓
干净整洁的理想世界
图24-2真实世界混乱不堪并不等于你的代码也得同样糟糕。将你的系统看做理想代
码、混乱的真实世界,以及从前者到后者的接口的结合
代码大全(第2版)

<==========================620end ==============================>
<==========================621start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看^
584
第24章重构
在你处理这一系统的时候,你可以设法把代码移过“真实世界接口”,转移到
更为有序的理想世界中。在处理一个旧的系统时,几乎整个系统可能都是那些写
得非常糟糕的代码拼凑起来的。当你对付某段混乱代码的时候,一种屡试不爽的
办法使这些代码靠近当前的代码规范,例如使用含义明确的变量名等,从而有效
地将这部分代码引入到理想世界中。一次次这样处理下去,代码的基础质量就能
迅速提升。如图24-3所示。
最初状态
目标状态
大多数写得很糟糕的遗产代码
大多数写得很好的重构后的代码
图24-3改善产品代码的策略之一就是在拿到拙劣的遗产代码时对其重构,由此使其
告别混乱不堪的真实世界
CHECKLIST: Refactoring Safely
cc2e.com/245725核对表:安全的重构
口每一改变都是系统改变策略的一部分么?
口在重构之前,你保存了初始代码了么?
口你是否保持较小的重构步伐?
口你是否同一时间只处理一项重构?
口在重构时你是否把要做的事情一条条列了出来?
口你是否设置了一个停车场,把你在重构时所想到的任何东西记下来?
口在每次重构后你会重新测试么?
口如果所做的修改非常复杂,或者影响到了关键代码,你会重新检查这些
修改么?
口你是否考虑过特定重构的风险,并以此来调整你的重构方法?
口你所做的修改是提升还是降低了程序的内在质量?
口你是否避免了将重构作为先写后改的代名词,或者作为拒绝重写拙劣代
码的托词?
代码大全(第2版)

<==========================621end ==============================>
<==========================622start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
要点
585
Additional Resources
更多资源
4
重构的过程在很多方面同修补缺陷有着相同之处。在第23.3节“修正缺陷”
有很多关于修补缺陷的内容。重构的风险则类似于代码调整的风险。如果想了解
如何管理代码调整的风险,请参阅第25.6节“代码调整方法总结
Fowler, Martin. Refactoring: Improving the Design of Existing Code). Reading,
MA: Addison Wesley,199该书是重构的权威指南。它包括了对本章所总结的很
多特定重构的详细讨论,同时还提供了一些本章没有涉及的重构方法。 Fowler还为
如何一步步进行重构给出了众多代码示例。1
Key Points
要点
修改是程序一生都要面对的事情,不仅包括最初的开发阶段,还包括首次发
布之后。
在修改中软件的质量要么改进,要么恶化。软件演化的首要法则就是代码演
化应当提升程序的内在质量。
重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的
警告或“代码臭味”。
重构成功的另一要素是程序员应当掌握大量特定的重构方法。
重构成功的最后要点在于要有安全重构的策略。一些重构方法会比其他重构
方法要好。
开发阶段的重构是提升程序质量的最佳时机,因为你可以立刻让刚刚产生的
改变梦想变成现实。请珍惜这些开发阶段的天赐良机!
译注:中译本《重构:改善既有代码的设计》,中国电力出版社。
代大全(第2版)

<==========================622end ==============================>
<==========================623start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看

<==========================623end ==============================>
<==========================624start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.con!.com!仅供试看^
Code-Tuning Strategies
第25章
代码调整策略
cc2e.c/2578内容
25.1性能概述:第588页
25.2代码调整简介:第591页
25.3蜜糖和哥斯拉:第597页
25.4性能测量:第603页
25.5反复调整:第605页
25.6代码调整方法总结:第606页
相关章节
代码调整技术:第26章
软件架构:第3.5节
本章讨论程序性能调整问题——这一直以来都是一个富有争议的话题。在20
世纪60年代,计算机资源非常有限,因此效率成了人们极为关注的一个问题。到
了70年代,随着计算机的功能越来越强大,程序员们意识到过分专注于性能会损
害程序的可读性和可维护性,因而代码调整受到的重视程度有所下降。性能限制
随着80年代微型计算机革命的开始而重新提了出来,效率问题又被推到台前,在
整个90年代中它被人关注的程度则逐渐下降。21世纪初,移动电话和PDA等设
备上嵌入式软件受到的内存限制,以及解释型代码的执行时间过长,使效率再度
成为了一个热点话题。
你可以在两个层面上考虑性能问题:策略上和技术上。本章要解决的是策略
层面上的性能问题:什么是性能,它的重要性,以及提高性能的一般性方法。如
果你已经理解了性能调整的策略,只是寻求在代码一级提高性能的具体技术,那
么请跳到第26章“代码调整技术”。当然在着手任何较大规模的性能调整工作
之前,最好浏览一下本章的内容,这样你就不会在原本应当去做其他工作的时候
耗费时间对代码做优化了。
代码大全(第2版)

<==========================624end ==============================>
<==========================625start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看
588
第25章代码调整策略
25.1
Performance Overview
性能概述
代码调整只是提高程序性能的一种方法。除此之外,你还可以找到提高性能
的其他方法,这些方法能让你以更少的时间和对代码更少的负面影响来实现你的
目标。本部分就描述了这些方法。
Quality Characteristics and Performance
质量特性和性能
相对于其他单个
人们常常透过有色眼镜来观察这个世界。像你我这样的程序员也喜欢透过代
因素—包括瞎码这副有色眼镜来观察世界。我们猜想,如果能编写出更好的代码,就会有更多
搅蛮干,计算之的客户和消费者喜欢上我们的软件。
效率(即使效率
这就像是现实中的邮件地址,但这个地址没有街道门牌号,也没有实际的建
并非关键所在。筑来容纳它。相对于代码质量(quality),用户更关心的是程序的外在特性。有时,
-W.A. Wulf
人们也会在乎纯粹的性能,但这仅仅是在性能影响到了用户工作的时候。相对于
纯粹的性能,用户更为重视的是程序的处理能力( throughput,吞叶量)对用户
来说,程序员按时交付软件,提供一个清爽的用户界面,避免系统死机常常比程
序的性能更为重要。
来看一个说明情况的例子。我每周会用自己的数码相机拍下至少50张照片。为了
把这些照片上传到我的计算机,我需要使用同相机配套的软件来逐一挑选照片,即在
一个仅能同时显示六张照片的窗口里面查看这些照片。这样一来,上传50张照片就成
了一项烦人的工作,需要无数次单击鼠标并在这样一个六张照片大小的窗口里不停地
前后浏览。在容忍这样的麻烦长达几个月后,我购买了一个读卡器,可直接把它插到
我的计算机上,而计算机会把它当做一个磁盘驱动器来处理。现在我就可以直接使用
Windows资源管理器把这些照片复制到我的计算机里。以前需要无数次点击和长时间
等待的工作,现在只需两次单击鼠标、按一下ctrl+A、然后拖放就能完成了我毫不
介意读卡器传输每个文件的时间是别的软件的一半还是两倍,因为我自己的吞吐量更
大了。无论读卡器代码运行得是快是慢,其“表现performance”显然都好于前一方式
性能同代码速度之间存在着很松散的联系。如果只是关注于代码的运行速度,
你的工作不免顾此失彼。要特别当心放弃其他功能去让你的代码跑得更快。如果
KEY POINT
过分强调速度,程序的整体性能(表现)常常不升反降。
Performance and Code Tuning
性能和代码调整
一旦你选择把效率作为头等大事,无论重点是在处理速度还是在处理代码所
占用的资源上,你都应该考虑一下其他可能选择,而且应当是在代码一级选择提
高速度还是减少资源占用之前去做。请从以下方面来思考效率问题:
代码大全(第2版)

<==========================625end ==============================>
<==========================626start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com! ^.com!仅供试看
25.1性能概述
589
程序需求
程序的设计
类和子程序的设计
程序同操作系统的交互
代码编译
■硬件
代码调整
Program Requirements
程序需求
Barry Boehm为我们讲述了一个故事,TRW公司开发一套系统,客户最初要
求该系统响应时间不能超过1秒。这样的需求直接导致了一套极其复杂的设计方
案以及1亿美元的预算。公司经过进一步的研究,认为在90%的情况下,即使是
4秒的系统实际响应时间,也能满足客户需求。经过如此修改的系统需求为公司
节省了人约7000万美元(Boehm2000b)
在花费时间处理一个性能问题之前,请想清楚你的确是在解决一个确实需要
解决的问题。
Program Design
程序的设计
交叉在本程序的设计包括了设计单个程序的主要框架,主要包括程序如何被分解为类。
资源”中你可以有时程序的设计会使一个高性能的系统难于实现。其他一些设计则使实现这样的
找到如何通过设系统易如反掌。
计改善程序性能
的详细介绍。
来看一个真实世界里数据采集程序的例子,在最高层的设计中我们明确了数
据的测量处理能力将是产品的关键属性。每次测量都包括:记录电子测量的时间、
按测量标准读出测量值、按比例转换测量值、将传感器所用的数据单位(例如毫
伏)转换为工程数据单位(例如摄氏度)
在这种情况下,如果不考虑高层设计中存在的风险,程序员会发现自己试图
在软件中优化一个13阶多项式的计算也就是计算一个有14项且自变量的幂
次最大为13的多项式。后来找到了一种替代方案,他们采用不同的硬件和另一种
高层设计,其中用了多个3阶多项式解决这一问题。这样的改变是无法通过代码
调整来实现的,再多的代码调整似乎也无济于事。这就是一个需要从程序的设计
一级来解决的问题。
代码大全(第2版)

<==========================626end ==============================>
<==========================627start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看
590
第25章代码调整策略
交叉参考第如果你知道程序的资源占用量和速度至关重要,那么就应该仔细设计程序架
20.2节中的“设构来满足这些要求。在设计架构时优先考虑整体性能,然后再为单个的子系统、
重目标”详细讲
述了程序员以目特征和类设置要达到的资源占用目标。这种方法有如下的好处。
标为导向的工作
方法。
设置单独的资源占用目标将使得系统的最终性能可预测。如果单个特征可以满
足资源占用目标,那么整个系统也应该满足系统相应的目标。你可以在早期就
发现那些无法满足目标的子系统,然后对这些子系统进行重新设计或代码调整。
把这些目标描述得越明确,越有可能来使子系统满足这些指标程序员只有
在了解目标后才能实现这些目标,目标定义得越清晰,工作就越容易做。
你可以设定一些目标,尽管借助这些目标无法直接实现高效率,但从长远来
看却能促进效率的提升。通常,在考虑效率问题时应将其同其他因素相结合
例如,实现高度可修改性就为满足效率目标提供了很好的基础,这比明确设
置一个效率目标更好。有了高度模块化的可修改设计,你就能毫不费力地用
更高效的模块来替换那些低效的模块。
Class and Routine Design
类和子程序设计
交叉参考在本
设计类和子程序的内部机制为高性能的设计提供了另一个机会。在这一层次
章末尾的“更多的处理中,是否选择了合适的数据类型和算法将对性能产生重要影响。因为这两
资源”中有关于
数据类型和算法者通常会同时影响程序的内存占用和执行速度。在这一层次,你可以用快速排序
的更多信息。来替代冒泡排序,用折半查找代替线性查找。
Operating-System Interactions
同操作系统的交互
交叉参考如果
如果你的程序要同外部文件、动态内存或输出设备打交道,那么程序很可能
在代码一级需要需要同操作系统进行交互。如果程序性能不尽人意,很可能是操作系统的子程序
对缓慢或臃肿的
操作系统例程进(例程)过于低效或臃肿。你或许没有注意到你的程序正同操作系统进行交互,
行处理,你可以因为有时你的编译器会生成系统调用,或是程序库使用了你未曾想到的系统调用。
参阅第26章“代
码调整技术”获稍后我们会谈到这一问题.
取相关信息。 Code Compilation
代码编译
优秀的编译器能将清晰的高级语言代码转换为经过优化后的机器码。如果选
择了合适的编译器,你可能无须再考虑如何进一步优化程序的运行速度,直接就
能获得满意的程序性能了。
第26章提供了很多编译器优化示例,相对于手动的代码调整,这种优化方法
能生成更高效的代码。
代码大全(第2版)

<==========================627end ==============================>
<==========================628start==============================>

该书下载自-书部落-分享计算机经典巨-. ! -www.shubulo. com!^com!仅供试看
25.2代码调整简介
591
Hardware
硬件
有时,最经济也是最有效的提升程序性能的方法就是购买新的硬件设备。如
果你是针对全国范围成百上千的客户发布程序那么购买新硬件是不现实的。但
如果你是为了个别内部客户开发定制软件,那么硬件升级或许会是最方便的办法。
它节省了性能优化工作的初期投资,也省下了将来对付性能问题的成本。同时,
它还改善了硬件上运行的其他所有程序的性能。
Code Tuning
代码调整
代码调整是一种对正确代码进行调整的实践,它可以使得代码的运行更为高
效。这也是本章剩余部分的主题。“调整(Tuning)”一词指的是较小规模的修改,
这种修改可能会影响到单个的类、单个子程序,更为普遍的情况是寥寥几行代码。
“调整”并不是指大型的设计修改或其他在概要层次上对性能的改进。
从系统设计到代码调整的各个层面上,你都有可能极大地提高程序性能jon
Bentley坚持认为,在某些系统中,各个层次的优化可以被累乘起来( Bentley1 1982)
因为在一个六层系统中如果每一个层面都实现了10倍的优化,那么可能的性能提
升就应该是百万倍。尽管要实现这样的累乘性能改进,需要程序各层的优化同其
他层的优化无关,而这是几乎不可能的,但考虑到可能产生的效果,这样的潜力
还是很鼓舞人心的。
25.2
Introduction to Code Tuning
代码调整简介
代码调整对程序员到底有什么魅力?它并不是改进性能的最为有效的方法,
完善程序架构,修改类的设计,选择更好的算法常常能带来更大幅度的性能提升。
它同样不是最方便的改善性能的方法一购买新的硬件或使用具有更好优化特性
的编译器会更方便。它也不是成本最低的方法在初期阶段你耗费在手工调整
代码上的时间越多,这些代码在后期就会越难于维护。
代码调整出于以下几个原因而受到了程序员们的青睐。这种方法似乎是在藐
视自然法则。调整几行代码,就能把原本运行起来会花上20微秒的程序优化到运
行时间只有2微秒,这给程序员们带来了不可思议的成就感。
它富有吸引力还在于掌握编写高效代码的这门艺术是成为严肃意义上程序员
所需的加冕仪式。如同在网球比赛中,你不会因为拣球的方式而得分,但你仍然
需要学会正确的拣球方法。你不能仅仅弯下身子用手拾起网球。如果你做得漂亮,
代大全(第2版)

<==========================628end ==============================>
<==========================629start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com!^^.com!仅供试看
592
第25章代码调整策略
你可以球拍顶部敲一下地上的网球,然后在它反弹到齐腰高的时候抓住它。敲了
超过三次,甚至是第一次球没有弹起来,都是无法容忍的失败。尽管拣球本身无
足轻重,但你优雅的拣球方式承载着你在网球文化中特定的个人魅力。与之类似,
只有你和其他程序员才会在乎你的代码是否紧凑尽管如此,在程序设计这种文
化中,编写出可以节省几微秒的代码还是能证明你很酷。
代码调整的问题在于,高效的代码并不一定就是“更好”的代码。在下面的
几节中我们会讨论这一问题。
The Pareto Principle
Pareto法则
Pareto法则也就是众所周知的80/20法则。它讲述的是你可以用20%的努力取得
80%的成效。这一法则适用于程序设计之外的众多领域,它对程序优化也绝对有效。
KEY POINT
Barry Boehm的研究表明,程序中20%的子程序耗费了80%的执行时间
(1987b)。在 Donald Knuth的经典论文“An Empirical Study of Fortran Programs
中,作者发现程序中不足4%的部分常常占用了超过50%的运行时间(1971)
)。
Knuth通过一个代码行剖测器发现了这一惊人的关系,这一结论对优化工作的
影响显而易见。程序员们应当衡量代码的各个部分,找出最需要关注的地方,然后
集中火力来对付占用了绝大部分资源的少量代码。 Knuth对自己的代码行剖测器进
行了性能分析,发现其中两个循环占用了整个程序一半的执行时间。于是他花不到
一个小时对这部分代码中的几行进行了修改,整个程序的速度就翻了一倍。
Jon Bentley也提到了一个案例,在一个拥有000行代码的程序中,80%的
运行时间都花费在了一个只有5行的平方根计算子程序中。把这一子程序的运算
速度提高三倍之后,整个程序的运行速度也提高了一倍(1998)根据 Pareto法
则,当某个程序绝大多数的代码都是由诸如 Python这样的解释型语言编写时,程
序员同样应该把其中最关键的部分用C这样的编译型语言重写。
Bentley还描述了另一个情况,某个开发团队发现操作系统一半的运行时间都
花费在一个小循环上。于是他们重新编写了由几行代码所构成的循环,从而让这
个循环的速度提升了10倍。但这一举动并没有改变系统的性能一因为他们重新
编写的是系统的空转循环!
曾设计了 ALGOL语言的团队(Algol是绝大部分现代语言的开山鼻祖,也是
有史以来最具影响力的语言之一)得到了下面的建议:“The best is the enemy of th
good(完美是优良之大敌)。愈是追求完美越有可能完不成任务。程序员们首
先应该实现程序应该具备的所有功能,然后再使程序臻于完美而这时,需要精
益求精的部分通常是很少的。
代码大全(第2版)

<==========================629end ==============================>
<==========================630start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubul.com!仅供试看^
25.2代码调整简介
593
Old Wives'Tales
一些无稽之谈
你所听到过的很多关于代码调整的观点都是错误的,这些观点包括了如下这
些常见的误解。
在高级语言中,减少代码的行数就可以提升所生成的机器代码的运行速度,
或是减少其资源占用错误!很多的程序员都顽固不化地坚持这样的信念:
如果他们能写出只有一两行代码的程序,那么这个程序将会最大限度的高效。让
我们看看下面一段对10个元素数组进行初始化的代码:
for=1 to 10
a[]= i
end for
你猜想下面这些完成了同样工作的代码比上面的代码是快还是慢?
a[1]=1
a[2]=2
a[31=3
a[4]=4
a[5]=5
a[6]=6
a[7]=7
a8=8
a[9=9
a[10]=10
如果你对“行数越少程序就越快”的古板教条深信不疑,那么你将认为第一
段代码要快些。但在 Microsoft Visual Basic和Jva中的测试表明,第二段代码比
第一段快了至少60%。下面就是统计数据:
语言
for循环的运行直接赋值语句的
时间
运行时间
所节省的时间效率比
Visual Basic
8.47
3.16
63%
2.5:1
Java
12.6
3.23
74%
4:1
注意:(1)该表和下面表格中的时间都以秒为单位,测试数据仅用于对比表中各行结
果。实际所用的时间随编译器种类、编译器选项和测试环境不同而有所差别。(2)
测试结果通常都是由代码片段的数千次到数百万次的运行生成的,这样的目的是
为了平滑样本的测量结果波动。(3)我们并没有指明编译器的种类和版本,因
为性能随编译器品牌和版本不同会表现出巨大的差异。(4)在不同语言之间进
行比较通常没有太大意义,因为不同语言编译器的代码生成选项没有可比性(5)
解释型语言(PHP和Python)的结果通常是基于不到其他语言1%的测试循环次数
得出的。(6)表格中的“节省时间”比例或许无法精确再现,因为“直接运行
时间”和“代码调整运行时间”是四舍五入所得。
代码大全(第2版)

<==========================630end ==============================>
<==========================631start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看
594
第25章代码调整策略
显然,这一结果并没有证明在高级语言中增加代码行数就必然会提升所生成
机器语言的运行速度,或者减少机器语言的资源占用。它只是表明,抛开最简洁
代码所具备的美感不谈,高级语言代码行数和程序最终的资源占用和运行速度之
间并无必然联系。
特定运算可能比其他的快,代码规模也较小错误!在讨论程序性能的
时候,没有“可能”一词的位置。你应该实际地测量程序的性能,这样才能知道
你的改动到底是提升还是降低了程序性能。这条游戏规则在你改变了所使用的语
言、编译器种类、编译器版本、库种类、库版本、中央处理器、机器内存、还有
你当时所穿衬衫颜色(哦,不,这条不算)的时候都会改变。在某台机器某种特
定环境下对的东西很可能在另一台机器的不同环境下就变成了谬论。
这一现象也为拒绝通过代码调整来提高程序性能提供了几条理由。如果你希
望自己的程序是可以移植的,那么就应当知道在某个环境下提升程序性能的方
法放到另一个环境中有可能会损害程序性能。如果改变了编器或选用了更高版
本的编译器,新的编译器或许会自动优化代码,以前自己的手动调整工作可能就
付之东流了。更为糟糕的是,之前的代码调整或许还削弱了强大编译器原本针对
直截了当的代码的优化能力。
在调整代码的时候你实际上隐含了一个承诺,即你将根据环境的变化(包括
编译器种类、版本、库版本的改变等)重新进行剖测和调整。如果你没有这样做,
那么在某版本编译器或某库环境下优化所带来的性能提升在另一种编环境下或
许会削弱性能。
我们应当忘记那
应当随时随地进行优化错误!一种理论认为,如果你努力使每一个子
些屑的效率提子程序达到最快和最小,那么你的程序也一定会非常小并且运行得很快。这样的
的场合下,不成方法会让程序员们陷入一叶障目的境地,程序员为微观范围的优化忙得不可开交,
熟的优化乃万恶而对整个系统全局性的重要优化视而不见。在应用这理论的时候,你会遇到下
之源。
Donald Knuth面这些麻烦。
几乎不可能在程序所有功能都运转之前确定出程序的性能瓶颈程序员在猜
测哪一个4%的代码占用了50%的执行时间方面常常出错。因此,平均而言,
那些随时随地都在优化程序的程序员们会有96%的时间是在对付那些原本
就不需要优化的代码。这使得程序员用在处理真正导致瓶颈的4%代码上的
时间所剩无几。
在极少情况下,程序员能正确确定出程序的瓶颈。但他们可能对这一部分代
码痛下重手而顾此失彼,让另一部分代码成为制约性能的关键因素。这样,
最终的结果是性能的下降。而如果优化放在整个系统完成之后,那么程序员
就可以明确各个问题域以及各自的相对重要性,从而有效地对全部优化所用
时间进行分配。
代码大全(第2版)

<==========================631end ==============================>
<==========================632start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo.c ^.com!仅供试看^
25.2代码调整简介
595
在最初的开发阶段中,程序员老是把目光集中在优化上面会干扰自己对其他
程序目标的理解和判断,让自己沉浸在那些最终并没有为用户提供多大价值
的算法分析和晦涩的讨论中,把对正确性、信息隐藏、可读性等的考虑放到
了第二位。实际上,在重视这些之后会更容易实施性能优化。如果首先考虑
前者,那么后期优化工作通常只会影响到不足5%的程序代码。你是愿意回
过头去处理5%代码的效能,还是去改善100%的程序的可读性?
一句话,不成熟优化的主要缺陷在于它缺乏前瞻性。受到损害的包括最终代
码的运行速度、比代码速度更为重要的性能特性、程序质量,直至最终软件用户
如果能将开发最简单程序所节省下来的时问放到优化可运行程序上面,结果得到
的程序必然会比那些未经斟酌便去优化的程序更快(Stevens1 1981)。
偶然有这样的情况,后期优化还无法全部满足性能目标,你不得不对已经完
工的代码进行大规模改动。这时,小型的周部优化无论如何也无法提供所需的性
能。造成这种局面的原因并不是代码质量不高而是软件架构的先天不足。
如果需要在程序完成之前做优化,那就应该在优化过程中建立一种全局观点,
这样才能降低风险。方法之一就是为某项程序功能确定一些资源占用和速度的目
标,在优化过程中使程序满足这些目标。这样一来,程序员在思考眼前这棵大树
到底有多高的时候,还能留意一下整个森林。
深入阅读如果
程序的运行速度同其正确性同等重要一错误!在程序无法正确运行的时
哲理的途闻趣,候,不可能去要求程序应当更小巧或是运行得更快。 Gerald Weinberg为我们讲述
可以阅读 Gerald了一个故事。一位程序员乘飞机到底特律帮助某个开发小组调试一个有问题的程
Weinberg所著的
Psychology of
序。他们一起开始了工作,在几个小时的研究之后,他们绝望了。
Computer Progr在回程的飞机上,这位程序员重新分析了一下所碰到的麻烦,发现了问题之
ammingX程序开
发心理学)所在。在抵达终点的时候,他脑海中已经有了新代码的轮廓。在接下来的几天里
(1998)
他测试了自己的新代码。正当他打算重返底特律的时候,一个电话来了,告诉他
项目已经被取消,取消原因是开发团队认为这个项目根本就不可能开发出来。他
还是赶回了底特律,希望能让执行主管们相信这一项目是可以完成的。
接下来他需要做的就是说服该项目的程序员。这群人听取了他的陈述。在他
说完之后,旧系统的设计师提了一个问题:“那么你的程序需要运行多少时间?”
“每次不定,大约是每个输入处理10秒。”
大全(第2版

<==========================632end ==============================>
<==========================633start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!仅供试看^
596
第25章代码调整策格
“哈!但我的程序只需要一秒!”老手大笑,其他的项目元老也侧着身,满
意地看着这位新手被这个难题所困扰。其他的程序员们似乎也同意这样的看法。
但是我们的这位新程序员并没有屈服。
“的确如此,但你的程序根本就算不出正确答案。如果你能容忍我的程序有
错,我也能让它立刻输出结果!”
对于特定类型的项目,运行速度或资源占用是程序员需要重点考虑的问题。
这种类型的项目比人们通常所认为的要少,并且随着时间的推移会越来越少。这
类项目的性能风险必须通过初期的设计来规避。对其他项目而言,过早地优化则
会对软件的整体质量产生严重威胁,受到影响的甚至会包括软件的性能。
When to Tune
何时调整代码
Jacksan的优化法程序员应当使用高质量的设计,把程序编写正确。使之模块化并易于修改,
则。法则一不要将让后期的维护工作变得很容易。在程序已经完成并正确之后,再去检查系统的
对代码进行优化。
法则二(仅限于高性能。如果程序运行迟钝,那么再设法让它更快更小。除非你对需要完成的工作
手使用):不要优一清二楚,否则绝不要对程序做优化。
化除非你已
经有了一个非常
几年前,我曾经在一个C++项目中工作。该项目要求对投资数据进行分析,
清晰,而且未经优并产生图形化的输出。在我的团队得到成的第一个图像时,测试报告表明我们
化的解决方案。
m.a. Jackson的程序花了45分钟来绘制此图这显然是让人无法接受的。于是我们开了一个会,
来决定应该如何处理这一问题。一位开发工程师开始暴跳如雷:“如果我们还指
望能发布任何可以被用户接受的产品,那么就应该从现在开始用汇编来重新编写
整个代码框架。”我回应说我并不这样认为或许只有4%的代码造成了50%
甚至更多的性能瓶颈。想让项目结束,最好的办法就是找出那个4%。在听完工
程师之间的一通大喊大叫之后,我们的经理指派我来完成初期的性能优化工作(我
几乎已经听见自己在大喊“噢,不!别把我扔进风暴中心!”)
正如大家常常遇到的情况一样,我一天的工作就是对付代码中几个引人注目
的性能瓶颈。通过一系列的代码调整,我们把图像的绘制时间从45分钟缩减到了
不到30秒。远不到1%的代码占用了90%的运行时间几个月后发布该软件的时
候,我们通过一系列额外的代码调整已经使绘制时间减小到1秒之内。
Compiler Optimizations
编译器优化
如今编译器的优化功能可能比你想象的要强大得多。在我之前描述过的例子
中,我的编译器能很好地优化深层嵌套的循环其效果不亚于我所能想到的更高
效的方式来重写代码。在购买某种编译器时请比较不同编译器在你的程序上所
代码大全(第2版)

<==========================633end ==============================>
<==========================634start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
25.3蜜糖和哥斯拉
597
体现的优化性能。每一种编译器都拥有和别的编译器所不同的优势和弱点,就你
的程序而言,某些编译器可能比别的更胜一筹。
与那些充满技巧的代码相比,编译器的优化功能对那些平铺直叙的代码更见
效。如果你在编写代码时自作聪明,例如在循环下标上玩些花招,那么你的编译器
在优化这些代码的时候会痛苦不堪,结果是你的程序倒霉。第31.5节“每行仅写一
条语句”就给出了一个例子。直白的代码通过编译器得到了优化,所生成的代码比
从技巧性代码中优化生成的代码快了11%
如果有了优化能力很强的编译器,你的代码速度通常可以提高40%甚至翻上
一倍。而在下面一章中所描述的技巧通常只能带来15%~30%的速度提升。为什
么程序员们不去编写直白的代码,然后让编译器来完成优化工作呢?下面的一组
测试结果显示了编译器是如何提升一个插入排序程序的运行速度的。
语言
使用编译器优化前使用编译器优化后所节省的
程序的执行时间程序的执行时间时间比率
性能比
C++编译器1
2.21
1.05
52%
2:1
C++编译器2
2.78
1.15
59%
2.5:1
C++编译器3
2.43
1.25
49%
2:1
C#编译器
1.55
1.55
0%
1:1
Visual Basic
1.78
1.78
0%
1:1
Java VM1
2.77
2.77
0%
1:1
Java VM2
1.39
1.38
<1%
1:1
Java VM 3
2.63
2.63
0%
1:1
两组不同程序的唯一差别就是编译器的优化选项是否打开显然,一些编译
器的优化功能要强于其他的编译器,一些编译器在最初没有使用优化选项的时候
表现就已经很突出。一些Java虚拟机(JVM)显然要比其他的虚拟机更好因此,
你需要检查一下自己所使用的编译器或JVM,或者两者都有,由此来比较这些不
同选择所带来的效果。
25.3蜜糖和哥斯拉
Kinds of Fat and Molasses
在调整代码的时候,你会发现程序某个部分运行起来如同是寒冬罐子里的蜜
糖一般粘乎乎,体积同哥斯拉一样,而你的目标就是让它运行起来像加了润滑油,
快如闪电,小得能藏在RAM中字节间的缝隙里。这时,你需要仔细完成程序的
性能剖测,明确哪一个部分的代码是笨拙不堪的。有些操作长期以来都是如此,
你可以从它们开始入手。
代码大全(第2版)

<==========================634end ==============================>
<==========================635start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
598
第25章代码调整策略
Common Sources of Inefficiency
常见的低效率之源
下面是一些常见的低效元凶。
输入/输出操作程序效率低下的根源之一就是不必要的输入/输出。如果你
可以选择在内存中处理文件,就不要费力地通过磁盘、数据库,或是跨越网络访
问相同的文件。除非程序对空间占用非常敏感,否则数据都应放在内存里面。
下面就比较了两段代码,他们都访问了100个随机元素。不同在于一段代码
所访问的元素存放在内存的数组中,另一段代码所访问的元素则是在一个磁盘文
件里。
语言访问外部文件数据访问内存数据节省的时间性能比
C++
6.04
0.000
100%
n/a
C#
12.80
0.010
100%
1000:1
按上面的数据,访问内存比访问文件快上100倍。的确,在我所使用的C++
编译器中,访问内存的时间甚至短得无法测量。
对顺序访问时间所进行的类似测试显示了相似的结果:
语言以外部文件形式存放以内存数据形式存放节省的时间性能比
C++
3.29
0.021
99%150:1
C#
2.60
0.030
99%
85:1
如果测试中涉及速度很慢的外部访问环节例如通过网络连接去读取硬盘
差异将更为明显。我们在网络和本地计算机上做了相同的随机访问测试,结
果如下:
Language访问本地文件时间访问网络文件时间节省的时间
C++
6.04
6.64
-10%
C#
12.80
14.10
10%
当然,测试结果会随着网络速度、网络负载、本地计算机到网络硬盘距离、
相对于本地硬盘速度的网络硬盘速度等因素产生剧烈的变化,你甚至还需要考虑
当时月亮的阴晴圆缺,以及其他各种因素。1
1译注:上面顺序测试所用到的数据总量是随机访问测试所用数据的13倍,因此这两种测试的结果不
是直接可比的。
代码大全(第2版)

<==========================635end ==============================>
<==========================636start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看^
25.3蜜糖和哥斯拉
599
总之,内存访问所带来的高效,已经足够让你对是否将IO引入到一个对速
度要求苛刻的程序中再三斟酌了。
分页引发操作系统交换内存页面的运算会比在内存同一页中进行的运算慢
许多。因此,有时一点简单的修改也能让你的程序性能焕然一新。在下面这个例
子中,一个程序员写下了一个初始化循环,这段程序在一个内存页面大小为4k的
系统上将产生很多的缺页中断(page faults)
for( column0 column MAX COLUMNS column++++)(
table[ row ] column =BlankTableElement( )
这是一个书写工整的循环,变量名也不错,问题在哪儿?问题出在 table中的
每一个元素都有大约4000字节长。如果该able的行太多,那么每一次程序访问
不同行元素的时候,操作系统都需要做页交换。按照这样的循环组织方式,每一
次的数组访问都需要切换所读取的行,这就意味着每一次的数组访问都会造成磁
盘和内存之间的页面交换。
于是程序员按照如下的方式修改了循环:
ava示例:导致较少缺页中断的初始化循环
for rwrowo Max ROwS row++
table[ row column= BlankTableElement();
这段代码在切换所读取的行的时候仍然会引发缺页中断,但只会发生
MAXROWS次,而非原来的 MAXROWS* MAXCOLUMNS次
在某些特定的情况下,代码调整会让性能表现出惊人的变化。在一台内存较
少的计算机上,第二段代码的运行速度比第一段快了100倍。而在一台内存很
大的计算机上,我测出的速度差异不过两倍。并且除非 MAXROWS和 MAXCOLUMNS
的值非常大,否则两种方法并不会显示出很大差异。
系统调用调用系统子程序的代价常常是十分可观的。这些调用通常会涉及
系统的上下文切换(context switch)——保存程序状态、恢复内核状态,以及相
反的操作。系统调用还包括对磁盘、键盘、屏幕、打印机或其他设备的输入输出,
以及运行内存管理程序和特定的工具程序。如果性能对程序来说已经成了一个问
代码大全(第2版)

<==========================636end ==============================>
<==========================637start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com!^.com!仅供试看^个
600
第25章代码调整策略
题,那么就应找出系统调用到底让你付出了多大的代价。如果发现付出不菲,那
么请考虑以下办法。
编写自己的服务程序。有时,你所需要的仅仅是某个系统调用所提功能中的
一小部分,这时你就可以自己基于更底层的系统子程序编写所需的程序。这
样的替代方式能够为你提供更快、更小巧、更能满足需要的功能。
■避免进入系统。
尝试同系统软件商沟通,让他们来把你所需的调用修改得更快。很多的软件
商都希望能改进自己的产品,他们会很高兴地看到你指出他们系统中性能较
差的部分(最初他们看起来会有些不爽,但是他们的确对你的意见很感兴
趣)。
在第25.2节的“何时调整代码”中,我描述了某次代码调整经历。程序所使
用的 AppTime类是从一个可用的商业类 BaseTime上派生出的(为了保护肇事者,
类名称有所改变)。 AppTime对象是该应用程序中最为常见的对象,因此我们初始
化了大约一万个 AppTime对象。在几个月之后,我们发现在其构造函数中,
BaseTime竟然需要用系统时间来初始化自己而系统时间和程序所要完成的功能
简直风马牛不相及,这意味着我们产生了数千次根本就不需要的系统级调用。我
们直接切入到 Base Time的构造函数中,然后把time域初始化为0而非系统时间,
这样一来,所得到的性能提升一举逼平了我们之前所有努力得到成果之总和。
解释型语言解释型语言似乎应当为系统性能所受到的损害做出解释,在机
器代码创建和执行之前,解释型语言必须要处理每一条程序指令。在本章和第26
章所进行的性能比较中,我观察到了不同语言之间大致的性能差异,如表25-1所
示。
表25-1编程语言的相对执行时间
语言
语言类型
相对于C++的执行时间
C++
编译型
1:1
Visual Basic
编译型
1:1
C#
编译型
1:1
Java
字节码
1.5:1
PHP
解释型
>100:1
Python
解释型
>100:1
如你所见,C++、 Visual Basic和C#的执行时间旗鼓相当Java接近以上三者,
但要慢一些。PHP和 Python是解释型语言,这些语言代码的执行速度不到C++、
Visual Basic、c#和Java的1/100。上面表中的数据需要谨慎对待。对于某些特定
的代码,C++、 Visual Basic、C#或Java的执行速度相对于另外两种语言或许会
代码大全(第2版)

<==========================637end ==============================>
<==========================638start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
25.3蜜糖和哥斯拉
601
快上一倍,也可能只有后者的一半(在第26章中,你可以找到详细的例子)。
错误程序性能的终极麻烦就是代码中的错误。这些错误可能是没有去掉调
试代码(例如继续把调试信息记录到文件中去)、忘了释放内存、数据库表设计
失误、轮询并不存在的设备直至超时,等等。
我曾经遇到过某个程序,1.0版本中的某个操作要比其他相似的操作慢很多。
为了说明为什么会有这么笨拙的操作,很多天花乱坠的解释便诞生了。在没有彻
底搞明白这个操作为什么这么慢的情况下,我们发布了1.0版本。在开发1.1发布
版的时候,我发现这项操作所用到的数据库表格居然没有索引!于是我们简单地
为该表格加上索引,一些操作一下就快了30倍。为经常使用的表格定义索引根本
不算优化,这只是一种很好的编程习惯罢了。
Relative Performance Costs of Common Operations
常见操作的相对效率
如果没有实际测量,你通常无法知道哪些操作会比其他的操作更为费时。尽
管如此,一些特定的操作似乎总是比较慢。当你寻觅代码中粘乎乎的蜜糖时,表
25-2能为你助上一臂之力。
表25-2常见操作所用时间
相对使用时间
操作
例子
C++
Java
基准(整数赋值)
i=j
1
1
函数调用
调用无参数函数
foo()
n/a
调用无参数私用成员函数
this.foo()
0.5
调用一个参数的私用成员函数this.foo(i)
1.5
0.5
调用两个参数的私用成员函数thisfoo(i,j)
0.5
对象成员函数调用
bar.foo(
111222
派生成员函数调用
derivedBar.foo()
多态成员函数调用
abstractBar. fooO
2.5
2
对象引用
一层对象解引用
i=obj.num
两层对象解引用
i=objl.obj2. num
1
每次增加解引用
i=obj.obj2.obj无法测量无法测量
代码大全(第2版)

<==========================638end ==============================>
<==========================639start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co!.com!仅供试看^
602
第25章代码调整策略
续表
相对使用时间
操作
例子
C++
Java
整数运算
整数赋值(局部)
i=j
整数赋值(继承)
i=j
整数加
i=j+k
整数减
i=j-k
整数乘
i=j*k
整数除
i=j\k
浮点运算
浮点赋值
=y
浮点加
=y+
浮点减
=y-z
11111511114
11111
1.5
浮点乘
=y*
浮点除
x=y/z
超越函数
111114
浮点方根
=sqrt() 15
浮点正弦
= sin(y)
25
20
浮点对数
x =log()25
20
浮点指数
=exp()50
20
数组
用常量下标访问整数数组
i=a[5]
用变量下标访问整数数组
i=]
用常量下标访问二维整数数组
i=a[3,5]
1111
1
用变量下标访问二维整数数组
i=a[j, k]
用常量下标访问浮点数组
x=z[5]
用整数变量下标访问浮点数组
=z[j]
用常量下标访问二维浮点数组x=z[3,5]
11111111
1
用整数常量下标访问二维浮点数组x=zj,k
注意:以上相对测量值会随着计算机配置、所使用的编译器优化选项以及生成代码的
特定编译器的不同而产生巨大的差异。测量数据在C++和Java之间没有直接可比性
代码大全(第2版)

<==========================639end ==============================>
<==========================640start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看^
25.4性能测量
603
在第1版《代码大全》出版至今的这段时间中,以上操作的相对效率已经发
生了很大变化,因此,如果还沿用着十年前对性能的理解来调整代码,那么应该
对你的思想升级了。
绝大部分常用操作所耗费的时间相差无几——成员函数调用、赋值、整型运
算和浮点运算等等之间都差不多。超越函数2的计算则会用去非常多的时间。多态
函数调用比其他函数调用略微费时。
表25-2或你自己所总结的类似表格就是用来解开代码性能约束的钥匙。这些
具体的改进在第26章会有叙述。在实际开发中性能的每一次提高都源自用耗时
较少的操作替换费时的操作。第26章的例子就讲述了如何去这样做。
25
Measurement
性能测量
由于程序中某些一小部分常常会耗费同自己体积不成比例的运算时间,所以
你应当测量代码性能,找出代码中的热点(hot spots)一旦发现了这样的区域并
对该处的代码进行了优化,就再一次进行测量,看看你到底有了多少改进。性能
问题的很多方面都是违反直觉的。在本章前面的一个例子,你看到了一个10行程
序远远要比另一个只有1行的程序速度要快还有很多代码会以类似的方法让你
大吃一惊。
经验对性能优化也没有太大的帮助。一个人的经验或许来源于一台老掉牙的
计算机,或许来自于过时的语言或编译器—在任何一种因素发生改变后,所有
KEY POINT的经验之谈也会成为狗屁。除非对效果进行测量评估,否则你永远也无法确定某
次优化所带来的影响。
很多年以前我写过一个对矩阵元素求和的程序。最初的代码就像下面这样:
C+示例:对矩阵元素求和的直接代码
sum -0: row rowCount; row++ our
for row
for column =0; column columnCoun; column++)
sum=sum+ matrix row column
代码很容易懂,但矩阵求和子程序的效率是一个关键问题。我知道,所有的
数组访问和循环条件判断都会花掉很多时间。我也从计算机科学的课堂里面学到
2译注:这里指加减乘除之外的运算。
代码大全(第2版)

<==========================640end ==============================>
<==========================641start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shuby.com!仅供试看^
604
第25章代码调整策略
深入阅读Jon了代码每执行一次二维数组访问,就会进行费时的乘法和加法运算。对于一个
Bentley有过类似
的经验,在改为100*100的矩阵而言,总共就会有一万次的乘法和加法,还要算上循环的开支。
指针实现后代码于是我很小心地把上面的代码改为用指针来实现,如下:
性能下降了C++示例:调整矩阵元素求和代码的一次尝试
1%而在另sum=0
环境下相同的改 elementPointer= matrixi
变却带来了超过1 lastElementpointer= matrix rowCount col
1+1
50%的性能提 while( element Pointer< lastElementPointer)
升。在“Software
sum sum *element Pointer++;
Exploratorium:
Nriting Efficient
C Programs
尽管这段代码不如第一段易懂(尤其对于不是C+专家的程序员来说),我
(Bentley 1991)
一书中对这一例
还是很为自己骄傲。通过计算,我为这个100*100矩阵的计算节省了一万次的乘
子有着详细的说法操作和众多的循环处理。我很高兴,我决定测量一下运行速度的改善。并不是
明。
每次我都会这样做,但这样我就会有更多理由来沾沾自喜了。
如果没有数据,任
知道我发现了什么吗?无论用何种方式测量,性能都没有丝毫改进。100*100
何程序员都无法
预测或分析出性
的矩阵不行,10*10的也不行。任何大小的矩阵都不行。我极度失望,于是深入
能瓶颈在哪儿。无到编译器所产生的汇编代码中寻觅优化失效的原因。令我吃惊的是,我的发现表
论你猜测性能会明我并不是第一个需要遍历数组中所有元素的程序员:编译器的优化功能早已将
如何变化,你都会
惊奇地发现事实数组访问改用指针实现。我得到了一个教训,如果没有测量性能变化,那么你想
与你的设想背道当然的优化结果不过是代码变得更为晦涩难懂了。如果你认为没有必要通过测量
而驰。
-Joseph
M. Newcomer
来证实哪种方法更为有效,那么同样也没有必要牺牲代码可读性,而把赌注押在
性能的提高上。
Measurements Need to Be Precise
性能测量应当精确
交叉参考第性能测量应当精确。用秒表或数着“一头大象,两头大象,三头大象”3来计
整”有关于代码算程序的运行时间,根本不准确。性能剖测工具这就能派上用场,你也可以使用
剖测工具的讨系统时钟和函数来记录运算操作所耗费的时间。
论。
无论是使用其他工具还是自己编写代码来测量,都应该明确:你仅仅是在测
量你现在正在调整的代码的运行时间。应当用分配给程序的CPU时钟来计算,而
不是日期时钟。否则,当系统从你自己的程序切换到其他程序的时候,算到你的
某个程序头上的时间实际上是被其他程序所占用了。与之类似,应该明确测量以
及程序初始化所带来的额外系统负担,否则无论是对最初代码还是调整后代码的
性能测量都是不甚公平的。
3译注:读出“elephant(大象)”这个单词大约会耗时1秒,这是一种生活中常用的粗略计时方法。
代码大全(第2版)

<==========================641end ==============================>
<==========================642start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com! ^.com!仅供试看^
25.5反复调整
605
25.5
Iteration
反复调整
一旦确定了性能瓶颈,你一定会为自己通过代码调整而获得的代码性能提升
吃惊不已。尽管几乎不可能从一种方法中获得10倍的性能改进,但你可以将多种
方法有效地结合起来。在优化时应当反复尝试,直到发现了有用的方法。
有一次我写了一个实现DES(数据加密标准)加密程序。实际上并不是只写了
一次,我写了大约30次。在不知道密码的情况下,仅有经过DES加密的密文是无法得
到明文的。这个加密算法是非常复杂,似乎算法本身都被加密过。我的DES实现的性
能目标是在一台原始的 IBM PC上用37秒以内的时间完成一个18K文件的加密。第一
个实现执行起来需要21分40秒。因此,我还有很长一段路要走。
尽管绝大部分优化方法单独看起来都收效甚微,但累计起来,效果是惊人的。
从提升百分比来看,没有三四种优化方法能达到我的性能目标。但这些方法结合
起来最终收到了很好的效果。这一例子所蕴含的哲理就是,如果你的坑挖得足够
深,你总会看到惊人的宝藏。
这次所进行的代码调整是我所遇到的最为棘手的。同时,最终生成的代码也
是我所写出的最难阅读和维护的代码。最初的算法很复杂,因此由高级语言生成
的汇编代码几乎无法阅读。这个500行的汇编函数我连看都不敢看。从整体而言,
代码调整和代码质量之间的关系印证了本章前面的描述。这里有张表,你可以看
到整个优化过程:
交叉参考该表
优化
基准时间
改进
格中的方法在第
26章“代码调整最初的实现(未经优化)
21:40
技术”中有着详将位域转化为数组
7:30
65%
细的叙述。
解开最内层的for循环
6:00
20%
去除最终排列
5:24
10%
将两个变量结合起来
5:06
5%
使用逻辑标识将DES算法的前两步组合起来4:30
12%
使两个变量共享相同的内存空间,从而减少内层循3:36
20%
环内的数据传递
使两个变量共享相同的内存空间,从而减少外层循3:09
13%
环内的数据传递
解开所有循环,并使用文字量下标
1:36
49%
代码大全(第2版)

<==========================642end ==============================>
<==========================643start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
606
第25章代码调整策略
续表
优化
基准时间
改进
去除函数调用,使用内联代码
0:45
53%
用汇编重写整个程序
0:22
51%
最终
0:22
98%
注意:在表中,稳步上升的性能优化并不表示所有的优化工作都起了作用。我并没
有列出我所尝试的让运行时间增加一倍的优化工作在我试过的优化方法中,至少
有2/3没有起作用。
25.6
Summary of the Approach to Code Tuning
代码调整方法总结
如果还对代码调整能否有助于提高某个程序的性能心存疑虑,按照以下的步
骤去做吧。
1.用设计良好的代码来开发软件,从而使程序易于理解和修改。
2.如果程序性能很差。
a.保存代码的可运行版本,这样你才能回到“最近的已知正常状态”;
b.对系统进行分析测量,找出热点;
C.判断性能拙劣是否源于设计、数据类型或算法上的缺陷,确定是否应该
做代码调整,如果不是,请跳回到第一步;
d.对步骤c中所确定的瓶颈代码进行调整;
e.每次调整后都对性能提升进行测量;
f.如果调整没有改进代码的性能,就恢复到步骤a保存的代码(通常而言,
超过一半的调整尝试都只能稍微改善性能甚至造成性能恶化)
3.重复步骤2
Additional Resources
更多资源
cc2e.com/2585/255本部分包括了同性能改善有关的通用读物。如果需要关于某特定的代码调整
技术的资料,可以参阅第26章末尾的“更多资源”部分。
Performance
性能
Smith, Connie U. and Lloyd G. Williams. KPerformance Solutions: A Practical
Guide to Creating Responsive, Scalable Software》《性能解决方案:创建反应迅速
的可伸缩软件的实用指南》) Boston,m: Addison-Wesle-,2002.该书内容包括
了软件性能工程,以及在开发过程的所有阶段将性能增强引入到软件系统中的
方法。
代码大全(第2版)

<==========================643end ==============================>
<==========================644start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看^
更多资源
607
它针对几类应用程序给出了大量示例和案例研究,为如何开发Wb应用给出了具
体的建议,同时还特意强调了程序的可扩展性。
ccc592 cc26.com/2592 newcomcr, joseph m. "optimization: Your Worst Enemy." (,josephm.optimzation:yourWorstEnemy(优化:你的大敌)
May2000,www. may 2000, www. flounder . com/optimization. htm. Newcomer.com/aptimizaion.htm.ewcomer是一位资深系统
程序员,他在该书中用图解的方式详细描述了低效优化存在的各种缺陷。
Algorithms and Data Types
算法和数据类型
cc2e.com/2599
Knuth, Donald. The Art of Computer Programming vol. 1, Fundamental
Algorithms), 3d ed. Reading, MA: Addison-Wesley, 1997.
Kouth, Donald. The Art of Computer Programming, vol. 2, Seminumerical
Algorithms), 3d ed. Reading, MA: Addison-Wesley, 1997
Knuth, Donald. The Art of Computer Programming vol. 3, Sorting and
Searching》,2ded. Reading,ma: Addison-Wesley-.1998
这是一系列从书4的前三卷,这一系列从书最初打算出7卷。似乎这三卷已
经取得了某种震撼效果。除了英语,该书还用数学符号或MI(一种针对虚构的
MIx计算机的汇编语言)描述了算法。该书包括了对数量庞大的各种主题的巨细
无遗的描述,因此,如果你对某种算法有着强烈的兴趣,你不会找到比这更好的
参考资料了。
Sedgewick, Robert. KAlgorithms in Java, Parts 1-4), 3d ed. Boston, MA:
Addison-Wesley-,2002该书共四卷包括了对解决各种类型问题的最佳方法的研究。内
容包括了基本原理、排序、搜索、抽象数据类型的实现和一些高级主题等 Sedgewick
的 Algorithms in Java,pa5》,3ded.(2003)还包括了图论算法。 Sedgewick的
《 KAlgorithms in++, Parts1 1-4》,3ded.(1998)、《 KAlgorithms in++,part5》,3ded
(2002)、《2004x《AIgoriwC,Prs4,3ded97《AlgorithsC,Part5X,3d,parts-4》,3ded.(197)以及《Alorithmsinc,part5》,3d
ed.(2001)四本书的组织方式相仿。 Sedgewick是 Knuth指导的博士生
CHECKLIST: Code-Tuning Strategies
cc2e.com2506
核对表:代码调整策略
程序整体性能
口你是否考虑通过修改需求来提高性能?
口你是否考虑通过修改程序的设计来提高性能?
口你是否考虑通过修改类的设计来提高性能?
4译注:影印版《计算机程序设计艺术》,清华大学出版社,中译本,国防工业出版社
代大(第2版)

<==========================644end ==============================>
<==========================645start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
608
第25章代码调整策略
口你是否考虑过减少程序同操作系统的交互从而提高性能?
口是否考虑过避免VO操作以提高性能?
口是否考虑使用编型语言替代解释型语言以提高性能?
口是否考虑过使用编译器优化选项来提高性能?
口是否考虑过使用不同的硬件来提高性能?
口是否仅仅将代码调整看做是解决问题的最后一招?
代码调整方法
口在开始调整代码之前,程序是完全正确的么?
口在调整之前是否测量过性能瓶颈在什么地方?
口是否记录了每一次修改所产生的效果?
口如果没有带来预期的性能提高,你是否放弃了所做的代码调整改变?
口你是否对每一个性能瓶颈进行不止一次的修改尝试一也就是说,你是在
反复进行代码调整么?
Key Points
要点
性能只是软件整体质量的一个方面,通常不是最重要的。精细的代码调整也
只是实现整体性能的一种方法,通常也不是决定性的。相对于代码本身的效
率而言,程序的架构、细节设计以及数据结构和算法选择对程序的运行速度
和资源占用的影响通常会更大。
定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能
的部分,在修改之后,应当通过重复测量来明确修改是提高还是降低了软件
的性能。
绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间。如果没
有测量,你不会知道是哪一部分代码。
代码调整需要反复尝试,这样才能获得理想的性能提高。
为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码,从而
使代码在后续工作中易于理解和修改。
代码大全(第2版)

<==========================645end ==============================>
<==========================646start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看^
Code-Tuning Technique
第26
代码调整技术
cc2eco/25内容
26.1逻辑:第610页
26.2循环:第616页
26.3数据变换:第624页
26.4表达式:第630页
26.5子程序:第639页
26.6用低级语言重写代码:第640页
26.7变得越多,事情反而越没变:第643页
相关章节
■代码调整策略:第25章
重构:第24章
在计算机程序设计史的绝大部分阶段中,代码调整都是一个广受追捧的话题。
如果决定对程序的性能进行改进并准备在代码一级动手(同时需要将第25章“代
码调整策略”中的警示铭记在心),你的手中其实有一大把的方法可以使用。
本章重点讲述提高代码运行速度的方法,同时也对如何减小代码的资源占用
给出了一些建议。程序性能通常同代码的速度和资源占用相关,但减小代码资源
占用更主要的是通过对类和数据结构的重新设计来实现,而非代码调整。代码调
整更多的是指小规模的修改,而非大范围的设计变更。
本章几乎没有什么放之四海皆准的方法,因此,你不要在自己的程序中直接
照葫芦画瓢。本章的主要目的是示范一些代码调整方法,以便你在遇到的具体情
况中对其灵活运用。
本章所讲述的代码调整似乎同第24章“重构”有些相似,但重构是去改善程
序的内部结构(Fowler1999)。而本章所述的内容,将其称之为“反重构”而非
“改善内部结构”或许更恰如其分。这种改变是以牺牲程序内部结构的某些特性
代码大全(第2版)

<==========================646end ==============================>
<==========================647start==============================>

该书下载自-书部落-分享计算机经典巨著--www !--www.shubulo.cor.com!仅供试看^
610
第26章代码调整技术
来换取更高的性能。就定义而言,这种说法并无不妥即使所做改变没有损害程
序的内部结构,我们也不应认为这是种优化我们就是这样使用,而且把这种
改变当做是标准编程实践的一部分。
交叉参考关于一些书将代码调整方法描述为灵丹妙药,或是引用某项研究结论证明特定的
代码调整的启发调整方法能为你的程序带来理想的效果正如你即将看到的一样,灵丹妙药一词
式方法的更多信
息请参阅5.3节应用到代码调整上根本就不合适。唯一可以信赖的法则就是每次都应当在具体的
“设计构造块:环境下评估代码调整所带来的效果。因此,本章列出的都是“可以尝试的”方法,
启发式方法”。
有的或许在你的环境根本不起作用,而有的则能实实在在产生很好的效果
26.1
Logic
逻辑
交叉参关于
语句逻辑,见第
很多程序都由逻辑操作构成。本节描述了如何因势利导运用逻辑表达式
14至19章。
Stop Testing When You Know the Answer
在知道答案后停止判断
假如你写下了这样的语句:
一旦你确定x不大于5,你就不需要执行第二部分判断了。
交叉参考想了
些语言提供了所谓的“短路求值”的表达式求值形式,这就意味着编译器
解更多关于“短所产生的代码一旦知道了判断的结果就会自动停止继续判断短路求值是C++的
请参阅第19.1节标准运算符功能的一部分,Java的“条件(conditional)”运算符也是这样。
的“理解布尔表
达式是如何求值
的”。
如果你的语言本身并不支持短路求值,那么就应当避免使用and或or,而应
当进一步使用逻辑判断。根据短路求值规则,上面的代码等同于:
if(5<x)then
if< 10 then ..
一旦知道答案就停止判断的原则同样适用于其他很多场合一种常见的情况
就是搜索循环。如果你在个存放输入数据的数组中寻找负数,并且仪仪需要知
道是否有负数存在,那么一种办法是检查每一个值,在找到负数后将
negat iveFound变量设置为真。下面就是这种搜索方法。
代码大全(第2版)

<==========================647end ==============================>
<==========================648start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
26.1逻辑
611
C++示例:在知道答案之后不停下
alse:
negativeInputFound false;
for(i0;i< count;i++)(
if input[
negativeInputFound true;
更好的方式是在找到负值后就立即停止查找下面的任何一种方案都可以解
决问题。
在 negativeInput Found=true之后添加一个 break语句
如果你使用的语言不支持 break,那么就用goto跳转到循环体结束后的第
一行语句,模拟break的行为。
将for循环改为 while循环,然后每次除了像for循环检查循环计数是否
超过 count外,还要检查negativeInput Found的值。
将for循环改为 while循环,在输入数组的最后一项之后第一个空位置设
置一个哨兵值(sentinel value),然后简单地在 while测试中检测负值。在
循环结束后,看看首先发现的值是在原数组的范围内还是在哨兵位置。本章
靠后部分有关于哨兵值的详细介绍。
下面的结果显示了在C++和Java中使用brek后所带来的效率改变:
语言调整前用时
调整后用时
节省的时间
C++
4.27
3.68
14%
Java
4.85
3.46
29%
注意:(1)本表和下面表格中的时间都是以秒为单位,测试数据仅用于对比表中
同一行的结果。实际所用的时间随编译器种类、编译器选项和测试环境不同
而有所差别。(2)测试结果通常都是由数千次到数百万次的代码片段运行所
生成,这样的目的是为了平滑不同样本之间的测量结果波动。(3)我们并没
有指明编译器的种类和版本。性能随种类和版本不同会表现出巨大的差异。
(4)在不同语言之间进行比较并没有太大意义,因为不同语言编译器的代码
生成选项没有可比性。(5)解释型语言(PHP和Python)的结果通常是基于
不到其他语言1%的测试循环次数得出的(6)表格中的“节省时间”比例或
许无法精确再现,因为“直接运行时间”和“代码调整运行时间”都是舍入
所得。
这种代码调整所带来的效果取决于你有多少个数值以及找到负数的几率。本
次测试平均假定采用了100个值,并假定程序有一半的可能能找到负数。
代码大全(第2版)

<==========================648end ==============================>
<==========================649start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^^.com!仅供试看^
612
第26章代码调整技术
Order Tests by Frequency
按照出现频率来调整判断顺序
安排判断的顺序,让运行最快和判断结果最有可能为真的判断首先被执行。
也就是说,让程序更容易进入常见情况的处理,如果有低效率的情况,那就应该
出现在处理非常见的情况时。这样的原则适用于case语句以及if-then -elses-
语句串。
下面就是一个 Select--ase语句,它负责在字处理程序中对键盘输入进行响
应:
Visual Basic示例:顺序差劲的逻辑判断
Select inputCharacter
case"+","=
ProcessMathSymbol( inputCharacter
Case "0" To "9"
rocesspigit inputcharacter
ProcessDigit( inputCharacter)
case"""""""""""2
ProcessPunctuation( inputCharacter)
,
case
ProcessSpace( inputCharacter)
Case "A" To "", "a" To "z"
ProcessAlpha inputCharacter
ProcessError( inputCharacter)
上例的case是按某种接近于 ASCIl码排列顺序的组织方式放置的然而,case
语句的效率常常与你写了一大堆的if-then -elses-的情况一样:如果输入了“a”,
程序首先要判断它是否是一个数学符号,然后看是不是标点,再次是不是数字或
空格,最后才判断它是否是一个字母。如果你能知道输入字符的出现频率,就可
以把最常见的情况放在最前面。下面就是重新组织后的case语句:
Visual Basic示例:顺序合理的逻辑判断
Select inputcharacter
Case "A" To "", "a" To "z"
ProcessAlpha( inputcharacter
Processspace( inputCharacter)
case"","."""""
?
Process Punctuation( inputCharacter)
Case "0" To "9"
ProcessDigit( inputcharacter
case ""
ProcessMathSymbol( inputCharacter
Case Else
End
ProcessError( inputCharacter
lect
代码大全(第2版)

<==========================649end ==============================>
<==========================650start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看^个
26.1逻辑
613
在优化后的代码中,由于最常见的情况通常会很快被发现,直接效果就是更
少的判断所带来的性能提升。下面就是针对标准混合字符的优化结果:
语言调整前用时调整后用时
节省的时间
C#
0.220
0.260
-18%
Java
2.56
2.56
0%
Visual Basic
0.280
0.260
7%
注意:测试基准数据是一组混合字符,里面有7%的字母,17%的空格,还有5%的
标点符号。
Microsoft Visual Basic的结果同预期的相同,但ava和C#的表现却出乎我们
的意料。显然,原因在于C#和Java中switch-case语句的组织方式一每一个
值都必须单独枚举出来,而不是放在一个范围中处理,因此,这两种语言无法像
Visual Basic一样从这种优化中得到好处。这样的结果也强调了不要盲从于任何优
化建议的重要性特定编译器实现将会极大地影响到优化结果
或许你会认为,在 Visual Basic编译器下,对一系列与上面case语句等价的
if-then- -elses语句而言,优化所产生的效果是相似的。请看看下面的结果:
语言
调整前用时调整后用时
节省的时间
C#
0.630
0.330
48%
Java
0.922
0.460
50%
Visual Basic
1.36
1.00
26%
结果大不相同。对相同数量的判断, Visual Basic在代码优化前后所花费的时
间是5:4。这表明编译器为case和if-then-else产生了不同的代码。
对if-then-else的改进结果要比case语句更为一致,这样的结果对程序员
来说可谓喜忧参半。对C#和 Visual Basic来说两者的case语句方案都会比各自
的if-then-else方案要快,而在Java中,sase和ifthen-else都要慢一些
结果的差异也暗示了有第三种可能的优化方法,我们将在下一节进行讨论。
代码大全(第2版)

<==========================650end ==============================>
<==========================651start==============================>

该书下载自-书部落-分享计算机经典巨著-- !-www.shubu.com!仅供试看^
614
第26章代码调整技术
Compare Performance of Similar Logic Structures
相似逻辑结构之间的性能比较
上面所说的示例可以用case语句或if-the-else语句组实现考虑到开发
环境的差异,任何一种方法都有可能更为高效。下表将上面两张表中的数据重新
进行了组织,给出了case语句和if -then-else-语句在“代码调整”上的性能差
异。
语言
casethen-else所节省的时间性能比率
C#
0.260
0.330
-27%
1:1
Jav
2.56
0.460
82%
6:1
Visual Basic 0.260
1.00
258%
1:4
这样的结果似乎不合逻辑。在一种语言中case的效率显然高于
if-then-else,而在另一种语言中,if-then-else又明显好于case.对第三种
语言,两者不相上下。你或许还猜测,既然C#和ava的case语句语法相似,结
果也应该差不多,但实际上它们却大相径庭。
这个示例清楚地表明了要实现代码调整的某种“黄金法则”或是“逻辑准则”
是多么的困难——简而言之,没有什么能替代测量得出的结论
Substitute Table Lookups for Complicated Expressions
用查询表替代复杂表达式
交叉参考第
在一些情况下,使用一张查询表会比穿梭在复杂的逻辑链路中更为高效。复
18章“表驱动杂逻辑链路的要点通常是对一些对象分类,然后根据类别采取相应动作。举一个
法”有用查表法
替代复杂逻辑的抽象的例子,假设所有对象属于A、B、C三个组,你需要对这些对象指定一个类
详细说明。
别号,规则如下。
B
C
代码大全(第2版)

<==========================651end ==============================>
<==========================652start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
26.1逻辑
615
可以通过复杂的逻辑结构指定类别号如下:
C++示例:复杂的逻辑链
if ( a& a & b &&)
category
。
else if((b&&a)(a&&c&&b))
category =2;
else if(c&&a&&b)
category =3:
else
category =0;
如果使用查询表,修改起来更容易,代码性能也会更高,如下:
表的定义理解起C++示例:使用查表法替换复杂逻辑
难。任何能让表/ define categoryTable
定义更易懂的注 static int categoryTable222=
释都是有益的。
/!b!c !bc b! c bc
0.3.2.2.!a
1,2,1,1
a
category= categoryTablel]lc
尽管要读懂这张表的含义有些困难,但如果附以适当文档说明,这不会比阅
读一段复杂的逻辑链路要麻烦。如果类别定义有所改变,这张表也会比前面的逻
辑判断更易于维护。下面是性能测试结果:
语言
调整前用时调整后用时节省的时间性能比率
C++
5.04
3.39
33%
1.5:1
Visual Basic
5.21
260
50%
2:1
Use Lazy Evaluation
使用惰性求值
我的前室友是个超级懒人。一些让别人感到十万火急的事情,在他看来根本
就不需要去做,他的拖沓可见一斑。他宣称,如果那些事情根本就不重要,那么
自然而然会在记忆中湮灭,也就没有必要去浪费时间了。
惰性求值( Lazy evaluation)就是基于我室友所使用的原则。如果程序采用了
这一方法,那么它会避免做任何事情,直到迫不得已。惰性求值类似于即时完成
策略(just-in-t-time),即仅到工作必须完成的时候才去处理。
1译注:该表用三维数组直接描述了上图中各种对象所在的类别,以首数字0为例,处于表中la、b、c
之交点(注释“a”、“!b!c”),故类别为!A!BC组。其余类似。
代码大全(第2版)

<==========================652end ==============================>
<==========================653start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. --www.shubulo.con.com!仅供试看
616
第26章代码调整技术
举个例子,假设你的程序有一张表,里面有5000个值。程序在启动时生成这
张表,然后在运行中使用它。如果程序仅仅用到整张表的很小一部分,那么与其
在最开始计算表中的全部内容,还不如到需要的时候再计算。一旦某个条目被计
算出来,仍然可以把它存放起来,以备后用(即所谓“缓存”)。
26.2
Loops
循环
交叉参考想循环会被执行很多次,由此它也是程序热点最常见的藏身之处。本节所讨论
了解关于循环的
详情,请阅第16的方法能让循环本身更快。
章“控制循环”。
Unswitching
将判断外提
切换( Switching)一词指代循环中的判断,该判断每次循环中都会被执行。
如果在循环运行时某个判断结果不会改变,你就可以把这个判断提到循环的外面,
从而避免在循环中进行判断。这样做时通常需要把循环的里面翻出来,把循环放
在条件语句内,而不是把条件语句放到循环内。下面的例子就是一个切换前的循
环。
C++示例:在循环内做判断
for i =0; i count: i++ )
if sumType = SUMTYPE_NET
netSum netSum amount i
else (rm
grossSum= grossSum+ amount
在这段代码中,测试语句if( sumType== SUMTYPE_NET)在每一次的循
环中都会重复执行,尽管在整个循环中它都取相同的值。你可以用下面的方式来
重写代码,以获得性能提升:
C++示例:将判断外提后的循环
if( sumType= SUMTYPE_net
for(i=0;i< count;i++)
CODING
netSum netSum+ amount[i
HORROR
else
for (i=0
grossSum
nt[ i ]
代码大全(第2版)

<==========================653end ==============================>
<==========================654start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! -www.shubulo.com!仅供试看^
26.2循环
617
注意:这段代码有悖于多条所提倡的编程规范。在很多情况下,代码的可读性和可维
护性都要比运行速度或资源占用更为重要,但本章的主题是性能,这也暗示了
本章中提到的一些方法是以牺牲代码其他特性为代价的。如同最后一章提到的
某些例子一样,这里的一些代码实例也不符合在本书其他部分提出的编程规范。
嗯,省了20%的时间,还不错:
语言
调整前用时
调整后用时节省的时间
C++
2.81
2.27
19%
Java
3.97
3.12
21%
Visual Basic
2.78
2.77
<1%
Python
8.14
5.87
28%
在该例中,一个显而易见的风险就是在维护代码的时候,两段循环需要同步
修改。如果你把 countclientCount改为了,你就得记住两个地方都要做相同的
修改。对你而言这只是个麻烦,而对其他需要维护该段代码的人而言就是一件很
头疼的事情了。
这段代码同样让我们看到了代码调整工作的关键性挑战:任何特定代码调整
所带来的效果都是无法预计的。在四种编程语言的三种里,这一代码调整都带来
了巨大的性能提升,但对 Visual Basic却是个例外。在该特定版本的 Visual Basic
,。
中进行这样的优化,代码变得更难于维护了,而且这样的牺牲并没有换来程序性
能任何程度的提高。这个例子所给出的启示就是你必须通过测量每一种特定优
化方法所带来的性能提升来确定优化效果—没有例外。
Jamming
合并
合并(jamming),或融合( fusion),就是把两个对相同一组元素进行操作
的循环合并在一起。此举所带来的好处就是把两个循环的总开销减少至单个循环
的开销。下面的代码就适合做循环融合:
Visual Basic示例:可以合并的两个独立循环
For i =0 to employeeCount -1
employeeName)
Next
For 0 to employeecount -1
employeeEarnings)=0
Next
在合并循环的时候,你需要看到两个循环里的代码可以合而为一。通常而言,
这意味着二者的循环计数器需要相同。在本例中,两个循环都是从0到
employeeCount1,因此,你可以做如下的合并:
代码大全(第2版)

<==========================654end ==============================>
<==========================655start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
618
第26章代码调整技术
Visual Basic示例:合并后的循环
For i 0 to employeeCount -1
employeeName(i)=
NexemployeeEarnings i )=0
下表是所节省的时间:
语言调整前用时
调整后用时
节省的时间
C++
3.68
2.65
28%
PHP
3.97
2.42
32%
Visual Basic
3.75
3.56
4%
注意:本例中,测量基准 employeeCount为100
同前面的例子一样,结果随语言不同而差异显著。
循环合并有两种主要风险。首先,要合并的两个循环各自的下标有可能被改
变,此后二者将无法共用一个循环下标。其次,你或许没有那么容易就能把循环
合并在一起。在合并之前,你要保证合并后二者相对于其他代码的先后次序仍然
正确。
Unrolling
展开
循环展开的目的是减少维护循环所需要做的工作在第25章,一个循环被完
全展开,所生成的10行代码表现出比之前更快的速度。在那个例子中,3行的循
环代码被解开为10行,使得所有10次数组访问都单独执行。
尽管完全展开循环是一种快速的解决办法,并且在对付少量元素时屡试不爽,
通常你可能会但如果你遭遇大量元素或者无法预知元素数量,这样的方法就不适用了。下面是
写for循环来完一个常见循环的例子:
成这项工作。Java示例:可以展开的循环
出于优化目→=0
的,你需要将 while(i< count)
其转化为 while
a[ i =i;
循环。为简明
i=i+1
起见,这里直
接给出了 while
循环。
要部分地将该循环展开,你要在每次遍历循环时进行两次或更多的处理而非
一次。这样展开循环会损害程序可读性,但并不影响循环的通用性。下面是展开
一次后的循环:
代码大全(第2版)

<==========================655end ==============================>
<==========================656start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! -www.shubule.com!仅供试看
26.2循环
619
Java示例:展开一次后的循环
i=0;
while (< count -1 )
CODING
a[ i ]=i;
HORROR
a[i+1=i+1
i=i+2;
这段用线框f(i count1
起来的代码
负责处理循
a[ count -1 count
环递增2时
无法处理的
情况。
这里的技术就是用两行语句替代了原来的a[i=i,并且i每次递增2
而不是1。 While循环后的附加代码处理,当 count是奇数时,在循环结束后可
能还要进行一次迭代。
当区区5行直白代码被扩展为9行的技巧性代码之后,代码阅读和维护就更
为困难了。抛开性能收益不谈,这段代码质量并不怎么样。然而,任何设计准则
都包括权衡取舍的成分。因此,尽管某种特定的方法通常被看做不良的编程实践,
然而在特定场合下它仍是不二之选。
下面是展开循环的结果:
语言调整前用时调整后用时节省的时间
C++
7
1.15
34%
Java
1.01
0.581
43%
PHP5.33
4.49
16%
Python
2.51
3.21
27%
注意:本例中,测量基准 count为100
百分之16到43的性能提高是很可观的,但也要提防落得像 Python那样性能
受损的可怜下场。解开循环的主要风险是在循环结束后处理最后情况的代码中,
有可能出现off-by-one错误。
如果进一步展开这个循环,那又会如何呢?比如两次或更多次的展开循环?
如果展开两次,效果会更好么?
Java示例:展开两次后的循环
=0;
while (< count -2 )
CODING
HORROR
ai+11=i+1;
a[i+2=i+2
i=+3;
代码大全(第2版)

<==========================656end ==============================>
<==========================657start==============================>

该书下载自-书部落-分享计算机经典巨著!www. !-www.shubul.com!仅供试看^
620
第26章代码调整技术
if (i<= count-1)(
a[ count count-1;
if (i = count -2
a[ count -2 ] count -2;
下面是第二次展开循环的结果:
语言
调整前用时
调整后用时节省的时间
C++
1.75
1.01
42%
Java
1.01
0.581
43%
PHP
5.33
3.70
31%
Python
2.51
2.79
12%
注意:本例中,测量基准count1为100
结果表明,进一步的解循环能进一步地节省时间,但这并不是必然的,正如
java测量结果所示。这种方法主要的问题在于代码变得更诡异了。看看上面的代
码,你或许认为这看起来还不算绝顶复杂,但如果认识到这段代码在几页之前仅
仅是一个5行的循环,你就会更深刻地体会到性能和可读性之间的此消彼长了。
Minimizing the Work Inside Loops
尽可能减少在循环内部做的工作
编写高效循环的关键在于尽可能减少循环内部所做的工作。如果你可以在循
环外面计算某语句或某部分语句,而在循环内部只是使用计算结果,那么就把它
们放到外面。这是一种很好的编程实践,在很多情况下还可以改善程序的可读性。
假设某频繁使用的循环,其内部有一个复杂的指针表达式,就像下面这个例
子:
C++示例:循环内部的复杂指针表达式
for(i=0; rateCounti+ates -sdi- scountf
netRate[ i baseRate[ i rates->discounts->factors->net;
这时,把复杂的指针表达式赋给一个命名准确的变量,不但可以改善代码的可读
性,还能提高代码性能。
C++示例:简化复杂的指针表达式
quantityDiscount rates->discounts->factors->net;
for i -: i rateCount; i++)
netRate[ i baseRate[ i quantityDiscount;
代码大全(第2版)

<==========================657end ==============================>
<==========================658start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co!^.com!仅供试看^
26.2循环
621
所引入的新变量 quantityDiscount清楚地说明了 baseRate数组中的元素
逐个同数量折扣(quantity-discount-)因子相乘,计算出了净费用。而在最初的循
环表达式中,这样的含义并没有清晰地表达出来。把复杂指针表达式转化为循环
外变量,同样使得程序在每次循环时节省了指针三次解引用所花费的时间,由此
带来了下面表格中的改进:
语言调整前用时调整后用时
节省的时间
C++
3.69
2.97
19%
#
2.27
1.97
13%
Java
4.13
2.35
43%
注意:本例中,测量基准 rateCount1为100
除了对于Java编译器,本例中的代码调整在其他语言上的效果并无太值得夸
耀之处。这些数据还暗示了在最初的代码编写阶段,你可以尽情地使用可读性更
好的方法,而把代码运行速度放到稍后来处理。
Sentinel Values
哨兵值
当循环的判断条件是一个复合判断的时候,你可以通过简化判断来节省代码
运行时间。如果该循环是一个查找循环,简化方法之一就是使用一个哨兵值
sentinel value),你可以把它放到循环范围的末尾,从而保证循环一定能够中止。
这里是一个通过引入哨兵值来改善代码的复合判断的经典例子:该循环一方
面要检查它是否发现了所要找的值,另一方面要检查它是否遍历了所有的值。代
码如下:
C#示例:搜索循环中的组合判断
found =FALSE;
i=0
这里是复合判 while((! found)(i< count))
if(item[i]== testvalue)
found TRUEi
else
i++;
if( found)
在这段代码里面,每一次的循环迭代都要判断! found和 count前者
判断是否找到了所需的元素,后者避免循环超出数组末尾。在循环内部,每一
代码大全(第2版)

<==========================658end ==============================>
<==========================659start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.co.com!仅供试看
622
第26章代码调整技术
个item[]又要单独判断。因此,对每一次迭代来说,循环中实际上有三次判断
在这种类型的查找循环里,你可以把三次判断合并起来,通过在查找范围的
末尾设置哨兵值的方式中止循环,使每一次的迭代只执行一次判断就可以了。你
可以简单地把需要查找的值赋给超过查找范围之外的那个元素(在声明数组的时
候,切记为该元素留出空间),然后再去检查各个元素。如果是在数组的最后发
现了你塞进去的元素,你会明白这实际上并不是需要查找的值。代码如下:
C#示例:使用哨兵值来加速循环
11 set sentinel value, preserving the original value
记住在数组末 initialvalue= item count
尾为哨兵值预item[ count=testValue
留空间
i=0
while( item testvalue)
i++
check if value was found
.< count)
当item是一个整数数组的时候,所节省的时间是非常惊人的:
语言
调整前用时调整后用时节省的时间性能比率
C#
0.771
0.590
23%
1.3:1
Java
1.63
0.912
44%
2:1
Visual Basic
1.34
0.470
65%
3:1
注意:查找对象是一个拥有100个整数元素的数组。
所有的结果很好,其中 Visual Basic尤为突出。当数组类型改变的时候,结果
也出现了变化。当item是单精度浮点数时,结果如下
语言
调整前用时
调整后用时
节省的时间
C#
1.351
1.021
24%
Java
1.923
1.282
33%
Visual Basic
1.752
1.011
42%
注意:查找对象是一个拥有100个4字节浮点数的数组。
同以前的测试一样,结果的变化是非常显著的。
代码大全(第2版)

<==========================659end ==============================>
<==========================660start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看^
26.2循环
623
事实上,在任何使用线性查找的场合你都可以使用哨兵法——从链表到数组
需要注意的是你必须仔细选择哨兵值,并小心地把它放到数据结构中去。
Putting the Busiest Loop on the Inside
把最忙的循环放在最内层
在循环嵌套时,需要考虑把哪一个循环放在外面,哪一个放在里面。下面这
个循环嵌套的例子就有改进的余地:
Java示例:可以改进的嵌套循环
sum sum table[ row ] column:
改进的关键在于解决外层循环执行的次数远远多于内层循环这一问题。每次
执行的时候,循环都要初始化循环的下标,在执行一遍循环代码后将它递增,然
后进行检查。循环所执行的总次数是100次外部循环,100*5即500次内部循环,
一共是600次。如果把内外循环交换,那么将会是5次外部循环,5*100次内部
循环,一共是505次。通过分析,你预期此举能节省下(600-505)/600即16%的
时间。下面是性能测量给出的不同结果:
语言
调整前用时
调整后用时
节省的时间
C++
4.75
3.19
33%
Java
5.39
3.56
34%
PHP
4.16
3.65
12%
Python
3.48
3.33
4%
结果同样存在很大的差异,这再次证明在你确信自己的优化工作卓有成效之
前,应当在特定的环境下实际测量优化效果。
Strength Reduction
削减强度
削减强度意味着用多次轻量级运算(例如加法)来代替一次代价高昂的运算
(例如乘法)。有时,你的循环内部有一个表达式,里面需要把循环下标同某个
因子相乘。加法通常会比乘法快,因此如果你能够用把每次迭代的数据相加得出
相同的结果而避免使用乘法,那么代码通常会快一些。使用乘法的例子如下:
代码大全(第2版)

<==========================660end ==============================>
<==========================661start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!仅供试看^
624
第26章代码调整技术
Visual Basic示例:乘以循环下标
Fori=0 to saleCount-1
commission(i)=(i+1) revenue* baseCommission* discount
Next
这段代码简单明了,但代价有些高。你可以重写这个循环,通过累加得到乘
积,而不是每次去计算。这就把计算乘法的代价减少到了使用加法的水平上。
Visual Basic示例:用加不用乘
incrementalCommission= revenue basecommissi* discount
cumulativeCommission incrementalCommission
For i 0 to saleCount
+ivecommiseio
commission i cumulativeCommission
Nex CumulativeCommission cumulativecommission incrementalcommission
使用乘法的代价十分昂贵。这样的改变就像是商家的优惠卷,让你在为循环
所支付的费用上打个折。在最初的代码中,I每一次迭代都会增加,并且需要乘以
revenue、 baseCommission和 discount,首先是1,接下来是2,然后是3,这
样继续下去。优化之后, incrementalCommission1就等于 revenue代码会在每
一次循环时把 incrementalCommission加到 cumulatived上面。在
第一次遍历的时候,需要加一次,第二次的时候就已经加了两次,第三次的时候
就已经加了三次,依此类推。这样的效果同 incrementalCommission乘以1、乘
依2、乘以3等的效果相同,但代价低很多。
关键在于在原来的循环里,乘法依赖于循环下标,而循环下标是表达式中唯
一变化的部分,因此这个表达式可以写得更为经济。下面的数据显示了代码调整
在示例中所起到的作用:
语言
调整前用时调整后用时
节省的时间
C++
4.33
3.80
12%
Visual Basic 3.54
1.80
49%
注意:测试基准saleCount为20。所有被计算的变量都是浮点类型。
26.3
Data Transformations
数据变换
数据类型的改变同样可以成为减少程序规模和改进执行速度方面的利器。本
书并不打算介绍数据结构设计,但对某种特定数据类型实现进行恰如其分的调整,
同样也能提高代码的性能,因此下面给出一些调整数据类型的方法。
代码大全(第2版)

<==========================661end ==============================>
<==========================662start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo..com!仅供试看^
26.3数据变换
625
Use Integers Rather Than Floating-Point Numbers
使用整型数而不是浮点数
交叉参考在第
12章“基本数据
整型数的加法和乘法要比浮点数的相应运算快很多。因此,例如把循环下标
类型”有关于整数
和浮点数的详细从浮点类型改为整型这样的方法能够为代码运行节省很多时间:
介绍。
Visual Basic示例:使用耗时的浮点循环下标
Dim x As Single
For x=0 to 99
a(x)=0
Next
与之相对,使用整型下标的 Visual Basic循环:
Visual Basic示例:使用省时的整数循环下标
Dim As Integer
For=0 to99
a(i)=0
Next
有多少差别?下面就是 Visual Basic代码以及++和PHP类似代码的结果:
语言
调整前用时调整后用时所节省的时间性能比率
C++
2.80
0.801
71%
3.5:1
PHP
5.01
4.65
7%
1:1
Visual Basic
6.84
0.280
96%
25:1
Use the Fewest Array Dimensions Possible
数组维度尽可能少
交叉参考在多年来积累的编程智慧表明,处理多维数组的代价是惊人的。如果你使用一
第12.8节“数维数组组织你的数据而非二维或三维,或许能够节省一些时间。假设最初有如下
组”中有关于数
组的详细介绍。代码:
Java示例:标准的二维数组初始化
for(rowo; row numRowsrow++)
for( column column numColumns column+++)
matrix[ row ] column =0;
代码大全(第2版)

<==========================662end ==============================>
<==========================663start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co!.com!仅供试看
626
第26章代码调整技术
如果这行代码需要遍历50行20列的数组,那么用我手中的Java编译器,运行该
段代码的时间将会是调整为一维数组之后的两倍。
Java示例:数组的一维表示法
for entry =0; entry numRows numColumns; entry++)(
matrix[ entry =0;
下面的表格除了Java代码测试结果外,还有其他一些语言代码的测试结果:
语言调整前用时调整后用时所节省的时间性能比率
C++
8.75
7.82
11%
1:1
C#
3.28
2.99
9%
1:1
Java
7.78
4.14
47%
2:1
PHP
6.24
4.10
34%
1.5:1
Python
3.31
2.23
32%
1.5:1
Visual Basic
9.43
3.22
66%
3:1
注意:Python和PHP所用的时间无法直接同其他语言进行比较,因为它们所执行的
迭代次数不到其他语言的1%。
结果显示,优化对Visual Basic和Java来说效果极佳,对PHP和 Python有些
改善,对C++和C#则不尽人意。当然,C#编译器产生的代码在未优化状态的性能
就已经傲然全部测试代码之首,因此你不能对它太过苛求。
测试结果迥异也再一次证明了盲目采纳各种代码调整建议会有多么危险。除
非在自己特定的环境下尝试了这种方法,否则你永远不能对它带来的效果信以为
真。
Minimize Array References
尽可能减少数组引用
除了避免对二维或三维数组的访问,减少对数组的访问总是有好处的。用这
种方法对付重复使用数组里同一元素的循环就是很好的选择。下面的例子使用了
不必要的数组访问:
++示例:在循环内部不必要地引用数组元素
eypel
rype++
for di scountType discountType typecount: discountType++)
for discountLevel= 0; discountLevel levelCount; discountLevel++){
rate[discountLevel] rate[discount Levell
discount discountType ]
代码大全(第2版)

<==========================663end ==============================>
<==========================664start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co!.com!仅供试看^
26.3数据变换
627
在内层循环中,虽然discountLevel1发生了改变,但对
discount[ discountType]的引用没有变。因此你可以把它从内层循环里面提
出来,这样在每一次外层循环中就只需要执行一次数组访问,而不是在每次内层
循环中都要执行一次数组访问。下面的例子是调整后的代码:
C++示例,将数组引用提出循环
for discountType =0: discountType typecount; discountType++)
for (discountLevel =0; discountLevel levelCount; discountLevel++){
ratef discountLevel rate[ discountLevel thisDiscount;
下面是结果:
语言
调整前用时调整后用时
所节省的时间
C++
32.1
34.5
7%
C#
18.3
7.0
7%
Visual Basic
23.2
18.4
20%
注意:每一次测试基准 typeCount为10, levelCount为100
同上面的例子一样,结果随编译器不同呈现出了巨大的差异。
Use Supplementary Indexes
使用辅助索引
使用辅助索引的意思就是添加相关数据,使得对某种数据类型的访问更为高
效。你可以把相关数据添加到主数据类型中,或者存放到并行结构中。
String-Length Index
字符串长度索引
你可以在不同的字符串存储策略中发现辅助索引的身影。在C语言中,字符
串是被一个值为0的字节中止。对 Visual Basic字符串而言,在每个字符串的开始
位置隐藏有一个长度字节,标识该字符串的长度。要确定C语言字符串的长度,
程序需要从字符串开始位置对各个字节计数,直到发现值为0的字节为止。要确
定 Visual Basic字符串长度,程序只需要看看长度字节就可以了。 Visual Basic长
度字节就是一个例子,说明给数据结构增加一个索引,有可能让一些特定操
作例如计算字符串长度——变得更快。
你可以把这种为长度添加索引的思想应用到任何变长度的数据类型上面。
在需要知道数据长度的时候,相对于临时计算,提早维护这样的结构长度数据显
然更为有效。
代码大全(第2版)

<==========================664end ==============================>
<==========================665start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
628
第26章代码调整技术
Independent, Parallel Index Structure
独立的平行的索引结构
有时,与操作数据类型本身相比,操作数据类型的索引会更为有效。尤其是
如果数据类型中的条目很大或是难于移动或许存放在磁盘上),那么对索引排
序和查找会比直接对数据进行相同操作要快当每一个数据条目都很大的时候,
你可以创建一个辅助结构,里面存放关键码和指向详细信息的指针。如果数据结
构条目和辅助结构条目的大小差异足够显著你可以把关键码条目存放在内存里,
而把数据存放在外部。这使所有的查找和排序都可以在内存里完成,知道了所需
访问条目的具体地址之后,进行一次磁盘访问就够了。
Use Caching
使用缓存机制
缓存机制就是把某些值存起来,使得最常用的值会比不太常用的值更容易被
获取。例如,一个程序随机从磁盘上读取记录某子程序会使用缓存来存放读取
最为频繁的记录。当该子程序收到了记录访问请求时,它首先会检查缓存里面是
否有这条记录,如果有,那么该记录就会直接从内存中返回,无须通过硬盘。
除了用来缓存磁盘上的记录,缓存机制还能应用到其他领域。在 Microsoft
Windows的字体描绘程序中,一度的性能瓶颈就是在显示每一个字符的时候获取
字符宽度。在将最近所使用的字符宽度缓存之后,显示速度即提升了大约一倍。
你也可以缓存那些需要耗费大量时间进行计算的结果尤其是在参与计算
的参数很简单的时候。假设你需要在给出两条直角边的情况下,计算直角三角形
的斜边长。直接实现的代码如下:
Java示例:收益于缓存的子程序
double Hypotenuse
double sideA,
double sideB
return Math.sqrt( sidea sideA)+( sideB sideB))
如果你知道有相同的值常常被重复请求计算,那么你可以按照如下方式把这
些值缓存起来:
代码大全(第2版)

<==========================665end ==============================>
<==========================666start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
26.3数据变换
629
java示例:缓存以避免昂贵的计算
private double cachedHypotenuse =;
private double cachedsideA 0;
private double cachedsideB =0;
public double Hypotenuse(
double sideA,
double sideB
)
/ check to see if the triangle is already in the cache
if( sidea cachedsideA&&ideb= cachedsideB))
return cachedHypotenuse;
compute new hypotenuse and cache it
cachedHypotenuse Math.sqrt(( sidea sideA)+( sideB sideB));
cachedsidea sideA;
cachedsideB sideB;
return cachedHypotenuse;
该程序的第二个版本比第一个要复杂,代码量也更大,但第二个版本以提升
执行速度作为补偿。很多缓存机制会缓存一个以上的元素,相关的开销也会更大
下面就是两个版本的执行速度差异:
语言调整前用时调整后用时所节省的时间性能比率
C++
4.06
1.05
74%
4:1
Java
2.54
1.40
45%
2:1
Python
8.16
4.17
49%
2:1
Visual Basic 24.0
12.9
47%
2:1
注意:假设一旦缓存某值后,该值会被命中两次。
缓存的成功取决于访问被缓存元素、创建未缓存元素,以及在缓存中保存新
元素等动作相关的代价。同样,缓存信息被请求访问的频率也是重要的因素。在
某些情况下,成功或许还依赖于硬件所做的缓存。一般而言,如果创建新元素的
代价越大,请求相同信息的次数越多,那么缓存就越有价值。同样,访问缓存元
素或将新元素存放到缓存中的开销越小,缓存体现出的价值就越大。同其他优化
技术一样,缓存增加了程序的复杂性,使得程序更容易出错。
代码大全(第2版)

<==========================666end ==============================>
<==========================667start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
630
第26章代码调整技术
26.4
Expressions
表达式
交叉参考在第
19.1节“布尔表达
程序里的很多工作都是在数学或逻辑表达式中实现的。复杂的表达式往往代
式”部分有关于表价昂贵,本章就将讨论减少其代价的方法。
达式的更多信息。
Exploit Algebraic Identities
利用代数恒等式
你可以通过代数恒等式,用低代价的操作替代复杂操作。例如,下面两个表
达式在逻辑上是等价的:
not a and not b
not (a or b)
如果选择第二个表达式,你就避免了一次not操作。
尽管避免执行一次not操作节省的时间可能微不足道,但这种普遍原则是具
有强大威力的。 Jon Bentley描述过一个判断sqrt()<sqrt(y)的程序(1982)
由于只有当x小于y的时候,sqrt(x)才会小于qrt(y),因此,你可以用x<y
来替代前面那个判断。由于sqrt()程序的代价很高,你可以预计此举的效果是激
动人心的。的确如此。下面就是结果:
语言调整前用时调整后用时所节省的时间性能比率
C++
7.43
0.010
99.9%
750:1
Visual Basic
4.59
0.220
95%
20:1
Python
4.21
0.401
90%
10:1
Use Strength Reduction
削弱运算强度
前面已经提过,削弱运算强度就是用代价低廉的运算代替代价高昂的运算。
下面就是可能的替代方法:
■用加法代替乘法。
用乘法代替幂乘。
利用三角恒等式代换等价的三角函数。
用1ong或int来代替 longlong整数(但请注意使用机器字长的整数和非
机器字长整数所带来的差异)。
用定点数或整型数代替浮点数。
用单精度数代替双精度数。
用移位操作代替整数乘2或除2
代码大全(第2版)

<==========================667end ==============================>
<==========================668start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor.com!仅供试看^
26.4表达式
631
假设你需要计算一个多项式。如果你已经忘了它们的模样,我得告诉你它们
长得就像Ax2+Bx+C。字母A、B、C都是系数,x是自变量。计算n阶多项式
的代码一般都像下面这样:
Visual Basic示例:多项式求值
value coefficient (0)
For power 1 To order
value value+ coefficient power)* x'power
Next
如果想削减这一计算的强度,你或许会认为求幂这个操作不太顺眼。一种解
决办法就是把求幂代换为每次循环做一次的乘法,这也类似于几个小节以前我们
用加法代替乘法,削减计算强度的示例。下面就是削减计算强度后的多项式求值
代码:
Visual Basic示例:多项式求职的强度削减法
value= coefficient(0)
powerofX =x
For power 1 to orde
value value coefficient power powerofx
powerofx =powerofx *x
Next
这样的改动对二次多项式或高次多项式的效果非常显著二次多项式就是最
高次项为平方的多项式。
语言调整前用时调整后用时所节省的时间性能比率
Python
3.24
2.60
20%
1:1
Visual Basic 6.26
0.160
97%
40:1
如果你对削减运算强度的态度十分坚决,那么你同样无法容忍两个浮点乘法。
运算强度削减的原则暗示你,可以进一步用累计乘幂的循环来代替每次做乘法,
由此进一步削减运算强度。
Visual Basic示例:进一步削减多项式求职的计算强度
value =0
For power order to 1 step-1
value=( value+ coefficient( power))
Next
value value coefficient
代码大全(第2版)

<==========================668end ==============================>
<==========================669start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看
632
第26章代码调整技术
这种方法减少了额外的 powerofx变量,在循环中的每一步计算中用一次乘
法替换了两次乘法。结果如下:
语言
调整前用时第一次优化第二次优化相对于第一次优化的改进
Python
3.24
2.60
2.53
3%
Visual Basic
6.26
0.16
0.31
94%
这是一个很好的例子,说明理论上很好的东西实践中却未必。削减强度的代
码应当跑得更快,但这段代码却并非如此。一种可能的解释是在 Visual Basic中,
循环索引递减1而非递增1会损害程序的性能当然,你需要对这一假设进行验
证才能确定。
Initialize at Compile Time
编译期初始化
如果在一个子程序调用中使用了一个具名常量或是神秘数值,而且它是子程
序唯一的参数,这就是一种暗示,你应当提前计算这一数值,把它放到某个常量
中,从而避免上面那种子程序调用。相同的原则也可以应用到乘法、除法、加法
等其他的操作上。
有一次我需要计算某个以2为底的整数对数,并将结果截断为整数。系统没
有计算2为底的对数函数,我就自己写了一个。最方便的方法就是用下面这个对
数换底公式:
logb2=
log b
根据这一等式,我写了如下的子程序:
交叉参考绑定C++示例:用系统函数实现的以2为底的对数函数
变量及其值的详 unsigned int Log22( unsigned int)
细方法请阅第return(un《uQ1og《)(og()/1og(2));
10.6节。“绑定时
间”
这个函数运行得太慢了。既然1og(2)的值不会改变,我就用计算出的
0.69314718来代替1og(2),就像下面这样:
C++示例:用系统函数和常量实现的以2为底的对数函数
const double LOG2 =0.69314718;
unsigned int Log2( unsigned int x
return(unsigned int)(log(x)log2)
代码大全(第2版)

<==========================669end ==============================>
<==========================670start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看
26.4表达式
633
log()似乎是最花时间的子程序——比类型转换或除法还要奢侈你或许
希望把对1og()的调用砍掉一半,就能省下一半的时间。下面是测量后的结果:
语言调整前用时
调整后用时所节省的时间
C++
9.66
5.97
38%
Java
17.0
12.3
28%
PHP
2.45
1.50
39%
在这个例子中,对除法和类型转换相对重要性的合理推测,以及对50%的时
间节省的估计,都非常接近现实。考虑到本章提到的结果不可预测性,我在本例
中所做的精确预测不过是瞎猫碰到死老鼠罢了。
Be Wary of System Routines
小心系统函数
系统函数运行起来很慢,提供的精度常常也是根本不需要的。举例说,标准
的系统数学函数是按照把宇航员送上月球着陆点的误差不超过两英尺的精度设计
的。如果你的程序无须如此精确,那么你也根本不用耗费时间去计算它。
在上一个例子里面,Log2()子程序返回了一个整型值,但却通过一个浮点
1og()得到这一结果。对一个整数结果而言这样做未免小题大做,因此,在我的
第一次尝试之后,我写出了一系列的整数判断,对计算整数结果的log2而言已经
足够精确了。下面就是改进后的代码:
C++示例:使用整数的以2为底的对数函数
unsigned int Log2 unsigned int x )
if x< 2 return 0
if(x<4) return1
if(x 8 )return
if (< 16 return 3;
if (x64 return i
if x 64 return 5
if x 128 return 6
if(x<256) return7;
if(x<512) return8;
if(<1024) return9
if(x<2147483648) return30
return 31
代码大全(第2版)

<==========================670end ==============================>
<==========================671start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
634
第26章代码调整技术
这个函数只用到了整数运算,根本没有把数据转换为浮点,其效率一举击败
两个使用浮点数的版本:
语言调整前用时调整后用时所节省的时间性能比率
C++
9.66
0.662
93%
15:1
Java
17.0
0.882
95%
20:1
PHP
2.45
3.45
41%
2:3
绝大多数所谓的“超越”( transcendental)函数都是为了最糟糕的情况设计
的,也就是说,即便你引入的是整型参数,这些函数在内部还是会把数据转换为
双精度浮点数去处理。如果在某段占用资源较多的代码中发现了此类函数,而你
又无须用到这样的精度,那么就应当立即有所警惕了。
另一种方法是借助右移位操作等同于除以2的事实减少运算。在结果非零的
情况下,你能对这个数字执行多少次除以2那么对该数字进行log2运算的结果
就会是多少。下面就是根据以上分析写出来的代码:
C++示例:使用右移运算的以2为底的对数函数
unsigned int Log2( unsigned int x )
unsigned int i 0;
ORROR
while((x=(x>1))=0)
++
return;
对那些非C++程序员来说,这样的代码太难读懂了。 While条件中复杂的表
达式是典型的你应当避免的编码实践,除非你有很好的理由写出它。
这个子函数比前面那个稍长版本的函数要慢,多耗费了350%的时间,即2.4
秒而非0.66秒。但它要比第一种方法快,并且该函数很容易适应32位、64位以
及其他的环境。
这个例子提醒我们,如果略尝到优化甜头就止步不前,你会蒙受多大的损失。
KEY POINT
第一次的优化带来了可观的30%到40%的时间节省,但根本无法同第二次和第三
次的优化效果相提并论。
代码大全(第2版)

<==========================671end ==============================>
<==========================672start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.c.com!仅供试看
26.4表达式
635
Use the Correct Type of Constants
使用正确的常量类型
所使用的具名常量和应该同被赋值的相应变量具有相同的类型。当常量和相
关变量的类型不一致时,那么编译器就不得不先对常量进行类型转换,然后才能
将其赋给变量。优秀的编译器可以在编译时完成转换,这样就不会影响程序运行
时的性能。
稍逊一筹的编译器或解释器生成的代码则会在运行时进行类型转换,这时你
就麻烦了。下面就是在两种情况下初始化浮点变量以及初始化整型变量i的性
能差异。在第一种情况下,初始化代码如下:
=5
i=3.14
假设x是一个浮点变量,i是一个整型变量,在上面的语句中就需要进行类
型转换。第二种情况:
=3.14
=5
则无须进行类型转换。下面就是结果,不同编译器的差异再次引起了我们的注意:
语言调整前用时调整后用时所节省的时间
性能比率
C++
1.11
0.000
100%
无法测量
C#
1.49
1.48
<1%
1:1
Java
1.66
1.11
33%
1.5:1
Visual Basic 0.721
0.000
100%
无法测量
PHP
0.872
0.847
3%
1:1
Precompute Results
预先算出结果
在详细设计阶段,常常需要做出的决定就是选择即时计算有关结果,还是提
早把它们算好并保存起来,在需要的时候再来查找如果结果会用到很多次,通
常提前计算出结果然后再查找会为你节省一些时间。
这种选择从很多方面都证明了自己的价值。在最简单的情况下,你可以在循
环外计算某个表达式的部分值,而不是在循环内部在本章前面有一个这样的例
子。在更为复杂的层面上,你可以在程序执行开始的时候算出一张查询表,在之
后每次需要的时候使用这一表格。你或许还可以把结果存放到数据文件中,或是
直接将其嵌入到程序中。
代码大全(第2版)

<==========================672end ==============================>
<==========================673start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld com!^.com!仅供试看^
636
第26章代码调整技术
交叉参考第18
举个例子,在太空大战视频游戏中,程序员最初是针对离太阳的距离远近来
章“表驱动法”有计算不同位置的重力系数。对重力系数的计算非常麻烦,并且会影响到性能。后
关于使用数据表
格代替复杂逻辑来,程序员发现要用到的相对于太阳的距离只有不多的几个,因此,程序可以预
的具体做法。先计算出这些重力系数,然后把它们存放到一个10元素的数组中。与执行复杂的
计算相比,在这个数组中找出想要的值就快得多了。
假设你有一个计算汽车贷款支付金额的函数其代码或许像下面这个样子:
Java示例:复杂的计算,本可以预先计算
double ComputePayment(
long loanAmount,
int months,
double interestRat
)
return loanAmount
,
1.0-math.pow(1.0+( interestRate12.0)),-months))
( interestRate/12.0)
)
支付金额计算公式比较复杂,计算的代价很高。把数据放到一张表格里,而
不是每次去计算,或许更便宜些。
那么这张表会有多大呢?最大范围变量就是1 loanAmount变量
interest Rate可能从5%到20%以0.25%递增,这也只有61个不同的值。 Months
会从12到72,也只有61种不同还款周期。较为可信的1 loanAmount范围应当是
从$1000到$100000,这一数字比你通常想在查询表中处理的条目数要大得多。
然而大部分计算并不依赖于 loanAmount,因此你可以把计算中最难看的那个
部分(大表达式里的那个分母)放入一个表里,用 interest Rate和 months作为
索引下标;而后每次重新计算1 loanAmount那一部分。
ava示例:预先计算某个复杂的计算
double Computepayment(
long loanAmount,
int months,
double interestRate
新创建的
)1erestindey_
interestlndex变
int interestIndex RNARTY100.00)
量为 loanDivisor
math. round((interestRate-LOWEST_rate) GRANULARITY100.00)
数组提供了一个
return loanAmount loanDivisor[ interest Index[ months ]
下标。
代码大全(第2版)

<==========================673end ==============================>
<==========================674start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看^个
26.4表达式
637
在这段代码中,复杂的计算被对数组索引的计算和单个数组访问所替代。下
面就是改变后的结果:
语言调整前用时调整后用时所节省的时间性能比率
Java
2.97
0.251
92%
10:1
Python
3.86
4.63
20%
1:1
根据环境的情况,你可以在程序的初始化阶段预先计算出1 oanDivisor数组,
或是从一个磁盘文件中把数组读进来。换一种方式,你也可以先把数组初始化为
0,在每个元素被首次访问时再来计算,并把结果保存起来以备下一次查询。这就
是某种形式的缓存,我们曾经在前面讨论过。
如果预先计算表达式也能获得性能的提升你就不需要创建表格了。下面代
码与前面有些例子里的代码类似,让我们进一步体会到了在开发中使用不同类型
预先计算的可能性。假设你有一段代码,计算各种数额贷款的支付金额,就像下
面这样:
Java示例:第二个复杂的计算本可以预先进行
double ComputePayments(
int months
double interestRate
)
for( long loanAmount=minLOANAMOUNT; loanAmountmax_LOANAMOUNT
loanAmount++
payment loanAmount
(1.0-math.pow(1.0+(interestRate/12.0),- months))
( interestRate/12.0)
下面这些代码应
);
该对 payment进
行处理,但就本
例而言,已经无
就算没有预先计算生成的表格,你也可以在循环外预先计算表达式中的复杂
部分,然后在循环内部使用计算结果,如下:
Java示例:预先计算第二个复杂的计算
double ComputePayments
int months,
double interestRate
long loanAmount;
这里就是预先计
double divisor=(1.0-math.pow(1.0+(interestRate/12.0)- months))
算的部分。
( interestRate/12.0):
for long loanAmoun
MIN_LOAN_AMOUNT;
loanAmount <=MAX_LOAN_AMOUNT;
loanAmount
payment loa
t/ divisor;
代码大全(第2版)

<==========================674end ==============================>
<==========================675start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co.com!仅供试看^
638
第26章代码调整技术
这类似于我们在前面讨论过的把数组下标和指针引用放在循环外面的方法。
对Java而言,如此改动的效果可以同第一次预计算表格的优化效果相媲美:
语言调整前用时调整后用时所节省的时间性能比率
Java
7.43
0.24
97%
30:1
Python
5.00
169
66%
3:1
这次 Python表现不错,是我们在第一次优化中没有看到的。很多情况下,某
次优化的效果可能不尽人意,但另一次看起来很相像的优化或许就会给你带来惊
喜。
通过预先计算优化程序可以有如下几种形式:
在程序执行之前算出结果,然后把结果写入常量,在编译时赋值;
■在程序执行之前计算结果,然后把它们硬编码在运行时使用的变量里;
■在程序执行之前计算结果,把结果存放在文件中,在运行时载入;
在程序启动时一次性计算出全部结果,每当需要时去引用;
尽可能在循环开始之前计算,最大限度地减少循环内部需要做的工作:
在第一次需要结果时进行计算,然后将结果保存起来以备后用。
Eliminate Common Subexpressions
删除公共子表达式
如果发现某个表达式老是在你面前出现,就把它赋给一个变量,然后在需要
的地方引用该变量,而非重新计算这个表达式下面这个计算贷款支付金额程序
里就有一个应该去掉的子表达式,原始代码如下:
java例:公共子表达式
payment loanAmount /
(1.0-math.pow(1.0+( interestRate/12.0),-months))
( interestRate12.0)
)
代码大全(第2版)

<==========================675end ==============================>
<==========================676start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
26.5子程序
639
在上面这个例子中,你可以把 interestRate/12.0赋值给一个变量,然后在
程序中对它进行两次引用,而无须计算两次表达式。如果变量的名字取得还不错,
在性能得到提升的同时,代码的可读性还能有所改善。这就是修改后的代码:
monthlyInterest= interestRate/12.0
payment loanAmount/(
(1.0 -Math.pow
ow( 1.0 monthlyInterest, -months
monthlyInterest
);
此举所节省的时间似乎并不那么惊人:
语言调整前用时调整后用时
所节省的时间
Java 2.94
2.83
4%
Python 3.91
3.94
1%
似乎Math.pow()函数消耗过大,削弱了删除子表达式带来的效果。另一种
可能是编译器在处理代码的时候已经将子表达式去掉了。但是,如果子表达式在
整个表达式中所占用的资源更多一些,或者编译器的优化不那么有效,这种优化
带来的效果或许会更显著。
26.5
Routines
子程序
交叉参考关于
代码调整的利器之一就是良好的子程序分解。短小、定义明确的子程序能够
处理子程序细节代替多处单独执行相同操作的代码,因而能够节省空间。这些子程序也使得优化
的问题,请问第了更为简单,因为重构某子程序的代码就可以惠及各处。短小的子程序更容易用低
“高质量的
序”。
级语言重写。而冗长的子程序本身就够难理解了,如果放在低级语言例如汇编中
要读懂简直是不可能的。
Rewrite Routines Inline
将子程序重写为内联
在计算机编程历史的早期阶段,在一些机器中调用子程序就可能严重地影响
性能。子程序调用意味着操作系统需要把程序从内存交换出去,换入一个子程序
目录,换入特定的子程序,执行子程序,然后再把这个子程序换出去,最后把调
用方子程序交换回来。所有的这些交换操作都要吞噬大量资源,让程序变慢。
代码大全(第2版)

<==========================676end ==============================>
<==========================677start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! -www.shubulo.c.com!仅供试看^
640
第26章代码调整技术
对今天的计算机来说,调用一个子程序要付出的代价小多了。下面是把某个
字符串拷贝函数写为内联子程序后的性能改善结果:
语言子程序用时
内联代码用时
所节省的时间
C++
0.47
0.431
8%
Java
13.1
14.4
10%
有的时候,利用诸如C++的inline关键字这样的语言特性,把某个子程序
的代码直接放到程序内部,还能省下若干纳秒的时间。如果你所用的语言并不直
接支持 inline,但你的编译器支持宏预编译,你可以借助宏把子程序代码放进去,
根据需要进行转换。事实上,现代计算机“现代”意味着你正使用的任何机
器——并不会为你调用了某个子程序而开出一张罚款单正如上面例子所示,把
子程序代码写为内联或许还会降低性能。
26.6
Recoding in a Low-Level Language
用低级语言重写代码
有一句亘古不变的箴言也不能不提:当程序遭遇性能瓶颈的时候,你应当用
低级语言重写代码。如果程序是用C++写的,低级语言或许是汇编;如果是 Python
写的,那么低级语言可能是C。在低级语言中重新编写代码更有可能改善速度和
减少代码规模。下面是使用低级语言优化代码的标准方法。
1.用高级语言编写整个应用程序。
2.对程序进行完整的测试,验证其正确性。
交叉参考程
3.如果测试后发现需要改进程序性能:就对程序进行分析,确定出热点。由
序中的很小一于5%的程序往往可以占用50%的运行时间,通常你能够将程序中很小的一部分
大部分的运行确定为热点。
时间,第25.24.把几小段代码在低级语言中重写,以此提高整体性能。你是否需要沿着这
节“pareto法
则”有对这一现条充满荆棘的道路走下去,取决于你对低级语言有多么得心应手,相关问题有多
象的详细描述。么适合使用低级语言来解决,以及你有多大的勇气去冒险。我第一次用这种方法
是在前面提到的DES程序里面。我已经试过了自己知道的所有优化方法,程序仍
然比预定目标慢了一倍。在汇编中重新编写部分程序是最后一招了。作为汇编新
手,我唯一能做的只是把高级语言所写的代码直接翻译成为汇编语言。就这样,
代码竟然得到了50%的性能提升,而且我仅仅是翻译,并没有对代码进行改进
假设你有一个子程序,它把二进制数据转化为大写的ASCI字符,下面就是
用 Delphi编写的代码:
代码大全(第2版)

<==========================677end ==============================>
<==========================678start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
26.6用低级语言重写代码
641
Delphi示例:更适合用汇编语言编写的代码
procedure HexExpand(
var source: ByteArrayi
var target: WordArray
bytecount: word
);
var
index: integeri
lowerByte: byte;
upperByte: byte;
betargetIndex:integer:
begin
target Index
he
for index : 1 to bytecount do begin
target[ targetIndex+1 :=(source[ index and $of) $41;
target target Index:=(source index andFo)shr4)+s41
targetIndex:= target Index+2
end;
end;
尽管要找到代码中最消耗资源的地方有些困难,但可以看到代码包含了许多
位操作,这显然不是 Delphi所擅长的。但位操作是汇编语言的拿手好戏,因此这
段代码是用低级语言重写的极好对象。下面就是汇编代码:
Example of a Routine Recoded in Assembler
procedure HexExpand(
var source
var targeti er
byteCount: Integer
label
EXPAND:
asm
MOV ECX, byteCount load number of bytes to expand
MOV ESI,source
source offset
MOV EDI, target
target offset
XOR EAX, EAX
zero out array offset
EXPAND:
MOV EBX, EAX
array offset
MOV DL, [ESI+EBX]
get source byte
MOV DH, DL
copy source byte
AND DH,
11get msbs
ADD DH,$41
11 add 65 to make upper case
SHR DL,4
moeieh
11 move lsbs into position
AND DL, SF
ADD DL,$41
get Isbs
add 65 to make upper case
代码大全(第2版)

<==========================678end ==============================>
<==========================679start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
642
第26章代码调整技术
SHL BX, 1 / double offset for target array offset
MOV [EDI+EBX],DX
/ put target word
INC EAX
11 increment array offset
LOOP EXPAND
repeat until finished
end;
用汇编重写这一例子物有所值,直接为你省下了41%的时间。从逻辑上分析,
我们认为最初编写代码的语言如果更适合进行位操作,例如C++,那么此举带来
的优化效果会小于对 Delphi代码的优化效果。下面就是测试结果:
语言高级语言用时汇编语言用时
所节省的时间
C++
4.25
3.02
29%
Delphi
5.18
3.04
41%
在测量结果中,调整前的数据反映出两种语言在位操作上的不同实力。调整
后数据看起来一样,它表明汇编代码最大限度地缩小了 Delphi和C+之前的性能
差异。
这个汇编语言的子程序让我们看到用汇编语言重写的代码未必会生成丑陋的
巨无霸,相反,生成的子程序大小适中,正如此例所示。有时,汇编语言代码同
其实现等价功能的高级语言一样紧凑
有一种相对简单有效的汇编重编码方法,即启用一个能顺带输出汇编代码列
表的编译器。把需要调整子程序的汇编代码提取出来,保存到单独的源文件中
将这段汇编代码作为优化工作的基础,手动调整代码,在接下来每一步工作中检
查代码的正确性并量化所取得的改进。一些编译器还可以将高级语言的语句作为
注释嵌入到汇编代码中。如果你的编译器提供了这项功能,你可以把高级语言代
码留下来,作为汇编代码的说明。
CHECKLIST: Code-Tuning Techniques
cc2e.com/2672
核对表:代码调整方法
同时改善代码执行速度和规模
口用查询表替换复杂逻辑
口合并循环。
口使用整型变量而非浮点变量。
口在编译时初始化数据。
口使用正确的常量类型。
口预先计算结果。
口删除公共子表达式。
口将关键子程序代码转化为某种低级语言代码。
代码大全(第2版)

<==========================679end ==============================>
<==========================680start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
26.7变得越多,事情反而越没变
643
仅仅提高代码执行速度
口在知道答案后就停止执行判断。
口根据各种情况的出现频率对case语句和ifthen-else串排序。
口比较相似逻辑结构的性能。
口使用惰性求值。
口将循环中的if判断转到外部。
展开循环。
口将循环内部所做的工作减少到最低限度。
口在查找循环中使用哨兵。
口把执行最为频繁的循环放在嵌套循环的最里面
口减轻内层循环的强度。
口将多维数组改为一维数组。
最大限度减少数组索引
口为数据类型扩充索引。
口对频繁使用的值进行缓存。
利用代数恒等式。
口降低逻辑和数学表达式的强度。
注意系统调用。
口用内联子程序重写代码。
The More Things Change, the More They Sta
26.7 the Same
变得越多,事情反而越没变
你可能会希望,在我写《代码大全》的第1版之后的十年时间里,系统的性
能特性已经以某种方式发生了变化。计算机的运行速度已经发生了翻天覆地的改
变,可用的内存对很多程序而言也绰绰有余在第1版中,我通常会运行本章的
测试一万次到五万次,由此得出有意义的可度量结果。而在第2版中,绝大多数
测试会运行一百万次到一亿次。当你需要让某个测试跑上一亿次才能得出一个可
测量的结果时,你不得不产生疑问,有谁会注意这些优化工作对实际程序所产生
的影响。如今的计算机已经如此强悍,对很多常见类型的程序来说,本章所讨论
的性能优化提升的意义已如明日黄花
代码大全(第2版

<==========================680end ==============================>
<==========================681start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
644
第26章代码调整技术
另一方面,性能也是个永恒的话题。编写桌面应用程序的人可以对优化毫
不关心,但那些为嵌入式系统、实时系统和其他对代码有着严格速度和资源限制
的系统编写代码的人仍然可以从中获益。
自 Donald Knuth在1971年公布了他对 Fortran程序的研究成果之后,对每一
次代码调整所产生的影响进行量化评估已经成了性能优化工作的永恒信条。根据
本章的测量结果,比起10年以前,任何特定优化的效果实际上都更加不可预测。
每一步代码调整所产生的影响都受制于编程语言、编译器、编译器的版本、代码
库、库版本以及编译器设置等各种因素
代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、
可维护性方面的代价。由于每一次调整后需要对性能进行重新评估,代码调整还
引入了巨额的管理维护开销。
我已经体会到,恪守“对每一次的改进进行量化”的准则,是抵御思考成熟
前匆忙优化之诱惑的法宝,这一准则也帮助我坚守编写清晰简单代码的一贯作风。
如果某项优化非常重要,值得为它付出剖析和对优化效果进行量化测量的代价,
那么只要优化有效,我们还是可以去做的。但是,如果某项优化的重要性不够,
不值得为它去做效能剖析,那么就不值得为它付出可读性、可维护性和其他代码
特性恶化等方面的代价。未经测量的代码优化对性能上的改善充其量是一次投机,
然而,其对可读性等产生的负面影响则确凿无疑。
Additional Resources
更多资源
cc2e.com/2679
我最喜欢的关于代码调整的参考资料就是《Writing Efficient Programs》
(Bentley, Englewood Cliffs, Nnj: Prentice Hall,19)。该书已经绝版,但如果你能找
得到,绝对值得一读。该书对代码调整领域涉猎甚广,乃此主题抗鼎之作。Bentley
给出了用执行速度换取空间,和用空间换取执行速度的方法,并提供了许多通过
重新设计数据类型来提高速度和减小空间占用的实例。他的论述方式比这里的更
为有趣,他的趣闻轶事也极吸引人。他描述了对几个子程序的一系列优化步骤,
使你可以看到针对一个问题的第一次、第二次和第三次优化尝试 Bentley在这本
135页的书中围绕代码调整这一主题自由挥洒,闲庭信步。这本书的信噪比异乎
寻常的高这本书是真正值得每位线程序员所拥有的珍宝。
Bentley的《 Programming Pearls》,2ded.的附录4(Boston,ma: Addison-Wesley-
2000)本书包含了该书作者对早期著作中代码调整规则的总结。
代码大全(第2版)

<==========================681end ==============================>
<==========================682start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo. com!^.com!仅供试看^
要点
645
cc2e.com/2686
你还可以找到一系列讨论特定优化方法的书籍。有的已经列在下面了,旁边
的链接还能够提供最新的书目列表。
Booth, Rick. Inner Loops: A Sourcebook for Fast 32-bit Software Development).
Boston, MA: Addison-Wesley, 1997
Gerber, Richard.《 Software Optimization Cookbook:high- -Performance Recipes
for the Intel Architecture). Intei Press, 2002.
Hasan, Jeffrey and Kenneth Tu. Performance Tuning and Optimizing ASP.NET
pplications). Berkeley, CA: Apress, 2003.
Killelea, Patrick. Web Performance Tuning》,2ded. Sebastopol,ca:o' Reilly&
Associates, 2002
Larman, Craig and Rhett Guthrie. Java 2 Performance and Idiom Guide.
Englewood Cliffs, NJ: Prentice Hall, 2000.
Shirazi,jack. Java Perforance Tuning》. Sebastopol,ca:o 'Reilly'&
Associates, 2000.
Wilson, Steve and Jeff Kesselman. Java Platform Performance: Strategies and
Tactics). Boston, MA: Addison-Wesley, 2000.
Key Points
要点
优化结果在不同的语言、编译器和环境下有很大差异。如果没有对每一次的
优化进行测量,你将无法判断优化到底是帮助还是损害了这个程序。
第一次优化通常不会是最好的。即使找到了效果很不错的,也不要停下扩大
战果的步伐。
代码调整这一话题有点类似于核能,富有争议甚至会让人冲动。一些人认
为代码调整损害了代码可读性和可维护性,他们绝对会将其弃之不用。其他
人则认为只要有适当的安全保障,代码调整对程序是有益的。如果你决定使
用本章所述的调整方法,请务必谨慎行事。
代码大全(第2版)

<==========================682end ==============================>
<==========================683start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c ^.com!仅供试看^

<==========================683end ==============================>
<==========================684start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
第6部分
System Considerations
系统考虑
本部分内容
■第27章程序规模对构建的影响
649
■第28章管理构建
.661
■第29章集成
689
■第30章编程工具
709
代码大全(第2版)

<==========================684end ==============================>
<==========================685start==============================>

该书下载自-书部落分享计算机经典巨著! ! --www.shubulo..com!仅供试看^

<==========================685end ==============================>
<==========================686start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo. com!^ .com!仅供试看^个
How Program Size Affects
Construction
第27章
程序规模对构建的影响
cc2e.com/2761/2761内容
27.1交流和规模:第650页
27.2项目规模的范围:第651页
27.3项目规模对错误的影响:第651页
27.4项目规模对生产率的影响:第653页
27.5项目规模对开发活动的影响:第654页
相关章节
软件构建的前期准备:第3章
辨明确定你所从事的软件类型:第3.2节
■管理构建:第28章
软件开发的规模扩大并不是像“拿一个小项目来,然后增大它的每一部分”
那样简单。假设你花费20个人月开发了一套有2500行代码的 Gigatron(千兆子)
软件包,并在领域测试中找出了500个错误。再假设 Gigatron1.0很成功, Gigatron
2.0也一样成功,现在你正在着手开发 Gigatron Deluxe版,该版本将对该程序做出
重大更新,预计将有250000行代码。
虽然它的规模是最初 Gigatron的10倍,但是开发 Gigatron Deluxe版的工作量
却不是原有工作量的10倍;而是30倍。此外,整体工作量增长为30倍并不意味
着构建活动的工作量就会增长为30倍。很可能是,构建活动的工作量增长为25倍,
架构和系统测试工作量增长为40倍。你所得到的错误数量也不会增长为10倍,而
会是15倍甚至更高。
如果你习惯于开发小项目,那么你的第一个中大型项目有可能严重失控,它
不会像你憧憬的那样成功,而会变成一头无法控制的野兽。本章将告诉你会遇到
些什么野兽,以及到哪里去找鞭子和铁链来驯服它。与此相对的是,如果你已经
习惯于开发大型项目,那么你所用的方法可能对小项目来说太正规了。本章将讲
述怎样进行节约,防止小项目被自己的额外负担压垮。
代码大全(第2版)

<==========================686end ==============================>
<==========================687start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看
650
第27章程序规模对构建的影响
27.1
Communication and Size
交流和规模
如果项目中只有你一个人,那么唯一的交流路径就是你和你顾客的交流,除
非你把连接左右大脑半球的胼胝体也算做交流路径。随着项目成员数目的增加,
交流路径的数量也随之增加。但是二者的关系并不是加性的,而是乘性的。即交
流路径的条数大致正比于人数的平方,如图27-1所示。
6
1
两名程序员之
三名程序员之
四名程序员之
间的交流路径
间的交流路径
间的交流路径
45
10
五名程序员之
十名程序员之
间的交流路径
间的交流路径
图27-1交流路径的数量与项目成员数量的平方大致成正比
可以看出,两人项目的交流路径只有1条。五人项目的交流路径有10条。十
人项目的交流路径有45条,前提是每个人都会与其他所有人交谈。有10%的项
POINT月里的程序员超过50名,其潜在的交流路径就至少有1200条。交流路径越多,
你花在交流上的时间就越多,因交流而出错的机会也就越大更大的项目要求采
取一些组织技术来改善交流效率,或者有意识地对其加以限制。
改善交流效率的常用方法是采用正式的文档不是让50个人以各种可能方式
相互交流,而让他们阅读和撰写文档。有些文档是文本,有些是图形有些文档
需要打印出来,有些则是电子格式。
代码大全(第2版)

<==========================687end ==============================>
<==========================688start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
27.3项目规模对错误的影响
651
27.2
Range of Project Sizes
项目规模的范围
你所从事的项目的规模具有典型性吗?项目规模的范围很宽,这也就意味着不
能把任何一种规模视为典型。评估项目规模的方法之一是考虑项目团队的规模。
以下是不同规模的团队所完成项目百分比的粗略统计:
团队规模
占项目总数的粗略比例
1-3
25%
4-10
30%
11-25
20%
26-50
15%
50+
10%
来源:节选自“ Survey of Software Engineering Practice: Tools, Methods,and
Results(Beck and Perkins1983)、《 Agile Software Development Ecosystems》
(Highsmith 2002), (Balancing Agility and Discipline)(Boehm and Turner 2003).
项目规模的数据中有一点可能不太直观,那就是“不同规模的项目百分比”
和“不同规模项目中程序员的数量的百分比是有区别的。由于一个大型项目雇
佣的程序员人数多于小项目,因此,大项目的用人数量占全部程序员数量的很大
比重。下面是在各种规模项目中工作的程序员的粗略比例:
团队规模
占程序员总数的粗略比例
1-3
5%
4-10
10%
11-25
26-50
20%
50+
50%
来源:数据来自“ Survey of Software Engineering Practice: Tools, Methods,and
Results"(Beck and Perkins 1983), Agile Software Development Ecosystems))
(Highsmith 2002), Balancing Agility and Discipline (Boehm and Turner 2003).
27.3
Effect of Project Size on Errors
项目规模对错误的影响
交叉参考关于项目的规模既会影响错误的数量,也会影响错误的类型。你也许不曾想到错误类
“错误”的更多
细节,参见第型也会受到影响,然而随着项目规模的增大,通常更大一部分错误要归咎于需求和设
22.4节“典型错计,如图27-2所示。
误”。
译注:《 KAgile Software Development Ecosystems》中译本《敏捷软件开发生态系统》,机械工业出版
社。另一本书见章末“更多资源”一节。
代码大全(第2版)

<==========================688end ==============================>
<==========================689start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo.com!^^.com!仅供试看^
652
第27章程序规模对构建的影响
100%
Construction
在某些项目中,
各种活动
这一部分错误
引发的错误
也可能来自
Design
“构筑构建”
0%
Requirements
2K 8K 32K
128K512K
项目规模(以代码行数计)
图27-2随着项目规模的增大,通常需求和设计犯的错误会更多。有些时候,错误仍
然主要来自构建(Boehm1981, Grady1987, Jones1998)
响不
在小项目中,构建错误大约占所有被发现错误的75方法论对于代码质量的影
响不大,对应用程序质量影响最大的通常是编写程序的各个开发者的技能(Jones
HARD DATA 1998).
在更大的项目中,构建错误占错误总数的比例逐步下降到50%左右;而需求错误
和架构错误则弥补了其中差额。推测起来大概是因为项目越大,所需的需求分析和架
构设计也就越多,所以这些活动产生错误的机会就会相应地增加了。然而,在一些非
常大的项目里,构建错误所占的比重仍然很大;有时候就是在包含500000行代码的
项目中,甚至会有75%的错误来源于构建活动(Grady1987)。
正如缺陷的种类会随项目规模而变一样,缺陷的数量也会随之变化。你也许会很
自然地认为,如果一个项目的规模是另一个项目的两倍,那么其中错误的数量也会是
KEY POINT两倍。但是缺陷密度每1000行代码所包含的缺陷数量会增加。项目规模变
成原来的两倍,其错误数量很可能会不止是两倍。表27-1显示了不同规模的项目中,
缺陷密度的预期范围。
表27-1项目规模和典型的错误密度
项目大小(以代码行数计)
典型的错误密度
少于2000行
每千行0到25个错误
2000到16000行
每千行0到40个错误
16000到64000行
每千行0.5到50个错误
64000到512000行
每千行2到70个错误
512000行或者更多
每千行4到100个错误
来源:“Program Quality and Programmer Productivity(oes1977), KEstimating
Software Costs)(Jones 1998)
代码大全(第2版)

<==========================689end ==============================>
<==========================690start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看^
27.4项目规模对生产率的影响
653
交叉参考表中数本表数据来源于一些特定的项目,这些数字很可能与你所开发的项目的实际数据
据代表的是平均情不太相似。不过,作为行业的一个侧影这些数据还是很能说明问题的。它表明随着
况。一些机构报告的
错误率要比本表中项目规模的增长,错误的数量也会随之显著增长,特大型项目的每千行错误数量甚至
最低的错误率低请会达到小项目的四倍。对于大项目,需要比小项目花更多的精力,才能维持同样的错
参考第22.4节“你
应该期望能出现多误率。
少错误”
27.4
Effect of Project Size on Productivity
项目规模对生产率的影响
在与项目规模的关系方面,生产率的情况与软件质量很相似。对于小项目(2000
行代码或者更少),影响生产率的最大因素莫过于单个程序员的技巧(Jones1998)
随着项目规模和团队规模的增大,组织方式对生产率的影响也将随之增大。
项目多大时团队规模就会开始影响生产率呢?在“Prototyping Versus Specifying:a
Multiproject Experiment(原型vs.详细说明:多个项目的实验)”一文中, Boehm、gray
HARD DATA和 Seewaldt报告说,完成项目的小型团队的生产率要比大型团队高出39%。那么这些
团队各有多少人呢?答案是:小项目两个人,大项目三个人(1984)。表27-2就项目
规模和生产率的一般关系做了进一步说明。
表27-2项目规模和生产率
项目大小(以代码行数表示)每人年的代码行数(括号里是Cocomo均值)
1K
250025000(4000)
200025000(3200)
100K
100020000(2600)
1000K
70010000(2000)
10000K
3005000(1600)
来源:数据选自《 Measures for Excellence》( Putnam and Meyers,1992),《 Industrial
Strength Software)(Putnam and Meyers, 1997), < Cost Estimation with Cocomo
)(Boehm et al. 2000), "Software Development Worldwide: The State of the Practice
(Cusumano et al. 200)
生产率主要取决于你所从事的软件类型、人员素质、编程语言、方法论、产品复
杂度、编程环境、工具支持、计算“代码行数”的方法、把非程序员的支持工作计入“每
人年的代码行数”的方法,以及许多其他因素因此表27-2中的数据呈现出了很大的
差异性。
不过,表中数据显示出的一般趋势还是很明显的。小项目的生产率会比大项目高
出2至3倍,并且最小的项目和最大的项目的生产率差距可能达到5到10倍之巨。
代码大全(第2版)

<==========================690end ==============================>
<==========================691start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^^.com!仅供试看^
654
第27章程序规模对构建的影响
27.5
Effect of Project Size on Development Activities
项目规模对开发活动的影响
如果你从事的是一个单人项目,那么对项目成败影响最大的因素就是你自己。如
果你在一个具有25个人的项目中工作,那么你仍然可能是最大的影响因素;但更有可
能的是,没人能够独享成功的奖牌;组织结构对项目成败的影响力更大。
Activity Proportions and Size
活动比例和项目规模
项目越大,所需要的正式交流越多,所需进行的各种活动的种类也会急剧变化。
图27-3展示了不同规模项目中的各种开发活动所占的比例。
100%
系统测试
集成
开发时间的百分比开发者测试
编码和调试
架构
详细设计
构建
0%
2K
8K
32K128K512K
项目大小(以代码行数计)
图27-3小项目以构建活动为主。更大的项目需要做更多的架构、集成工作和系统测
试工作才能成功。图中并未显示“需求工作”,因为其工作量并不(像其他
活动那样)直接是程序大小的函数( Albrecht1979; Glass1982; Boehm、
Gray and Seewaldt 1984; Boddie 1987; Card 1987: McGarry, Waligora
and McDermott 1989; Brooks 1995; Jones 1998; Jones 2000; Boehm et
al.2000
对于小型项目,构建尤为最主要的活动,它占了整个开发时间的差不多65%。对
于中型项目,构建仍是处于主导地位的活动,但是它所占的比例已经下降到了大约
KEY POINT50%对于非常大型的项目,架构集成和系统测试占去了更多的时间,而构建活动
则变得不再那么占主导地位了。简而言之,随着项目规模的增大,构建活动在整个工
作量中所占的比重将逐渐减小。从这幅图来看如果一直往右延伸的话,构建似乎就
会最终消失,因此,为了保住我的工作,我就把它画到512K处为止。
构建活动的主导地位下降的原因是,随着项目增大,构建活动详细设计、编
码、调试和单元测试将会按比例增长,但是其他很多活动增长得更快。图27-4显
示了这一点。
代码大全(第2版)

<==========================691end ==============================>
<==========================692start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
27.5项目规模对开发活动的影响
655
其他活动
工作量
构建
规模
图27-4软件构建的工作量与项目大小呈近似线性的关系。其他活动的工作量随项目
规模扩大而非线性地增加
规模相近的项目会执行相似的活动,但是随着项目规模不同,其所需要进行的活
动的种类也会有很明显的差异。正如在本章引言中提到的,当 Gigatron Deluxe版的规
模达到最初 Gigatron的10倍时,其构建活动的工作量是原来的25倍,计划的工作量
是原来的25到50倍,集成的工作量是30倍而架构和系统测试的工作量则为40倍。
不同活动的比例发生变化,是因为它们对于不同规模的项目的重要性不一样Barry
Boehm和 Richard Turner发现,对于10000行代码左右的项目来说,把5%的项目成本
花在架构上会使整个项目的成本最低。但是对于100000行代码左右的项目而言,需要
在架构上耗去15%到20%的工作量才能产生最佳结果( Boehm and Turner2004)
随着项目规模的增加,下面这些活动的工作量增长超过线性:
■交流
HARD DATA
■计划
■管理
需求分析
系统功能设计
■接口设计和规格说明
■架构
■集成
消除缺陷
■系统测试
■文档生成
不论项目的规模如何,有些技术总是很有价值的有训练的编码实践、让其
他开发者审查设计和代码、好的工具支持,以及使用高级语言。这些技术对小项目很
有价值,对大项目的价值更是无法衡量。
代大全(第2版)

<==========================692end ==============================>
<==========================693start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
656
第27章程序规模对构建的影响
Programs, Products, Systems, and System Products
程序、产品、系统和系统产品
深入阅读关代码行数和团队规模并不是影响项目大小的仅有的因素。另一个更敏感的影响因
这一观点的另一素是最终软件的质量和复杂度。 Gigatron的最初版本,即 Gigatron初级版,可能连开
种解释,请参阅
人月神话》发带调试只花了1个月时间。它是由一个人开发、测试并撰写文档的程序。那么,既
(Bos195)然开发2500行的 Gigatron初级版只用了1个月,为什么开发完整的、具有2500行
第1章。
代码的 Gigatron要花20个月呢?
最简单的一类软件是一个单一的“程序”,只有它的开发者使用它,或者其他少
数几个人非正式地使用它。
稍复杂些的一类程序是软件“产品”,它打算供给最初开发者以外的人员使用。
软件产品的使用环境也与开发环境不同。在发布之前要做充分的测试,要有文档,并
且可以由其他人来维护。开发软件产品的成本大约是开发“软件程序”的3倍。
更复杂一些的是开发一组能够结合起来工作的程序。这样一组程序通常称为软件
“系统”。开发个系统要比开发一个简单的程序复杂得多,因为开发各个组成部分
之间的接并把它们集成起来会很复杂。大体上,系统的开发成本也是简单程序的开
发成本的3倍。
如果开发的是“系统产品”,它既要具有单一产品的精致特征,又要拥有一套系
统所需具备的多个成分。系统产品的开发成本大约是简单程序的9倍(Brooks1 1995,
HARD DATA Shull et al. 2000).
没能认识到程序、产品、系统以及系统产品在精致度和复杂度上的区别,是导致
估算出偏差的一个常见原因。程序员用他们开发“程序”的经验来估计开发一套系统
产品的进度,可能会低估10倍。当你考虑下面这个例子时,请参考图27-3(在第654
页)。如果你依据自己写2000行代码的经验来估计开发一个2000行的程序需要多长
时间,那么你估计的时间将只是“为了开发该程序而实际需要进行的全部活动的总耗
时”的65%。写2000行代码的时间不等于开发一个具有2000行代码的程序的时间。
如果你不把“非构建”活动的用时考虑进去,开发时间将会比你的估计要多出50%。
随着项目规模的增长,构建活动将只占项目总工作量的一小部分。如果你完全依
照构建的经验来做估算,估算误差就会增加。如果你用自己200行代码的构建经验来
估算开发32000行代码程序所需的时间,你的估算结果将只是所需全部时间的50%;
开发过程的耗时将比你佔计的多100%。
代码大全(第2版)

<==========================693end ==============================>
<==========================694start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo...com!仅供试看^
27.5项目规模对开发活动的影响
657
这里所说的估算误差,其产生原因全在于你不理解“项目规模对开发大型程序所
造成的影响”。如果除此之外你还没有考虑到开发一个“产品”比仅仅开发一个“程
序”需要做史多的“抛光”工作,那么误差将会再增长至3倍,甚至更多。
Methodology and Size
方法论和规模
各种方法论都被用于不同大小的项目。对于小项日,方法论的应用显得很不经
意并且趋于本能。对于大项目,它们的应用变得十分严格,并且计划得非常细
有些方法论是很宽松的,程序员察觉不到自己正在使用它。也有些程序员说一些
方法论太刻板了,他们不会去碰。程序员可能的确没有有意识地选择某种方法论,然
而,任何一种编程方法都可以算是方法论,而不论该编程方法有多随意或者原始。早
上爬出被窝后去上班就是一种最初级的方法论,尽管它不是特别有创意。那些坚持不
用方法论的程序员,事实上只是在避免明确地选择某种方法论没有谁能做到完全
不用方法。
形式化的方法不一定总是有趣,而且如果用得不合适也可能得不偿失。然而,项
目越大,复杂度也越大,也就越要求有意识地去关注方法论建造摩天人楼的方法和
POINT搭狗窝的方法是不一样的。不同规模的软件项目也是如此。对于大项目来说,如果不
有意识地去选择方法论,就将无法完成任务。成功的项目计划人员会明确为大型项目
选择合适的策略。
在社交场合,活动越正式,你所穿的服装就会越不舒服(高跟鞋、领带等等)。
在软件开发领域里,项目越正规,你不得不写的文件的数量也会越多,用于确认你已
经完成了白己的工作。 Capers Jones指出,代码量为1000行的项目需要在文书工作
(paperwork)上花费7%的精力,而代码量为10000行的项目的这一比例则是26%(Jones
1998)。
做这些文书工作可不是因为文档写起来有趣。撰写它们是由于图27-1所示的
现象直接引起的:你要协调的人员越多,那么为了与他们相互协调,所需要写的文档
也就越正规。
你撰写文档的目的并不在于文档本身。比如,写配置管理计划的目的不是要锻炼
你的写作肌。先写计划的关键在于,它能迫使你细考虑配置管理,并且把你的计划
向每个人解释。文档只是你在计划并构建软件系统过程中所做的那些真实工作的种
有形的副产品罢了。如果你感觉自己只是在履行写作手续,写出来的内容也很泛泛无
奇,那肯定是什么地方出了问题。
代码大全(第2版)

<==========================694end ==============================>
<==========================695start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo...com!仅供试看^
658
第27章程序规模对构建的影响
并不是越“多”越好,至少对于方法论而言是这样的 Bary Boebm和 Richard Turner
对比了敏捷(agile)和计划驱动(plan--driven)的方法论,他们警告说,如果你以小的方法
KEY POINT
论为起点,把它逐渐扩充为适用于大项目,那么其效果会好于以一个囊括一切的方法
论为起点,把它缩减到适用于小项目(Bochm和 Turner2004)。有些软件学究们会谈
到“轻量级”和“重量级”的方法论,但在实践中最关键的是要考虑你的项目的实际
规模和类型,然后找出“适量级”的方法论
Additional Resources
更多资源
cccm276请使用以下资料,以进一步探索本章的主题。
Boehm, Barry and Richard Tumer. Balancing Agility and Discipline: A Guide for the
Perplexed. Boston,ma: Addison-Wesley-,2004 Boehm和 Turner描述了项目规模对使用敏
捷和计划驱动的方法有何影响,也涉及其他一些与敏捷和计划驱动有关的话题。2
Cockburn, Alistair. KAgile Software Development). Boston, MA: Addison-Wesley,
2002第4章描述与选取适当的项目方法论有关的问题,包括项目规模。第6章介绍
Cockburn的 Crystal系列方法论,即一系列用于开发不同规模、不同危险程度的项
目的详细方法。3
Boehm, Barry W. Software Engineering Economics), Englewood Cliffs, NJ: Prentice
hal,1981. Boehm在此书中广泛地讨论了软件开发过程中的成本、生产率,项目规模
及其他变量对质量的影响。书中讨论了项目规模对构建和其他活动的影响。第11章非
常精彩地解释了软件因规模扩大而增加成本费用的现象有关项目规模的其他信息散
布于书中的其他章节 Boehm在其2000年出版的《 Software Cost Estimation with Cocomo
1》一书中对他的Cocomo评估模型给出了更多最新的资料,但是前一本书就该模型的
背景讨论为深入,这些信息仍然适用。4
Jones, Capers. Estimating Software Costs) New York, NY: McGraw-Hill, 1998.
本书用了很多的图表来深入解析软件开发生产率的根源。如果特别关心“项规模带
来的影响”,那么 Jones1 1Programming986年出版的《 Productivity书第3章的“the
Impact of Program Size”节中就此做出了精彩论述。
Brooks, Frederick P., Jr. (The Mythical Man-Month: Essays on Software Engineering,
Anniversary Edition》(2ded.). Reading,m: Addison-Wesley-,1995. Brooks IBM的
OS/360开发项目经理,这是一个花费了50人年的庞大项目。他讲述了与大、小团
队相关的管理问题,并在这本精彩的散文集中非常生动地描绘出了一个首席程序员团
队的样子。5
2译注:影印版《平衡敏捷和纪律》,中国电力出版社;中译本《平衡敏捷与规范》,清华大学出版社
3译注:中译本《敏捷软件开发》,人民邮电出版社。
4译注:中译本分别为《软件工程经济学》、《软件成本估算: COCOMO模型方法》,机械工业
出版社。
5译注:中译本《人月神话》,清华大学出版社。
代码大全(第2版

<==========================695end ==============================>
<==========================696start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看
要点
659
DeGrace, Peter, and Leslie Stahl. Wicked Problems, Righteous Solutions: A
Catalogue of Modern Software Engineering Paradigms). Englewood Cliffs, NJ: Yourdon
Press,1990.正如书名所示,这本书收编了软件众多开发方法。如本章所说明的那样,
你使用的方法应该随着项目规模的变化而变化 DeGrace和 Stahl更清晰地说明了这一
点。第5章的“Attenuating and Truncating”一节讲述了如何根据项目的规模和正规程
度来定制软件开发过程。书中包含了对NASA和美国国防部的模型的讲解,并且举了
很多启发性的例子。
Jones, T. Capers. "Program Quality and Programmer Productivity." IBM Technical
cP0274197428ones《oriaLzPvgrammJng.764(jauary1977):42-78.也见于ones《tutorial:programming
Productivity: Issues for the Eighties), 2d ed Los Angeles, CA: IEEE Computer Society
Press,1986.这是首篇深入分析大项目与小项目的支出形态(工作量分配模式)不同的
原因的文章。其中深入讲述了大项目和小项目的诸多不同之处,包括需求、质量保证
手段等。其内容有些陈旧,但仍然很有趣。
Key Points
要点
随着项目规模的扩大,交流需要加以支持。大多数方法论的关键点都在于减
少交流中的问题,而一项方法论的存亡关键也应取决于它能否促进交流。
在其他条件都相等的时候,大项目的生产率会低于小项目。
在其他条件都相等的时候,大项目的每千行代码错误率会高于小项目
在小项目里的一些看起来“理当如此”的活动在大项目中必须仔细地计划
随着项目规模扩大,构建活动的主导地位逐渐降低。
放大轻量级的方法论要好于缩小重量级的方法论最有效的办法是使用“适
量级”方法论。
代丹大全(第2版)

<==========================696end ==============================>
<==========================697start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^

<==========================697end ==============================>
<==========================698start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
Managing Constructi
第28
管理构建
cc2ecom/2836内容
28.1鼓励良好的编码实践:第662页
28.2配置管理:第664页
28.3评估构建进度表:第671页
28.4度量:第677页
28.5把程序员当人看:第680页
28.6管理你的管理者:第686页
相关章节
软件构建的前期准备:第3章
辨明你所从事的软件的类型:第3.2节
程序规模:第27章
软件质量:第20章
在过去的几十年里,软件开发的管理已经变成一项令人生畏的挑战如图28-1
所示,有关软件项目管理的一般论题超出了本书的范围,但是本章将讨论与构建
直接相关的一些特定管理论题。如果你是一名开发人员,本章将帮助你了解管理
者需要考虑的一些问题。如果你是一名管理者,本章将帮助你了解开发人员是如
何看待管理者的,以及如何才能有效地管理构建。由于本章涵盖的内容范围非常
广,其中的几小节还将告诉你到哪里去找更多的资料。
一般管理
一软件管理
构建管理
图28-1本章讲述与构建相关的软件管理话题
代码大全(第2版)

<==========================698end ==============================>
<==========================699start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
662
第28章管理构建
如果你对软件管理有兴趣,那么一定要读第3.2节“辨明你所从事的软件类
型”,以便能够理解传统的顺序型开发方法和现代的迭代式开发方法之间的差异。
另外还要读第20章“软件质量概述”以及第27章“程序规模对构建的影响”。
质量目标和项目规模都会显者影响这个软件项目的管理方式。
28.
Encouraging Good Coding
鼓励良好的编码实践
由于代码是构建活动最主要的产出,因此,管理构建中的一个关键问题就是
“如何鼓励良好的编码实践?”一般而言,从管理的角度出发,强制采用一套严
格的技术标准并不是个好主意。程序员倾向于将管理者视为技术进化的低级层次,
认为他们大概处于单细胞生物和冰川期灭绝的猛犸象之间。如果建立一套编程标
准,程序员就必须遵循之。
如果项目中有人要制定标准,那么应该由一位受人尊敬的架构师来做,而不应
该由管理者来做。在软件项目中,“专家层”起的作用至少与“管理层”相同。如
果项目组把这位架构师视为该项目的精神领袖那么通常就会接受他制订的标准。
如果你决定这么做的话,一定要保证这位架构师真是受人尊敬的。有时项目
的架构师只是一名在项目中待的时间非常长的资深闲杂人士,他已经不再接触与
产品编码有关的事务了。由这种“架构师”定义出来的标准是会受到程序员怨恨
的,因为他根本不了解程序员正在做的工作。
Considerations in Setting Standards
设定标准的考虑事项
标准对于有些组织非常有用,而对于其他组织则用处不大一些程序员很乐
意接受标准,因为标准有助于减少项目中随意出现的诸多分歧。如果你的团队反
对采用严格的标准,那么可以考虑一些其他的选择,如灵活的指导原则、一些建
议(而非指导原则),或者一组能够表现最佳实践的例子。
Techniques for Encouraging Good Coding
鼓励良好的编码实践的技术
本节讲解推行良好的编码实践的若干技术,这些编码实践比呆板的编码标准
更容易实行。
交叉参考关于
给项目的每一部分分派两个人如果每行代码都由两个人共同完成,那么你
结对编程的更多可以保证至少有两个人认为这段代码是能工作的,而且是可读的。两人组队的办
细节,请参阅第
21.2节“结对编法有结对编程、导师带学生、 buddy-system-(伙伴系统,各负责另一人之安全的两
程”。
人同行制)复审等。
代码大全(第2版)

<==========================699end ==============================>