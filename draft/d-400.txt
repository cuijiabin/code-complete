<==========================300start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.c.com!仅供试看^
11.1选择好变量名的注意事项
263
心的程序员会避免使用短的变量名。
对位于全局命名空间中的名字加以限定词如果你在全局命名空间中定义了
一些变量(具名常量、类名等),那么请考虑你是否需要采用某种方式对全局命名
空间进行划分,并避免产生命名冲突。在C++和C#里,你可以使用 namespace
关键字来划分全局命名空间。
C++示例:使用 namespace关键字来划分全局命名空间
namespace UserInterfaceSubsystem
1/ lots of declarations
namespace DatabaseSubsystem
ii lots of declarations
如果你同时在 UserInterfacesubsystem和 DatabaseSubsystem命名空间里声
明了 Employee类,那么你可以通过写 UserInterfaceSubsyst:: Employee或者
Databasesubsystem:: Employee来确定引用哪一个 Employee在java中,你也可
以通过使用包(package)来达到同样的目的。
在那些不支持命名空间或者包的语言里,你同样也可以使用命名规则来划分
全局命名空间。其中一项规则要求为全局可见的类加上带有子系统特征的前缀。
用户接口部分的雇员类可能命名为 uiEmployee,据库部分的雇员类可能命名为
dbEmployee,这样做能把全局命名空间的命名冲突降到最低。
Computed-Value Qualifiers in Variable Names
变量名中的计算值限定词
很多程序都有表示计算结果的变量:总额、平均值、最大值,等等。如果你
要用类似于 Total、Sum、 Average、Max、 Min Record、 String、 Pointer这样
的限定词来修改某个名字,那么请记住把限定词加到名字的最后。
这种方法具有很多优点。首先,变量名中最重要的那部分,即为这一变量赋
予主要含义的部分应当位于最前面,这样,这一部分就可以显得最为突出,并会
被首先阅读到。其次,采纳了这一规则,你将避免由于同时在程序中使用
totalRevenue和 revenueTotal1而产生的歧义。这些名字在语义上是等价的,上
述规则可以避免将它们当作不同的东西使用还有,类似 revenueTotal1(总收入)
expenseTotal(总支出)、 revenueAverage(评价收入)、 expenseAverage(平
均支出)这组名字的变量具有非常优雅的对称性。而从 totalRevenue
expenseTotal、 revenueAverage、 averageExpense这组名字中则看不出什么规
代码大全(第2版)

<==========================300end ==============================>
<==========================301start==============================>

该书下载自-书部落分享计算机经典巨著! ! --www.shubulo..com!仅供试看^
264
第11章变量名的力量
律来。总之,一致性可以提高可读性,简化维护工作。
把计算的量放在名字最后的这条规则也有例外,那就是Num限定词的位置已
经是约定俗成的。Num放在变量名的开始位置代表一个总数: numCustomers表示
的是员工的总数。Num放在变量名的结束位置代表一个下标: customerNum表示
的是当前员工的序号。通过 numCustomers最后代表复数的s也能够看出这两种
应用之间的区别。然而,由于这样使用Nu常常会带来麻烦,因此可能最好的办
法是避开这些问题,用 count或者 Total来代表员工的总数,用 Index来指代某
个特定的员工。这样, customerCount就代表员工的总数, customerIndex代表
某个特定的员工。
Common Opposites in Variable Names
变量名中的常用对仗词
交叉参考用于
对仗词的使用要准确。通过应用命名规则来提高对仗词使用的一致性,从而
子程序名的类似提高其可读性。比如像 begin/end这样的一组用词非常容易理解和记忆。而那些与
对仗词的清单,见
第7.3节中的“准常用语言相去甚远的词则通常很难记忆,有时甚至会产生歧义。下面是些常用
确使用对词”的对仗词:
■ begin/end
first/last
locked/unlocked
■min/max
next/previous
old/new
opened/closed
visible/invisible
source/target
source/destination
■up/down
11.2
Naming Specific Types of Data
为特定类型的数据命名
在为数据命名的时候,除了通常的考虑事项之外,为一些特定类型数据的命
名还要求做出一些特殊的考虑。本节将讲述与循环变量、状态变量、临时变量、
布尔变量、枚举类型和具名常量有关的考虑事项。
代码大全(第2版)

<==========================301end ==============================>
<==========================302start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看^
11.2为特定类型的数据命名
265
Naming Loop Indexes
为循环下标命名
交叉参考关于循环是一种极为常见的计算机编程特征,为循环中的变量进行命名的原则也
循环的详细讨论,由此应运而生。i、j和k这些名字都是约定俗成的:
见第16章“控制
循环”
java示例:简单的循环变量名
(i= firstItem; i lastItem; i++
for
atal i =0;
如果一个变量要在循环之外使用,那么就应该为它取一个比ij或者k更有
意义的名字。举个例子,如果你在从文件中读取记录,并且需要记下所读取记录
的数量,那么类似于 recordCount这样的名字就很合适:
java示例:描述性较好的循环变量名
recordcount =0:
while moreScores()
scorel recordcount GetNextScore
recordcount++;
/1 lines using recordcount
如果循环不是只有几行,那么读者会很容易忘记i本来具有的含义,因此你
最好给循环下标换一个更有意义的名字。由于代码会经常修改、扩充,或者复制
到其他程序中去,因此,很多有经验的程序员索性不使用类似于i这样的名字。
导致循环变长的常见原因之一是出现循环的嵌套使用。如果你使用了多个嵌
套的循环,那么就应该给循环变量赋予更长的名字以提高可读性:
ava示例:嵌套循环中的好循环变量名
for teamIndex =0; teamIndex teamCount; teamInd
for( eventIndex0; event Index eventCountteamIndex]:e
Endex++ )
score[ teamIndex ] event Index
谨慎地为循环下标变量命名可以避免产生下标串话( index cross-ttalk)的常见
问题:想用j的时候写了i,想用i的时候却写了同时,这也使得数据访问变
得更加清晰: score[teamIndex][event Index]要比 score[i][]给出的信息更
多。
如果你一定要用i、j和k,那么不要把它们用于简单循环的循环下标之外的
任何场合——这种传统已经太深入人心了,一旦违背该原则,将这些变量用于其
他用途就可能造成误解。要想避免出现这样的问题,最简单的方法就是想出一个
比i、j和k更具描述性的名字来。
代码大全(第2版)

<==========================302end ==============================>
<==========================303start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
266
第11章变量名的力量
Naming Status Variables
为状态变量命名
状态变量用于描述你的程序的状态。下面给出它的命名原则。
为状态变量取一个比flag更好的名字最好是把标记(flag)看做状态变量。
标记的名字中不应该含有flag,因为你从中丝毫看不出该标记是做什么的。为了
清楚起见,标记应该用枚举类型、具名常量,或用作具名常量的全局变量来对其
赋值,而且其值应该与上面这些量做比较下面例子中标记的命名都很差:
C++示例:含义模糊的标记
if flag
if statusFlag OxoF
if printFlag = 16 )
RROR
flag Ox1;
statusFlag =0x80;
printFlag=16
computeFlag =0
像 statusFlag=0x80这样的语句是反映不出这段代码能做什么的,除非你
亲自写了这段代码,或者有文档能告诉你 statusFlag和0x80的含义。下面是作
用相同但更为清晰的代码:
C++示例:更好地使用状态变量
if dataReady ..
if characterType
PRINTABLE_CHAR
if reportType = ReportType_Annual )..
if recalcNeeded = false)...
dataReady true:
characterType CONTROL_CHARACTER;
reportType ReportType_Annual;
recalcNeeded= false;
显然, characterType= CONTROLCHARACTER比 statusFlag=0x80更
有意义。与之类似,条件判断语句if(reportType= ReportType_Annual
要比if(printFlag==16)更为清晰。第二个例子说明你可以结合枚举类型和
预定义的具名常量来使用这种方法。下面例子展示了如何使用具名常量和枚举类
型来组织例子中的数值:
在C++中声明状态变量
/values for CharacterType
const int LETTER -0x01:
const int Drcroxo2i
const int PUNCTUATION =0x04;
const int LINE_DRAW-0x08;
代码大全(第2版)

<==========================303end ==============================>
<==========================304start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看^
11.2为特定类型的数据命名
267
const int PRINTABLE_CHAR=( LETTER I DIGIT I PUNCTUATION I LINE_DRAW
const int CONTROL_CHARACTER =0x80;
values for ReportType
enum ReportType
ReportType_Daily.
ReportType_Monthly.
ReportType_Quarterly,
ReportType_Annual,
ReportType_All
};
如果你发现自己需要猜测某段代码的含义的时候,就该考虑为变量重新命名。
猜测谋杀案中谁是神秘凶手是可行的,但你没有必要去猜测代码。你应该能直接
读懂它们。
Naming Temporary Variables
为临时变量命名
临时变量用于存储计算的中间结果,作为临时占位符,以及存储内务管理
(housekeeping)值。它们常被赋予temp、x者其他一些模糊且缺乏描述性的名
字。通常,临时变量是一个信号,表明程序员还没有完全把问题弄清楚。而且,
由于这些变量被正式地赋予了一种“临时”状态,因此程序员会倾向于比其他变
量更为随意地对待这些变量,从而增加了出错的可能。
警惕“临时”变量临时性地保存一些值常常是很有必要的。但是无论从哪
种角度看,你程序中的大多数变量都是临时性的。把其中几个称为临时的,可能
表明你还没有弄清它们的实际用途。请考虑下面的示例:
C++示例:不提供信息的“临时”变量名
/Compute roots of a quadratic equation. ve
/ This assumes that (b2-4*a*c) is positive.
temp sqrt( 4*a*c
root=-b+tem)(2*a)
把表达式sqrt(b^2-4*a*c)的结果存储在一个变量里是很不错的,特
别是当这一结果还会被随后两次用到的时候。是名字temp却丝毫也没有反映该
变量的功能。下面例子显示了一种更好的做法:
C++示例:用真正的变量替代“临时”变量
Compute roots of a quadratic equation.
This assumes that (b2-4*a*c) is positive.
discriminant=srtb^2-4*a*c)
root[ =(-b discriminant ) 2 a
root [1] =(-b discriminant )/ 2* a
代码大全(第2版)

<==========================304end ==============================>
<==========================305start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.co.com!仅供试看^
268
第11章变量名的力量
就本质而言,这段代码与上面一段是完全相同的,但是它却通过使用了准确
而且具有描述性的变量名(discriminant,判别式)而得到了改善。
Naming Boolean Variables
为布尔变量命名
下面是为布尔变量命名时要遵循的几条原则。
谨记典型的布尔变量名下面是一些格外有用的布尔变量名
done用done表示某件事情已经完成。这一变量可用于表示循环结束或者
一些其他的操作已完成。在事情完成之前把doe设为 false,在事情完成之
后把它设为 true
error用 error表示有错误发生。在错误发生前把变量值设为 false,在错
误已经发生时把它设为true
found用 found来表明某个值已经找到了在还没有找到该值的时候把
found设为 false,一旦找到该值就把 found设为 true在一个数组中查找某
个值,在文件中搜寻某员工的ID,在一沓支票中寻找某张特定金额的支票
等等的时候,都可以用 found
success或ok用 success或ok来表明一项操作是否成功。在操作失败的时
候把该变量设为 false,在操作成功的时候把其设为true如果可以,请用
个更具体的名字代替 success,以便更具体地描述成功的含义。如果完成处
理就表示这个程序执行成功,那么或许你应该用 processingComplete来取而
代之。如果找到某个值就是程序执行成功,那么你也许应该换用 found
给布尔变量赋予隐含“真/假”含义的名字像done和 success这样的名字
是很不错的布尔变量名,因为其状态要么是true,要么是 false;某件事情完成了
或者没有完成;成功或者失败。另一方面,像status和 sourceFile这样的名字却是
很糟的布尔变量名,因为它们没有明确的true或者 false status是true反映的是
什么含义?它表明某件事情拥有一个状态吗?每件事都有状态。true表明某件事
情的状态是OK吗?或者说 false表明没有任何错误吗?对于 status这样的名字,
你什么也说不出来。
为了取得更好的效果,应该把status替换为类似于rror或者 statusOK这样的
名字,同时把 sourceFile替换为 sourceFileAvailable、 sourceFileFound,或者其他能
体现该变量所代表含义的名字。
有些程序员喜欢在他们写的布尔变量名前加上s这样,变量名就变成了
个问题: isdone? isError? isFound isProcessingComplete?用tre或 false回答问题
也就为该变量给出了取值。这种方法的优点之是它不能用于那些模糊不清的名
字: isStatus?这毫无意义。它的缺点之一是降低了简单逻辑表达式的可读性:if
(isFound)的可读性要略差于if(found)
代码大全(第2版)

<==========================305end ==============================>
<==========================306start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com!仅供试看^
11.2为特定类型的数据命名
269
使用肯定的布尔变量名否定的名字如 notFound、 notdone以 notSuccessful
等较难阅读,特别是如果它们被求反:
if not notFound
这样的名字应该替换为 found、done或者 processingComplete,然后再用适当
的运算符求反。如果你找到了想找的结果,那么就可以用 found而不必写双重否
定的 not notFound了
Naming Enumerated Types
为枚举类型命名
交叉参考关于在使用枚举类型的时候,可以通过使用组前缀,如 Color, Planet或者
使用枚举类型的
详情,见第12.6 Month_来明确表示该类型的成员都同属于一个组。下面举一些通过前缀来确定枚
节“枚举类型”。举类型元素的例子:
Visual Basic示例:为枚举类型采用前缀命名约定
Public Enum Color
Color_Red
Color_Green
Color_Blue
End Enum
Public Enum Planet
eart
Planet_Earth
Planet_Mars
Planet_Venus
End Enum
Public Enum Month
Month_January
Month_February
Month_December
End Enum
与此同时,也有很多命名方法可用于确定枚举类型本身的名字(Color,
Planet或 Month),包括全部大写或者加以前缀(e_Color,e_Planet,e_Month)
有人可能会说,枚举从本质上而言是一个用户定义类型,因此枚举名字的格式应
该与其他用户定义的类型如类等相同。与之相反的一种观点认为枚举是一种类型,
但它也同时是常量,因此枚举类型名字的格式应该与常量相同。本书对枚举类型
采用了大小写混合的命名方式。
在有些编程语言里,枚举类型的处理很像类,枚举成员也总是被冠以枚举名
字前缀,比如Color. Color_red或者 Planet. Planet_Earth.如果你正在使用
这样的编程语言,那么重复上述前缀的意义就不大了,因此你可以把枚举类型自
身的名字作为前缀,并把上述名字简化为 Color.red和 Planet. Earth
代码大全(第2版)

<==========================306end ==============================>
<==========================307start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
270
第11章变量名的力量
Naming Constants
为常量命名
交叉参考关于
在具名常量时,应该根据该常量所表示的含义,而不是该常量所具有的数值
使用具名常量的为该抽象事物命名。FIVE是个很糟的常量名(不论它所代表的值是否为5.0)。
情,见第12.7
节“具名常量” CYCLESNEEDED是个不错的名字 CYCLES_NEEDED可以等于5.0或者6.0而FVE
=6.0就显得太可笑了。出于同样原因,BAs_DOZEN就是个很糟的常量名;而
DONUTS_MA则很不错。
The Power of Naming Conventions
命名规则的力量
有些程序员会抵制标准和约定(convention,规则)一—并且有很好的理由:
有些标准和约定非常刻板并且低效它们会毁坏创造性和程序质量。这真让人
感到遗憾,因为有效的标准是你所能掌握的最强大的工具之一本节将讲述为什
么、何时以及如何创建自己的变量命名标准。
Why Have Conventions
为什么要有规则
命名规则可以带来以下的好处。
要求你更多地按规矩行事。通过做一项全局决策而不是做许多局部决策,你
可以集中精力关注代码更重要的特征。
有助于在项目之间传递知识。名字的相似性能让你更容易、更自信地理解那
些不熟悉的变量原本应该是做什么的。
有助于你在新项目中更快速地学习代码。你无须了解 Anita写的代码是这样
的, Julia是那样的,以及 Kristin的代码又是另一种样子,而只须面对一组
更加一致的代码。
有助于减少名字增生(name proliferation)。在没有命名规则的情况下,会
很容易地给同一个对象起两个不同的名字。例如,你可能会把总点数既称为
pointTotal,也称为 total Points。在写代码的时候这可能并不会让你感
到迷惑,但是它却会让一位日后阅读这段代码的新程序员感到极其困惑。
弥补编程语言的不足之处。你可以用规则来仿效具名常量和枚举类型。规则
可以根据局部数据、类数据以及全局数据的不同而有所差别,并且可以包含
编译器不直接提供的类型信息。
代码大全(第2版)

<==========================307end ==============================>
<==========================308start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww ! --www.shubu.com!仅供试看^
11.3命名规则的力量
271
强调相关变量之间的关系。如果你使用对象,则编译器会自动照料它们。如
果你用的编程语言不支持对象,你可以用命名规则来予以补充。诸如
address、 phone以及name这样的名字并不能表明这些变量是否相关。但
是假设你决定所有的员工数据变量都应该以 Employee作为前缀,则
employeeAddressempl oyee Phone和 empioyeeNam就会毫无疑问地表明
这些变量是彼此相关的。编程的命名规则可以对你所用的编程语言的不足之
处做出弥补。
关键之处在于,采用任何一项规则都要好于没有规则。规则可能是武断的。
命名规则的威力并非来源于你所采取的某个特定规则,而是来源以下事实:规
KEY POINT
则的存在为你的代码增加了结构,减少了你需要考虑的事情
When You Should Have a Naming Convention
何时采用命名规则
没有金科玉律表明何时应该建立命名规则,但是在下列情况下规则是很有价
值的。
当多个程序员合作开发一个项目时
当你计划把一个程序转交给另一位程序员来修改和维护的时候(这几乎总是
会发生
当你所在组织中的其他程序员评估你写的程序的时候
当你写的程序规模太大,以致于你无法在脑海里同时了解事情的全貌,而必
须分而治之的时候
当你写的程序生命期足够长,长到你可能会在把它搁置几个星期或几个月之
后又重新启动有关该程序的工作时
当在个项目中存在一些不常见的术语,并且你希望在编写代码阶段使用标
准的术语或者缩写的时候
你一定会因使用了某种命名规则而受益。上述诸多注意事项将会帮助你决定
在一个特定项目中按照何种程度来制定规则里所使用的规则的范围。
Degrees of Formality
正式程度
交叉参考关于
不同规则所要求的正式程度也有所不同。一个非正式的规则可能会像“使用
小型项目和大有意义的名字”这样简单。下一节将会讲述其他的非正式规则。通常,你所需的
项目的在正式程
度上的区别,见正式程度取决于为同一程序而工作的人员数量、程序的规模,以及程序预期的生
第27章“程序规命期。对于微小的、用完即弃的项目而言,实施严格的规则可能就太没有必要了。
模对构建的影
响”。
对于多人协作的大型项目而言,无论是在开始阶段还是贯穿整个程序的生命周期,
正式规则都是成为提高可读性的必不可少的辅助手段。
代大全(第2版)

<==========================308end ==============================>
<==========================309start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
272
第11章变量名的力量
Informal Naming Conventions
非正式命名规则
大多数项目采用的都是类似于本节所讲的相对非正式的命名规则。
Guidelines for a Language-Independent Convention
与语言无关的命名规则的指导原则
下面给出用于创建一种与语言无关的命名规则的指导原则。
区分变量名和子程序名字本书所采用的命名规则要求变量名和对象名以小
写字母开始,子程序名字以大写字母开始: variableName对 RoutineNam
区分类和对象类名字与对象名字或者类型与该类型的变量——之间的
关系会比较棘手。有很多标准的方案可用,如下例所示:
方案1:通过大写字母开头区分类型和变量
Widget widget;
Longerwidget longerwidget
方案2:通过全部大写区分类型和变量
WIDGET widget;
LONGERWIDGET longerWidget
方案3:通过给类型加“t”前缀区分类型和变量
t_Widget Widget;
t_LongerwidgetLongerWidget
方案4:通过给变量加“a”前缀区分类型和变量
Widget awidget;
Longerwidget aLongerwidget;
方案5:通过对变量采用更明确的名字区分类型和变量
widget employeewidget;
Longerwidget fullEmployeewidget;
每一种方案都有其优点和不足。第一种方案是在大小写敏感语言如C++和
Java里常用的规则,但是有些程序员对仅依靠大写区分名字感到不大舒服。的确,
创建两个只有第一个字母大小写不同的名字所能提供的“心理距离”太短了,二
者之间的视觉差异也太小。
代码大全(第2版)

<==========================309end ==============================>
<==========================310start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
11.4非正式命名规则
273
在多语言混合编程的环境中,如果任一种语言是大小写不敏感的,则将无法
一直使用第一种命名方案。以 Microsoft Visual Basic为例, Dim widget as widget
将会引发一处语法错误,因为 widget和 widget会被当做同一个标识符看待。
第二种方案使类型名和变量名之间的差异更加鲜明。然而,由于历史原因,
在C++和Java里面全部字母大写只用于表示常量,同时这种方案也会与第一种方
案一样面临混合语言环境的问题。
第三种方案可用于所有语言,但是很多程序员从审美的角度出发并不喜欢增
加前缀。
第四种方案有时会用作第三种方案的备选项,但是它存在的问题是需要改变
类的每个实例的名字,而不是仅仅修改类名。
第五种方案要求基于每个变量的实际情况做出更多的考虑在大多数情况下,
要求程序员为每个变量想出一个特别的名字会有助于提高代码的可读性。但是有
时候,一个 widgetwidget确实就是一个普通的,在这种情况下你会发现自己会
想出一些并不鲜明的名字,如genericwidget,它的可读性比较差。
简而言之,每一种可选方案都不是十全十美的。本书代码采用的是第五种方
案,因为当不要求代码的阅读者熟悉一种不太直观的命名规则时,这种规则做是
最容易理解的。
标识全局变量有一种编程问题很常见,那就是滥用全局变量假如你在所
有的全局变量名之前加上g_前缀,那么程序员在读到变量g_ RunningTotal之后
就会明白这是个全局变量,并且予以相应对待。
标识成员变量要根据名字识别出变量是类的数据成员即明确表示该变量
既不是局部变量,也不是全局变量。比如说,你可以用m前缀来标识类的成员变
量,以表明它是成员数据。
标识类型声明为类型建立命名规则有两个好处:首先它能够明确表明一个
名字是类型名,其次能够避免类型名与变量名冲突。为了满足这些要求,增加前
缀或者后缀是不错的方法。C++的惯用方法是把类型名全部大写例如 COLOR
和MENU。(这一规则适用于 typedef和 struct,不适用于类名)但是这样就会
增加与命名预处理常量发生混淆的可能。为了避免出现这样的麻烦,你可以为类
型名增加t_前缀,如t_ Color和t_Menu
标识具名常量你需要对具名常量加以标识,以便明确在为一个变量赋值时你
用的是另一个变量的值(该值可能变化),还是一个具名常量。在 Visual Basic里,
还会有另外的可能,那就是该值可能是一个函数的返回值。 Visual Basic不要求在调
用函数时给函数名加括号,与之相反,在C++里即使函数没有参数也要使用括号
代码大全(第2版)

<==========================310end ==============================>
<==========================311start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
274
第11变量名的力量
给常量命名的方法之一是给常量名增加c前缀。这会让你写出类似
c_RecesMax或者LinesPerPageMax这样的名字来。C++和java里的规则是全
部用大写,以及如果有可能,用下画线来分隔单词,例如 RECSMAX或者 RECSMAX,
以及 LINESPERPAGEMAX或者 LINES_PER_PAGeMAX
标识枚举类型的元素与具名常量相同,枚举类型的元素也需要加以标识
以便表明该名字表示的是枚举类型,而不是一个变量、具名常量或者函数。标准
方法如下:全部用大写,或者为类型名增加e_前缀,同时为该类型的成员名
增加基于特定类型的前缀,如 color_或者 Planet_o
在不能保证输入参数只读的语言里标识只读参数有时输入参数会被意外修
改。在C++和 Visual Basic这样的语言里,你必须明确表明是否希望把一个修改后
的值返回给调用方子程序。在C++里分别用*、&和 const指明,在 Visual Basic
里分别用 ByRef和 Byval指明。
交叉参考可以
在其他的语言里,如果你修改了输入变量的取值,那么无论你是否愿意,它
通过命名方面的
约定来增强某的新值都会被返回。特别是当你传递对象的时候。举例来说,在java里所有对象
语言的功能,从而都是“按值(by value)”传递的,因此当你把一个对象传递给一个了程序的时候,
弥补该语言自身该对象的内容就可以在被调用子程序中修改(Arnold, Gosling, Hoimes2000)
的缺陷。这种方式
正是“深入一种语
在这些语言里,如果你制定了为输入参数增加一个 const前缀(或者fina1、
去编程”而非仅
仅“在一种语言上nonmodifiable等)的命名规则那么当你看到const前缀出现在赋值符号左边
编程”的典范。第的时候,就会知道出现了错误。如果你看到 constMax. Set NewMax),就会知道
34.4节“深入一
门语言去编程,不这里有大漏洞,因为 const前缀表明了该变量是不应该被修改的。
一主题的详细论
格式化命名以提高可读性有两种常用方法可以用来提高可读性,那就是用
述
大小写和分隔符来分隔单词。例如, GYMNASTICSPOINTTOTAL就要比 gymnastics
PointTotalgymnastics或者 point_total难得多。C++、Java、 Visual Basic
和其他的编程语言允许混合使用大小写字符。另外,C++、ava、 Visual Basic和
其他的编程语言也允许使用下画线()作为分隔符。
尽量不要混用上述方法,那样会使代码难以阅读。如果你老老实实地坚持使
用其中任意一种提高可读性的方法,你的代码质量一定会有所改善。人们曾经就
诸如变量名的第一个字母是不是应该大写(TotalPoints对 totalPoints)的
做法的价值展开了非常激烈的讨论,但是只要你和你的团队在使用上保持一致,
那么大写小写就没有太大区别。基于Java经验的影响,同时为了促进不同编程语
言之间命名风格的融合,本书对首字母采用小写
代码大全(第2版)

<==========================311end ==============================>
<==========================312start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
11.4非正式命名规则
275
Guidelines for Language-Specific Conventions
与语言相关的命名规则的指导原则
应该遵循你所用语言的命名规则。对于大多数语言,你都可以找到描述其风
格原则的参考书。下面将给出C、C++、Java和 Visual Basic的指导原则
C Conventions
C的命名规则
深入阅描述有很多命名规则特别适用于C语言。
语言编程风格的经
典读物是( Prog和ch是字符变量。
ramming Guide和是整数下标
kines >(Plun
1984)
n表示某物的数量。
p是指针
s是字符串
预处理宏全部大写(ALL_CAPS)这通常也包括 typedef
变量名和子程序名全部小写(all_lowercase)
下画线()用做分隔符:1 letters_in_lowercaselet要比更
具可读性。
这些都是属于一般性的、UNIX风格或者 Lioux风格的C编程规则,C编程
规则在不同的环境下也会有所差异。开发 Microsoft Windows应用的C程序员倾向
于采用匈牙利命名法,并在变量名中混合使用大小写。在 Macintosh平台下,C程
序员会倾向于在子程序的名字中混合使用大小写,这是因为Macintosh工具箱和
操作系统子程序最初是为支持 Pascal接口而设计的。
C++ Conventions
C++的命名规则
深入阅读The
以下是围绕着C++编程形成的命名规则。
Elements of Ct+
Style(Misteldt和是整数下标。
Bumgardner,and
Gray2004)一书详p是指针
细描述了C++编程常量、 typedef和预处理宏全部大写(LL_CAPs)
风格。
类和其他类型的名字混合大小写(MixedupperandLow(
变量名和函数名中的第一个单词小写,后续每个单词的首字母大写例
variableorRout ineName.
不把下画线用做名字中的分隔符,除非用于全部大写的名字以及特定的前缀
中(如用于标识全局变量的前缀)。
代码大全(第2版)

<==========================312end ==============================>
<==========================313start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看
276
第11章变量名的力量
与C编程相比,上述规则还远没有形成标准并且不同的环境也会形成不同
的具体规则。
Java Conventions
Java的规则
深入阅读(The与C和C++不同,Java语言的风格约定从一开始就创建好了。
Elements of Java
Style,2ded.i和j是整数下标。
(Vermeulen et al.
2000)书详细描常量全部大写(ALLCAPS)并用下画线分隔。
述了Java编程风
格。
类名和接口名中每一个单词的首字母均大写,包括第一个单词例如,
ClassOrInterfaceName.
变量名和方法名中第一个单词的首字母小写,后续单词的首字母大写—例
如, variableorRoutineNamee
除用于全部大写的名字之外,不使用下画线作为名字中的分隔符
访问器子程序使用get和set前缀
Visual Basic Conventions
Visual Basic的命名规则
Visual Basic还没有固定的规则。下节将就 Visual Basic给出一份规则建议
Mixed-Language Programming Considerations
混合语言编程的注意事项
在混合语言环境中编程时,可以对命名规则(以及格式规则、文档规则等)
做出优化以提高整体的一致性和可读性——即使这意味着优化后的规则会与其中
某种语言所用的规则相冲突。
在本书里,变量名均以小写开头,这符合Jav的编程实践传统以及部分但并
非全部的C++传统。本书把所有子程序名的首字母大写,这遵循了C++规则。在
Java中所有的方法名都是以小写字母开始的但是本书对所有语言的子程序名的
首字母都大写,从而提高了整体可读性。
Sample Naming Conventions
命名规则示例
上述的标准规则容易使我们忽略前页里谈论过的有关命名的若干重要事
项—包括变量作用域(私用的,类的或者全局的)类名、对象名、子程序名和
变量名之间的差异等。
代码大全(第2版)

<==========================313end ==============================>
<==========================314start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co!.com!仅供试看^
11.4非正式命名规则
277
在命名规则的指导原则长度超过了几页之后,看上去就显得非常复杂。然而,
它们没必要变得如此复杂,你也可以按实际需要来加以应用。变量名包含了以下
三类信息:
变量的内容(它代表什么)
数据的种类(具名常量、简单变量、用户自定义类型或者类)
■变量的作用域(私用的、类的、包的或者全局的作用域)
根据上述指导原则,表11-3、表11-4和表11-5给出了C、C++、Java和 Visual
Basic的命名规则。这些特殊规则并非是强制性的,但是它们能帮你了解一份非正
式的命名规则应包含哪些内容。
表11-3C++和Java的命名规则示例
实体
描述
ClassName
类名混合使用大小写,首字母大写
TypeName
类型定义,包括枚举类型和 typedef,混合使用大
小写,首字母大写
EnumeratedTypes
除遵循上述规则之外,枚举类型总以复数形式表
示
局部变量混合使用大小写,首字母小写。其名字
localVariable
应该与底层数据类型无关,而且应该反映该变量
所代表的事物
routineParameter
子程序参数的格式与局部变量相同
RoutineName()
子程序名混合使用大小写(第7.3节已经讨论过
什么是好的子程序名)
m_classvariable
对类的多个子程序可见(且只对该类可见)的成
员变量名用m_前缀
g_GlobalVariable
全局变量名用g_前缀
CONSTANT
具名常量全部大写
MACRO
宏全部大写
Base_EnumeratedType
枚举类型名用能够反映其基础类型的、单数形式
的前缀例如, Color_red, Color_Blue
代码大全(第2版)

<==========================314end ==============================>
<==========================315start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubuld.com!仅供试看
278
第11章变量名的力量
表11-4C的命名规则示例
实体
描述
TypeName
类型名混合使用大小写,首字母大写
GlobalRoutineName()
公用子程序名混合使用大小写
f_FileRoutineName (
单一模块(文件)私用的子程序名用f_前
局部变量混合使用大小写。其名字应该与底层数
LocalVariable
据类型无关,而且应该反映该变量所代表的事物
RoutineParameter
子程序参数的格式与局部变量相同
f FileStaticvariable
模块(文件)变量名用f_前缀
全局变量名以G前缀和一个能反映定义该变量
_GLOBALGlobalVariable1的模块(文件)的、全部大写的名字开始例
如,g_SCREEN_Dimensions
单一子程序或者模块(文件)私用的具名常量全
LOCAL_CONSTANT
部大写例如,ROWSMAX
全局具名常量名全部大写,并且以G前缀和一
G_GLOBALCONSTANT
个能反映定义该具名常量的模块(文件)的、全
部大写的名字开始,如SCREENROWSMAX
LOCALMACRO()
单一子程序或者模块(文件)私用的宏定义全部
大写
全局宏定义全部大写,并且以G前缀和一个能
G_GLOBAL_MACRO()
反映定义该宏的模块(文件)的全部大写名字开
始—例如,g_SCREEN_LOCATION()
由于 Visual Basic对大小写不敏感,因此需要采取一些特殊的规则来区分类型
名和变量名。请见表11-5
表11-5 Visual Basic的命名规则示例
实体
描述
_ClassName
类名混合使用大小写,首字母大写,并且加C前缀
T_TypeName
类型定义,包括枚举类型和 typedef,混合使用大小写,
首字母大写,并且加T前缀
T_EnumeratedTypes
除遵循上述规则之外,枚举类型总以复数形式表示
代码大全(第2版)

<==========================315end ==============================>
<==========================316start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
11.5标准前缀
279
续表
实体
描述
局部变量混合使用大小写,首字母小写。其名字应该与
localVariable
底层数据类型无关,并且应该反映该变量所代表的事物
routineParameter
子程序参数的格式与局部变量相同
子程序名混合使用大小写(第7.3节已经讨论过什么是
RoutineName()
好的子程序名)
只在一个类范围内对该类的多个子程序可见的成员变
m_ClassVariable
量名以m_前缀打头
GlobalVariable全局变量名以g前开始
CONSTANT
具名常量全部大写
枚举类型名以能够反映其基础类型的、单数形式的前缀
Base_EnumeratedType
开始例如, Color_red, Color_Blue
Standardized Prefixes
标准前缀
深入阅读the对具有通用含义的前缀标准化,为数据命名提供了一种简洁、一致并且可读性
Hungarian
Revolution好的方法。有关标准前缀最广为人知的方案是匈牙利命名法,该方案由一组用于指
(《Slmonn,《导变量和子程序命名(而不是指导如何给匈牙利人取名!)的详细原则组成,并且
有对匈牙利命名曾经一度被广泛用于 Microsoft Windows编程。尽管目前匈牙利命名法已经不再得到
法的详细描述。广泛使用,但是使用简洁准确的缩写词的基本命名标准理念却仍然具有价值。
标准化的前缀由两部分组成:用户自定义类型(UDT)的缩写和语义前缀。
User-Defined Type Abbreviations
用户自定义类型缩写
UDT缩写可以标识被命名对象或变量的数据类型UDT缩写可以被用于表示
像窗体、屏幕区域以及字体一类的实体。UDT缩写通常不会表示任何由编程语言
所提供的预置数据类型。
UDT用很短的编码描述,这些编码是为特定的程序创建的,并且经过标准化
以在该程序内使用。这些编码有助于用户理解其所代表的实体,如用wn代表窗
体,scr代表屏幕区域。表11-6列出了一份UDT示例,你可能会在开发文字处理
程序的时候用到它们。
代码大全(第2版)

<==========================316end ==============================>
<==========================317start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
280
第11章变量名的力量
表11-6用于文字处理程序的UDT示例
UDT缩写
含义
字符( Character,这里的字符不是指C++中的字符,而是指文
ch
字处理程序可能用于表示一份文档中的字符的数据类型
doc
文档( Document)
pa
段落( Paragraph)
scr
屏幕区域( Screen region)
sel
选中范围( Selection)
wn
窗体( window)
当你使用UDT的时候,你还要按与UDT同样的缩写去定义编程语言的数据
类型。这样,如果你有表11-6所列出的那些UDT,你就会看到下面这样的数据声
明:
CH chCursorPosition;
SCR sC
scrUserWorkspacei
docActive
PA firstPaActiveDocument
PA last PaActiveDocument
wnMain;
同样,这些例子是与文字处理程序相关的。要把它们用于你自己的项目,你
需要为环境中最常用的那些UDT创建UDT缩写。
Semantic Prefixes
语义前缀
语义前缀比UDT更进一步,它描述了变量或者对象是如何使用的。语义前缀
与UDT不同,后者会根据项目的不同而不同,而前者在某种程度上对于不同的项
目均是标准的。表11-7列出了一组标准的语义前缀。
表11-7语义前缀
语义前缀含义
c
数量( count,如记录、字符或者其他东西的个数)
first
数组中需要处理的第一个元素。 first与mn类似,但它是相对于
当前操作而不是数组本身的
gi
全局变量(global variable)
数组的下标( index into an array)
last
数组中需要处理的最后一个元素。last与 first相对应
代码大全(第2版)

<==========================317end ==============================>
<==========================318start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor ^.com!仅供试看
11.5标准前缀
281
续表
语义前缀含义
数组中需要处理的元素的上限lim不是一个合法的下标。它与la
lim
都是与 first相对应的概念。不同之处是lim表示的是一个数组中
并不存在的上界;而last表示的则是最终的、合法的元素。通常
lim等于last+1
m
类一级的变量
数组或者其他种类的列表中绝对的最后一个元素。max反映的是
max
数组本身,而不是针对数组的操作
min
数组或者其他种类的列表中绝对的第一个元素
指针( pointer)
语义前缀可以全用小写,也可以混合使用大小写,还可以根据需要与UDT和
其他的语义前缀结合使用。例如,文档中的第一段应该命名为pa,以表明它是个
段落,还要加上 first以强调它是第一个段落:即 firstPa.一组段落的下标可以命
名为iPa;cPa是相应的计数值,段落的总数量; firstPaActiveDocument和
last PaActiveDocument表示当前活动文档中的第一个和最后一个段落。
Advantages of Standardized Prefixes
标准前缀的优点
除了具备命名规则所能提供的一般意义上的优点外,标准前缀还为你带来了
另外一些好处。由于很多名字都已经标准化了,因此你在一个程序或者类内需要
KEY POINT记忆的名字更少了。
标准前缀能够更为精确地描述一些含义比较模糊的名字。min、 first、last
和max之间的严格区别就显得格外有用。
标准化的前缀使名字变得更加紧凑。例如,你可以用cpa而不是
total Paragraphs表示段落总数。你可以用ipa表示一个段落数组的下标,而不
是用 index Paragraphs或者 paragraphsIndex.
最后,在你用的编译器不能检查你所用的抽象数据类型的时候,标准前缀能
帮助你准确地对类型做出判断: paReformat= docReformat很可能不对,因为
pa和doc是不同的UDT。
标准前缀的主要缺陷是程序员在使用前缀的同时忽略给变量起有意义的名
字。如果ipa已经能非常明确地表示一个段落数组的下标,那么程序员就不会主
动地去想类似于 ipaActiveDocument这样有意义的名字。为了提高可读性,应该
停下来为数组下标起一个具有描述性的名字。
代码大全(第2版)

<==========================318end ==============================>
<==========================319start==============================>

该书下载自-书部落分享计算机经典巨著!--www. ! --www.shubulo..com!仅供试看^
282
第11章变量名的力量
Creating Short Names That Are Readable
创建具备可读性的短名字
从某种程度上说,要求使用短变量名是早期计算的遗留物。早期语言,如汇
编、一般的 Basic和 Fortran都把变量名的长度限制在2到8个字符,并要求程序
XEY POINT
员创建简短的名字。早期的计算科学更多的同数学联系在一起,并大量使用求和
及其他等式中的、j和k等符号。而在现代语言如C++、ava和 Visual Basic
面,实际上你可以创建任何长度的名字;儿乎没有任何理由去缩短具有丰富含义
的名字。
如果环境真的要求你创建简短的名字,请注意有些缩短名字的方法要好于其
他的方法。你可以通过消除冗余的单词、使用简短的同义词以及使用诸多缩写策
略中的任意一种来创建更好的短变量名。熟悉多种缩写技巧会很有用,因为没有
哪种方法能够适用于所有的情况。
General Abbreviation Guidelines
缩写的一般指导原则
下面是几项用于创建缩写的指导原则。其中的一些原则彼此冲突,所以不要
试图同时应用所有的原则。
使用标准的缩写(列在字典中的那些常见缩写)
去掉所有非前置元音。(computercmptr变成 screen变成scrn, apple
变成appl, integer变成 intgr.)
去掉虚词and,or,the等
使用每个单词的第一个或前几个字母。
统一地在每个单词的第一、第二或者第一个(选择最合适的一个)字母后截
断。
保留每个单词的第一个和最后一个字母。
使用名字中的每一个重要单词,最多不超过三个。
去除无用的后缀ing,ed等。
保留每个音节中最引人注意的发音。
确保不要改变变量的含义。
反复使用上述技术,直到你把每个变量名的长度缩减到了8到20个字符,
或者达到你所用的编程语言对变量名的限制字符数。
代码大全(第2版)

<==========================319end ==============================>
<==========================320start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^ ^.com!仅供试看
11.6创建具备可读性的短名字
283
Phonetic Abbreviations
语音缩写
有些人倡导基于单词的发音而不是拼写来创建缩写。于是 skating就变成了
sk8ing, highlight变成了 hilite, before变成了b4, execute变成了xqt
诸如此类。这样做很像是要人去猜出个性化汽车牌照的意思,我不提倡这么做。
作为一项练习,请猜猜下面这些名字各表示什么:
ILV2SK8 XMEQWK S2DTM80 NXTC TRMN8R
Comments on Abbreviations
有关缩写的评论
在创建缩写的时候,会有很多的陷阱在等着你。下面是一些能够用来避免犯
错的规则。
不要用从每个单词中删除一个字符的方式来缩写键入个字符算不上是什
么额外工作,而节省一个字符带来的便利却很难抵消由此而造成的可读性损失。
这就像日历中的“Jun”和“Jul”。你只有在非常着急的情况下才有必要把June拼
成“Jun”。对于大多数删除一个字母的做法而言,你很难回忆起自己是不是删了
一个字符。所以,要么删除不止一个字符要么就把单词拼写完整。
缩写要一致应该一直使用相同的缩写。例如,要么全用Num,要么全用
No,不要两个都用。与之类似,不要在一些名字里缩写某个单词而在其他名字里
不缩写。比如,不要在有些地方使用完整的单词 Number,同时在其他地方使用
Num缩写。
创建你能读出来的名字用xPos而不用 xPstn,用 needsCompu而不用
ndsCmptg.此处可以借助电话来测试如果你无法在电话中向他人读出你的代
码,就请重新给变量起一个更清晰的名字吧(Kernighan and Plauger1978)
避免使用容易看错或者读错的字符组合为了表示B的结尾,nDB要比BEND
更好。如果你使用了一种好的分隔技术,那么就不需要这条原则,因为-END、
BEnd或者bend都不会被读错。
使用辞典来解决命名冲突创建简短名字会带来的一项麻烦就是命名冲
突缩写后名字相同。例如,如果命名长度被限制为3个字符,并且你需要在
程序中的同一代码段使用 fired和 full revenue disbursal,你可能会不经意地把缩写
都写成了frd。
避免命名冲突的一种简单做法是使用含义相同的不同单词,这样一来,有一
部辞典就显得很方便。在本例中,可以用 dismissed代替,以及用 complete
revenue disbursal来代替 full revenue disbursal这样,3个字母的缩写就分别变成
了dsm和crd,从而消除了命名冲突。
代大全(第2版)

<==========================320end ==============================>
<==========================321start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看^
284
第11章变量名的力量
在代码里用缩写对照表解释极短的名字的含义当编程语言只允许用非常短
的名字的时候,增加一张缩写对照表来为用户提示更多的变量含义。把该表格作
为注释加到一段代码的开始。下面是一个例子:
Fortran示例:良好的名字对照表
★★★★★★★★★★
c Translation Table
Variable Meaning
CXPOS
C YPOS
Y-Coordinate Position (in meters)
NDSCMP
Needs Computing (=0 if no computation is needed;
1
ation is needed)
PTGTTL
Point Grand Total
C PTVLMX
PSCRMX
Point value Maximum
Possible Score Maxim
你可能会认为这种方法已经过时了,但是在2003年中期,我与一家客户合作,
该客户有上万行用RPG语言写成的、变量名被限制在6个字符以内的代码。这些
要求极短变量名的问题仍然时不时地出现。
在一份项目级的“标准缩写”文档中说明所有的缩写代码中的缩写会带来
两种常见风险。
代码的读者可能不理解这些缩写。
其他程序员可能会用多个缩写来代表相同的词从而产生不必要的混乱。
为了同时解决这两个潜在的问题,你可以创建一份“标准缩写”文档来记录
项目中用到的全部编码缩写。这份文档既可以是文字处理程序的文档,也可以是
电子表格文档。在很大的项目里,它还可以是一个数据库。这份文档应签入(check
in)到版本控制系统里,当任何人于任意时间在代码里创建了一种新的缩写时把
它签出(check out)来修改。文档中的词条应该按照完整单词排序,而不是按照
缩写排序。
这看上去可能显得非常麻烦,但是除了开始的一点额外工作,它事实上是建
立了一种在项目中有效地使用缩写的机制。通过对所有用到的缩写加以说明,就
解决了上面描述的两种常见风险中的第一种。程序员如果不费力把标准缩写文档
从版本控制系统中 check out、输入新的缩写并把它 check in回去,就不能创建一
个新的缩写。这是件好事。它表明,只有当一个缩写在代码中应用非常广泛,程
代码大全(第2版)

<==========================321end ==============================>
<==========================322start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
11.7应该避免的名字
285
序员不惜花上很多精力来为它编写缩写文档时,这一缩写才的的确确应当被创建。
这种方法通过降低程序员创建多余的缩写的可能性,从而解决了第二种风险。
想创建缩写的程序员会把缩写文档 check out并输入新的缩写。如果他想缩写的单
词已经有了缩写,该程序员就会注意到它,并且去使用该现有的缩写而不是创建
一个新的。
本原则中体现出来的核心问题,是方便编写代码同方便阅读代码两种理念之
间的差异。上面的方法很明显会带来代码编写时的麻烦,但是程序员们在整个项
KEY POINT
目生命周期里会把更多的时间花在阅读代码而不是编写代码之上。这种方法提高
了阅读代码的方便性。当一个项目尘埃落定之后,它可能还会提高编写代码的方
便性。
记住,名字对于代码读者的意义要比对作者更重要去读一读你自己写的并
且至少有六个月没看过的代码,注意哪些名字是你需要花功夫才能理解其含义的。
应下决心改变导致这种混乱的做法。
Kinds of Names to Avoid
应该避免的名字
下面就哪些变量名应该避免给出指导原则。
避免使用令人误解的名字或缩写要确保名字的含义是明确的。例如, FALSE
常用做TRUE的反义词,如果用它作为“Fig and Almond Season的缩写就很糟糕
了。
避免使用具有相似含义的名字如果你能够交换两个变量的名字而不会妨碍
对程序的理解,那么你就需要为这两个变量重新命名了。例如, input和
inputvalue, recordnum和 numRecords,以及 fileNumber和 fileIndex在语
义上非常相似,因此,如果把它们用在同一段代码里,会很容易混淆它们,并且
犯下一些微妙且难以发现的错误。
交叉参考有
避免使用具有不同含义但却有相似名字的变量如果你有两个名字相似但含
个术语用来描述义不同的变量,那么试着给其中之一重新命名,或者修改你的缩写。避免使用类
相似变量名之间
的差异,即“心理似于 client Recs和 clientReps这样的名字。它们之间只有一个字母的差异,并
距离( paycholog且这个字母很难被注意到。应该采用至少有两个字母不同的名字,或者把不同之
ical distance )
在第23.4节有关处放在名字的开始或者结尾 Records和 client Reports就要比原来的名
于它的详细叙述。字好。1
译注:即增加标识符之间的 Hamming距离
译注:即增加标识符之间的Hamming距离
代大全(第2版

<==========================322end ==============================>
<==========================323start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
286
第11章变量名的力量
避免使用发音相近的名字,比如wrap和rap当你试图和别人讨论代码的时
候,同音异义字就会产生麻烦。我家猫对于极限编程的抱怨之一是它过于聪明地
使用了 Goal Donor和 Gold Owner两个概念事实上它们读起来很难区分。你最
终就会同别人展开类似于这样的对话:
我刚和 Goal Donor谈过话
你是说“Gold Owner”还是“Goal Donor”?
我是说“Goal Donor”
什么?
GOAL ---DONOR!
好了, Goal Donor.你不应该大喊大叫,烦死了。
你是说“Gold Donut吗?
记住,电话测试也适用于测试发音相近的名字,就像它适用于对付稀奇古怪
的缩写名一样。
避免在名字中使用数字如果名字中的数字真的非常重要,就请使用数组来
代替一组单个的变量。如果数组不合适,那么数字就更不合适例如,要避免使
用 filel和file2,或者 totall和 total22。你几乎总能想出一种比在名字的最后加上1
或2更好的方法米区分两个变量。我不能说永远不要用数字。有些现实世界的事
物(例如203国道、 Route66或者 Interstate05)中就嵌入了数字。不过在你创建
一个含有数字的名字之前,请考虑是否还有更好的选择。
避免在名字中拼错单词弄清楚单词实际应该怎么拼写是够难的。想让人们
想出什么是“正确的”错拼更是勉为其难。比如说,把 highlight错拼为 hilite以省
下3个字符,让读者很难想起这是 highlight错拼。是 highlite? hilite? hilight?
hilit?jai-a-lai-t?天知道。
避免使用英语中常常拼错的单词Absense,《Absense,acummlateacsendcaener,《,acsend,calender
concieve, defferred, definate, independance, occassionally, prefered, reciept, superseed
以及其他很多英语单词经常会拼错。很多英语手册中会包含一份常常拼错单词的
清单。避免在你的变量名中使用这些单词。
不要仅靠大小写来区分变量名如果你在用一种大小写敏感的语言如C+t做
开发,你也许会倾向于使用frd来代表 fired,用FRD代表 final review duty,以及
用Frd来代表 full revenue disbursal应该避免这样做。尽管这些名字都是唯一的,
但把其中任一名字与某个特殊的含义关联起来的方式却太随心所欲,且让人感到
迷惑Frd会很容易地与 final review duty联系起来,FRD也会被认为是 full revenue
disbursal,没有逻辑法则能够帮助你或者其他人记住谁是谁
代码大全(第2版)

<==========================323end ==============================>
<==========================324start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shuby.com!仅供试看^
11.7应该避免的名字
287
避免使用多种自然语言在多语言的项目中,对于全部代码,如类名、变量
名等,要强制使用一种自然语言,阅读其他程序员的代码可以称为一种挑战;阅
读用火星东南部的语言写成程序代码则是绝无可能的。
一种更微妙的问题产生于英语的变体。如果一个项目在多个说英语的国家进
行,就应该以其中一种英语版本为标准,以便你不用一直为在代码中应该使用
“color""”还是“colour,“check”还是“cheque”等感到迷惑
避免使用标准类型、变量和子程序的名字所有的编程语言指南都会包含一
份该语言保留的和预定义的名字列表。请不时读一读这份列表,以确保你自己的
命名没有冒犯你所用的语言。例如,下面代码在P中是合法的,但除非你是个
十足的傻瓜,否则是不会这么用的:
ifif then then
then else
Ise;
else else if;
HORROR
不要使用与变量含义完全无关的名字如果你在程序中点缀着诸如 margaret
和 pookie这样的名字,就会在事实上保证没有其他人能够理解它。避免用你男朋
友的名字、妻子的名字、最喜欢的啤酒的名字或者其他自作聪明的(也就是傻的)
名字来为变量命名,除非你的程序真的是与你的男朋友、妻子或者最爱的啤酒有
关。即使如此,你也应该明智地认识到这其中的每一项都可能会变的,所以
boyfricnd、wife和 favoriteBeer这些通用的名字会更好!
避免在名字中包含易混淆的字符要意识到有些字符看上去是非常接近,很
难把它们区分开来。如果两个名字的唯一区别就是这些字符中的一个,那么你区
分这些名字就会变得非常困难。例如,请试着把下列每纽中不属于该组的名字圈
出来:
eyechartl
eyechartI
eyechartl
TTLCONFUSION TTLCONFUSION TTLCONFUSION
hard2Read
hardzRead ha
GRANDTOTAL
GRANDTOTAL
6RANDTOTAL
tt15
ttls
ttls
很难区分的“对”包括(1(数字1)和1(小写字母L),(1和(大写字母i)
(和,),(0(零)和0(大写字母),(2和Z)(和),(S和5)以及(G和6)
交叉参考关于
像这样的细节真有用吗?没错! Gerald Weinberg报导说,在20世纪70年代,
使用数据方面的条 Fortran FORMAT语句中的句号错写成了逗号。结果科学家们算错了太空飞
讨论,见第10章
中“使用变量的船的轨道,导致了太空探测器的丢失损失高达16亿美元(Weinberg1983)
一般事项”的核
对表。
代玛大余(第2版)

<==========================324end ==============================>
<==========================325start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
288
第11章变量名的力
CHECKLIST: Naming Variables
cc2e.com/1191
核对表:变量命名
命名的一般注意事项
口名字完整并准确地表达了变量所代表的含义吗?
口名字反映了现实世界的问题而不是编程语言方案吗?
口名字足够长,可以让你无须苦苦思索吗?
口如果有计算值限定符,它被放在名字的最后吗?
口名字中用 Count或者 Index来代替Num了吗?
为特定类型的数据命名
口循环下标的名字有意义吗(如果循环的长度超出了一两行代码或者出现
了嵌套循环,那么就应该是ij或者k以外的其他名字)?
口所有的“临时”变量都重新命以更有意义的名字了吗?
口当布尔变量的值为真时,变量名能准确表达其含义吗?
口枚举类型的名字中含有能够表示其类别的前缀或后缀了吗?例如,把
Color_用于 color_red, Color_Green, Color_Blue等了吗?
口具名常量是根据它所代表的抽象实体而不是它所代表的数字来命名的
吗?
命名规则
口规则能够区分局部数据、类的数据和全局数据吗?
口规则能够区分类型名、具名常量、枚举类型和变量名吗?
口规则能够在编译器不强制检测只读参数的语言里标识出子程序中的输入
参数吗?
口规则尽可能地与语言的标准规则兼容吗?
口名字为了可读性而加以格式化吗?
短名字
.口代码用了长名字吗(除非有必要使用短名字)?
口是否避免只为了省一个字符而缩写名字的情况?
所有单词的缩写方式都一致吗?
代码大全(第2版)

<==========================325end ==============================>
<==========================326start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^^.com!仅供试看^
要点
289
口名字能够读出来吗?
口避免使用容易被看错或者读错的名字吗?
口·在缩写对照表里对短名字做出说明吗?
常见命名问题:你避免使用…
口…容易让人误解的名字吗?
口……有相近含义的名字吗?
口…只有一两个字符不的名字吗?
发音相近的名字吗?
口…包含数字的名字吗?
口为了缩短而故意拼错的名字吗?
…英语中经常拼错的名字吗?
口……与标准库子程序名或者预定义变量名冲突的名字吗?
口…过于随意的名字吗?
口…含有难读的字符的名字吗?
Key Points
要点
好的变量名是提高程序可读性的一项关键要素对特殊种类的变量,比如循
环下标和状态变量,需要加以特殊的考虑。
名字要尽可能地具体。那些太模糊或者太通用以致于能够用于多种目的的名
字通常都是很不好的。
命名规则应该能够区分局部数据、类数据和全局数据。它们还应当可以区分
类型名、具名常量、枚举类型名字和变量名。
无论做哪种类型项目,你都应该采用某种变量命名规则。你所采用的规则的
种类取决于你的程序的规模,以及项目成员的人数。
■现代编程语言很少需要用到缩写。如果你真的要使用缩写,请使用项目缩写
词典或者标准前缀来帮助理解缩写。
代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便
而不是编写方便。
代丹大全(第2版)

<==========================326end ==============================>
<==========================327start==============================>

该书下载自-书部落分享计算机经典巨著!- ! --www.shubulo..com!仅供试看^

<==========================327end ==============================>
<==========================328start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
Fundamental Data uypes
第12章
基本数据类型
cc2.com/1278内容
12.1数值概论:第292页
12.2整数:第293页
12.3浮点数:第295页
12.4字符和字符串:第297页
12.5布尔变量:第301页
12.6枚举类型:第303页
12.7具名常量:第307页
12.8数组:第310页
12.9创建你自己的类型(类型别名):第311页
相关章节
数据命名:第11章
不常见的数据类型:第13章
■使用变量的一般事项:第10章
格式化数据声明:第31.5节中的“数据声明的布局”
注释变量:第32.5节中的“注释数据声明”
■创建类:第6章
基本数据类型是构建其他所有数据类型的构造块( building blocks)本章包含
了使用数(普遍意义上)、整数、浮点数、字符和字符串、布尔变量、枚举类型、
具名常量以及数组的一些技巧。本章的最后一节将讲述如何创建自己的数据类型。
本章也涵盖了与基本数据类型有关的问题的基本处理方法。如果你已经了解
了关于基本数据类型的内容,就可以跳到本章的最后去查看需要避免的问题的列
表,然后去阅读第13章有关不常见的数据类型的讨论。
代码大全(第2版)

<==========================328end ==============================>
<==========================329start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulcom!仅供试看
292
第12章基本数据类型
12
Numbers in General
数值概论
下面一些建议能够使你在使用数的时候少犯错误。
交叉参考关于使避免使用“神秘数值( number)”神秘数值是在程序中出现的、没有
用命名常量代替经过解释的数值文字量(litertal numbers),如100或者47523.如果你编程用的
神秘数值的详情,
见本章后面的第语言支持具名常量,那么就用它来代替神秘数值。如果你无法使用具名常量,在
12.7节“具名常可行的情况下应该使用全局变量。
量”。
避免使用神秘数值会带来以下三点好处:
修改会变得更可靠。如果你使用了具名常量,就不会在修改时漏掉多个100
中的某一个,或者修改了一个代表其他含义的100
修改会变得更容易。当记录的最大值由100变成200的时候,如果你用了
神秘数值,就不得不找出所有的100,然后把它们改成200。如果你用的是
100+1或者100-1,你还是要找出所有的101和99来,并把它们改成201
和199。如果你用了具名常量,你只需简单地在一处把该常量的定义由100
改成200
你的代码变得更可读。当然,对于表达式。
for i 0 to 99 do ..
你可以猜测99表示的是数据项的最大数目。但是表达式
for i to MAX_ENTRIES-1 do ..
根本就不需要去猜。即使你确信某个数在代码中永远也不会改变,使用具名
常量也会有助于提高可读性。
如果需要,可以使用硬编码的0和1数值0和1用于增量、减量和从数组
的第一个元素开始循环。0用于
for i 0 to CONSTANT do ..
是可以接受的,把1用在
total=tata1+1
也可以。一条很好的经验法则是,程序主体中仅能出现的文字量就是0和1任
何其他文字量都应该换成更有描述性的表示。
预防除零( devide--by-zero)错误每次使用除法符号的时候(在多数语言里
是“1”),都要考虑表达式的分母是否有可能为0。如果这种可能性存在,就应该
写代码防止除零错误的发生。
代码大全(第2版

<==========================329end ==============================>
<==========================330start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
12.2整数
293
使类型转换变得明显确认当不同数据类型之间的转换发生时,阅读你代码
的人会注意到这点。在C++里你可以使用
=+ (float)i
在 Microsoft Visual Basic里你可以使用
y=+ CSng()
这种实践还能帮助确认有关转换正是你期望发生的一不同的编译器会执行
不同的转换,因此,如果不这么做,你就只有碰运气了。
交叉参考第
避免混合类型的比较如果x是浮点数,i是整数,那么下面的测试
等判断”提到if)then
了本例的一种变不能保证可行。在编译器设法弄清了应该用什么类型去进行比较之后,它会把
体
其中一种类型转化为另一种,执行一些四舍五入运算之后才得出结果。要是在
这样的情况下你的程序还能跑起来,那就是你的运气了。请自己动手进行类型
转换,这样编译器就能比较两个相同类型的数值了,你也会确切地知道它比较
的是什么。
注意编译器的警告当你在同一表达式中使用了多种类型的数值的时候,很
多现代的编译器都会通知你。要小心!很多程序员都曾被请去帮助别人解决某个
KEY Ponm
讨厌的错误,结果却发现编译器一直都在对这个错误发出警告杰出的程序员会
修改他们的代码来消除所有的编译器警告。通过编译器警告来发现问题要比你自
找容易得多。
2.2
Integers
整数
在用整数的时候,要记住下面的注意事项。
检查整数除法当你使用整数的时候,7/10不等于0.7。它总是等于0,或者
等于负无穷大,或者等于最接近的整数,或者你应该懂了吧。其结果会随语
言的不同而不同。这一说法对中间结果也同样适用。在现实世界中10*(7/10)=
(10*7)/10=7但在整数运算的世界里却不同10*(7/10)等于0,因为整数除法(7/10)
等于0。对此问题最简单的补救办法是重新安排表达式的顺序,以最后执行除法:
(10*7)/10
检查整数溢出在做整数乘法或加法的时候,你要留心可能的最大整数。允
许出现的最大无符号整数经常是232-1,有时候是216-1,即65535。当你把两个
整数相乘,得出的数值大于整数的最大值时就会出现问题。比如,如果你执行
250*300,正确的答案是75000。但如果最大的整数是65535,那么你得到的答案
代大全(第2)

<==========================330end ==============================>
<==========================331start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.cor.com!仅供试看^
294
第12章基本数据类型
可能会是9464,因为发生了整数溢出(7500065536=9464)表12-1列出了
常用整数类型的取值范围。
表12-1不同类型整数的取值范围
整数类型
取值范围
带符号8-bit整数
-128至127
无符号8-bit整数
0至255
带符号16-bit整数
-32768至32767
无符号16-bit整数0至65535
带符号32-bit整数-2147483648至2147483647
无符号32-bit整数0至4294967295
带符号64-bit整数-922337203685477808至9223372036854775807
无符号64-bit整数0至18446744073709551615
避免整数溢出的最简单办法是考虑清楚算术表达式中的每个项,设想每项可
能达到的最大值。例如,如果在整数表达式m=j*k中,j可预期的最大值是200,
k可预期的最大值是25,那么m可预期的最大值就是200*25=5000这在32
位计算机上是没问题的,因为最大的整数是2147483647然而,如果j可预期
的最大值是200000,k可预期的最大值是100000,那么m可预期的最大值就是
200000*100000200000000。这时就行不通了,因为20000000要大于
2147483647。在这种情况下,你就必须使用64位整数或者浮点数,以容纳m的
预期最大取值。
另外还要考虑程序在未来的扩展。如果m的取值永远不会超过5000,那很
好。但如果你预计m的取值会在几年时间内稳定增长,那么就要把这种情况考虑
进来。
检查中间结果溢出你需要关心的不仅是一个算式的最后数值。假设你写有
下述代码:
Java示例:中间结果溢出
int terma 1000000;
int termB 1000000:
int product termA termB 1000000;
System.out. println""+ termA+
.+termB + 1000000 = product
如果你认为 product的赋值结果与(1000000000000)/1000100相
等,可能期望所得的结果为1000000。但是这段代码必须先计算出1000000
1000000的中间结果,然后再除以最后面的1000000,而这就意味着它需要一
个像100000000000这么大的数字。你觉得会怎么样?下面就是结果:
(1000000*10000)/1000000=-727
代码大全(第2版)

<==========================331end ==============================>
<==========================332start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co!.com!仅供试看^
12.3浮点数
295
如果整数值最高只能达到2147483647,那么中间结果对于这一整数数据类
型来说实在是太大了。如此一来,本该等于100000000000的中间结果实际
上等于了-727379968。因此,当你用100000去除的时候,得到的是-727,
而不是100000
你可以用处理整数溢出的相同办法来处理中间结果溢出,换用一种更长的整
型或者浮点类型。
2.3
Floating-Point Numbers
浮点数
使用浮点数字时主要考虑的是,很多十进制小数不能够精确地用数字计算机
8中的1和0来表示。像1/3或者1/7这样的无限循环小数通常只用7位或者15位
精度有效数字表示。在我所用的 Microsoft Visual Basic版本中,1/3的32位浮点
KEY POINT
数表示形式为0.3330。它的精确度是小数点后7位。这对于大多数用途而言
是足够精确的,但是有时它的不精确性也足以给你带来麻烦。
下面是一些在使用浮点数时应该遵循的指导原则。
交叉参考有一避免数量级相差巨大的数之间的加减运算32位浮点变量,10000.00+0.1
些算法方面的书可能会得到100000.00,因为32位不能给你足够的有效位数包容100000和0.1
籍描述了解决这
些问题的方法,参之间的数值区间。与000000001能会得到00
见第10.1节中的
解决方案是什么?如果你必须要把一系列差异如此巨大的数相加,那么就先
“有关数据类型
的更多资源”。对这些数排序,然后从最小值开始把它们加起来。同样,如果你需要对无穷数列
进行求和,那么就从最小的值开始——从本质上来说,是要做逆向的求和运算。
这样做并不能消除舍入问题,但是能使这一问题的影响减少到最低限度。很多的
算法书都建议采用这种处理方式。
1等于2,对充
避免等量判断很多应该相等的浮点数值并不一定相等。这里的根本问题是,用
分大的1成立。两种不同方法来求同一数值,结果不一定总得到同一个值。举例来说,10个0.1加起
佚名
来很少会等于1.0。下面例子显示了应该相等但却不等的两个变量, nominal和sum
变量 nominal是ava示例:对浮点数进行错误的比较
个64位实数。 double nominal=1.0;
double sum =0 0
,。
应当等于1.0
sum+=0.1
这是错误的比较if( nominal=sum)
System.out. printIn("Numbers are the same.")
)
else
System, out. printIn( "Numbers are different.")
代码大全(第2版)

<==========================332end ==============================>
<==========================333start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看^
296
第12章基本数据类型
正如你可能已经猜到的那样,这个程序的输出是
Numbers are different.
按代码逐行运行,for循环中的sum值是这样的
0.
0.2
0.30000
0.4
0.5
0.6
0.7
0.999999
0.89999999
0.9999999999999
因此,应该找一种代替对浮点数字执行等量判断的方案。一种有效的方法是
先确定可接受的精确度范围,然后用布尔函数判断数值是否足够接近。通常应该
写一个Equa1s()函数,如果数值足够接近就返回true,否则就返回 false在
Java中,这样的函数类似下面这样:
交叉参考这个Java示例:比较浮点数的函数
规则皆有例外这 boolean Eoualsbsdouble Termer ACEPTABLe DELta
哲理这个实际
return true;
例子里的变量名
包含了数字。在第
else
11.7节的“应该
return false;
避免的名字”里
提到过避免在变
量名中使用数字如果修改了前面对浮点数做出错误比较的例子中的代码,改用上述函数来做
这一规则
比较,那么新的比较就会是:
if( Equals( Nominal,sum))
使用了这样的比较方法后,程序的输出就会变成:
Numbers are the same.
根据程序需求,对 ACCEPTABLE_DELTA的值进行硬编码可能是不合适的。你也许
需要根据待比较的两个数的大小算出 ACCEPTABLE_DELTA
代码大全(第2版)

<==========================333end ==============================>
<==========================334start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com!仅供试看^
12.4字符和字符串
297
处理舍入误差问题由于舍入误差而导致的错误与由于数字之间数量级相差
太大而导致的错误并无二致。问题相同,解决的技术也相同。除此之外,下面列
出一些专门用于解决舍入问题的常见方案
换用种精确度更高的变量类型。如果你正在用单精度浮点值,那么就换用
双精度浮点值,同理类推。
交叉考通常,换用二进制编码的十进制(binary coded decimal,BCD)变量BCD模式的
将二进制编码转
处理通常更慢一些,并且要占用更多的存储空间,但是它能防止很多舍入错
换为BCD对性能
产生的影响是很
误的发生。当你使用的变量代表的是美元、美分或者其他必须要精确结算的
小的如果你对这数量的时候,这种方法会特别有用。
一影响仍心存疑
虑,可以看看第把浮点变量变成整型变量。这是种自力史生转到BCD变量的方法。你可
节“代码调
整方法总结”。
能必须要用64位整数才能获得所需的精度。采用这种方法要求你自己来处
理数字的小数部分。假设你原来是用浮点数处理美元,其中美分表示为美元
的小数部分。这是一种常用的处理美元和美分的方式。当你转到用整数的时
候,就必须要用整数来表示美分,用美分的100倍来表示美元。换句话说,
你把美元乘以100,并把美分保存到变量值中0到9的范围内这样做乍一
看有点别扭,但是无论从速度还是精确度的角度来看,它都是一种有效的解
决方案。你可以创建一个能够隐藏整数表示并且支持必要数字运算的
DollarsAndCents类,来简化这些操作
检查语言和函数库对特定数据类型的支持有些语言,包括 Visual Basic在
内,包含了像 Currency这样的数据类型,专用于处理对舍入误差敏感的数据。如
果你的语言中内置了提供此类功能的数据类型,那么就用它!
2.4
Characters and Strings
字符和字符串
本节给出一些使用字符串的技巧。其中的第一条适用于所有的语言。
交叉参考在第
避免使用神秘字符和神秘字符串神秘字符( magic character)是指程序中
12.1节“数概随处可见的字面形式表示的字符( literal character,例如a)神秘字符串(magi
数值的描述,里面string)是指字面形式表示的字符串(sig《IteasringGigamaticAccoaning,例如“gigamaticaccounting
提到的一些事项p
同样适用于神秘 Program)。如果你用的编程语言支持具名常量,则用具名常量来加以取代。否则
字符以及神秘字就用全局变量。避免使用字面形式的字符串的众多原因如下:
符串。
对于程序的名字、命令名称、报表标题等常常出现的字符串,你有时可能需
要修改它们的内容。例如,“Gigamatic Accounting Program”可能会在一个新
版本里改为“New and Improved! Gigamatic Accouting Program
代大全(第2版)

<==========================334end ==============================>
<==========================335start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
298
第12章基本数据类型
国际市场的重要意义正在日益突现,翻译存放在字符串资源文件中的字符串
要比翻译存在于代码中的字符串容易得多。
字符串的字面表示形式通常都会占用较多的存储空间。它用于菜单、消息、
帮助屏幕、录入表格等。如果字符串的数量太多,就会失控,并引发内存问
题。在很多环境中,字符串的存储空间并不是要考虑的因素,但是在嵌入式
系统开发以及其他存储空间非常珍贵的应用中,这一点就必须考虑。在那些
情况下,如果字符串是相对独立于源代码的,那么针对字符串空间问题的解
决方案就会更容易实施。
■字符和字符串的字面表示形式的含义是模糊的。注释或具名常量能够澄清你
的意图。在下例中,0x1B的含义并不清楚。使用 ESCAPE常量使得这一含义
变得更加明显了。
糟糕!
C++示例:字符比较
input_char = Ox1B )
好一点
if input_char -=ESCAPE
避免off-by-one错误由于子字符串的下标索引方式几乎与数组相同,因此
。
要避免因为读写操作超出了字符串末尾而导致的off-by-one(偏差一)错误
cc2e.com/1285了解你的语言和开发环境是如何支持 cc2e.com/1285 Unicode Java,的在ava等语言里,所有的
字符串都是 Unicode的。在C和C++等其他的语言里,处理 Unicode就要用到与
之相关的一组函数。为了标准函数库与第三方函数库之间的通信,常常需要在
Unicode和其他的字符集之间进行转换。如果有些字符串不需要表示成 Unicode(例
如,在C或C++中),就要尽早决定是否采用 Unicode字符集如果你决定要用
Unicode字符串,就要决定何处以及何时使用它。
在程序生命期中尽早决定国际化/本地化策略与国际化和本地化相关的事项
都是很重要的问题。关键的考虑事项包括:决定是否把所有字符串保存在外部资源
里,是否为每一种语言创建单独的版本,或者在运行时确定特定的界面语言1
cc2e.com/1292
如果你知道只需要支持一种文字的语言,请考虑使用ISO8859字符集对于
只需要支持单一文字(例如英语)、无须支持多语言或者某种表意语言(例如汉语)
的应用程序,可以使用ISO8859扩展ASCI类型标准来很好地替代 Unicode
译注:指自然语言。
代码大全(第2版)

<==========================335end ==============================>
<==========================336start==============================>

该书下载自-书部落-分享计算机经典巨著-w. !--www.shubulo.com!^^.com!仅供试看
12.4字符和字符串
299
如果你需要支持多种语言,请使用 Unicode与ISO8859或者其他标准相比,
Unicode对国际字符集提供了更为全面的支持。
采用某种一致的字符串类型转换策略如果你使用了多种字符串类型,有一
种常用方法能维护各种字符串类型,那就是在程序中把所有字符串都保存为一种
格式,同时在尽可能靠近输入和输出操作的位置把字符串转换为其他格式。
Strings in C
语言中的字符串
C++的标准模板库(STL)中的 string类已经消除了大多数与C中字符串相关
的传统问题。下面为那些直接处理C字符串的程序员提供一些避免常见错误的方
法。
注意字符串指针和字符数组之间的差异与字符串指针( string pointer)和字
符数组(character array)相关的问题来源于C处理字符串的方式。请从以下两方
面留心二者之间的差异。
警惕任何包含字符串和等号的表达式。C中的字符串操作差不多都是通过
strcmp()、 strcpy()、 strlen()及其他相关的子程序完成的。等号几乎总
意味着某种指针错误。在C里面,赋值并不把字符串字面量(string literal
拷贝给字符串变量。假设你写有下面这行语句
StringPtr "Some Text String";
在这种情况下,Some Text String"是一个指向字面量字符串的指针,
因此这个赋值的结果只是让 stringPt指针指向该字面字符串。这个赋值
并没有把字符串内容拷贝给 StringPtr
■通过命名规则区分变量是字符数组还是字符串指针。一种常见的规则是用
ps前缀来标识字符串指针,用ach前缀来标识字符数组。尽管同时含有p
和ach前缀的表达式不一定总是错的,但你还是应该对它们持怀疑态度。
把C- -style字符串的长度声明为 CONSTANT+1在C和C+中,与C-styl
字符串相关的off-by-one错误很常见,因为很容易忘记长度为n的字符串需要n+
1字节的存储空间,从而忘记为空结束符(位于字符串的最后取值为0的字节)
预留空间。避免这类错误的一种有效方法是用具名常量来声明所有字符串。这种
方法的关键之处在于你每次都用同样的方式使用该具名常量。把字符串的长度声
明为 CONSTANT+1,然后在余下的代码里用 CONSTANT来指代字符串的长度。下
面举一个例了:
代大全(第2版)

<==========================336end ==============================>
<==========================337start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看^
300
第12章基本数据类型
C示例:好的字符串声明
Declare the string to have length of "constant+1"._
Every other place in the program, "constant"rather
这里声明的字符串长 thanconstant+1" is used.n
度为
char name NAME_LENGTH } / string of length NAME_LENGTH
NAME_LENGTH+1
:1. the srina to a
/ Example 1: Set the string to all 'A's using the constant,
NAME_LENCTH, as the number of 'A's that can be copied.
Note that NAME_LENGTH rather than NAME_LENGTH 1 is used
在这里,对字符串的→for(i=0;NAMELENGTH++
操作用到了
name[ i ]='A';
NAME_LENGTH
/ Example 2: Copy another string into the first string using
the constant as the maximum length that can be copied.*/
这里也用到了。strncpy(name, someothername, NAMELENGTH
如果你没有采用上面的规则来处理这一问题,你就会有时把字符串的长度声
明为NAME_LENGTH,然后在操作中使用NAM_LENGTH1;而有时你会把字符串
长度声明为 NAMELENGTH+1,然后在操作中使用 NAMELENGTH每次使用字符
串的时候你都不得不去想自己是如何声明它的。
当每次都用相同的方式来使用字符串的时候,你就不需要去记住每个字符串
是怎么处理的,从而避免由于忘记某字符串的处理细节而导致的错误。使用规则
有助于减少脑力消耗以及编程失误。
交叉参考第用null初始化字符串以避免没有终端的字符串C通过查找空结束符,即字
始化原则”有关于符串末尾取值为0的字节,来判断字符串的末尾。不管你认为字符串有多长,只
数据初始化的详要C没有找到空结束符,它就认为字符串还没有结束。如果你忘记在字符串的最
细介绍。
后放置一个空值,字符串操作的结果可能就会与你预想的不一样。
你可以用两种方法来避免无终端的字符串。首先,在声明字符数组的时候把
它初始化为0:
示例:声明字符数组的好做法
char EventName MAX_NAME_LENGTH 1 ]=
其次,在你动态分配字符串的时候,使用 calloc()而不是 malloc()来把它
初始化为0。 calloc()会负责分配内存,并把它初始化为0 malloc()只分配内
存,并不执行初始化,因此,当你使用由 malloc()分配的内存的时候就要小心了。
代码大全(第2版)

<==========================337end ==============================>
<==========================338start==============================>

该书下载自-书部落-分享计算机经典巨著--ww !--www.shubulo.c.com!仅供试看^
12.5布尔变量
301
交叉参考本章
用字符数组取代C中的指针如果内存不是限制性的因素通常都不是
后面的第12.8节
那么就把你所有的字符串变量都声明为字符数组这样做有助于避免指针错
“数组”详细描
述了数组。
误,并且在出错的时候,编译器会给你更多的警告。
用 strncpy取代 strcpy以避免无终端的字符串C中的字符串子程序既有安
全版本,也有危险版本。较危险的子程序,如strcpy()和 strcmp(),一直运
行下去,直到它们遇到了一个空结束符为止。安全版本即 strncpy()和
strncmp(),会接受一个表示最大长度的参数因此一旦处理到此参数长度位置,
即使字符串会一直延续下去,你的函数调用也会及时返回。2
12.5布尔变量
要把逻辑变量或者布尔变量用错是非常困难的,而更仔细地运用它会让你的
程序变得更清晰。
交叉参考第32章用布尔变量对程序加以文档说明不同于仅仅判断一个布尔表达式,你可以
“自说明代码”详
细介绍了如何使用
把这种表达式的结果赋给一个变量,从而使得这一判断的含义变得明显。例如,
注释对程序做进一在下面的代码片断中,if检查的对象到底是工作完成、错误条件还是其他什么,
步说明。
情况很不明确:
交叉参考第19.1java示例:目的不明确的布尔判断
节“简化复杂的表达if(((e1enenTndex《0MAELEWENSe1<0)(max_elementse
式”里有一个借助布 ement Index lastEle
尔函数来对程序提
供说明的例子。
在下面这段代码中,布尔变量的使用使得if的判断对象明确多了:
ava示例:目的明确的布尔判断
finished=( elementIndex0)1( MAX ELEMENTS elementIndex))
repeatedEntry= element Index= lastElement Inde
if finished repeatedEntry )
用布尔变量来简化复杂的判断常有这样的情况,在需要编写一段复杂的判
断时,你要尝试好几次才能成功。在你事后想要修改这一判断的时候,首先弄清
楚这段判断在做什么就已经很困难了。逻辑变量可以简化这种判断。在前述示例
中,程序事实上需要判断两个条件:子程序是否已经结束,以及子程序是否在重
复的记录上工作。通过创建 finished和 repeatedEntry两个布尔变量,if的判
断得到了简化:读起来很容易,更不容易出错,修改起来也更加方便了。
2译注:更安全的做法是使用 strlcpy()或 strcpy_s()
代码大全(第2版)

<==========================338end ==============================>
<==========================339start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
302
第12章基本数据类型
下面再举一个复杂判断的例子:
Visual Basic示例:复杂的判断
f(( document. AtEndofstream))ad( Not inputError))and
MIN_LINES < lineCount And lineCount <=MAX_LINES And-
HORROR
( Not ErrorProcessing())then
do something or other
End If
本例中的判断相当复杂,但是这种情况并不罕见它给读者很重的思维负担。
我猜你甚至不会去试着理解if判断的含义,而是看着它说,“要是需要的话,我
会以后再去弄清楚。”请注意这种想法,因为这就是别人阅读你所写的含有类似判
断语句代码时的真切反应。
下面是重写的代码,增加了布尔变量以简化判断:
Visual Basic示例:简化后的判断
这是简化之后的1ega1nCunNs《eCounAn1necounNES=(min_lins<=linecountand(inecount=maxlines
这是简化之后f( allDataRead And( legallineCount)and( Not ErrorProcessing())Then
判断。
do something or,other
End If
第二个版本更简单些。我想你阅读这个if判断里的布尔表达式不会有任何困
难。
如果需要的话,创建你自己的布尔类型有些语言,比如C++、Java和 Visual
Basic,含有预定义的布尔类型。其他语言,比如C,却没有。在C这样的语言中,
你可以定义你自己的布尔类型。在C中你可能会这样做:
c示例:用 typedefBOOLEAN定义类型
typedef int BOOLEAN:
或者你也可以这么做,其额外好处是同时定义出了true和 false:
示例:用枚举定义 Boolean类型
enum Boolean
True=1,
False=(!True)
代码大全(第2版)

<==========================339end ==============================>
<==========================340start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo...com!仅供试看^
12.6枚举类型
303
把变量声明为 BOOLEAN而非int,可以让其用途更为明显,并且使你的程序
不言自明。
12.6
Enumerated Types
枚举类型
枚举类型是一种允许用英语来描述某一类对象中每一个成员的数据类型。C++
和 Visual Basic都提供了枚举类型,通常用在你知道变量的所有可能取值,并且希
望把它们用单词表达出来的时候。下面举一些 Visual Basic中的枚举类型示例:
Visual Basic示例:枚举类型
Public Enum Color
Color_Red
Color_Green
Color_Blue
End Enum
Public Enum Country
Country_China
Country-England
Country-France
Country_Germany
Country_India
C
ountry dapan
Country_Usa
Enum
Public Enum Output
Output_Screen
Output_Printer
noutput_File
End Enum
枚举类型是老式说明方法的强有力替代者,使用老式说明方法的时候你需要
明确地说,“1代表红色,2代表绿色,3代表蓝色…”。下面给出一些如何使用
枚举类型的指导原则。
用枚举类型来提高可读性与下面这个语句相比
if chosenColor =1
你可以通过下面这样的语句来提高可读性
if chosenColor= Color_red
每当你看到字面形式数字的时候,就应该问问自己,把它换成枚举类型是不是更
合理。
枚举类型特别适用于定义子程序参数。有谁知道下面函数调用里的参数代表
什么?
代码大全(第2版)

<==========================340end ==============================>
<==========================341start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看^
304
第12章基本数据类型
C++示例:函数调用用枚举会更好
int result= RetrievePayrollDatadata,true, false, false,true)
DING
与之相反,下面函数调用里的参数更容易理解:
CODING
HORROR
C++示例:函数调用一使用枚举提高可读性
int result =RetrievePayrol1Data(
dataen satrrenve
Payrol1Type_Salaried,
Medicascoveragee uaepepe
);
用枚举类型来提高可靠性对于少数语言而言(尤其是Ada),枚举类型会使
编译器执行比整数和常量更为彻底的类型检查。如果采用具名常量,编译器将无
法知道仅有 Color_red, ColorGreen和oor_Blue是合法的值。编译器不会
反对像 color= Country_England或者 country= Output_Printer这样的语
句。但如果你用了枚举类型,把一个变量声明 Color为,编译器就会只允许把该
变量赋值为 Color_red, ColorGreen或 Color_Blue
用枚举类型来简化修改枚举类型使得你的代码更容易修改。如果你在“1
代表红色,2代表绿色,3代表蓝色”方案中发现了一处缺陷,你就必须从头到尾
检查代码,并且修改所有的1、2、3等。如果用的是枚举类型,你就可以继续向
列表增加元素,只要把它们加入类型定义后重新编译就可以了。
将枚举类型作为布尔变量的替换方案布尔变量往往无法充分表达它所需要
表达的含义。举例而言,假设你有一个子程序在成功地完成任务之后返回true,
否则返回 false后来你可能发现事实上有两种 false第一种表示任务失败了,
并且其影响只局部于子程序自身;第二种表示任务失败了,而且产生了一个致命
错误,需要把它传播到程序的其余部分在这种情况下,一个包含
Status_Success、 Status_Warning和 Status_FatalError值的枚举类型,就
比一个包含true和 false的布尔类型更有用。如果成功和失败的具体类型有所
增加,对其进行扩展以区分这些情况也是非常容易的。
检查非法数值在if或者case语句中测试枚举类型时,务必记得检查非法
值。在case语句中用else子句捕捉非法值:
代码大全(第2版)

<==========================341end ==============================>
<==========================342start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com!仅供试看^
12.6枚举类型
305
Visual Basic示例:检查枚举类型数据中的无效值
Select Case screencolor
Case Color_Red
Case Color_Blue
Case Color Green
这是对无效值的
Case Else
判断。
DisplayInternalError False, "Internal Error 752: Invalid color.")
End Select
定义出枚举的第一项和最后一项,以便用于循环边界把枚举的第一个和最
后一个元素定义成 Color_First, Color_lst, Country_First, Countrylast
等,以使你更方便地写出能遍历所有枚举元素的循环来。你可以用明确的数值来
定义该枚举类型,如下所示:
Visual Basic示例:设置枚举类型数据第一项和最后一项
uhnum
Public Enum Country
Countrye
Country_China =0
Country_England=1
Country_France =2
Country cerman
Country_Germany=3
Country_India 4
Country_Japan =5
Country_Usa=6
Country_Last=6
End Enum
现在就可以把 CountryFirst和 Country_Last用做循环边界了:
Visual Basic示例:遍历枚举类型数据元素
compute currency conversions from US currency to target currency
Dim usaCurrencyConversionRate( Country_Last As Single
Dim iCountry As Country
For iCountry= Country_First To Countrylast
ieacurrenv
usaCurrencyConversionRate( iCountry)=ConversionRate( Countryusa, iCountry
Next
把枚举类型的第一个元素留做非法值在你声明枚举类型的时候,把第一个
值保留为非法值。很多编译器会把枚举类型中的第一个元素赋值为0。把映射到0
的那个元素声明为无效会有助于捕捉那些没有合理初始化的变量,因为这些变量
值更有可能为0,而不是其他的非法值。
代码大全(第2版)

<==========================342end ==============================>
<==========================343start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看
306
第12章基本数据类型
下面就是采用了这种方法后的 Country声明:
Visual Basic示例:将枚举中第一个元素声明为无效值
Public Enum Country
Country_InvalidFirst=0
Country_First =1
country_China 1
Country_England =2
Country_France=3
Country_Germany=4
Country_India=5
CountryJapan=6
Country_Usa=7
count
Country_Last =7
End Enu
明确定义项目代码编写标准中第一个和最后一个元素的使用规则,并且在使
用时保持一致在枚举中使用 InvalidFirst, First和last元素,能使数组声
明和循环更具有可读性。但是这样做也可能会造成混乱,究竟枚举中的合法项是
从0开始还是从1开始的?枚举中的第一个和最后一个元素合法吗?如果使用这
种技术,项目的编码标准中就应该要求在所有的枚举中都统一使用
InvalidFirst、 First、Last,以减少出错。
警惕给枚举元素明确赋值而带来的失误有些语言允许对枚举里面的各项元
素明确地赋值,如下面这个C++例子所示:
对枚举元素直接赋值的C++范例
enum Color
Color_InvalidFirst 0,
st
Color_First =1,
1a
Color_Red =1,
Color Green =2
Color_Blue-4
Color_Black =8
Color_Last =8
在这个例子中,如果你把一个循环的下标声明为color类型,并且尝试去遍
历所有的 Color,那么你在遍历1,2,4,8些合法数值的同时,也会遍历3,5
6,7这些非法数值。
代码大全(第2版)

<==========================343end ==============================>
<==========================344start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
12.7具名常量
307
If Your Language Doesn't Have Enumerated Types
如果你的语言里没有枚举类型
如果你的语言里没有枚举类型,那么可以用全局变量或者类来模拟它。例如,
可以在Java中使用下面这些声明:
交叉参考在我写ava示例:模拟枚举类型
这一章的时候,/ set up Country enumerated type
java还不支持枚 class Count
举类型。等你阅读 private Country()
ina -new countryl:
public static final Country China =new Country()
本章的时候,它或public static final Country England= new Country
许能够支持了。这 public static final Country France new Country
正是我在第4.3节 public static final Country Germanynew Country()
“你在技术浪潮public static final Country Japan new Country()
中的位置”中写到
的“翻滚的技术
流”的一个极好实/ set up Output enumerated type
例。
class Output
private Output ( (
public static final output scree
w Output (
public static final Output Printer =new Output()
public static final output File new Output()
这些枚举类型会增强你的程序的可读性,因为你可以用 Country. England和
Output. Screen等公用类成员来代替具名常量这种特殊的创建枚举类型的方法
还是类型安全(type safe)的;因为每种类型都声明为类,因此编译器会检查非法
的赋值,比如outpuoutpucounry.ang1ana《BIoch20010=country.england(Bloch2001)
在不支持类的语言中,你也可以通过对全局变量的规范应用来模拟枚举类型
中的每一个元素,从而获得同样的基本效果。
12.7
Named Constants
具名常量
具名常量很像变量,一旦赋值以后就不能再修改了。具名常量允许你用一个
名字而不是数字比如说 MAXIMUMEMPLOYEES而不是100来表示固定的
量,比如员工人数的最大值。
使用具名常量是一种将程序“参数化”的方法把程序中可能变化的一个
方面写为一个参数,当需要对其修改时,只改动一处就可以了,而不必在程序中
到处改动。如果你曾经声明过一个你认为大小肯定够用的数组,后来却因为容量
不够而用光了存储空间,你就会赞美具名常量的作用了。一旦数组的大小变了,
代码大全(第2版)

<==========================344end ==============================>
<==========================345start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
308
第12章基本数据类型
你只需要修改声明该数组时所用的那个常量的定义。这种“单点控制(single-point-
control)”对让软件真正地“软”了许多用起来和改起来都很方便。
在数据声明中使用具名常量在需要定义所用数据的大小的数据声明和其他
语句里,使用具名常量可以提高程序的可读性和可维护性。在下例中,就用
LOCAL_NUMBER_LENGTH来描述员工电话号码的长度,而不用数字7
Visual Basic示例:在数据声明中使用具名常量
LOCAL_NUM-Const CODEMENRTLENGTH
BER_LENGTH Const LOCAL_NUMBER_LENGTH 7
此处声明为常量。
Type PHONE_NUMBER
ar
在这里使用。
calNumber( LOCAL_NUMBER_LENGTH As String
End Type
.
'make sure all characters in phone number are digits
这里也用到了。 FFor iDigit=1 To LOCAL_NUMBERLENGTH
if( phoneNumber. localNumber( iDigit")or-
("9"< phoneNumber. locaINumber( iDigit))then
do some error processing
这个例子很简单,但是你可以设想这样一个程序,其中很多地方都用到有关
于员工电话号码的信息。
在你创建这个程序的时候,所有的员工都在同一个国家里,所以你只需要7
位数字就能容纳他们的电话号码。随着规模的扩张,公司在很多国家都建立了分
支机构,你就会用到更长的电话号码。如果你将号码长度参数化,那么就可以只
修改一处:即 LOCALNUMBER_LENGTH具名常量的定义。
交叉参考单点控正如你所料到的那样,使用具名常量非常有助于程序的维护。作为一项一般
制的意义在
《Software Conf性的原则,任何一种能够对可能发生改变的事物进行集中控制的技术,都是减少
lict》Glass1 1991)
第57至60页有详维护工作量的好技术(Gls1991
细叙述。
避免使用文字量,即使是“安全”的在下面的循环里,你认为12代表着什
么含义?
Visual Basic示例:含义模糊的代码
Fori=1o12- revenue)- expense(i)
Next
代码大全(第2版)

<==========================345end ==============================>
<==========================346start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
12.7具名常量
309
根据这段代码的特殊本质,看上去它可能是在遍历一年里的12个月。不过你
能确定吗?你敢用你收藏的 Monty Python全集来打赌吗?
3
在这种情况下,你是不大需要用具名常量来支持将来的灵活性的:一年中月
份的数量在任何时间都不太可能改变。但是如果代码的写法会让人对它的作用产
生任何一丝疑虑,就应该用命名良好的常量来明确它,如下所示:
Visual Basic示例:含义清晰的代码
For 1 To NUM MONTHS_IN_YEAR
profit() revenue() expensel i
Next
这样好多了,但是,为了完成这个例子,循环下标的名字也应该能反映出更
多的信息来:
Visual Basic示例:含义更加清晰的代码
For month 1 TO NUM_MONTHS_IN_YEAR
profit( month) revenue month- expense month)
Next
这看上去已经非常不错了,但是我们还可以用枚举类型来让它更上一层楼:
Visual Basic示例:含义一目了然的代码
For month Month January Month December
profit( month revenue( month expense( month
Next
对于最后的这个示例,没有人会对循环的用途产生怀疑了。即使你认为使用
文字量(literal)是安全的,也应当转去使用具名常量。请成为从代码中剔除文字
量的狂热者吧。用一款文本编辑器来寻找代码里的2、3、4、5、6、7、8和9,
以确认你没有由于不小心而使用了它们。
交叉参考前面用具有适当作用域的变量或类来模拟具名常量如果你的语言不支持具名常
第12.6节中的如量,
果你的语言里没量,你可以自行创建解决方案。通过使用与前面模拟枚举类型ava示例中建议的
有枚举类型”有关相似的方法,你同样可以获得具名常量的优点。需要遵循的典型的作用域原则是:
于如何模拟枚举
类型的详细介绍。优先选用局部作用域,其次是类作用域,再次是全局作用域。
统一地使用具名常量如果需要表示的是同一个实体,在一处使用具名常量,
而在另一处使用数字符号是非常危险的。有些编程实践是在自找麻烦;就像是在
拨打800免费热线,并要求把错误送上门来如果某个具名常量的值需要修改,
3译注: Monty Python为20世纪60年代英国经典电视连续剧, Python语言由此得名。
代码大全(第2版)

<==========================346end ==============================>
<==========================347start==============================>

该书下载自书部落-分享计算机经典巨著--www. !--www.shubulo.com!^ .com!仅供试看
310
第12章基本数据类型
你就会去修改它,然后自信已经做了全部所需的改动。这样就会忽略掉那些硬编
码的数字符号,从而给你的程序带来难于发现的问题,而解决这些问题可要比抓
起电话大声求助难得多。
12.8
Arrays
数组
数组是最简单和最常用的结构化数据类型。在有些语言里,数组是唯一的结
构化数据类型。一个数组含有一组类型完全相同,并且可以用数组下标来直接
KEY POINT
访问的条目。下面就如何使用数组给出一些建议
确认所有的数组下标都没有超出数组的边界在任何情况下,与数组有关的
所有问题都源于一个事实:数组里的元素可以随机访问。最常见的问题就是程序
试图用超出数组边界的下标去访问数组元素。在有些语言里,这种情况会产生一
个错误;在其他语言里,这样做会产生一个奇怪的不可预料的结果。
考虑用容器来取代数组,或者将数组作为顺序化结构来处理计算机科学界
的一些最聪明的人士建议永远不要随机地访问数组,只能顺序地访问(Mills and
Linger1986)他们的论点是,在数组里随机访问就像在程序里面随便使用的goto
语句一样:这种访问很容易变得难于管理且容易出错,要证明其是否正确也很困
难。他们建议使用集合、栈和队列等按顺序存取元素的数据结构来取代数组。
在一项小型试验里, Mills和 Linger发现按照这种方法所创建的设计中只需要
更少的变量和变量引用。相对而言,这样做设计的工作效率较高,能产生高度可
HARD DAT靠的软件
在你习惯性地选用数组之前,考虑能否用其他可以顺序访问数据的容器类作
为替换方案一如集合、栈、队列等。
交叉参考使用
数组和使用循环
检查数组的边界点正如考虑循环结构的边界是非常有用的样,你可以通
所遇到的问题有过检查数组的边界点来捕获很多错误。问问自己,代码有没有正确地访问数组的
相似之处,二者也第一个元素?还是错误地去访问了第一个元素之前或者之后的那个元素?而后一
是紧密联在一个元素呢?代码会导致off-by-one的误吗?最后,问问你自己代码有没有正确
起的。在第16章
“控制循环”有地访问数组中间的元素。
关于循环的详细
介绍
如果数组是多维的,确认下标的使用顺序是正确的很容易把 Array]i
写成 Array[i][j],所以请花些时间检查下标的顺序是否正确与其用i和j这类
不明不白的东西,不如去考虑更有意义的名字。
代码大全(第2版)

<==========================347end ==============================>
<==========================348start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com!^.com!仅供试看^
12.9创建你自己的类型(类型别名)
311
提防下标串话如果你在使用嵌套循环,那么会很容易把 Array[i]写成了
Array[j.调换循环下标称为“下标串话ross-talk)”请检查这种问题。更好
的做法是使用比i和j更有意义的下标名,从而在一开始就降低下标串话错误的发
生几率。
在C中结 ARRAY合LENGTHO宏来使用数组通过定义类似于下面的
ARRAYLENGTH()宏,你可以更加灵活地使用数组:
C示例:定义 ARRAYLENGTH(宏
#define ARRAY_LENGTH x (sizeof () /sizeof (x[)
在你操作数组的时候,用 ARRAYLENGTH()宏取代具名常量来表示数组大小的上
限。如下例所示:
C示例:借助 ARRAYLENGTHO宏对数组进行操作
ConsistencyRatios=
0.0,0.0,0.58,0.90,1.12,
1.24,1.32,1.41,1.45,1.49,
1.51,1.48,1.56,1.57,1.59);
riratiodyn.
这里使用了宏。for( ratioIdx=0; ratioIdx< ARRAYLENGTH ConsistencyRatios); ratioIdx++)
这种技术对于例子中出现的这种一维数组特别有用。如果你增加或者减少了
数组中的条目,你不需要记着去改变用于描述数组大小的具名常量。当然,这种
技术也同样适用于多维数组,并且,如果用了这种方法,你就没有必要总为定义
数组而多创建一个具名常量。
12.9
Creating Your Own Types(Type Aliasing)
创建你自己的类型(类型别名)
程序员自定义的数据类型是语言所能赋予你的一种最强有力的、最有助于澄
清你对程序的理解的功能之一。它保护你的程序免受预料之外更改之困扰,并使
KEY POINT
得程序更容易阅读所有这一切都不需要你去设计、构造或者测试新的类。如
果你在使用C、C++或者另外一种能够支持用户自定义类型的语言,就请好好利用
这些自定义类型!
交叉参考很多
情况下,创建一个
为了感受创建自定义类型的威力,假设你正在写一个程序,把x、y、z坐标
类会比创建单个系中的坐标值转化为纬度、经度和海拔高度。你觉得可能需要用双精度浮点值,
数据类型好得多。但除非能对此完全肯定,否则你宁愿用单精度浮点值写程序你可以使用C或C+
在第6章“可以
工作的类”里面中的 typedef语句或者其他语言中的相关语句来为坐标创建一个新的特殊类型。
有详细的介绍。
代码大全(第2版)

<==========================348end ==============================>
<==========================349start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看^
312
第12章基本数据类型
下面是你用C++创建该类型定义的代码:
C++示例:创建一个数据类型
typedef float Coordinate; 1/ for coordinate variables
该类型定义声明了一个新的类型, Coordinate,其功能与 float类型完全相同。
在使用这一新类型时,你就像使用float等预定义类型一样用它来声明变量。下
面就是一例:
C++示例:使用前面创建的数据类型
Routinel(..)
Coordinate latitude; latitude in degrees
Coordinate longitude;/ longitude in degrees
Coordinate elevation; / elevation in meters from earth center
Routine22
Coordinate coordinate in meters
coord
Coordinate y: / y coordinate in meters
Coordinate z; /1 z coordinate in meters
在这段代码里,变量 latitude(纬度), longitude(经度), elevation(海
拔),x,y和z都声明为 Coordinate类型。
现在假设程序发生了变化,你最终发现自己需要使用双精度变量来表示坐标
由于你已经专门为坐标数据定义了一种类型,因此唯一需要修改的就是类型的定
义。而且只需要在一处做修改: typedef语句里面。下面是修改后的类型定义:
C++示例:改变后的类型定义
最的oat为→ typedef double Coordinate for coordinate variables
double.
下面再举一例—这回用的是 Pascal。假设你在开发一套薪资系统,其中员
工姓名的最大长度不超过30个字符。你的用户已经说过没有任何人的姓名超出
30个字符。你会在你的程序里到处硬编码30这一数字吗?如果你这么做,那么
你对你用户的信任要远远超过我对我用户的信任!更好的做法是为员工姓名定义
一种类型:
Pascal示例:为雇员姓名创建数据类型
Type
employeeName= array1..30 of chari
代码大全(第2版)

<==========================349end ==============================>
<==========================350start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! -www.shubulo.c!^.com!仅供试看^
12.9创建你自己的类型(类型别名)
313
一旦涉及到使用字符串或者数组,最明智的做法通常是定义出一个能够表明
该字符串或数组长度的具名常量,然后在类型定义中使用该具名常量。程序中有
很多地方会用到该具名常量—这里只是第一个位置。代码如下:
Pascal示例:为雇员姓名创建数据类型更好的做法
Constm
这里定义了具名常 NAMELENGTH=30
量。
Type
这里使用了前面€oYeeNaaxNNNG1oh3€=array1..namelengthofchar
定义的具名常量
一个更强大的例子是把创建自己的类型和信息隐藏这两种理念结合起来。在
一些情况下,你想要隐藏的信息就是该数据的类型信息。
上面C++的坐标示例只是部分地实现了信息隐藏。如果你总是使用
Coordinatefloat而非或者 double,你就有效地隐藏了数据的类型在C++里,
这差不多就是语言能够为你隐藏的全部信息。除此之外,你或者你代码的后续使
用者还必须遵守“不去查看Coordinate的定义”的纪律C++为你提供了象征性
的、而不是字面的信息隐藏的能力。
其他的语言,例如Ada,走得更进一步,支持字面的信息隐藏( literal information
hiding)下面是一个声明了 Coordinate代码段的Ada包(package)的样子:
Ada示例:将类型细节隐藏到包内部
这条语句声明 package Transformation is
Coordinatetype Coordinate is private;
包的私用成员。
下面是另一个使用了 Coordinate的包的例子
Ada示例:使用另一个包内的类型
with Transformation;
procedure Routine1(...)..
latitude: Coordinate;
longitude: Coordinate;
begin
statements using latitude and longitude
end Routinel;
代码大全(第2版)

<==========================350end ==============================>
<==========================351start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看
314
第12章基本数据类型
请注意, Coordinate类型在包规格中声明为私用的。这意味着程序中唯一了
解 Coordinate类型定义的部分是 Transformation包的私用部分。在一个团队
开发的环境里,你可以只分发包规格,从而使开发其他包的程序员不能查看
Coordinate的底层类型。该信息被字面地隐藏了像C++这样要求你通过头文件
来分发 Coordinate定义的语言里较难实现真正的信息隐藏。
这些例子阐明了多项创建你自己类型的原因。
易于修改创建一个新类型并不费事,而且它为你带来了很多灵活度。
避免过多的信息分发采用硬编码而非集中在一处管理数据的方式会导致
数据类型的细节散布于程序内部。这是第6.2节讨论的集中化的信息隐藏原
则时的一个例子。
增加可靠性在Ada中,你可以定义 type Age is range0.99这样的类型。编
译器接着就会生成运行时检查,以验证所有Age类型变量的取值都处于0
到99的范围内
弥补语言的不足如果你的语言不具有你所需要的预定义类型,你可以自己
来创建它。例如,C没有布尔或者逻辑类型。这种不足很容易通过自己创建
该类型来予以弥补:
typedef int. Boolean;
Why Are the Examples of Creating Your Own Types in Pascal and
Ada
为什么创建自己的类型的示例是用 Pascal和Ada写的
Pascal和da已经在走向灭亡,而且一般来,取代它们的语言都更好用。
然而,就简单类型定义而言,我认为C++、Jav和 Visual Basic在这方面改善不大。
Ada声明如下:
currentTemperature: INTEGER range 0..212;
包含了下述语句所不具备的重要语义信息:
int temperature;
再进一步,像下面这样的类型声明
type Temperature is range 0..212;
currentTemperature: Temperature;
代码大全(第2版)

<==========================351end ==============================>
<==========================352start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com.com!仅供试看
12.9创建你自己的类型(类型别名)
315
使编译器能保证只把 current Temperature赋给其他 Temperature类型的变量,
这样只需要很少的额外代码就能为程序提供更多的安全边界。
当然,程序员可以创建一个Temperature类,去推行Ada语言里自动推行
的同样的语义。但从写一行代码创建的一个简单数据类型,到创建一个类,是很
大的一步。在许多情况下,程序员可能愿意创建这个简单类型,但却不愿意向前
走一步,付诸更多努力去创建一个类。
Guidelines for Creating Your Own Types
创建自定义数据类型的指导原则
交叉在任
请在创建自己的“用户自定义”类型时考虑下述原则。
何情况下,都应该
考虑用类是否会给所创建的类型取功能导向的名字避免使用那些代表了类型底层计算机数
比用简单数据类据类的类型名。应该用能代表该新类型所表现的现实世界问题的类型名。前面例
型更好,相关内容
在第6章“可以工子中的定义就为坐标和人员姓名创建了命名良好的类型它们代表了现实世界
作的类”中有详细中的事物。与之相似,你可以为货币、支付代码、年龄等现实世界问题的方
的介绍。
方面面创建类型。
要提防创建了引用预定义类型的类型名像 BigInteger或 LongString这样
的类型名所反映的是计算机数据,而非现实世界问题创建自定义类型的最大优
点,就在于它提供了介于你的程序和实现语言之间的一层绝缘层。引用了底层编
程语言类型的类型名就是在该绝缘层上戳了一个洞。它不会比使用一种预定义类
型给你带来更多好处。另一方面,以现实问题为导向的名字也使自定义类型容易
修改,其作用不言自明。
避免使用预定义类型如果类型有一丝变化的可能,就应避免在除 typedef
或类型定义之外的任何位置使用预定义的类型。创建功能导向的新类型很容易,
但是修改那些使用了硬编码的类型的程序里的数据却很难。更何况使用功能导向
的类型声明,实际上部分地解释了那些通过它们声明的变量。像Coordinate
这样的声明要比 float xx这样的声明告诉你更多有关x的信息。请尽可能多地使
用自己创建的类型。
不要重定义一个预定义的类型改变一个标准类型的定义会引起混淆。例如,
如果你的语言有一个预定义的类型 Integer,那么就不要创建名为 Integer的自
定义类型。代码的读者可能会忘记你已经重新定义了该类型,并认为他们所看到
的 Integer就是他们习惯看到的那个 Integer
定义替代类型以便于移植与不要修改标准类型的定义的建议相反,你可能
需要为标准类型定义替代类型,以便让变量在不同的硬件平台上正确地代表相同
的实体。例如,你可以定义一个NT32类型,用它来代替int,或者定义loNG64
代大全(第2版)

<==========================352end ==============================>
<==========================353start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo. ^.com!仅供试看^
316
第12章基本数据类型
类型来代替long.最初,这样的两个类型之间唯一的区别就是它们名字的大小写不
同。但是当你把程序移植到一个新的硬件平台之上的时候,你就可以重新定义大写
的那个类型版本,以便它们能够与原始硬件的数据类型相匹配。
一定不要定义容易被错认为是预定义类型的类型或许可以定义INT而非
INT32,但你最好把自定义类型和语言所提供的类型明显地区分开来。
考虑创建一个类而不是使用 typedef简单的 typedef对隐藏变量的底层类型
信息是大有帮助的。然面,在一些情况下,你可能会需要定义类所能获得的那些
额外的灵活度和控制力。详细信息请见第6章“可以工作的类”
CHECKLIST: Fundamental Data
c2co20核对表:基本数据类型
交叉如果想看数值概论
针对普遍数据类型
而非特定数据类型口代码中避免使用神秘数值吗?
的核对表,请看第10
章257页的“使用变口代码考虑了除零错误吗?
量的一般事项”。如口类型转换很明显吗?
果想看如何为变量
命名的注意事项核口如果在一条语句中存在两个不同类型的变量,那么这条语句会像你期望
对表,请看第11章
288页的“变量名的
的那样求值吗?
力量”。
口代码避免了混合类型比较吗?
口程序编译时没有警告信息吗?
整数
口使用整数除法的表达式能按预期的那样工作吗?
口整数表达式避免整数溢出问题吗?
浮点数
口代码避免了对数量级相差巨大的数字做加减运算吗?
口代码系统地阻止了舍入错误的发生吗?
口代码避免对浮点数做等量比较吗?
字符和字符串
口代码避免使用神秘字符和神秘字符串吗?
口使用字符串时避免了off-by-one错误吗?
代码大全(第2版)

<==========================353end ==============================>
<==========================354start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
12.9创建你自己的类型(类型别名)
317
口C代码把字符串指针和字符数组区别对待了吗?
口C代码遵循了把 CONSTANT字符串声明为+1长度的规则了吗?
口C代码在适当的时候用字符数组来代替指针了吗?
口C代码把字符串初始化为NULL来避免无终端的字符串了吗?
口c代码 strncpy用()代替 strcpy()吗? strncat()和 strncmp()呢?
布尔变量
口程序用额外的布尔变量来说明条件判断了吗?
口程序用额外的布尔变量来简化条件判断了吗?
枚举类型
口程序用枚举类型而非具名常量来提高可读性、可靠性和可修改性吗?
口当变量的用法不能仅用true和 false表示的时候,程序用枚举类型来
取代布尔变量吗?
口针对枚举类型的测试检测了非法数值吗?
口把枚举类型的第一项条日保留为“非法的”了吗?
具名常量
口程序用具名常量而不是神秘数值来声明数据和表示循环界限吗?
口具名常量的使用一致吗?没有在有些位置使用具名常量又在其他位
置使用文字量?
数组
口所有的数组下标都没有超出数组边界吗?
数组引用没有出现off-by-one错误吗?
口所有多维数组的下标的顺序都正确吗?
口在嵌套循环里,把正确的变量用于数组下标来避免循环下标串话了吗?
代码大全(第2版)

<==========================354end ==============================>
<==========================355start==============================>

该书下载自-书部落-分享计算机经典-www. ! --www.shubulo.com!^.com供试看
318
第12章基本数据类型
创建类型
口程序对每一种可能变化的数据分别采用不同的类型吗?
口类型名是以该类型所表示的现实世界实体为导向,而不是以编程语言
类型为导向的吗?
口类型名的描述性足以强,可以帮助解释数据声明吗?
口你避免重新定义预定义类型吗?
口与简单地重定义一个类型相比,你考虑过创建一个新类吗?
Key Points
要点
使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用
本章的核对表来确认你已经对常见问题做了考虑。
如果你的语言支持,创建自定义类型会使得你的程序更容易修改,并更具有
自描述性
当你用 typedef或者其等价方式创建了一个简单类型的时候,考虑是否更应
该创建一个新的类。
代码大全(第2版)

<==========================355end ==============================>
<==========================356start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
Unusual Data Types
第1章
不常见的数据类型
cc2.com/17内容
13.1结构体:第319页
13.2指针:第323页
13.3全局数据:第335页
相关章节
基本数据类型:第12章
■防御式编程:第8章
不常见的控制结构:第17章
软件开发中的复杂度:第5.2节
有些语言除了支持第12章“基本数据类型”所讨论的那些数据类型之外,还
支持一些“奇异的”数据类型。第13.1节描述了什么时候你可能会在一些场合中
使用结构体而不使用类。第13.2节描述了使用指针的细节。如果你曾经被与使用
全局数据有关的问题困扰,那么第13.3节将会为你解释如何避免遇到这些麻烦。
如果你发现本章描述的数据类型并不是你通常在一些现代面向对象编程书籍中所
读到的类型,这就对了。这正是为什么本章被命名为“不常见的数据类型”的原
因。
Structures
结构体
“结构体”这一术语指的是使用其他类型组建的数据。由于数组是一个特殊
情况,因此把它单独放到了第12章。本节讲述用户创建的结构化数据C和
C++中的 struct,以及 Microsoft Visual Basic中的 Structure在ava和C++里面,
类有时表现得也像结构体一样(当类完全由公用的数据成员组成,而不包含公用
子程序的时候)。
通常情况下,你会希望创建类而非结构体,这样除了能使用结构体可以提供
的公用数据成员外,还能利用类所提供的私密性和功能性。但是有时直接操纵成
块的数据会十分方便,下面就列出了一些使用结构体的理由。
代码大全(第2版)

<==========================356end ==============================>
<==========================357start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
320
第13章不常见的数据类型
用结构体来明确数据关系结构体把相关联的一组数据项聚集在一起。有时
了解一个程序最为困难的部分就在于理清哪些数据之间相互有联系。这就像来到
一座小镇上问谁认识谁一样。你会发现每个人似乎都与其他人有关,但又并不尽
然,这样你永远不会得到一个好的答案。
如果数据的组织结构非常清晰,那么弄清楚哪些数据与哪些相关联就会容易
多了。下面是一个数据没有组织起来的例子:
Visual Basic示例:令人误解的、无组织的一堆变量
name inputName
address =inputAddress
phone =inputPhone
title= inputTitle
department =inputDepartmen
bonus =inputBonus
因为这些数据是无组织的( unstructured),因此看上去好像所有的赋值语句都
相互有关。而事实上, nameaddress和 phone是与单个雇员相关联的变量,title、
department和 bonus是与主管相关联的变量。这段代码并没有提示说这里有两
类数据在运作。在下面的代码片段里,结构体的引入使得这些关系变得更加清晰:
Visual Basic示例:提供更多信息的结构化变量
employee.name inputName
employee. address= inputAddress
employee. phone= inputPhone
supervi sor. tile inputTitle
supervisor. department= inputDepartment
supervisor. bonus= inputBonus
在使用了结构化变量的代码里,很明显可以看出有一些数据与雇员有关,其
他的数据与主管有关。
用结构体简化对数据块的操作你可以把相关的元素组织到结构体里面,然
后对该结构体执行操作。对结构体执行操作要比对各元素执行同样的操作容易得
多。这样做也会更可靠,并且只需更少的代码。
假设你有一组彼此关联的数据条目例如,是一个人事数据库中有关某雇
员的数据。如果这一数据没有组织到一个结构体里仅仅复制这组数据就会牵涉
到很多条语句。下面是一个 Visual Basic示例:
代码大全(第2版)

<==========================357end ==============================>
<==========================358start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
13.1结构体
321
Visual Basic示例:复制一组数据项—笨拙的做法
newName =oldName
newAddress oldAddress
newPhone =oldphone
newssn =olassn
newGender =oldgender
newSalary oldsalary
每次想要传递雇员信息的时候,就不得不写出这样整组的语句。如果你增加
一项新的雇员信息例如, numWithholdings你就不得不设法找到各块赋
值语句的位置,往里面增加一条赋值语句 newNumwithholdings= oldNum
Withholdings.
想象一下交换两个雇员的数据会多么可怕无须运用你的想象力下面给
出了这些语句:
Visual Basic示例:交换两组数据——困难的做法
swap new and old employee data
previousol dName oldName
CODING previousoldAddress =oldAddress
HORROR previousoldPhone oldPhone
previousolassn =olassn
previousoldGender oldGender
previousolasalary oldsalary
newName
oldName newName
oldAddress newaddress
oldphone newPhone
olassn =newssn
oasender= newGender
newName previousolaName
newAddress =previousoldAddress
newPhone =previousoldPhone
newsen erpreviousoldssncende
newGender =previousoldgender
newSalary =previousoldsalary
解决该问题的一种更简便的方法是声明一个 Structure变量:
Visual BasicStructure示例:声明
structure Employee
name As string
address As string
phone As string
ssn As String
gender As string
salary As long
代码大全(第2版)

<==========================358end ==============================>
<==========================359start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
322
第13章不常见的数据类型
End Structure
Dim newEmployee As Employee
Dim oldEmployee As Employee
Dim previousoldEmployee As Employee
现在你用三条语句就可以交换新旧雇员结构体中的元素了:
Visual Basic示例:交换两组数据容易的做法
previousoldEmployee oldEmployee
oldEmployee newEmployee
newEmployee =previousoldEmployee
如果你想增加一个字段,比如说numWithholdings,你只需要简单地把它增
加到结构体声明中即可。以上这三条语句或者程序里的任何相似语句都无须改动。
C++以及其他的语言都具有这样的功能。
交叉参考第5.3
用结构体来简化参数列表你可以利用结构体变量简化子程序的参数列表。
节中的“保持松散
耦合”详细讨论了方法与刚才提到的相似。与单独传递每一个需要的元素相比,你可以把相关的元
子程序之间到底应素组织到一个结构体里,然后把它作为一个整体传递进去。下面这个例子用了一
当
多少数据的种笨拙的方法来传递一组相关参数:
问题。
Visual Basic示例:笨拙的子程序调用(未使用结构体)
HardWayRoutine name, address phone, ssn, gender, salary
下面的方法则要简单得多。该方法在调用子程序时使用了一个包含前面参数
列表中诸元素的结构体变量:
Visual Basic示例:优雅的子程序调用(使用结构体)
EasyWayRoutine employee
如果你想在第一种调用里增加一个 numWithholdings元素,你就不得不费力
地查看所有代码,修改对 HardWay Rout ine()的每一处调用。而如果你在 Employee
结构体中增加 numWithholdings元素,你就根本不需要去修改传递给 EasyWay
Routine()的参数。
交叉参考第
5.3节“保持松散
你也可以把这种技术运用到极致,即把程序中所有的变量都放置在一个巨大
耦合”介绍了数的内容丰富的变量里,然后到处传递它除非逻辑上有必要,细致的程序员会避
据传递过多带来免把数据捆扎在一起。此外,他们还会避免把一个只需要其中一两个字段的结构
的风险。
体作为参数传递—相反,他们只会传递那些必需的特定字段。这是信息隐藏原
则的一个方面:有些信息藏在子程序里面,而有些信息是对子程序隐藏的。信息
应该按照有必要了解(need-to-know)的原则进行传递。
代码大全(第2版)

<==========================359end ==============================>
<==========================360start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
13.2指针
323
用结构体来减少维护由于你在使用结构体的时候是把相关的数据组织在一
起的,因此对结构体的修改只会导致对程序做很小的改动特别是对那些逻辑与
结构体变化没有关联的代码来说,这一点尤为正确由于变化容易带来错误,因
此变化越少,错误也就越少。如果 Employee构体中含有一个 title(头衔)字段,
但你又想删除它,那么不需要对任何参数列表或者用到了整个结构体的赋值语句
做出修改。当然,你必须要修改那些专用于处理雇员 title的代码,但是从概念上
来说,这直接关系到删除 title字段,因而不容易被忽略。
结构化数据所带来的最大好处体现在那些与 title字段没有逻辑关系的代码段
里。有的时候,程序中有的语句是与数据集合的整体有概念联系,而不是与其中
的个别成分有联系。在这些情况下,引用其中的个别成分,比如 title字段,只是
因为它属于整体的一部分。这些代码片段与tite字段之间并没有任何逻辑上的明
确联系,当你改变了 title的时候,很容易忘了修改这些代码段。但如果你使用了
结构体,那么忽视这些代码段是没有问题的,因为这些代码引用的是相关数据的
集合,而不是某个个别部分。
13.2
Pointers
指针
指针的使用是现代编程中最容易出错的领域之一,以至于像Java、C#和 Visual
Basic这些现代语言都没有提供指针数据类型。对指针的运用具有其固有的复杂
KEY POINT性,正确使用指针要求你对所用编译器的内存管理机制有很好的理解。很多常见
的安全问题,特别是缓冲区溢出,其产生都可以追溯到错误地运用指针上去
(Howard and LeBlanc 2003).
即便你的语言不要求你使用指针,很好地理解指针也会有助于你理解你的编
程语言是如何工作的。丰富的防御式编程实践经验则会为你带来更大的帮助。
Paradigm for Understanding Pointers
用来理解指针的范例
从概念上看,每一个指针都包含两个部分:内存中的某处位置,以及如何解
释该位置中的内容。
Location in Memory
内存中的位置
内存中的一个位置就是一个地址,常用16进制形式表示。32位处理器中的一个
地址用一个32位的值表示,比如x0001EA4指针本身只包含这个地址。为了使用
该指针所指向的数据,就必须访问该地址,解释该位置的内存内容。如果去查看该地
址的内存,可以发现它只是一组二进制位。必须经过解释才能使它变得有意义
代大全(第2版)

<==========================360end ==============================>
<==========================361start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubu.com!仅供试看
324
第13章不常见的数据类型
Knowledge of How to Interpret the Contents
如何解释指针所指的内容
如何解释内存中某个位置的内容,是由指针的基类型(base type)决定的。如
果某指针指向整数,这就意味着编译器会把该指针所指向内存位置的数据解释为一
个整数。当然,你可以让一个整数指针、一个字符串指针和个浮点数指针都指向
同一个内存位置。但是其中(至多)只有一个指针能正确地解释该位置的内容。
在理解指针的时候,应该记住内存并不包含任何与之相关联的内在的解释。只有
通过使用一个特定类型的指针,一个特殊位置的比特才能解释为有意义的数据。
图13-1显示对内存中同一位置的儿种不同观点,用儿种不同的方式做出解释。
0A6162636465666768696A
解释方式:用于进一步举例的原始内存空间(用16进制表示)
意义:没有与之关联的指针变量,没有任何意义
0A6162636465666768696A
解释方式: String[10](以Visual Basic的格式表示,第一个字节存储长度)
意义: abcdefghij
A6162636465666768696A
解释方式:双字节的整数
意义:24842
06162636465666768696a
解释方式:四字节的浮点数
意义:4.17595656202980E+0021
0A6162636465666768696A
解释方式:四字节的整数
意义:1667391754
0A6162636465666768696A
解释方式:字符
解释:换行符(ASCI码16进制的0A或者10进制的10)
图13-1各数据类型所用的内存量用双线框表示
在图13-1的每一种情况里,指针指向的都是以16进制数值0x0A开始的位置。
0A之后使用的字节数量取决于这片内存的解释。内存内容如何使用也要取决于内
代码大全(第2版)

<==========================361end ==============================>
<==========================362start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com!^.com!仅供试看^
13.2指针
325
存的解释方式。(它还取决于你用的是什么处理器,如果想把这些结果复制到你的
袖珍计算器的时候,请记住这一点。)同样的原始内存空间可以解释为一个字符串、
一个整数、一个浮点数,或者任何其他事物一切都取决于指向该内存的指针
的基类型。
General Tips on Pointers
使用指针的一般技巧
对解决很多类型的程序错误来说,最容易的一部分是定位错误,而难的是更
正错误。然而指针错误的情况则有所不同。通常指针错误都产生于指针指向了
它不应该指向的位置。当你通过一个坏了的指针变量赋值时,会把数据写入本不
该写值的内存区域。这称为“内存破坏( memory corruption)”。有时内存破坏会
导致可怕、严重的系统崩溃;有时它会篡改程序其他部分的计算结果。有时它会
致使你的程序不可预知地跳过某些子程序而有时候它又什么事情都没做。在最
后一种情况下,这种指针错误就像一颗嘀哒做响的定时炸弹,等着在你把程序演
示给最重要客户的前5分钟时引爆。指针错误的症状常常与引起指针错误的原因
无关。因此,更正指针错误的大部分工作量便是找出它的位置。
正确地使用指针要求程序员采用一种双向策略。第一,要首先避免造成指针
错误。指针错误很难发现,因此采取一些预防性措施是值得的。其次,在编写代
码之后尽快地检测出指针错误来。指针错误的症状飘忽不定,采取一些额外措施
来使得这些症状可以被预测是非常值得的。下面说明如何才能实现这些目标。
把指针操作限制在子程序或者类里面假设你在程序中多次使用了一个链
表。每次使用它的时候,不要通过手动操作指针去遍历该链表,应该编写一组诸
如 NextLink()、 Previouslink()、 Insertlink(和Deletelink()这样的访问
器子程序来完成操作更好些。减少访问指针代码位置的数量,你也就减小了犯下
遍布程序各处、永远也找不完的粗心过错的可能性。这样一来,这些代码能相对
独立于数据的实现细节,因此也增大了在其他程序内重用这些代码的可能性。为
指针分配编写子程序是另一种集中控制数据的方法。
同时声明和定义指针在靠近变量声明的位置为该变量赋初始值通常是一项好
的编程实践,在使用指针时,应用这条原则会更有价值。你应该避免下面这种做法:
C+示例:糟糕的指针初始化
Employee *employeePtr;
1/ lots of code
employeeptr =new Employee;
代码大全(第2版)

<==========================362end ==============================>
<==========================363start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
326
第13章不常见的数据类型
即使这段代码一开始能正确地工作,修改时也容易出错,可能有人会试着在
指针声明和指针初始化之间的位置使用 employeeptr.下面是一种更为安全的做
法:
C++示例:良好的指针初始化
lots of code
Employee *employeePtr new Employee;
在与指针分配相同的作用域中删除指针要保持指针分配和释放操作的对称
性。如果你需要在一个单一作用域内使用指针,那么就应该在此作用域范围内用
new分配指针,用 delete释放指针。如果你在一个子程序内分配了一个指针,那
么就在同一个子程序里释放它。如果你在一个对象的构造函数里面分配了一个指
针,那么就在该对象的析构函数里释放它如果一个子程序分配了内存,却指望
调用它的代码来释放该内存,这样造成的不一致的处理方式很容易出错。
在使用指针之前检查指针在程序的关键之处使用一个指针之前,要确保它
所指向的内存位置是合理的。例如,如果你希望的内存位置介于 StartData和
EndData之间,那么你就该对一个指向 startData之前或者 EndData之后的指针
产生疑问。你还必须要确定在你的环境下 StartData和的取值如果你
是用访问器子程序来操作指针,而不是直接操作它们的话,那么这一检查工作就
可以自动进行。
先检查指针所引用的变量再使用它有时你应该对指针所指向的数据执行合
理性检查。例如,如果你认为指针指向的是一个介于0和1000之间的整数,那么
你就应该对大于1000的数值产生怀疑。如果指向的是一个++-style的字符串,
那么就应该对长度超过100的字符串持怀疑态度。同样,如果你是通过访问器子
程序来使用指针,那么这一项工作就可以自动完成了。
用狗牌字段来检测损毁的内存“标记字段( tag field)”或者“狗牌(dog tag)”
是指你加入结构体内的一个仅仅用于检测错误的字段。在分配一个变量的时候,
把一个应该保持不变的数值放在它的标记字段里。当你使用该结构的时候特
别是当你释放其内存的时候—检测这个标记字段的取值。如果这个标记字段的
取值与预期不相符,那么这一数据就被破坏了。
在删除指针的时候,就破坏这个字段。这样如果你不小心再次释放了同一
个指针,就会检测到这种破坏。举例来说,假定你需要分配100个字节:
1.首先,分配104个字节,比需要的多出4个字节。
104 bytes
代码大全(第2版)

<==========================363end ==============================>
<==========================364start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--www.shubulo. com!^ .com!仅供试看
13.2指针
327
2.把前4个字节设为狗牌值,然后返回指向这4个字节后面的内存的指针。
Set pointer to here
tag
3.到了需要删除该指针的时候,检查这个标记。
-Check this tag.
tag
4.如果标记的值是正确的,那么就把它置为0或者其他你和你的程序可以识
别为非法标记值的值。你当然不希望在释放该内存后还会把这个值错误地当成表
示指针合法的标记。同理,也请将数据设为0,0xCC,或者其他的非随机的数值。
5.最后,删除该指针
Free the whole 104 bytes
把狗牌放置在你所分配的内存区域的开始位置,让你能检查是否多执行了释
放该内存的操作,而无须去维护一个包含你所分配的全部内存区域的列表。把狗
牌放置在内存区域的后面,让你能检查是否做过超出该内存块末尾的覆盖数据操
作。你可以同时在前面和后面放狗牌,以便同时达到上述两个目标。
你可以结合使用这种方法和前面介绍到的合理性检测检查指针位于
StartData和 EndData之间。为了确认指针指向的是一个合理的位置,而不单是
指向一个大概的内存区间,请检查该指针是否位于已分配的指针列表里。
你可以在删除某一变量之前检查一下标记字段。损毁的标记会告诉你,在这
一
变量的生命期里其内容已经被损坏了。然而,你检查标记字段越频繁,就会越
接近产生问题的根源。
增加明显的冗余还有一种可以代替标记字段的方案,就是某些特定字段重
复两次。如果位于冗余字段中的数据不匹配,你就可以确定数据已经破坏了如
果你直接操作指针,这么做会带来很高的成本然而,如果你把指针操作限制在
子程序里面,那么就只需要少数几处重复的代码。
用额外的指针变量来提高代码清晰度一定不要节约使用指针变量。这个要
点来自别处,那就是不要把同一个变量用于多种用途。这一点对指针变量来说尤
为正确。在没弄清楚为什么要反反复复使用 genericlink变量,也没弄清楚
代码大全(第2版)

<==========================364end ==============================>
<==========================365start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! -www.shubulo.c ^.com!仅供试看^
328
第13章不常见的数据类型
pointer->next->last->next指向什么之前,很难弄清别人在用链表做些什么。
请考虑下面的代码片段:
C++示例:传统的插入节点的代码
void InsertLink(
Node *currentNode
Node *insertNode
){
insert insertnoden after currentode
insertNode->next =currentNode->next;
insertNode->previous currentNode;
这条语句本不应if( currentNode--next=nuLL)(
该如此复杂。
currentNode->next->previous insertNode;
currentNode->next insertNode;
这是往链表里插入一个节点的传统代码,它毫无必要地如此晦涩难解。插入一个
新节点涉及到三个对象:当前节点,此时位于当前节点后面的节点,以及将要被
插入到二者之间的节点。这段代码片段只明确地承认了两个对象: insert Node和
currentNode它要求你要弄清楚并且要记住 currentNode-->next也被包含在内
了。如果你想在不画出最初跟在currentNode面的那个节点的情况下,用图形
表示发生的事情,会得到如下的图示:
currentNode insertnode
更好的图示是把全部三个对象都给识别出来。该图示会是这样的:
startNode newMiddleNode followingNode
下面的代码明确引用了操作中涉及的全部三个对象:
C++示例:更具可读性的节点插入代码
void InsertLink(
Node *startNode,
Node *newMiddleNode
)
/1 insert "newMiddleNode" between "startNode" and "followingNode"
Node *followingNode =startNode->next;
newMiddleNode->next followingNode;
newMiddleNode-->previous= startNode;
if followingNode ! NULL
followingNode-->previous= newMiddleNode;
startNode->next =newMiddleNode;
代码大全(第2版)

<==========================365end ==============================>
<==========================366start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. cor.com!仅供试看^
13.2指针
329
虽然这段代码中多了一行代码,但是由于没有了前一段代码中绕口的
currentNode-->next->previous,因此它读起来更容易些。
简化复杂的指针表达式复杂的指针表达式是很难读懂的。如果你的代码里
含有类似于p-q->r->s.data这样的语句,那么请考虑一下这个表达式的读者的
感受吧。下面举一个极端的例子:
C++示例:难以理解的指针表达式)
fore rate ndeeindex raternde rateumRatesid erateIndex++
netRate[ rateIndex ] baseRate[ rateIndex
CODING
rates->discounts->factors->net;
HORROR
像本例中指针表达式这样复杂的代码,简单读读不可能理解,要费很多气力才能
弄清楚。如果在你的代码里面包含了一个复杂的表达式,那么就把它赋给一个命
名良好的变量,以明确该操作的用意。下面是该示例改进后的版本:
C++示例:简化一个复杂的指针表达式
quantityDiscount rates->discounts-sfactors->net;
for rateInde
teindex rate rat numgates rat eIndex.
netRate rateIndex baseRate rateIndex quantityDiscount;
经过这样一番简化,不但提高了可读性,而且还可能因为简化了循环内的指
针操作而改善了性能。依照惯例,你必须要先度量它的性能收益,然后再下赌注。
画一个图用代码来解释指针可能会让读者感到困惑。画一个图通常会有所
帮助。例如,有关链表插入问题的一张图示可能会像图13-2这样。
交叉参考图
132这样的图最初的链接关系
表可以用来对程
startNode->next
序做额外的说
startNode
明。第32章“自
followingNode
说明代码”详细
followingNode->previous
介绍了一些程序
文档化方面的良
期望得到的链接关系
好实践。
startNode->next
followingNode->previous
startNode
followingNode
newMiddleNode->previous
newMiddlenode->next
InewMiddlenode
图13-2能帮助我们考虑指针链接步骤的示例图
代码大全(第2版)

<==========================366end ==============================>
<==========================367start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!.com!仅供试看^
330
第13章不常见的数据类型
按照正确的顺序删除链表中的指针在使用动态分配链表时,经常遇到的一
个问题是,如果先释放了链表中的第一个指针,就会致使表中的下一个指针无法
访问。为了避免这一问题,在释放当前指针之前,要确保已经有指向链表中下一
个元素的指针。
分配一片保留的内存后备区域如果在你的程序中使用了动态内存,就需要
避免发生程序忽然用尽了内存、把你的用户和用户的数据丢在RAM空间里的尴
尬场景。使你的程序对这类错误留出缓冲地带的一种方法是预先分配一片内存后
备区域。设法确定程序为了“保存所做的工作执行清理并体面地退出”需要用
多少内存。在程序初始化阶段把这部分内存分配出来作为后备,然后就可以不再
管它。一旦你真的用光了内存,就释放保留下来的这片后备区,执行清理工作,
然后退出。
粉碎垃圾数据指针错误是很难调试的,因为你无法确定指针所指向的内存
《 Writing Solia
CodeMaguire何时变成非法的。有时指针已经释放了很长一段时间,相应内存的内容看起来还
1993)一书中有对像是有效的。而在另一些时候,这些内存内容马上就会改变。
安全操作C指针
的精彩描述。
在C语言中,在释放内存区域之前用垃圾数据来覆盖这些内存区域,可以让
与使用已释放的指针有关的错误的表现方式更一致。和其他很多操作相似,如果
你使用了访问器子程序,那么就可以让这一功能自动执行。在C++里面,你可以
在每次删除指针的时候使用类似于下面的代码:
C++示例:强制让释放的内存包含垃圾数据
memset( pointer, GARBAGE_DATA, MemoryBlockSize pointer
当然,该方法对C++中指向对象的指针不奏效它还要求你维持一份可以通
过 MemoryBlocksize()子程序来获取的记录指针大小的列表,我将在后面解释怎
么做。
在删除或者释放指针之后把它们设为空值一种常见的指针错误是“悬空指
针(dangling pointer)”,即使用一个已经被 delete或者free的指针指针错误
难于检测的原因之一就是,这类错误有的时候并不产生任何征兆。尽管在删除指
针后再将其设为null并不能阻止你去读取一个空悬指针所指向的数据,但这的确
可以保证当你向一个空悬指针写入数据时会产生错误。这一错误可能引发一场巨
大的灾难。但至少可以由你首先发现这一错误,而不是留给其他人。
可以扩充前例中位于 delete操作之前的代码,以实现这一技巧
C++示例:在删除指针之后将其设为NULL
memset( pointer, GARBAGEDATA MemoryBlocksize( pointer));
delete pointeri
pointer =NULL;
代码大全(第2版)

<==========================367end ==============================>
<==========================368start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
13.2指针
331
在删除变量之前检查非法指针破坏程序的最好办法之一就是在已经删除或
者释放了一个指针之后再 delete()或者fee()它。不幸的是,很少有语言能够
检测出这类问题来。
如果把已经释放的指针设置为空,就可以在使用或试图再度删除指针之前对
其进行检测。如果不把已释放的指针设为空值,就不可能拥有这项选择。这就提
出了对前面删除指针的代码的另一扩充:
c++示例:在删除指针之前断言其不为NULL
ASSERT( pointer ! NULL, "Attempting to delete null pointer.")
memset( pointer, GARBAGE_data, MemoryBlocksize( pointer))
delete pointer:
pointer =NULL;
跟踪指针分配情况维护一份你已经分配的指针的列表。这样就能让你在释
放一个指针之前检查它是不是位于列表里面。下面是一个例子,说明怎样修改普
通指针删除代码,以增加这项功能:
C+示例:检查是否已经分配了某个指针
ASSERT( pointer ! NULL, "Attempting to delete null pointer. "
if( IsPointerInList( pointer))
memset pointer GARBAGEDATA, MemoryBlocksize pointer));
RemovePointerFromList pointer
delete pointer
pointer =NULL;
else
ASSERT( FALSE, "Attempting to delete unallocated pointer.
编写覆盖子程序,集中实现避免指针问题的策略正如从上面这个例子里所
看到的,每次新建或者删除指针的时候,都需要多写很多额外的代码。在本节所
描述的技术里,有些是相互排斥或者前后重复的而你却不希望在同一个代码库
上面应用多种相互冲突的策略。比如说,如果你维护了一份自己的合法指针的列
表,那么就不需要设置并检查狗牌值。
通过对常见的指针操作编写覆盖子程序(cover routine),可以减少编程的工
作量,并且降低错误几率。在C++中,你可以使用下面两个子程序。
Se_new这个子程序调用new来分配指针,把这一新的指针加入已分配
指针列表中,然后将这一新分配的指针返回给调用方子程序。它还可以在该
子程序内检查new操作的返回值是否为空或是否抛出异常(也就是是否发
生“内存不足”错误),从而简化了程序其他部分的错误处理。
代码大全(第2版)

<==========================368end ==============================>
<==========================369start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
332
第13章不常见的数据类型
SAFE_DELETE这个子程序检查传递给它的指针是否在已分配指针的列表
里。如果它在列表里,就把该指针所指向的内存设置为垃圾数值,把该指针
从列表中移除,再调用C++的delete运算符释放该指针,并且把该指针设为
空值。如果该指针不在列表里,那么 SAFEDELETE将显示条诊断信息,
并且终止程序运行。
这里我们用宏来实现SAFE_DELETE子程序。代码如下:
C++示例:在删除指针的代码外加一层包裹
#define SAFE_DELETE pointer
ASSERT( pointer=null,"Attempting to delete null pointer.")
if( IsPointerInList pointer
memset( pointer, GARBAGEDATA, MemoryBlocksize( pointer));
RemovePointerFromList pointer
delete pointer:
pointer NULL;
else (
ASSERT( FALSE, "Attempting to delete unallocated pointer. " i
在C++里,这一子程序会删除单个的指针,但是你还需要一个实现相似功能
8.6节中的“计划
移除调试辅助的的SAFE_DELETEARRAY子程序来删除指向数组的指针。
代码”介绍了如
何为移除辅助调
通过把指针操作集中到这两个子程序中,你还可以使得 SAFENEW和
试的代码做计SAFE_DELETE在调试模式和产品模式下的表现有所不同。例如,当sAFE_DELETE
划
在开发阶段检测到试图释放空指针的操作时,它可能会终止程序的执行,但是在
产品阶段,它可能只简单地记录下这个错误,然后继续执行。
你可以很容易地把这种机制应用于C中 calloc的和free,以及其他使用指针
的语言。
采用非指针的技术指针比较难理解,容易用错,也容易导致依赖于具体机
器的不可移植代码。如果你能想到任何替代指针的方案,而它又能工作得很合理,
那么就应该去用它,避免这些令人头痛的问题。
C++-Pointer Pointers
C++指针
深入阅读关于C++引入了一些特定的使用指针和引用的方法。下面介绍一些适用于在C++
在C++中使用指
针的诀窍,见中使用指针的指导原则。
《 KEffective++》
2d ed. (Meyers
理解指针和引用之间的区别在C++中,指针(*)和引用(&)都能够间接
1998)和《More地引用对象。对新手而言,这唯一的差别似乎只是字面上 object-->field和
Effective++》
(《Meyes19《obect,e1)object.field的不同。但事实上,最重要的区别是,引用必须总是引用一个对
这两本书。
代码大全(第2版)

<==========================369end ==============================>
<==========================370start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!.com!仅供试看^个
13.2指针
333
象,而指针则可以指向空值,还有,引用所指向的对象在该引用初始化之后不能
改变。
把指针用于“按引用传递”参数,把 const引用用于“按值传递”参数C++
向子程序传递参数的默认方式是传递值(pass by value)而不是传递引用(pass by
reference)。当你以传递值的方式向一个子程序传递一个对象的时候,C++创建了
该对象的一份拷贝,当该对象传递回调用方子程序的时候,又有创建了一份拷贝。
对于大对象而言,这种复制可能耗费大量时间和其他的资源。因此,当你向一个
子程序传递对象的时候,通常会希望避免复制该对象,这就意味着你希望按照引
用来传递它而不是按值来传递。
然而,有时你可能希望具有“传值”的语义也就是说,不能修改传入的
对象—却用“传引用”的方式实现,即传递对象本身而非它的拷贝。
在C++中,上述事项的解决方案是使用指针来实现按引用传递,同时这
术语可能听上去挺怪用“const引用( const references)”来实现按值传递!
下面举一个例子:
C++示例:参数传递方式 by referenceby和 value
LARGE_OBJECT *modifiableobject
这种方法还有额外的好处,那就是在被调用的子程序里对可修改的和不可修
改的对象做了语法上的区分。在可以修改的对象里,成员引用使用
object-->member的表示法;而对不可修改的对象,成员引用使用 object. member
表示法。
这种方法的局限性在于 const引用难以传播。如果你控制着自己的代码库,那
么就应尽可能地应用 const( Meyers1998),而且也应该把按值传递的参数声明为
const引用。对于库代码或者其他你无法控制的代码而言,如果使用 const子程序
参数就会遇到麻烦。这里的退路是仍然用引用来表示只读参数,但是不把它们声
明为 const采用这种方法,你无法获得编译器检测的全部好处,因为它不能帮你
检查企图修改传入子程序中不可修改参数的情况,但是至少你可以清楚地看到
object-->member和 object. member的区分。
使用auto_ptr如果你还没有养成使用 autoptr的习惯,那么就努力吧!
通过在离开作用域的时候自动释放内存,auto_ptr能避免很多与常规指针相关的
内存泄漏问题ScottMeyers的《ScottMeyers《MoreEfectivC++autootr+》书第9条中针对auto_ptr
展开了很好的讨论(Meyers1996)。1
译注:现在C++已经基本抛弃了auto_ptr,为推荐使用 shared_ptr,见 Effective++第三版》
第3章“资源管理”。
代码大全(第2版)

<==========================370end ==============================>
<==========================371start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com!^.com!仅供试看^个
334
第13章不常见的数据类型
灵活运用智能指针智能指针(smart pointers)是规指针或者“哑(dumb)”
指针的一种替代品(Meyers1996)。它用起来与常规指针十分相像,但是针对资
源管理、拷贝操作、赋值操作、对象构造和对象析构提供了更多的控制。这项技
术仅与C++相关。在《《MoreEeceCw+28《++》的第28条里包含了完整的讨论
C-Pointer Pointers
C指针
下面是特别针对C语言的一些指针应用技巧。
使用显式指针类型而不是默认类型C允许你对任何类型的变量使用char或
者void指针。C语言只关心这类指针有所指向,不会真正去关心它所指向的是什
么。然而,如果你使用了显式的指针类型,编译器就会针对不相符的指针类型和
不合适的解除引用( dereferences)发出警告。如果你不这样做,它就不发出警告。
因此请尽可能地使用显式的指针类型。
采纳这项规则的必然结果是,当你必须进行类型转换的时候要使用显式类型
转换。例如,在下面的代码段中,分配的明显是一个 NODEPTR类型的变量:
C示例:显式类型转换
Nodeptr=node_ptr) calloc(1 sizeof(node))
避免强制类型转换避免强制类型转换(type casting)与上戏剧学校或者从
总是演“反面角色”中解脱出来没有丝毫关系它与避免把一种类型的变量挤压
入另一种类型变量的空间有关。强制类型转换关闭了编译器检查类型不符的功能,
因此在你的防御式编程的铠甲上挖了一个洞。一个需要很多强制类型转换的程序
在架构方面可能就存在一些需要修正的问题。如果可能,就请重新做设计;否则,
就应该尽可能地避免强制类型转换。
遵循参数传递的星号规则在C语言里,只有当你在赋值语句的参数前面加
了星号(*),才能把该参数从子程序中传回去。很多C程序员对确定什么时候C
允许把值传回调用方子程序感到困惑。这很容易记,只要你给这个参数赋值的时
候在它前面添加一个星号,那么所赋的值就会被传回调用方子程序。无论你在声
明中叠加了多少个星号,如果你想回传数值,就必须在赋值语句中至少使用一个
星号。举例而言,在下述代码段中,赋给 parameter的数值并没有传回给调用方
子程序,因为赋值语句没有使用星号:
2译注:cast有指定角色的含义。
代码大全(第2版)

<==========================371end ==============================>
<==========================372start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !-www.shubulo..com!仅供试看^
13.3全局数据
335
示例:不奏效的参数传递
void TryToPassBackAvalue int *parameter
parameter =SOME_VALUE;
下面,赋给 parameter的值被传递回去了,因为在 parameter前面有一个星号:
示例:奏效的参数传递
void TryToPassBackAValue int *parameter )
*parameter =SOME_VALUE;
在内存分配中使用 sizeof确定变量的大小使用 sizeof()要比到手册里去
查找大小容易得多,而且 sizeof()能够用于你自定义的结构体,这种结构体是在
手册里查不到的。由于 sizeof()是在编译期间计算的,因此不会带来性能上的损
失。它是可以移植的在不同的环境下重新编译,将自动修改sizeof()计算出
来的值。而且它需要的维护工作也很少,因为你可以修改已经定义的类型,而内
存分配也会随之做出自动调整。
3.3
Global Data
全局数据
交叉参考第5.3全局数据可以在程序中任意一个位置访问。这一概念有时被延伸到作用域比
节中的“把类内数局部变量更广的变量—例如可以在一个类内部的任意位置进行访问的类变量。
据”对全局数据和但是,在一个类内部的任意位置可访问,并不意味该变量是全局的。
类数据进行了详
细的比较。
大多数有经验的程序员已经得出结论:使用全局数据的风险比使用局部数据
大。极富经验的程序员还认为通过一些子程序来访问数据很有帮助。
不过,即便全局数据并不总是引发错误,也很难将其作为最佳的解决办法。
本节的剩余部分会对有关问题展开全面讨论。
KEY POINT
Common Problems with Global Data
与全局数据有关的常见问题
如果你随意使用全局数据,或者认为不能随心所欲地使用它们是一种约束,
那么你可能还没有充分理解信息隐藏和模块化的意义。模块化、信息隐藏并结合
使用设计良好的类可能还算不上是绝对真理,但是它们能极大地提升大型程序的
可理解性和可维护性。一旦明白了这一点,你就会努力去写出与全局变量和外界
联系尽可能少的子程序和类来。
代码大全(第2版)

<==========================372end ==============================>
<==========================373start==============================>

该书下载自-书部落-分享计算机经典巨著!--www !--www.shubulo.c!.com!仅供试看^
336
第13章不常见的数据类型
人们指出了使用全局数据的许多问题,实际上这些问题都可以归结到下面几
种情况。
无意间修改了全局数据你可能会无意间在某处修改了一个全局变量的值,
然后错误地认为它在其他的位置还是保持不变的。这种问题称为“副作用”(side
theAnswer是全 effects例如,在下例中, theAnswer是一个全局变量:
变量。
Visual Basic示例:副作用的问题
GetOtherAnswer
theAnswer =Get TheAnswer
改变了 theAnswer otherAnswer GetotherAnswer
theAnswer的值出 averageAnswer=(theAnswer+ otherAnswer
错了。
你也许会假定对 GetOtherAnswer()的调用不会改变 theAnswer的值,而如
果它确实改变了,那么第三行求出的平均值就是错误的。然而,事实上,
GetOtherAnswer()的确改变了 theAnswer的值,所以这个程序就包含了一个错
误,需要更正。
与全局数据有关的奇异的和令人激动的别名问题“别名( aliasing)指的是
两个或更多不同名字,说的是同一个变量。当一个全局变量被传递给一个子程序,
然后该子程序将它既用作全局变量又用作参数使用的情况下,就会出现这种情况。
下面是一个使用了全局变量的子程序:
Visual Basic示例:准备好遭遇别名问题的子程序
Sub WriteGlobal( ByRef inputVar As Integer)
inputVar =0
HORROR
globalvar inputvar, +5
MsgBox "Input Variable: " Str( inputVar )
End dsgBoxGlobal Variable:"&str( globalVar))
Sub
下面是调用该子程序的代码,它把全局变量用做了参数:
Visual Basic示例:调用前一个子程序,暴露出别名问题
WriteGlobal( globalvar
由于 inputVar被初始化为0,而且 WriteGlobal()把 inputVar加上5来求
得 globalVar,所以你可能预计 globalvar比 inputVar大5.但是下面就是令
人吃惊的结果:
前述 Visual Basic别名问题的结果
Input variable: 5
Global Variable:5
这里的微妙之处在于 globalVar和 inputVar实际上是同一个变量!由于
globalVar被调用方子程序传递给了 WriteGlobal1(),所以它被两个不同的名字
代码大全(第2版)

<==========================373end ==============================>
<==========================374start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
13.3全局数据
337
所引用或者加以“别名”了。这样一来, MsgBox()代码行的效果就与预期效果完
全不同了:尽管引用了两个不同的名字,代码却使同一个变量显示了两次。
与全局数据有关的代码重入(re-entrant-)问题可以由一个以上的线程访问
的代码正变得越来越常见。多线程代码造成了这样一种可能性,那就是全局数据
KEY POINT将不但在多个了程序之间共享,而且也将在同一个程序的不同拷贝之间共享。在
这种环境下,你必须确保即使一个程序的多个拷贝同时运行,全局数据也会保持
其意义。这是一个重大问题,你可以使用本节后面将要建议的技巧来加以避免。
全局数据阻碍代码重用要把一个程序里的代码应用于另一个程序,你必须
能够把它从第一个程序里取出,然后插入到另个程序里面。在理想状况下,你
可以把一个单一子程序或者类取出来,把它插到另一个程序里面去,然后高兴地
继续下去。
全局数据使这件事变得复杂了。如果你想重用的类读或写了全局数据,那么
你就无法简单地把它插入到新的程序里。你将不得不修改新的程序或者旧类,以
便让它们相容。如果选择上策,你应该去修改旧类,让它不再使用全局数据如
果你真的这么做了,那么下次你再需要重用这个类的时候,就可以把它插入到新
程序中而无须花费额外的力气。如果选择下策,那就去修改新的程序,以创建旧
有的类所需要使用的全局数据。这样做就像传播病毒:该全局数据不但影响了原
来的程序,还传染到使用旧程序中的类的新程序甲面。
与全局数据有关的非确定的初始化顺序事宜有些语言,特别是C+,没有
定义不同“转译单元”(文件)里的数据初始化的顺序。如果在初始化一个文件中
的全局变量的时候使用了在另一个不同文件中初始化的全局变量,那么除非你用
明确的手段来确保这两个变量能按照正确的顺序初始化,否则请不要对第二个变
量的取值下任何赌注。
这个问题可以用ScottMeyer《EctiveC++47Meyets1998在ffecriveC++》第47条(Meyers1998)中
描述的一种办法来解决。但是这一解决方案的复杂程度也是对使用全局数据所引
入的额外麻烦的一种印证。
全局数据破坏了模块化和智力上的可管理性创建超过几百行代的程序的
核心便是管理复杂度。你能够在智力上管理一个大型程序的唯一方法就是把它拆
分成几部分,从而可以在同一时间只考虑一部分模块化就是你手中可以使用的
把程序拆分成几部分的最强大工具。
全局数据使得你的模块化能力大打折扣。如果你用了全局数据,你能够在同一
时间只关注一个子程序吗?不能。你不得不关注一个子程序,以及使用了同样全局
代码大全(第2版)

<==========================374end ==============================>
<==========================375start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
338
第13章不常见的数据类型
数据的其他所有子程序。尽管全局数据并没有完全破坏程序的模块化,但是却削弱
了它,而这已经是很充分的理由,要求你去寻找问题的更好解决方案了。
Reasons to Use Global Data
使用全局数据的理由
数据纯化论者有时争论说,程序员应该绝不使用全局数据,但是按照“全局
数据”这一术语的广义解释,大多数程序都使用了它。存在于数据库中的数据是
全局数据,存在于配置文件如 Windows注册表中的数据也是。具名常量也是全局
数据,只不过不是全局变量罢了。
如果遵循使用的原则,那么全局变量在一些场合下也是有用的。
保存全局数值有时候你会有一些在概念上用于整个程序的数据。这可能是
个用于表示程序状态的变量例如,交互式模式或者命令行模式、正常模式
或者错误恢复模式等的模式标识。也可能是在整个程序里面要用到的信息例
如,程序中的每一个子程序都会用到的数据表。
交叉参考第
模拟具名常量尽管C++、Java、 Visual Basic和多数现代语言都支持具名常
12.7节“具名常量,但是 Python、Perl、Awk以及UNIX shell脚本等语言却不支持。当你的语言
量”有对具名常量
更为详尽的描述不支持具名常量的时候,你可以用全局变量代替它们例如,你可以用取值分别
为1和0的全局变量TRUE和 FALSE来代替字面量1和0,或者用
LINSESPER_PAGE=66代表每页行数的6旦采用了这种方法,那么日后再
修改代码就会更容易了,而且这样的代码会更方便阅读。贯彻这种对全局数据的
使用原则是在一种语言上编程(programming in language)和深入一种语言去编
程(programming into language)之间差异的一个主要示例,第34.4节“深入一
门语言去编程,不浮于表面”对此有深入探讨。
模拟枚举类型你还可以在 Python等不直接支持枚举类型的语言里用全局变
量来模拟枚举类型。
简化对极其常用的数据的使用有的时候你会大量地引用一个变量,以致于它
几乎出现在你所编写的每一个子程序的参数列表里。与其将它包含在每一个参数列
表里面,不如把它设置成全局变量。不过,事实上很少会出现代码到处访问某一个
变量的情形。通常该变量是由为数不多的一组子程序来访问的,你可以把这些子程
序以及它们所用到的数据整合进一个类里面下面会就这一问题展开讨论。
消除流浪数据有的时候你把数据传递给一个子程序或者类,仅仅是因为想
要把它传递给另一个子程序或者类。例如,你可能有一个在每个子程序里都使用
的错误处理对象。当调用链中间的子程序并不使用这一对象的时候,这一对象就
被称为“流浪数据(tramp data)”。使用全局变量可以消除流浪数据。
代码大全(第2版)

<==========================375end ==============================>
<==========================376start==============================>

该书下载自-书部落分享计算机经典巨著!-- ! --www.shubu.com!仅供试看
13.3全局数据
339
Use Global Data Only as a Last Resort
只有万不得已时才使用全局数据
在你选择使用全局数据之前,请考虑下面这些替换方案。
首先把每一个变量设置为局部的,仅当需要时才把变量设置为全局的开始
的时候先把所有的变量设置为单一子程序内部的局部变量。如果你发现还需要在
其他位置用到它们,那么在一举把它们转变成全局变量之前,先把它们转变为类
里的 private或者 protected变量。如果你最终发现必须要把它们转变成全局变量,
那么就转变它们。不过请先确定除此之外别无选择。如果你一开始就把变量设置
为全局的,那么你将永远不可能把它转变成局部的反之,如果你开始时把变量
设置为局部的,那么你可能永远也不需要把它转变成全局的。
区分全局变量和类变量有些变量由于要被整个程序访问,因此是真正的全
同变量。其他只在一组特定的子程序里被频繁使用的实际是类变量。在频繁使用
某个类变量的子程序组里,你可以采用任何希望的方式来访问它。如果类外部的
子程序需要使用该变量,那么就用访问器子程序来提供对该变量的访问。不要直
接访问类变量一好像它们是全变量一样即便你的编程语言允许你这么做。
这一建议等价于高呼:“模块化!模块化!模块化!”
使用访问器子程序创建访问器子程序是避免产生与全局数据相关问题的主
要方法。下一节会对此做更多的讨论。
Using Access Routines Instead of Global Data
用访问器子程序来取代全局数据
你用全局数据能做的任何事情,都可以用访问器子程序做得更好。使用访问
器子程序是实现抽象数据类型和信息隐藏的一种核心方法。即使你不希望使用装
备齐全的抽象数据类型,你仍然可以用访问器子程序来集中控制你的数据,并保
KEY POINT
护你免受变化的困扰。
Advantages of Access Routines
访问器子程序的优势
使用访问器子程序可以带来很多的好处。
你获得了对数据的集中控制。如果你日后发现了一种更合适的实现该结构的
方法,那么你无须到处修改引用该数据的代码所需做的修改不会波及整个
程序。它被限制在访问器了程序的内部。
交叉参考如果想你可以确保对变量的所有引用都得到了保护。如果你用
详细了解隔栏,请
参阅第8.5节“隔
stack.arraystack.top= newElement这样的语句向栈中压入元素,你
离程序,使之包容
会很容易就忘记检查栈溢出,从而犯下严重的错误。如果你使用了访问器子
由错误造成的损
害”
程序例如 Pushstack(newElement
一你就可以把溢出检测写到
Pushstack()程序里。这一检测会在每次调用该子程序的时候自动执行,
你可以忘记它。
代码大全(第2版)

<==========================376end ==============================>
<==========================377start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubulo..com!仅供试看^
340
第13章不常见的数据类型
交叉参考第5.3你可以自动获得信息隐藏的普遍益处。访问器子程序是信息隐藏的一个例
节中的“隐藏秘密
(信息隐藏)”有对
子,哪怕你并不是出于这一理由才设计它们的。你可以修改一个访问器子程
信息隐藏的详细论序的内部代码而无须涉及程序的其余部分。访问器了程序允许你在不改变你
述。
房子外表的情况下重新装修内部,而你的朋友们还是可以认出它来。
访问器子程序可以很容易地转变为抽象数据类型访问器子程序的一项优点
是,让你可以创建一个很难用全局数据来直接创建的抽象层。例如,与其写
if linecount> MAXLINES,访问器子程序让你能采用 if PageFuil()
这样一种小修改说明了这个 if lineCount检测的用意,代码也实现了所表
示的用途。这是对可读性的一点小小改进,但是如果能坚持重视这些细节,
就能写出同那些东拼西凑(hack)到一起的代码迥然不同的精致程序了。
How to Use Access Routines
如何使用访问器子程序
下面是有关访问器子程序的理论和实践的总结:把数据隐藏到类里面用
static关键字或者它的等价物来声明该数据,以确保只存在该数据的单一实例。
写出让你可以查看并且修改该数据的子程序来。要求类外部的代码使用该访问器
子程序来访问该数据,而不是直接操作它。
举例来说,如果你有一个全局的状态变量g_,用于描述这个
程序整体状态,你可以创建两个访问器子程序: globalstatus.gett和
globalstatus.set(),它们所执行的操作都和名字所描述的一样。这些子程序访
问了隐藏在类内部的一个取代了g_globalstatus的变量。程序的其余部分可以
借助 globalstatus.get()和 globalst.atus.set),获得原有全局变量所能提
供的所有好处。
交叉参考即使如果你的语言不支持类,你仍然可以创建访问器子程序来操纵全局数据,但
编程语言没有强必须制定严格的代码编写标准,限制对全局数据的使用,以代替编程语言内置的
制要求限制对全
局变量的访问也约束。
是一种很好的编
下面是在你的语言没有内置对类的支持的情况下,使用访问器子程序来隐藏
正是“深入一种语全局变量的一些详细的指导原则。
言去编程”而非
在一种语言上
要求所有的代码通过访问器子程序来存取数据一个好习惯是要求所有的全
编程”的极好例局数据都冠以g前缀,并且除了该变量的访问器子程序以外,所有的代码都不可
子。这在第34.4以访问具有9前缀的变量。其他全部代码都通过访问器子程序来存取该数据。
节里有详细论述。不要把你所有的全局数据都扔在一处如果把所有的全局数据都堆到一起,
然后为它编写一些访问器子程序,你可以消灭所有与全局数据有关的问题,但这
也使代码丧失了信息隐藏和抽象数据类型所带来的好处。既然已经在编写访问器
子程序,就请花些时间考虑每一个全局数据属于哪个类,然后把该数据和它的访
问器子程序以及其他的数据和程序打包放入那个类里面。
代码大全(第2版)

<==========================377end ==============================>
<==========================378start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
13.3全局数据
341
用锁定来控制对全局变量的访问与一个多用户数据库环境中的并发控制相
类似,锁定要求在使用或者更新一个全局变量值之前,该变量必须被签出(check
out)。在用完这一变量之后再把它签入(check)回去。在使用期间( check
out),如果程序的其余部分尝试要将它 check out,那么锁定/解锁子程序就会显示
一条错误消息,或者触发一个断言。
交叉参考在第关于锁定的这种描述忽略了很多通过编写代码来充分支持并发操作的微妙之
8.6节中的“计划处。基于这种原因,像这样的简化的锁定方式最适用于开发阶段。除非很好地设
代码”以及第8.7计它,否则它可能不足以可靠到放入产品环境里面去。当把程序投入产品环境里
节“确定在产品代时,这些代码就要进行修改,以执行一些比显示错误消息更安全和优雅的操作。
中该保留多少
防御式代码”里详例如,当代码检测到程序的多个组成部分都在试图锁定同一个全局变量的时候,
细介绍了如何对它可能会在文件里记录下一条错误消息。
程序的开发版本
和产品版本之间
当你使用访问器子程序来取代全局数据的时候,这种开发阶段的防范措施就
的差异进行安排。会相当容易实现,然而如果你直接使用全局数据,那么实现起来就会十分不便。
在你的访问器子程序里构建一个抽象层要在问题域这一层次上构建访问器
子程序,而不是在细节实现层次上。这种方法会为你的代码带来更好的可读性,
同时防止在代码编写过程中不小心修改到实现细节。
比较表13-1中的一对对语句。
表13-1直接访问全局数据和通过访问器子程序访问全局数据
直接访问全局数据
通过访问器子程序来使用全局数据
node node.next
account NextAccount(account )
node =node.next
employee Next Employee (employee)
rateLevel= NextRateLevel(rateLevel)
event= eventQueuequeueFront event= HighestPriorityEvent(
event= eventQueuequeueBack event Lowest PriorityEvent()
前三个例子中的关键点是,一个抽象的访问器子程序所能提供的信息量要远
远多于一个通用数据结构所能提供的。如果你直接使用该数据结构,那么你就在
同一时间里做了太多的事情:既显示了结构体自身要做什么(移到链表中的下一
个节点),又显示了该结构体所代表的实体要做什么(获取一个账户、下一个雇员
或者费率等级)。对于一次简单的数据结构体赋值来说,这样做负担太重了。把这
些信息隐藏在抽象访问器子程序后面,将会使得代码的作用不言自明,同时使得
代码在问题域的层面上就能被理解,而不是在实现细节层上去理解它。
代码大全(第2版)

<==========================378end ==============================>
<==========================379start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看^
342
第13章不常见的数据类型
使得对一项数据的所有访问都发生在同一个抽象层上如果你用一个访问器
子程序对一个结构体执行了某种操作,那么在对此结构体执行任何其他操作时,
你同样也应该使用一个访问器子程序。如果你用某个访问器子程序读取该结构体,
那么就用另一个访问器子程序写入该结构体如果你调用 InitStack()来初始化
找,就应该调用PushStack()来往栈上压值,这样你就为该数据创建了一个一致
的视角。但如果通过value= array[stack top]来从栈中弹出数据,你所创建
的对该数据的操作就不一致。这种不一致性会使得其他人很难理解该代码。应该
创建一个 PopStack()子程序来代替 value arraystack.top]
交叉参考针对在表13-1的示例语句对中,两个事件队列的操作是对应发生的。向队列中插
事件队列使用访入一个事件会比表中这两个操作中的任何一个都要麻烦,它要求写几行代码来找
问器子程序即暗
示你应该创建到插入该事件的位置,调整现有的事件以便为这一新的事件留出空间,同时调节
个类,第6章“可该队列的前端或者后端。从队列中移除事件也同样复杂。在编写代码的时候,这
以工作的类”详细些复杂的操作会被放入相应子程序里面,而剩下的功能将通过对数据直接进行操
讲述了这一点。
作来实现。这样一来,对这一数据结构的操作就会显得缺乏美感且不协调。现在
比较一下表13-2中的语句。
表13-2对复杂数据一致和不一致的操作
对复杂数据的不一致操作
对复杂数据的一致操作
event EventQueuequeueFront event Highest Priority Event(
event EventQueue queueBack event= Lowest PriorityEvent()
AddEvent(event)
AddEvent(event)
eventCount eventCount-1
RemoveEvent (event)
尽管你可能认为这些指导原则只适用于大型程序但实践证明,访问器子程
序可以成为一种能避免同全局数据相关问题的有效解决方案。除此之外,它会使
得代码更具可读性,并且增加了代码的灵活度。
How to Reduce the Risks of Using Global Data
如何降低使用全局数据的风险
在许多情况下,全局数据事实上就是没有设计好或没有实现好的类中的数据。
在少数情况下,一些数据的确需要作为全局数据,但是可以使用访问器子程序对
其进行封装,从而最大限度地减少发生问题的可能性。在剩余的极少情况下,你
真的需要使用全局数据。这时,你可以把下面的原则看做是在出游陌生国度前注
射的疫苗,它们在某种程度上或许会带来些痛苦,但可以让你在旅行中更加健康。
交叉参考第
11.4节中的“标
创建一种命名规则来突出全局变量在对全局变量进行操作时,为全局变量
识全局变量”详命以更醒目的名字可以让你少犯错误。如果你正在把全局变量用于多种用途(比
细介绍了全局变如说,用做变量以及具名常量的替代品),那么就要确保你的命名规则能够区分开
量的命名规范。这些不同的用法。
代码大全(第2版)

<==========================379end ==============================>
<==========================380start==============================>

该书下载自-书部落-分享计算机经典巨著!www. ! --www.shubulo..com!仅供试看
更多资源
343
为全部的全局变量创建一份注释良好的清单一旦你的命名规则表明了某个
变量是全局的,那么指出该变量的具体功能将会大有好处。一份全局变量的清单
是在你的程序上工作的人所能获得的最有用的工具之一。
不要用全局变量来存放中间结果如果你需要为一个全局变量计算新值,那
么应该在计算结束后再把最终结果赋给该全局变量,而不要用它来保存计算的中
间结果。
不要把所有的数据都放在一个大对象中并到处传递,以说明你没有使用全局
变把所有一切都放在一个大对象里可能会满足不使用全局变量的要求,但是
这样做纯粹是一种负担,它也无法真正带来封装所能带来的那些好处。如果你要
使用全局数据,那么就公开地用。不要试图通过使用大对象来掩盖这一点
Additional Resources
更多资源
c2.com/1385下面是一些有关不常见的数据类型的更多资源。
Maguire, Steve. Writing Solid Code). Redmond WA: Microsoft Press, 1993.
其第3章很好地讲述了使用指针的风险,并就如何避免与指针相关的问题给出了
大量的具体建议。
Meyers, Scott. (EFffective C++>, 2d ed. Reading, MA: Addision-Wesley, 1998;
Meyers,MeyersScott《MoreEectiveC++,Reading,MA:AddisionWeley196《++》.readingA:ddision-wesey,1996正如其
书名所示,这两本书里面包含了大量用于改善C程序编程的具体技巧,包括安
全并有效地使用指针的指导原则。《《MoreEjcivaC#+《++》特别就C++的内存管理问
题做出了精彩的描述。
CHECKLIST: Considerations in Using Unusual Data Types
c2c2核对表:使用不常见数据类型的注意事项
结构体
口你使用结构体而不是使用单纯的变量来组织和操作相关的数据吗?
口你考虑创建一个类来代替使用结构体吗?
全局数据
口所有的变量是否都是局部的或者是类范围的?除非绝对有必要才是全
局的?
口变量的命名规则能把局部数据、类数据和全局数据区分开吗?
口你对所有的全局变量都加以文档说明吗?
代大全(第2版)

<==========================380end ==============================>
<==========================381start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com!^^.com!仅供试看
344
第13章不常见的数据类型
口避免使用伪全局数据,即被四处传递且包含有杂乱数据的巨大对象吗?
口用访问器子程序来取代全局数据吗?
口把访问器子程序和数据组织到类里面吗?
口访问器子程序提供了一个在底层数据类型实现之上的抽象层吗?
口所有相关的访问器子程序都位于同一抽象层之上吗?
指针
口把指针操作隔离在子程序里吗?
口指针引用合法吗?或者说指针有可能成为空悬指针吗?
口代码在使用指针之前检查它的有效性吗?
口在使用指针所指向的变量之前检查其有效性吗?
口指针用完后被设置为空值吗?
口就可读性而言,代码用了所有需要使用的指针变量吗?
口链表中的指针是按正确的顺序加以释放吗?
口程序分配了一片保留的内存后备区域,以便在耗尽内存的时候能够优雅
地退出吗?
口是不是在没有其他方法可用的情况下最终才使用指针的?
Key Points
要点
结构体可以使得程序更简单、更容易理解,以及更容易维护
每当你打算使用结构体的时候,考虑采用类是不是会工作得更好。
指针很容易出错用访问器子程序或类以及防御式编程实践来保护自己的代
码。
避免用全局变量,不只是因为它们很危险,还是因为你可以用其他更好的方
法来取代它们。
如果你不得不使用全局变量,那么就通过访问器子程序来使用它。访问器子
程序能为你带来全局变量所能带来的一切优点,还有一些额外好处。
代码大全(第2版)

<==========================381end ==============================>
<==========================382start==============================>

该书下载自-书部落-分享计算机经典巨著!--www !-www.shubulo..com!仅供试看^
第4部分
Statements
语句
本部分内容
■第14章组织直线型代码
347
第15章使用条件语句
355
■第16章控制循环
367
■第17章不常见的控制结构
391
第18章表驱动法
..411
第19章一般控制问题
431
代码大全(第2版)

<==========================382end ==============================>
<==========================383start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看

<==========================383end ==============================>
<==========================384start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看^
Organizing Straight-Line code
第14章
组织直线型代码
cc2e.com/1465内容
14.1必须有明确顺序的语句:第347页
14.2顺序无关的语句:第351页
相关章节
一般控制问题:第19章
条件代码:第15章
■循环代码:第16章
变量和对象的作用域:第10.4节“作用域”
本章从以数据为中心的编程观点转到以语句为中心的观点上。本章介绍最简
单的控制流:即按先后顺序放置语句和语句块。
尽管组织直线型代码是一个相对简单的任务但代码结构上的一些微妙之处
还是会对代码的质量、正确性、可读性和可维护性带来影响。
Statements That Must Be in a Specific Order
必须有明确顺序的语句
最容易组织的连续语句是那些顺序相关的语句。下面举一个例子:
Java示例:有前后依赖关系的语句
dataReadData()i
results CalculateResultsFromData(data)
PrintResults( results)
除非这段代码里发生了某些不可思议的事情,否则这些语句必须按照所显示
的顺序依次执行。在计算数据之前必须要先读入数据,而在打印之前也必须先计
算出结果。
这个例子中潜在的根本概念与依赖性有关。第三条语句依赖于第二条,第二
条依赖于第一条。在本例中,前后语句之间的依赖关系可以很明显地从子程序名
代码大全(第2版)

<==========================384end ==============================>
<==========================385start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !-www.shubul.com!仅供试看^
348
第14章组织直线型代码
中看出来。在下面的代码段中,依赖关系就不那么明显了:
ava示例:有不太明显的前后依赖关系的语句
revenue. ComputeMonthly (
revenue. Computeouarterly()
revenue. ComputeAnnual();
在这个例子中,对季度收入的计算要求假定月收入已经计算出来了。熟悉会
计学的人甚至常识——可能会告诉你必须先计算季度收入,然后才能计算年
收入。这就是一种依赖,但是这一点仅仅通过阅读代码是不太看得出来的。下面
代码中的顺序依赖关系也不明显——它事实上被隐藏起来了:
Visual Basic示例:隐藏了语句的前后依赖关系
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DisplayExpenseSummary
假定 ComputeMarketing Expense()会初始化类的成员变量,以便其他所有子
程序都能把它们的数据放进去。在这种情况下,它需要在其他子程序之前被调用。
然而仅通过阅读代码你怎么能知道这一点呢?由于这些子程序调用都不带任何参
数,因此你可能会猜测这里的每一个子程序都会访问类数据。但是仅通过阅读代
码,你是无法确定这一点的。
如果语句之间存在依赖关系,并且这些关系要求你把语句按照一定的顺序加
以排列,那么请设法使得这些依赖关系变得明显。下面是一些用于组织语句的简
KEY POINT单原则。
设法组织代码,使依赖关系变得非常明显在刚刚给出的那个 Microsoft
Visual Basic示例里, ComputeMarketingExpense()不应该初始化类的成员变量。
那里所用的子程序名暗示 ComputeMarketingExpense()类似于 computesales-
Expense()、 ComputeTravelExpense()和其他的子程序,只是它处理的是
marketing数据而不是 sales数据或者其他数据让 ComputeMarketingExpense()
来初始化成员变量是一种应该避免的草率的措施。为什么要在这个子程序里执行
初始化而不是由其他两个语句中的某一个来做?除非你能给出一个好的理由,否
则就应该另外写一个子程序,如InitializeExpenseData(),来初始化成员变量
这个子程序的名字清楚地表明了程序员应该在运行其他的开支计算子程序之前调
用它。
使子程序名能突显依赖关系在 Visual Basic示例里, ComputeMarketing
Expense()的命名是错误的,因为它做的不仅仅是计算 Marketing费用;它还初始
化了成员数据。如果你反对再写一个子程序来初始化该数据,那么至少要给
ComputeMarketingExpense()一个能够反映它所执行的全部功能的名字。在本例
代码大全(第2版)

<==========================385end ==============================>
<==========================386start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.c!.com!仅供试看^
14.1必须有明确顺序的语句
349
中, ComputeMarketingExpenseAndInitializeMemberData()就是一个适当的
名字。你也许会说这个名字太糟糕了,因为它太长,但是它却描述了这个子程序
做了什么,因此并不算糟糕。实际上是这个子程序本身太糟糕了!
交叉参考第5利用子程序参数明确显示依赖关系还是针对那个 Visual Basic示例,在那些
的设计”有关于子程序之间没有传递任何数据,由此你不知道有哪些子程序使用了相同的数据。
章“软件构建中
使用子程序和参通过重写代码让数据在子程序之间传递,你就可以暗示执行顺序是很重要的新
数的详细介绍。
写的代码看上去会是这样:
Visual Basic示例:暗示顺序依赖关系的数据
InitializeExpenseData( expenseData
ComputeMarketingExpense expenseData
ComputeSalesExpense( expenseData
ComputeTravelExpense( expenseData
Compu
mputePersonnel Expense( expensepata)
DisplayExpenseSummary( expenseData)
由于所有的子程序都使用了 expenseData,你会从中得到提示,即它们可能
操作了相同的数据,因此这些语句的顺序可能是重要的。
在这个特殊的例子里面,还有一种可能更好的方法,即把这些子程序转变成
输入 expenseData并把更新过的 expenseData作为输出加以返回的函数,这样
就使代码中包含顺序依赖关系的这一事实变得更加明显。
Visual Basic示例:暗示顺序依赖关系的数据和子程序调用
expenseData InitializeExpenseData expenseData
expenseData =ComputeMarketingExpense( expenseData
expenseData ComputesalesExper expenseData
expenseData= ComputeTravelExpense( expenseData)
expenseData= ComputePersonnelEx expenseData
DisplayExpenseSummary expenseData
也可以用数据来表明执行顺序并不重要,如下例所示:
Visual Basic示例:表示没有顺序依赖关系的数据
ComputeMarketingExpense marketingData
ComputeSalesExpense( salesData
ComputeTravelExpense( travelData)
ComputepersonnelExpense( personnelData
DisplayExpenseSummary( marketingData salesData, travelData,
personnelData
前面四行中的子程序不包含任何共同的数据因此这一代码表明它们的调用
顺序并不重要。而由于第五行中的子程序使用了来自前四个子程序中每一个子程
序的数据,因此你可以认为它需要在前四个子程序之后执行。
代码大全(第2版)

<==========================386end ==============================>
<==========================387start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
350
第14章组织直线型代码
用注释对不清晰的依赖关系进行说明首先要尽力写没有顺序依赖关系的代
码。其次尽力写依赖关系明显的代码。如果你还担心某一项依赖关系不够清楚,
KEY POINT那么就用文档说明它。对不清晰的依赖关系进行说明是描述编程意图的一个方面,
它对编写出可维护、易修改的代码来说是至关重要的。在上一个 Visual Basic示例
中,给代码增加些注释会非常有用:
Visual Basic示例:语句的顺序依赖关系不明显,但借助注释加以澄清
Compute expense data. Each of the routines accesses the
'member data expenseData. Display ExpenseSummar
should be called last because it depends on data calculated
by the other routines.
计算 expense数据。每个子程序都访问了 expenseData数据成员
DisplayExpenseSummary应该最后调用,因为它依赖于其他子程序
计算出的数据。
InitializeExpenseData
omputesarlestingespense
C
omputeTravelExpense
ComputePersonnelExpense
DisplayExpensesummary
这一代码没有使用那些让顺序依赖关系变得明显的技巧。编写代码时更应该
依赖于那些技术,而不是依赖于注释。但如果你是在维护控制得非常严格的代码,
或者由于一些其他的原因使你无法改进代码本身,那么就用文档来弥补代码的不
足吧。
用断言或者错误处理代码来检查依赖关系如果代码非常重要,你可以用状
态变量以及错误处理代码或断言来对关键的顺序依赖关系做出说明。例如,在类
的构造函数里面,你可以把一个名为 isExpenseDataInitiali的类成员变量
初始化为 false。然后在 InitializeExpenseData(中,你可以把
isExpenseDataInitialized设置为true每一个依赖于已初始化的
expenseData的函数就可以在对 expenseData做出其他操作之前,检查
isExpenseDataInitialized有没有被设为true取决于依赖关系的影响范围,
你可能还需要诸如 isMarketingExpenseComputed、 issalesExpenseComputed等
变量。
这种技术引入了一些新变量、新初始化代码和新错误处理代码,所有这一切
都增加了出错的可能性。因此应该在由此获得的好处和由此带来的额外复杂度和
所增加的二次出错几率之间做出权衡。
代码大全(第2版)

<==========================387end ==============================>
<==========================388start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
14.2顺序无关的语句
351
4.2
Statements Whose Order Doesn't Matter
顺序无关的语句
你也许见过这种情形,即代码中若干语句或语句块的先后顺序看上去完全没
有关系。一条语句并不依赖于或者在逻辑上承接另一条语句。但是顺序的确对可
读性、性能和可维护性有影响,而且当缺少执行顺序依赖关系的时候,你可以用
第二标准来判断语句或者代码块的顺序这其中的指导原则就是就近原则
(Principle of Proximity):把相关的操作放在一起。
Making Code Read from Top to Bottom
使代码易于自上而下地阅读
作为一条普遍性原则,要让程序易于自上而下阅读,而不是让读者的目光跳来
跳去。专家们认为自上而下的顺序对提高可读性最有帮助简单地让控制流在运行
时自上而下地运行还不够。如果有人在阅读你代码的时候不得不搜索整个应用程序
以便找到所需的信息,那么就应该重新组织你的代码了。下面举一个例子:
例:跳来跳去的糟糕代码
MarketingData marketingData;
SalesData salesData;
TravelData travelData;
travelData. ComputeQuarterly();
salesData. ComputeQuarterly
marketingData. ComputeQuarterly()
salesData. ComputeAnnual();
marketingData. ComputeAnnual();
traveldata.computeannual() :
salesData. Print
travelData. Printl;
marketingData. Print()
假设你希望知道 marketingData是怎么计算出来的。你就必须从最后一行开
始,跟踪所有对 marketingData的引用直至回到第一行。 marketingData只在代
码中其他少数的几个位置用到,但你却不得不集中精力去想:是否在从头到尾的
每行代码中都用到了 marketingData.换句话说为了理解 marketingData是如
何计算的,你必须要查看并且考虑这段代码块中的每一行代码。更何况这个例子
当然比你在实际系统里看到的代码简单得多。下面是组织得更好的完成同样功能
的代码
C++示例:组织良好的顺序代码,能从头到尾阅读
MarketingData marketingData;
marketingData. ComputeQuarterly();
marketingData. ComputeAnnual()
marketingData. Print()
代码大全(第2版)

<==========================388end ==============================>
<==========================389start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
352
第14章组织直线型代码
salespata salespatai
salesData. ComputeQuarterly ()
salesData. ComputeAnnual();
salesData. Print ()
TravelData travelData:
T
travelData. ComputeQuarterly()
travelData. ComputeAnnual();
travelData. Print()
交叉参考第这
这段代码在很多方面都好。把对每一个对象的引用都放在一起;把它们“局
10.4节“测量变量
的生存时间”有对部化(localized)”了。对象“存活(live)的代码行数非常少。然而也许最重要的
“存活”更精确的是,这段代码现在的样子说明它可以拆分为分别计算 marketing、 sales和 travel
技术定义。
数据的子程序。第一段代码却没有暗示这样一种分解是可能的。
Grouping Related Statements
把相关的语句组织在一起
交叉参考如果把相关的语句放在一起。一些语句之所以相关,是因为它们都处理了相同的
你遵循伪代码编
程过程进行开发,数据、执行了相似的任务,或者具有某种执行顺序上的依赖关系。
那么相互有联系
的代码会自然而
检查相关的语句是不是组织得很好起来的一种简便方法是,打印出你的子程
然地组织到一起
第9章“伪代码编序代码,然后把相关的语句画上框。如果这些语句排列得很好,你就会得到类似
程过程”对此有详于图14-1那样的图形,其中的方框是不会彼此交叠的。
细介绍。
交叉参考第
10.4节“作用
域”有关于如何图14-1如果代码组织良好,那么围绕各段的方框就不应该交叠,但有可能嵌套
把对变量的操
作集中到一起
如果语句排列得不好,你就会得到类似于图14-2的那种图形,其中方框是有
的详细说明。重叠的。请重新组织你的代码,使相关的语句组织得更好。
代码大全(第2版)

<==========================389end ==============================>
<==========================390start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c!^.com!仅供试看^
要点
353
图14-2如果代码组织不良好,那么围绕各段代码的方框就会交叠
一旦把相关的语句组织在一起,你有可能发现它们之间有很强的联系,而与
它们前后的语句组没有多少有意义的联系。在这种情况下,你可能希望把这些关
联度很强的语句重构成独立的子程序。
Checklist: Organizing Straight-Line Code
cc2.com/147242核对表:组织直线型代码
口代码使得语句之间的依赖关系变得明显吗?
口子程序的名字使得依赖关系变得明显吗?
口子程序的参数使得依赖关系变得明显吗?
口如果依赖关系不明确,你是否用注释进行了说明?
口你用“内务管理变量”( housekeeping variables)来检查代码中关键位置
的顺序依赖关系了吗?
口代码容易按照自上而下的顺序阅读吗?
口相关的语句被组织在一起吗?
口把相对独立的语句组放进各自的子程序里吗?
Key Points
要点
组织直线型代码的最主要原则是按照依赖关系进行排列。
可以用好的子程序名、参数列表、注释,以及如果代码足够重要内
务管理变量来让依赖关系变得更明显。
■如果代码之间没有顺序依赖关系,那就设法使相关的语句尽可能地接近。
代码大全(第2版)

<==========================390end ==============================>
<==========================391start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^

<==========================391end ==============================>
<==========================392start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
Using Conditionals
第15章
使用条件语句
cc2eco/1538内容
15.1if语句:第355页
15.2case语句:第361页
相关章节
驯服深层嵌套:第19.4节
一般控制问题:第19章
循环代码:第16章
■直线型代码:第14章
数据类型和控制结构之间的关系:第10.7节
条件语句用来控制其他语句是否执行;其他语句在if、else、case、 switch等
语句里时变为“有条件”执行。尽管从逻辑上说,把 while、for等循环控制符看
做条件语句也是合理的,但传统上还是把它们分别对待。第16章“控制循环”会
仔细研究 while和for语句
if Statements
if语句
根据所用语言的不同,你可能使用几种if语句中的任何一种。其中最简单的
是简单if或者if-then语句。ifthen-else稍微复杂一点,而连续一组if-then-else所
构成的语句串是最为复杂的。
Plain if-then Statements
简单if-then语句
在写if语句的时候请遵循下述指导原则。
首先写正常代码路径;再处理不常见情况在编写代码时,要使得正常情况
的执行路径在代码中是清晰的。确认那些不常见的情况不会遮掩正常的执行路径
KEY POINT这对可读性和代码性能来说都很重要。
确保对于等量的分支是正确的请不要用“>代替“>=”或用“<”代替“<=”,
这类似于在访问数组或者计算循环下标的时候犯下off-by-one(偏差一)错误。在
代码大全(第2版)

<==========================392end ==============================>
<==========================393start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
356
第15章使用条件语句
循环里,要仔细考虑端点以避免犯off-byone错误。在条件语句里,也要仔细考
虑条件是否同实际情况相符合,避免犯同样的错误。
交叉参考第把正常情况的处理放在i后面而不要放在else后面把你认为会正常出现的
嵌套层次的技术情况放在前面来处理。这符合把决策的结果代码放在尽可能靠近决策位置的一般
19.4节“对减少
的总结”介绍了其原则。下面代码示例里执行了很多错误处理,并在该过程中随意地检测错误:
他一些编写错误
Visual Basic示例:随意地处理大量错误的代码
处理代码的办法。 OpenFile( inputFile, status
if( status Status_Error)then
出错情况。
errorType =FileOpenerror
正常情况。
Else
→ Readrile( inputFile, fileData, status
正常情况。
if( status= StatusSuccessThen
SummarizeFileData fileData, summaryDat, status
f( status StatusErrorthen
出错情况。
→ errorType ErrorTypeDataSummaryError
正常情况。
Elsemmarvpata
SaveSummaryData summaryData, status)
出错情况。
status StatusError Then veerro
→errorType ErrorType Summarysaveerror
正常情况。
Else
→ UpdateAllAccounts()
EraseUndoFile()
Eno errorType =ErrorType_None
If
If
errorType ErrorTypeFileReaderror
End If
End If
这段代码很难理解,因为它把正常的情况和出错的情况混在了一起。很难从
中找出正常代码的路径来。除此之外,因为错误条件有的时候是在if子句而不是
else子句中处理的,所以很难判断到底哪一个if子句检测了与之相关的正常情况。
在下面重写的代码里,正常的路径一致地写在前面,而所有的错误情况都写在了
后面。这样就能很容易找到并且阅读正常的情况了。
Visual Basic示例:系统地处理大量错误的代码
OpenFile( inputFile, status
if( statusStatusSuccessthen
正常情况。
ReadFile( inputFile, fileData, status)
if( status Status_Success)hen
正常情况。
SummarizeFileData fileData, summaryData, status
正常情况。
if( status statusSuccess)hen
-PrintSummary( summaryData
arvpata at
SaveSummaryData( summaryData, status)
正常情况。
If Sstaus Success)then
UpdateAllAccounts
EraseUndoFile()
代码大全(第2版)

<==========================393end ==============================>
<==========================394start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
15.1if语句
357
errorType ErrorType_None
Else
出错情况。
→ errorType ErrorType_Summarysa
ElseEnd If
出错情况。
errorType ErrorType_DataSummary Error
nd If
出错情况。
se
errorType= ErrorType_FileReaderror
出错情况。
nerrorType ErrorType_FileOpenError
在修改后的例子里,你可以通过阅读if条件测试的主流程来找到正常的情况。
这一修改使人的注意力集中到了阅读代码的主流程上,而不是费力地去理解那些
异常处理情况,因此整体代码更容易阅读。嵌套条件语句的下部积累了全部的错
误情况是良好的错误处理代码的一个标志。
这个例子演示了一种系统化的处理正常情况和错误情况的方法。本书还会讨
论多种解决这一问题的其他方法,包括使用防卫子句(guard clauses)转为多态
分派(polymorphic dispatch)、以及将测试的内部提取成为一个独立的子程序。如
果想获得一份完整的可用方法的清单,请阅读第19.4节中的“对减少嵌套层次的
技术的总结”
让if子句后面跟随一个有意义的语句有的时候你会看到下例中的这种代
码,其中if子句是空的:
Java示例:空的if子句
if SomeTest
CODING
else
HORROR
/ do something
交叉参考构造哪怕仅仅为了少写那个额外的空语句行和else代码行,大多数有经验的程序
一条有效的if语
句的关键就是要
员也都会避免这么编写代码。这样写看上去很傻,而且修改起来也很容易:简单
正确地写出控制地对if语句中的谓词作否定,把lse子句中的代码移到if子句中来,并且去掉else
该语句的布尔表
达式。第19.1节
子句就可以了。下面就是修改后的代码:
“布尔表达式对ava示例:空if子句转换后的代码
此有详细的说明。 if someTest
/ do something
代码大全(第2版)

<==========================394end ==============================>
<==========================395start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
358
第15章使用条件语句
考虑else子句如果你认为自己只需要一个简单的if语句,那么请考虑你是
否真的不需要一个if-then-else语句。通用汽车公司做的一项经典分析发现,有5
HARD DATA至8成的if语句都应该配有一个else子句(Elshoff1976)
一种选择是编写else部分如果需要也可以用一个空语句以表明这种
else情况已经考虑了。仅为了表明已经考虑了相应的情况而编写空的else部分,
似乎显得有些小题大做,但这至少可以促使程序员在编写代码的时候考虑else情
况。当你有一个不包含else部分的if测试的时候,除非其原因显而易见,否则请
用注释来解释为什么在这里else子句是没有必要的,就像下面一样:
ava示例:有益的、带注释的else子句
/ if color is valid
if COLOR_MIN < color & color < COLOR_MAX )
/ do something
else
11 else color is invalid
1/ screen not written to - safely ignore command
测试else子句的正确性在测试代码的时候,你可能会认为只有主子句(即
if子句)需要测试。然而如果有可能测试else子句的话,也一定要测试它。
检查if和else子句是不是弄反了编程中常常会犯这么一种错误,那就是要
么把本应放在if子句后面的代码和本应放在else子句后面的代码给弄反了,要么
就把if测试的逻辑弄反了。请检查你的代码中有没有这种常见错误。
Chains of if-then-else Statements
if-then-else语句串
在不支持或者只是部分支持case语句的语言里,你会发现自己常常要写
if-then-else检测串。例如,给字符分类的代码可能会使用如下的检测串:
交叉参考第C++示例:使用if-then-else语句串对字符分类
19.1节“布尔表if( inputCharacter SPACE)
达式”给出了简化
characterType =CharacterType_ControlCha
复杂表达式的具
体方法。
else if
inputCharacter =
inputCharacter =
inputCharacter
inputCharacter
inputcharacter
inputCharacter = 'I
代码大全(第2版)

<==========================395end ==============================>
<==========================396start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! -www.shubul com!^.com!仅供试看^
15.1if语句
359
inputCharacter ==' 'I1
inputCharacter =='
inputCharacter =='?'I
inputCharacter =='-
){
characterType CharacterType_Punctuation;
else if 0'<= inputCharacter & inputCharacter <=9')
characterType= CharacterTypeDigit;
else if (
< inputCharacter & inputCharacter <='z
(A'<= inputCharacter & inputCharacter <='Z')
)
characterType= CharacterTypeLetter;
在写这种 if-then--else串的时候,请注意下述指导原则。
利用布尔函数调用简化复杂的检测上面例子中的代码难读的一个原因是对
字符分类的判断是很复杂的。为了提高可读性,你可以把它替换成布尔函数调用。
下面就是使用布尔函数取代判断后的代码示例:
C++示例:使用了布尔函数调用的if-then-else语句串
if( IsControl inputCharacter))
characterType CharacterType_ControlCharacter;
else if( IsPunctuation( inputCharacter))
characterType= CharacterType_Punctuation;
else if( IsDigit( inputCharacter))
characterType= CharacterType_Digit;
characterType =CharacterType_Letter;
把最常见的情况放在最前面把最常见的情况放在前面,可以让阅读代码的
人为找出正常情况的处理代码而必须要读的处理非常见情况的代码变得最少。同
时,由于把在执行最常见情况代码之前所需的判断减到最少,代码效率也得到了
提高。在上面例子中,字母比标点符号更为常见,但是对标点符号的检测却放在
了前面。下面是修改后的代码,它把对字母的检测放在前面:
在本例中,最为C++示例:首先测试最常见的情况
常见的情况会先if( IsLetter( inputCharacter)){
在这里得到处
characterType CharacterType_Letteri
理。
代码大全(第2版)

<==========================396end ==============================>
<==========================397start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. !--www.shubuld.com!仅供试看^
360
第15章使用条件语句
else if( IsPunctuation( inputCharacter))
characterType CharacterType_Punctuation:
: nicitinnucharacter)
else if( IsDigit( inputCharacter))(
characterType CharacterType_Digiti
最不常见的情况
则是放在最后来 else if( IsControl( inputCharacter
解决。
characterType CharacterType_ Controlcharacter;
确保所有的情况都考虑到了写一个放在最后的else子句,用出错消息或者
断言来捕捉那些你不考虑的情况。这种消息是给你而不是给最终用户看的,因此
请适当地措辞。下面是对前面字符分类的例子的改进,执行对“其他情况”的检
测:
交叉参考这个C+示例:检查默认情况以捕获错误
例子同样是如何if( IsLetter( inputcharact
if-then-else characterType =CharacterType_Letter;
典范。第19.4节 if IsPunctuation)on
“驯服危险的深
characterType CharacterType_Punctuation;
层嵌套”有详细1seif( Ispigit( inputCharacter)
介绍。
ifacsenigit( inputcharacter Diait!
characterType CharacterType Digit:
else if( IsControl( inputCharacter))(
characterType CharacterType_Controlcharacter;
else
DisplayInternalError("Unexpected type of character detected.")
如果你的语言支持,请把if-then-else语句串替换成其他结构少数语言例
如 Microsoft Visual Basic和Ada提供了支持字符串、枚举和逻辑函数的case语
句。请使用它们它们比ifthen-else语句串更容易编写和阅读。在 Visual Basic
中用case语句给字符分类的代码可以写成:
Visual Basic示例:用case语句代替if-then-else语句串
Select Case inputcharacter
Case "a" To "z"
characterType -CharacterType_Letter
case""","".","!","(",")"," uatin
characterType CharacterType_Punctuation
Case "0" To ""
er
characterType= CharacterType_Digit
Case FIRST_CONTROL_CHARACTER To LAST_CONTROL_CHARACTER
characterType CharacterType_Control
case Else
End
SelecsplayInternalError "Unexpected type of character detected.")
代码大全(第2版)

<==========================397end ==============================>
<==========================398start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubuld.com!仅供试看
15.2case语句
361
15.2
case Statements
case语句
case语句或者 switch语句随着编程语言的不同而有着很大的差异C++和Java
只支持在case中使用序数类型(整数),并且一次只能取一个值。 Visual Basic支
持在case中使用序数类型,同时提供了强大的表示区间和数值集合的简化记法。
很多脚本语言根本不支持case语句。
下面几节就如何有效地使用case语句给出一些指导原则
Choosing the Most Effective Ordering of Cases
为case选择最有效的排列顺序
你可以有很多方式来组织case语句中的各种情况(cases)如果你有一个小
小的case语句,其中只有3个选项和3行相对应的代码,那么顺序的选择就不那
么重要了。如果你的case语句很长例如,一条用于处理事件驱动程序里面的
数十个事件的case语句那么顺序就很重要了。下面是一些可能的排列顺序。
按字母顺序或按数字顺序排列各种情况如果所有情况的重要性都相同,那
么就把它们按A-B-C的顺序加以排列,以便提高可读性。这样做很容易从中找出
某个特定的情况来。
把正常的情况放在前面如果有一个正常的情况和多个异常情况,那么就把那个
正常的情况放在最前面。用注释来说明它是正常情况,而其他的属于非正常情况。
按执行频率排列case子句把最经常执行的情况放在最前面,最不常执行的
放在最后。这样做有两个方面的好处。首先,阅读程序的人可以很容易地找到最
常见的情况。那些检索情况列表,找出某个具体情况的读者很可能会对最常见的
情况感兴趣,而把常见的情况放在代码的上部会加速这种检索。
Tips for Using case Statements
使用case语句的诀窍
下面是使用casc语句的几点提示。
交叉第24
第
简化每种情况对应的操作使得与每种情况相关的代码短小精悍。简短的情
章“构”讲了其况处理代码会使case语句的结构更加清晰。如果某种情况执行的操作非常复杂
他简化代码的诀那么就写一个了程序,并在该情况对应的case子句中调用它,而不要把代码本身
窍。
放进这一case子句里。
不要为了使用case语句而刻意制造一个变量cse语句应该用于处理简单
的、容易分类的数据。如果你的数据并不简单,那么就使用if-then-else语句串
为使用case而刻意构造出的变量很容易把人搞糊涂,你应该避免使用这种变量。
例如,不要这么做:
代码大全(第2版)

<==========================398end ==============================>
<==========================399start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看^
362
第15章使用条件语句
Java示例:刻意制造一个虚假的case变量—糟糕的实践
action userCommand[ ]
switch action )
CODING
case 'c':
HORROR
Copy()
break;
case 'd':
Deletecharacter()
break;
case 'f'
Format();
break;
case'h':
break;
default:
HandleUserInputError( ErrorType. InvaliduserCommand)
这里控制case语句的变量是 action。在本例中, action是通过截取
userCommand字符串个用户输入的字符串的第一个字符创建的。
交叉参考同这这种捣乱的代码很容易带来问题。一般而言,当你为了用case语句而刻意去
里的建议恰好相造出一个变量时,真正的数据可能不会按照你所希望的方式映射到case语句里。
反,有的时候你可
以把某个复杂的在本例中,如果用户输入的是copy,那么case语句就会截取到第一个“c”,并且
表达式赋给一个正确地调用opy()子程序。然而,如果用户输入的是 cement overshoes clambake
命名准确的布尔
变量或函数,由此或者 cellulite,那么这个case语句还是会取得“c”并且调用copy()。case语句中
提高代码的可读的 default子句所执行的错误命令检测也会失效,因为这个子句只能检测到第一个
性。在第19.1节
“简化复杂的表字母就有错的命令,不能检测整个命令。
达式”里有相关介
绍。
与其刻意制造一个本不适用于case的假冒变量(phony variable),不如使用一
个if-then-else-if检测串来检查整个字符串。以下是改写后的代码:
Java示例:使用if-then-else语句串替代虚假的ase变量良好的实践
if UserCommand. equals COMMAND
Copy();
else if( UserCommand. equals( COMMAN
Deletecharacter(
else if UserCommand
Format()
else if UserComma
LP ))
Help();
else
HandleUser
ndInput
代码大全(第2版)

<==========================399end ==============================>