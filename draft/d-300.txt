<==========================200start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!仅供试看^
71创建子程序的正当理由
163
这个子程序没有一个单一的目的。它初始化了一些变量,向数据库写入数据,
又做了一些计算从这些事情之间看不出任何联系。子程序应该有单一而
明确的目的。
这个子程序没有注意防范错误数据( bad data)如果 crntQtr等于0,那
么表达式 ytdRevenue*4.0/(double) crntQtrh将会导致除零错误。
这个子程序用了若干神密数值(magic number):100、4.0、12、2、3等
神秘数值的问题会在第12.1节“数值概论”中探讨。
这个子程序未使用其中一些参数: screenx和 screeny在程序中都没有被
引用过。
这个子程序的一个参数传递方式有误: prevcolor被标为引用参数(&),
但在这个子程序内却未对其赋值。
■这个子程序的参数太多了。合理的参数个数,其上限大概是7个左右,而这
个子程序有11个。这些参数的排布方式也难以理解,估计没人想仔细研究
它们、甚至没人想数数有几个参数。
这个子程序的参数顺序混乱且未经注释。(参数的顺序会在本章探讨。而代
码注释问题会在第32章中阐述。)
cc2e.com/0799
抛开计算机本身,子程序也算得上是计算机科学中一项最为重大的发明了
交叉参考类也子程序的使用使得程序变得更加易读更易于理解,比任何编程语言的任何功能
算得上是计算机特性都更容易。像上例那样滥用这一计算机科学中最为重要的特性,简直就是一
科学中的一项重
要发明想了解如种犯罪
何有效地使用类,
请参考第6章可
子程序也是迄今为止发明出来的用以节约空间和提高性能的最重要手段。设
以工作的类”。想,如果对每个子程序调用都重复写出代码,而不是转到相应的子程序,那么代
码会变得多么臃肿。再设想一下,如果要对段代码的性能进行改善,但这些代
码反复出现在不同地方,而不是被纳入了一个子程序,那该有多困难。正是子程
序使得现代化的编程成为可能。
“好吧,”你可能会说,“我早就知道子程序很重要,而且我在编程时
在用它们。这里的讨论好像是要纠正什么,那么你想让我做些什么呢?直
我希望你能够理解,创建一个子程序可以有很多合理的原因,但完成它的方
式却有对错之分。当我还是一名在读的计算机系大学生时,我曾认为创建子程序
的主要原因不过是为了避免重复代码。我所用过的那本入门教程也告诉我说,使
用子程序的好处就是因为它避免了重复的代码,从而使程序更易于开发、调试、
编档和维护,等等。除了还讲了一些如何使用参数和局部变量等语法细节之外,
这就是那本教程所涵盖的全部内容了。它对子程序理论和实践的解释既不够好,
也不够完整。下面的几节将给你一些更好的解释。
代丹大全(第2版)

<==========================200end ==============================>
<==========================201start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
164
第7章高质量的子程序
Valid Reasons to Create a Routine
创建子程序的正当理由
这里列出的是一些创建子程序的正当理由。有些理由互有重叠,因为本来也
未打算让它们形成一个正交的集合。
降低复杂度创建子程序的一个最重要的原因,就是为了降低程序的复杂
度。可以通过创建子程序来隐藏一些信息,这样你就不必再去考虑这些信息了。
KEY POINT
当然,在你要编写这个子程序的时候肯定是要考虑它们的。不过一旦程序写好
了,你就应该能忘记这些细节,可以直接调用该子程序而无须了解其内部工作
细节。创建子程序还有其他一些原因如缩小代码规模、改善可维护性、提高
正确性等一也都是很不错的,但如果没有子程序的抽象能力,我们的智力将根
本无法管理复杂的程序。
当内部循环或条件判断的嵌套层次很深时,就意味着需要从子程序中提取出
新的子程序了。把嵌套的部分提取出来形成一个独立的子程序,可以降低外围子
程序的复杂度。
引入中间、易懂的抽象把一段代码放入一个命名恰当的子程序内,是说明
这段代码用意最好的方法之一。与读下面这一串语句相比,
if(node> NULL then
while node. next <>NULL do
node =node.next
leafName node.name
end while
leafName
end if
读懂下这条语句就更容易:
leafName GetLeafName( node
这段新程序如此之短,只要给它取个好的名字就足够说明它的用意了。与上
面的8行代码相比,这个名字提供了更高层次的抽象,从而使代码更具可读性,
也更容易理解,同时也降低了原来包含着上面那段代码的子程序的复杂度。
避免代码重复毋庸置疑,创建子程序最普遍的原因是为了避免代码重复。
事实上,如果在两段子程序内编写相似的代码就意味着代码分解(decomposition)
出现了差错。这时,应该把两段子程序中的重复代码提取出来,将其中的相同部
分放入一个基类,然后再把两段程序中的差异代码放入派生类中。还有另一种办
法,你也可以把相同的代码放入新的子程序中,再让其余的代码来调用这个子程
序。与代码的重复出现相比,让相同的代码只出现一次可以节约空间。代码改动
代码大全(第2版)

<==========================201end ==============================>
<==========================202start==============================>

该书下载自-书部落分享计算机经典巨著-- ! --www.shubu.com!仅供试看
7.1创建子程序的正当理由
165
起来也更方便,因为你只需要在一处修改即可这时的代码也会更加可靠,因为
为了验证代码的正确性,你只需要检查一处代码。同时,这样做也会使改动更加
可靠,因为你可以避免需要做相同的修改时,却做了一些略有不同的修改。
支持子类化( subclassing)覆盖(override简短而规整的子程序所需新代
码的数量,要比覆盖冗长而邋遢的子程序更少如果你能让可覆盖的子程序保持
简单,那你在实现派生类的时候也会减少犯错的几率。
隐藏顺序把处理事件的顺序隐藏起来是一个好意。比如,如果一个程序
通常都是先从用户那里读取数据,然后再从一个文件中读取辅助数据,那么,无
论是从用户那里读取数据的子程序还是从文件中读取数据的子程序,都不应该依
赖另一个子程序是否已执行。再举一个有关顺序的例子,假设你写了两行代码,
先读取桟顶的数据,然后减少stackTop变量的值。你应该把这两行代码放到一
个叫 PopStack()的子程序中。从而把这两行代码所必须执行的顺序隐藏起来。把
这种信息隐藏起来,比让它们在系统内到处散布要好很多。
隐藏指针操作指针操作的可读性通常都很差,而且也容易出错。通过把这
些操作隔离在子程序内部,你就可以把精力集中于操作的意图本身,而不是指针
操作机制的细节。同时,如果此类操作都能在个位置完成,那么你对代码的正
确性就会更有把握。如果你发现了比指针更合适的数据类型,也可以对程序做出
修改,而不用担心会破坏了那些原本要使用指针的代码。
提高可移植性可以用子程序来隔离程序中不可移植的部分,从而明确识别
和隔离未来的移植工作。不可移植的部分包括编程语言所提供的非标准功能、对
硬件的依赖,以及对操作系统的依赖等。
简化复杂的布尔判断为了理解程序的流程,通常并没有必要去研究那些复
杂的布尔判断的细节。应该把这些判断放入函数中,以提高代码的可读性,因为:
(1)这样就把判断的细节放到一边了;(2)一个具有描述性的函数名字可以概括
出该判断的目的。
把布尔判断的逻辑放入单独的函数中,也强调了它的重要性。这样做也会激
励人们在函数内部做出更多的努力,提高判断代码的可读性。最终,代码的主流
程和判断代码都变得更加清晰。简化布尔判断也是降低复杂度的一个例子,这一
点在前面就已经讨论过了。
改善性能通过使用子程序,你可以只在一个地方优化代码。把代码集中在
一处可以更方便地查出哪些代码的运行效率低下。同时,在一处进行的优化,就
能使用到(无论是直接调用还是间接使用)该子程序的所有代码都从中受益。把
代码集中在一处之后,想用更高效的算法或更快速高效的语言来重写代码也更容
易做了。
代大全(第2版)

<==========================202end ==============================>
<==========================203start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看^
166
第7章高质量的子程序
交叉参考关于确保所有的子程序都很小不是的既然有这么多好的理由来把代码写成子
信息隐藏的详细
情况,见第5.3节程序,这一点就没有必要了。事实上有些事情写一个大的子程序来完成还会更
中的“隐藏秘密好。(有关子程序的最佳长度,请参见第7.4节“子程序可以写多长”)
(信息隐藏)”。
Operations That Seem Too Simple to Put Into Routines
似乎过于简单而没必要写成子程序的操作
编写有效的子程序时,一个最大的心理障碍是不情愿为一个简单的目的而编
写一个简单子程序。写一个只有两三行代码的子程序可能看起来有些大才小用,
KEY POINT但经验可以表明,一个很好而又小巧的子程序会多有用。
小的子程序有许多优点。其一便是它们能够提高其可读性。我曾在一个程序
的十多处地方写了下面这行代码:
伪代码示例:某种计算
pointsdeviceUnits POINTS_per_INCH DeviceUnitsPerInch(
这肯定不是你所读过的最复杂的代码。多数人最终都能看懂,它进行的是从
设备单位( device unit)到磅数(point)的转换计算。人们也会看出这十几处代码
都在做着同样的事情。但是,它们原本可以更清楚些,所以我创建了一个子程序,
并给它起了个好的名字,使这一转换可以只在一个地方进行:
伪代码示例iceUnitsTopoints deviceUnits Integer: Integer
DeviceUnitsToPoints deviceUnits
( POINTSperINCH DeviceUnitsPerInch())
End Function
在用这个子程序取代了那些直接嵌入计算的代码(inline code)之后,程序中
的那十几行代码就差不多都成了下面这样:
伪代码示例:调用计算函数
points= DeviceUnitsToPoints deviceUnits
这行代码更具可读性—甚至已经达到自我注解的地步。
这个例子还暗示出把简单操作写成函数的另一个原因:简单的操作常常会变
成复杂操作。写这段子程序时我还没有认识到这一点,但在某些情况下,当某个
设备激活(active)时, DeviceUnitPerInch()返回0。这意味着我必须考虑到
除以零的情况,为此需要再多写3行代码:
代码大全(第2版)

<==========================203end ==============================>
<==========================204start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
7.1创建子程序的正当理由
167
伪代码示例:维护代码时扩展了的函数
Function DeviceUnitsToPoints( deviceUnits Integer Integer;
if DeviceUnitsPerInch() <>0)
DeviceUnitsToPoints deviceUnits
( POINTS_PERINCH DeviceUnitsPerInch())
eDeviceUnitsTopoints
End functis
如果还是在程序中的十几处地方出现原来那样的代码行,那么这一测试也就
要重复十几次,这样就需要增加总共几十行代码。用一个简单的子程序,就把那
几十行代码减到了3行。
Summary of Reasons to Create a Routine
总结:创建子程序的理由
下面概括了创建子程序的一些理由
降低复杂度
引入中间的、易懂的抽象
■避免代码重复
支持子类化
隐藏顺序
隐藏指针操作
提高可移植性
简化复杂的逻辑判断
改善性能
除此之外,创建类的很多理由也是创建子程序的理由:
隔离复杂度
■隐藏实现细节
限制变化所带来的影响
■隐藏全局数据
形成中央控制点
促成可重用的代码
达到特定的重构目的
代码大全(第2版)

<==========================204end ==============================>
<==========================205start==============================>

该书下载自书部落-分享计算机经典巨著!--www. ! --www.shubulo.com! ^ .com!仅供试看^
168
第7章高质量的子程序
Design at the Routine Level
7.2在子程序层上设计
内聚性( cohesion)的概念是由Wayne Stevens、 Glenford Myers和 Larry
Constantine在1974年发表的一篇论文中提出来的。其他一些更为现代的概念,如
抽象和封装等,通常在类这一层次的设计中更为适用(事实上,抽象和封装在类
层次上已经很大程度上取代了内聚性),但内聚性的概念仍然存在,而且在单个子
程序这一层次上,仍是设计时常用的启发式方法。
交叉参考关于对子程序而言,内聚性是指子程序中各种操作之间联系的紧密程度。有些程
内聚性的全面探序员更喜欢使用“强度( strength)”这一术语:一个子程序中各种操作之间的联
讨,请参见第5.3系有多强?像 Cosine()(余弦函数)这样的函数就是极端内聚的,因为整个程序
节中的“高内聚
性”
只完成一项功能。而 CosineAndTan()(余弦与正切)这个函数的内聚性相对较
弱,因为它完成了多于一项的操作。我们的目标是让每一个子程序只把一件事做
好,不再做任何其他事情。
这样做的好处是得到高的可靠性。一项针对40个子程序所做的研究发现,高
内聚性的子程序中有50%没有任何错误,而低内聚性的子程序中只有18%是没有错误
HARD DATA
的(Card, Carch and Agresti 11986)。另一项针对另外450个子程序(选取了同样数量
的子程序进行研究纯属巧合)所做的研究发现,合度与内聚性之比最高的那些子程
序1,其中所含的错误是耦合度与内聚性之比最低的子程序的7倍之多,而其修正成
本则为20倍(Selby and Basili1991)
关于内聚性的讨论一般会涉及到内聚性的几个层次。理解一些概念要比记住
一些特定的术语更重要。这些概念可以帮助你思考如何让子程序尽可能地内聚
功能的内聚性functional cohesion)是最强也是最好的一种内聚性,也就是说让
一个子程序仅执行一项操作。例如sin(), GetCustomerName()、 EraseFile1、
CalculateLoan Payment()以及AgeFromBirthdate()这样的子程序都是高度内聚
的。当然,以这种方式来评估内聚性,前提是子序所执行的操作与其名字相符
如果它还做了其他的操作,那么它就不够内聚,同时其命名也有问题。
除此之外,还有其他一些种类的内聚性人们却通常认为是不够理想的。
顺序上的内聚性(sequential cohesion)是指在子程序内包含有需要按特定顺
序执行的操作,这些步骤需要共享数据,而且只有在全部执行完毕后才完成
了一项完整的功能
举一个顺序上的内聚性的例子,假设某个子程序需要按照给定出生日期来
计算出员工的年龄和退休时间。如果子程序先计算员工的年龄,再根据他的年
龄来计算退时间,那么它就具有顺序的内聚性而如果子程序先计算员工的
年龄,然后再重新计算他的退休时间,两次计算之间只是碰巧使用了相同的出
生日期,那么这个子程序就只具有通信上的内聚性communicational cobesion
1译注:也就是耦合度高且内聚性低的子程序
代码大全(第2版)

<==========================205end ==============================>
<==========================206start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo..com!仅供试看^
7.2在子程序层上设计
169
那么该怎样设计具有功能上的内聚性的子程序呢?你可以创建两个不
同的子程序,它们能根据给定的生日分别计算员工的年龄和退休时间。其中,
计算退休时间的子程序可以调用计算年龄的子程序这样两者就都具有功能
上的内聚性了。而其他的子程序则可以调用二者之一或全部。
通信上的内聚性( communicational cohesion)是指一个子程序中的不同操作
使用了同样的数据,但不存在其他任何联系例如某个子程序先根据传给它
的汇总数据打印一份汇总报表,然后再把这些汇总数据重新初始化,那么这
个子程序就具有通信上的内聚性:因为这两项操作只是因为使用了相同的数
据才彼此产生联系。
要改善这个子程序的内聚性,应该让重新初始化汇总数据的操作尽可能
靠近创建汇总数据的地方,而不是放在打印报表的子程序里应该把这些子
程序进一步拆分成几个独立的子程序:一个负责打印报表,一个负责在靠近
创建或修改数据的代码的地方重新初始化数据然后在原本调用那个具有通
信内聚性的子程序的更高层的子程序中调用这两个子程序。
临时的内聚性( temporal cohesion)是指含有一些因为需要同时执行才放到
一起的操作的子程序。典型的例子有: Startup()、
CompleteNewEmployee()、 Shutdown(等有些程序员认为临时的内聚性
是不可取的,因为它们有时与不良的编程实践相关比如说在 startup()
子程序里塞进一大堆互不相关的代码等。
为避免这个问题,可以把临时性的子程序看做是一系列事件的组织者。
前面提到的 startup()子程序可能需要读取配置文件、初始化临时文件、设
置内存管理器,再显示启动画面。要想使它最有效,应该让原来那个具有临
时内聚性的子程序去调用其他的子程序,由这些子程序来完成特定的操作,
而不是由它直接执行所有的操作。
这个例子提出这样一个问题,即如何选择个能够在恰当的抽象层次上
描述子程序的名字。你可能决定把一个子程序命名为
ReadConfigFileInitScratchFileEtc(,它可以暗示该子程序只有巧合
的内聚性(coincidental cohesion)。而如果你把它命名为 startup(),那么
很明显,这个子程序就只具有一个功能,且具有功能上的内聚性。
一般来说,其他类型的内聚性都是不可取的。它们都会导致代码组织混乱、
难于调试、不便修改。如果一个子程序具有不良的内聚性,那最好还是花功夫重
新编写,使其具有更好的内聚性,而不是再去花精力精确地诊断问题所在了。因
此,知道应该避免什么是非常有用的,下面就给出一些不可取的内聚性。
代大全(第2版)

<==========================206end ==============================>
<==========================207start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
170
第7章高质量的子程序
过程上的内聚性(procedural cohesion)是指一个子程序中的操作是按特定
的顺序进行的。一个例子是依次获取员工的姓名、住址和电话号码的子程序。
这些操作执行的顺序之所以重要,只是因为它和用户按屏幕提示而输入数据
的顺序相一致。另一个子程序用来获取员工的其他数据。这段程序也具有过
程上的内聚性,因为它把一组操作赋以特定的顺序,而这些操作并不需要为
了除此之外的任何原因而彼此关联
为了得到更好的内聚性,可以把不同的操作纳入各自的子程序中让调
用方的子程序具有单而完整的功能: Get Employee(就比
GetFirstPartof EmployeeData()更为可取。你可能还需要修改用来读取其
余数据的子程序。为了让所有的子程序都具有功能上的内聚性,对两个或更
多的原有子程序进行修改是很常见的。
逻辑上的内聚性( logical cohesion)是指若干操作被放入同一个子程序中,
通过传入的控制标志选择执行其中的一项操作之所以称之为逻辑上的内聚
性,是因为子程序的控制流或所谓“逻辑”是将这些操作放到一起的唯一
因它们都被包在一个很大的if语句或case语句中,而不是因为各项
操作之间有任何逻辑关联。认为是逻辑上的内聚性的标志性属性就是各项操
作之间没有关联,因此,似乎更应称其为“缺乏逻辑的内聚性”。
这方面的一个例子是名为 InputAll()的子程序,它根据传入的控制标
志来决定是输入客户姓名、员工考勤卡信息,还是库存数据。类似的例子还
有 ComputeAll()、 EditAll()、 PrintAll()和 SaveAll()这种子程序的
主要问题是你不该通过传入控制标志来控制另一个子程序的处理方式相比
之下,让三个子程序分别完成不同的操作,要比用个“根据传入的控制标
志选择执行三项不同的操作之一”的子程序清晰得多。如果这些操作中含有
一些相同代码或共用了数据,那么应该把那些代码移入一个低层程序中,
这些子程序也应该包裹在一个类中。
交叉参考虽然
子程序可能具有
如果子程序里的代码仅由一系列的if语句或者case语句,以及调用
更好的内聚性,一
其他子程序的语句组成,那么创建这样一个具有逻辑上的内聚性的子程序通
个更高层次的设
常也是可以的。在这种情况下,如果子程序唯一的功能就是发布各种命令,
计问题则是系统其自身并不做任何处理,这通常也是一个不错的设计。这类子程序的技术术
是否应该用case
语句而不用多态。
语便是“事件处理器(event handler)”。事件处理器通常用在各种交互性
关于这个问题更的环境中,例如像 Apple Macintosh、 Microsoft Windows及其他一些GUI(图
多的内容,请参考
第24.3节中的“用
形式用户界面)环境。
多态来替代条件巧合的内聚性(coincidental cohesion)是指子程序中的各个操作之间没有任何
语句(尤其是重复
的case语句”。
可以看到的关联。它也可称为“无内聚性”或“混乱的内聚性”。本章开头给
出的那个拙劣的C++子程序就具有巧合的内聚性很难从巧合的内聚性转变为
任何一类更好的内聚性通常你需要深入地重新设计和重新实现。
代码大全(第2版)

<==========================207end ==============================>
<==========================208start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. --Www.shubulo.com! ^ ^.com!仅供试看
7.3好的子程序名字
171
这些术语中没有哪个是神秘的或者神圣不可侵犯的。需要理解的是其中的想
法,而不是那些术语。编写具有功能上的内聚性的子程序几乎总是可能的,因此
REY PONT把注意力集中于功能上的内聚性,从而得到最大的收获。
7.3
Good Routine Names
好的子程序名字
交叉参考关于好的子程序名字能清晰地描述子程序所做的一切。这里是有效地给子程序命
给变量命名的更名的一些指导原则。
考第11章“变量描述子程序所做的所有事情子程序的名字应当描述其所有的输出结果以及
名的力量”。副作用( side effects)。如果一个子程序的作用是计算报表总额并打开一个输出文件,
那么把它命名为
ComputeReportTotals()就还不算完整
ComputeReportTotalsAndopenoutputFile()是很完整,但是又太长且显得有点
傻。如果你写的是有一些副作用的子程序,那就会起出很多又长又笨的名字。解决
的方法不是使用某个描述性较弱的子程序名,而应该换一种方式编写程序,直截了
当地解决问题而不产生副作用。
避免使用无意义的、模糊或表述不清的动词有些动词的含义非常灵活,可
以延伸到涵盖几乎任何含义。像Handlecalculation()、 Performservices()、
OutputUser)、 ProcessInput()和 DealWithoutput()这样的子程序名字根本
不能说明子程序是做什么的。最多就是告诉你这些子程序所做的事情与计算、服
务、用户、输入、输出有关。当然,当动词“handle(处理)”用做“事件处理(event
handling)”这一特定的技术含义时是个例外。
有时一个子程序中仅有的问题就是其名字表述不清,而子程序本身也许设计
得很好,但如果把它的名字由 HandleOutput)改为 FormatAndPrintoutput(),
那你就很容易看清楚这个子程序的功能了。
KSY POINT
还有另外一些情况,其中的动词之所以含糊,是由于子程序执行的操作就是
含糊不清的。这种子程序的问题在于目的不明确,而其模糊不清的名字仅是一种
表象。如果是这种情况,那么最佳的解决办法便是重新组织该子程序及任何与之
相关的子程序,以便使它们都具有更为明确的目的,进而赋予其能够精确描述这
些目的的更为清晰的名字。
不要仅通过数字来形成不同的子程序名字有个程序员把所有的代码都写成
一个大的函数,然后为每15行代码创建一个函数,并把它们分别命名为Part1、
Part2等。在此之后,他又创建了一个高层次的函数来调用这些部分(Partn)这
种创建子程序和给子程序命名的做法实在是骇人听闻(我真希望这很少发生)但
程序员们有时会用数字来区分类似于 OutputUser、 OutputUser1和 Out putUser22
这样的子程序。这些名字后面的数字无法显示出子序所代表的抽象有何不同,
因此这些子程序的命名也都很糟糕。
根据需要确定子程序名字的长度研究表明,变量名的最佳长度是9到15个
代大全(第2版)

<==========================208end ==============================>
<==========================209start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
172
第7章高质量的子程序
字符。子程序通常比变量更为复杂,因此好的子程序名字通常也会更长一些。
另一方面,子程序名字通常是跟在对象名字之后,这实际上为其免费提供了一部
分名字。总的来说,给子程序命名的重点是尽可能含义清晰,也就是说,子程序
名的长短要视该名字是否清晰易懂而定。
交叉参考关于给函数命名时要对返回值有所描述函数有返回值,因此,函数的命名要应该针
别,请参阅本章对其返回值进行。比如说,cos()、 customerId.next()、 printer. IsReady(和
7.6节“使用函数pen. CurrentColor()都是不错的函数名,它们精确地表述了该函数将要返回的结果。
时要特别考虑的
问题”
给过程起名时使用语气强烈的动词加宾语的形式一个具有功能内聚性的过
程(procedure)通常是针对一个对象执行一种操作。过程的名字应该能反映该过
程所做的事情,而一个针对某对象执行的操作就需要一个动词十宾语
(verb-plus--object)形式的名字。如PrintDocument)、CalcMonthlyRevenues()
Checkorderinfo)和 RepaginateDocument()等,都是很不错的过程名
在面向对象语言中,你不用在过程名中加入对象的名字(宾语),因为对象本
身已经包含在调用语句中了。你会用 document. Print)、 orderInfo. Check()
和 monthlyRevenues.calc()等语句调用子程序而诸如
document.€dcunent,PrinDocunenc€()这样的语句则显得太臃肿,并且当它们在派生类中
被调用时也容易产生误解。如果 Check(支票)类是从Document(文档)类继承
而来的,那么check. Print()就很显然表示打印一张支票,而
check Print Document()看上去像是要打印支票簿或是信用卡的对账单,而不像
是打印支票本身。
交叉参考关
准确使用对词命名时遵守对仗词的命名规则有助于保持一致性,从而也
的相似的一组对提高可读性。像 firstlast这样的对仗词组就很容易理解;而像 Fileopen)和
仗词,请参阅第1close()这样的组合则不对称,容易使人迷惑。下面列出一些常见的对仗词组:
11.1节中的“变
量名中的常用对add/remove
increment/decrement
open/close
仗词”。
begin/end
insert/delete
show/hide
create/destroy lock/unlock
source/target
first/ast
min/max
start/stop
getput
nextprevious
up/down
getset
old/new
为常用操作确立命名规则在某些系统里,区分不同类别的操作非常重要
而命名规则往往是指示这种区别的最简单也是最可靠的方法。
在我做过的一个项目的代码里,每个对象都被分配了一个唯一标识。我们忽
视了为返回这种对象标识的子程序建立一个命名规则,以至于有了下面这些子程
序名字:
代码大全(第2版)

<==========================209end ==============================>
<==========================210start==============================>

该书下载自-书部落-分享计算机经典巨著!--www ! --www.shubu.com!仅供试看^
7.4子程序可以写多长
173
employee.id.get()
dependent. GetId()
supervisor()
candidate.id()
其中: Employee类提供了其id对象,而该对象又进而提供了et()方法;
Dependent类提供了 Get Id)方法 Supervisor类把id作为它的默认返回值
Candidate类则认为id对象的默认返回值是id,因此暴露了id对象到了项目
中期,已经没人能记住哪个对象应该用哪些子程序,但此时已经编写了太多的代
码,已经无法返回再重新统一命名规则了。这样来,项目组中每个人都不得不
花费不必要的精力,去记住每个对象上采用的获取id的语法细节而这些问题完
全可以通过建立获取id的命名规则而避免。
7.43程序可以e
在前往美洲的途中,英国清教徒们( Pilgrims)就日常工作(routine)的最大
长度限度展开了争论。他们争执了一路,最终到达了普利茅斯巨礁(Plymouth
Rock),然后便开始起草五月花协议(Mayflower Compact)这时,他们仍然无法
就最大长度问题达成一致,而如果他们不签订五月花协议就不能登陆,因此他们
放弃了争论而把这项内容排除在协议之外而由此带来的结果就是,从此以后人
们就“routine”的长度问题展开了旷日持久的讨论。
理论上认为的子程序最佳最大长度通常是一屏代码或打印出来一到两页的代
码,也就是约50~150行代码。按这种精神IBM曾经把子程序的长度限制在50
行之内,而TRW则把这一长度限制在两页纸之内(McCabe1976)现代的计算
机程序通常都是由很多极短的子程序外加少量较长的子程序组成然而很长的子
程序却也仍然存在。在即将完成本书的时候,我曾在一个月的时间里登门拜访了
两家客户。其中一家的程序员们正在与一段400多行代码的子程序较劲,而另
家的程序员们则在试图弄懂一段超过12000行代码的子程序!
多年来,人们已经在子程序的长度问题上积累了大量的研究成果,其中一些
适用于现代编程,而另一些则不尽如此。
Basili和 Perricone所做的一项研究发现,子程序的长度与错误量成反比,即:
随着子程序长度的增加(上至200行代码)每行代码所包含的错误数量就
HARD DATA
会减少(Basili和 Perricone1 1984)。
另一项研究则发现,子程序的长度与错误量没有关联,而结构复杂度以及数
据量却与错误量有关(Shen et al.1985)。
代大全(第2版

<==========================210end ==============================>
<==========================211start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
174
第7章高质量的子程序
1986年所做的一项研究发现,短小的子程序(含有32行或更少代码)与更
低的成本或错误率无关(Card, Church and Agresti1986; Card and Glass
1990)。有证据表明,较长的子程序(含有65行或更多代码)使得每行代
码的成本更低。
一项对450个子程序所做的实证研究发现相对较长的子程序而言,短小的
子程序(包括注释在内少于143行语句)中每行代码所含的错误数量要多
23%,而较长子程序的修改成本却高2.4倍(Selby and Basili1991)
另一项研究发现,平均长度为100到150代码的子程序需要被修改的几率
最低(Lind and Vairavan1989)。
IBM所做的一项研究发现,最容易出错的是那些超过500行代码的子程序。
超过500行之后,子程序的出错率就会与其长度成正比( Jones1986a)
那么,上述这些研究对于面向对象程序中子程序的长度又意味着什么呢?在
面向对象的程序中,一大部分子程序都是访问器子程序( accessor routines),它们
都非常短小。在任何时候,复杂的算法总会导致更长的子程序。在这种情况下,
可以允许子程序的长度有序地增长到100至200行(不算源代码中的注释行和空
行)。数十年的证据表明,这么长的子程序也和短小的子程序一样不易出错。与其
对子程序的长度强加限制,还不如让下面这些因素如子程序的内聚性、嵌套
的层次、变量的数量、决策点(decision points)的数量、解释子程序用意所需的
注释数量以及其他一些跟复杂度相关的考虑事项等来决定子程度的长度。
这就是说,如果要编写一段超过200行代码的子程序,那你就要小心了。对
于超过200行代码的子程序来说,没有哪项研究发现它能降低成本和/或降低出错
率,而且在超过200行后,你迟早会在可读性方面遇到问题。
How to Use Routine Parameters
如何使用子程序参数
子程序之间的接口是程序中最易出错的部分之一由 Basili和 Perricone(1984)
所做的一项被广为引用的研究发现,程序中有9%的错误都是属于内部接口错误
HARD DATA
一也就是子程序间互相通信时所发生的错误。以下是一些可以减少接口错误的
交指导原则。
于说明子程序参
按照输入修改-输出的顺序排列参数不要随机地或按字母顺序排列参数,
数的详情,请见而应该先列出仅作为输入用途的参数,然后是既作为输入又作为输出用途的参数,
第32.5节中的
“注释子程序”。最后才是仅作为输出用途的参数。这种排列方法暗含了子程序的内部操作所发生
关于格式化参数的顺序—先是输入数据,然后修改数据,最后输出结果。下面给出一些Ada语
的详情请见第
31.7节中的“子言中参数列表的示例:
程序的布局”。
代码大全(第2版)

<==========================211end ==============================>
<==========================212start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看^
7.5如何使用子程序参数
175
Ada示例:按照输入修改输出的顺序排列参数
procedure InvertMatrix(
Ada语言使用了 originalMatrix: in Matrix
in和out关键字,
resultMatrix: out Matrix
使输入、输出参);
数更为明确。
procedure Changesentencecase(
desiredcase: in stringcase;
sentence: in out Sentence
procedure PrintPageNumber
pageNumber: in Integer;
status: out statusType
)
这种排列规则与C函数库中所用的把会被修改的参数列在最前面的规则是不
同的。然而对我来说,这种输入修改-输出的排列规则更有意义,当然,如果你总
是统一地采取某种排列规则的话,那么为代码的读者考虑,你还是延用自己的规
则为好。
考虑自己创建in和out关键字其他一些现代编程语言并没有像Ada那样支
持in和out关键字。在使用这些语言的时候,你可能还是可以通过预处理指令来
自己创建in和out关键字:
C++示例:定义你自己的N和OUT关键字
#define IN
#define OUT
void InvertMatrix(
IN Matrix originalMatrix,
OUT Matrix *resultMatrix
);
void ChangeSentencecase(
IN Stringcase desiredcase,
IN OUT Sentence *sentenceToEdit
);
void PrintPageNumber
IN int pageNumber,
OUT StatusType &status
)
在这里,IN和OUT这两个宏关键字只是起说明性的作用。如果你想让被调用
的子程序修改某一个参数的值,那么还是得通过指针或引用参数来传递该参数。
代码大全(第2版)

<==========================212end ==============================>
<==========================213start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
176
第7章高质量的子程序
请在应用这一技术之前,请考虑它的以下两种显著弊端。自行定义的IN和
OUT关键字扩展了C++语言,从而在某种程度上让多数阅读这一代码的人感到生
疏。如果你以这种方式扩展所用的语言,请确保能够持续致地使用该方法,最
好是在整个项目的范围内。第二个弊端在于编译器并不会强制I和OUT关键字的
使用,也就是说,你有可能把某个参数标记为IN,但仍在子程序中修改了该参数
的值。阅读代码的人可能会误认为有关代码是正确的,然而事实却并非如此。使
用C++中的 const关键字来定义输入参数通常更为适宜。
如果几个子程序都用了类似的一些参数,应该让这些参数的排列顺序保持一
致子程序的参数顺序可以产生记忆效应一不一致的顺序会让参数难以记忆。
比如说在C语言中, fprint()函数比printf()函数就是多了一个放在开头的文
件参数而已,其他都完全一样。而与之类似的函数 fputs(),它比 puts只多了
一个放在最后的文件参数。本来应该很容易记住的参数,却因为这点儿毫无道理
的可气的区别而变得难以记忆了。
而另一方面,C语言中的 strncpy()函数所接受的参数依次是目标字符串、
源字符串和最大字节数, mercpy)函数也是接受同样顺序相同的参数。这两个函
数的相似性对记住函数中的参数不无禆益。
使用所有的参数既然往子程序中传递了一个参数,就一定要用到这个参数。
如果你不用它,就把它从子程序的接口中删去。未被用到的参数和出错率的增加
HARO DATA不无关系。在一项研究中,不出现未被用到的变量的子程序中有46%没有错误,
而含有超过一个未被用到的变量的子程序中则仅有17%~29%没有错误(Card,
Church和 Agresti1986)
这样去除未被用到的参数的规则也有一个例外。如果你是在一定条件下编译
某部分程序,那么就可能只是编译了子程序中使用某个参数的那一部分对这种
做法要慎重,但如果你确信这样可行,那么这样做也没问题。总之,如果你有很
好的理由不使用某个参数,那就继续留着它吧相反,如果你没有很好的理由,
那就应该花功夫来清理代码。
把状态或出错变量放在最后按照习惯做法,状态变量和那些用于指示发生
错误的变量应放在参数表的最后。它们只是附属于程序的主要功能,而且它们是
仅用于输出的参数,因此这是一种很有道理的规则。
不要把子程序的参数用做工作变量把传入子程序的参数用做工作变量是很
危险的。应该使用局部变量。比如说在下面这段Java程序中, inputval这个参
数就被不恰当地用于存储计算的中间结果:
代码大全(第2版)

<==========================213end ==============================>
<==========================214start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo...com!仅供试看^
7.5如何使用子程序参数
177
ava示例:不恰当地使用输入参数
int Sample( int inputval )
inputVal inputval CurrentMultiplier inputval
inputVal inputVal CurrentAdder inputval
此处 inputVal已经
不再是当初传入 return inputvali
的值了。
在这段代码中, inputVal1这个名字很容易引起误解,因为当执行到最后一行
代码时, inputval1包含的已经不是最初的输入值了,它的值是用输入值计算出的
结果,因此这个参数名起得不对。如果日后你又要修改这段程序,要在其他地方
使用原有的输入值,你可能会想当然地以为inputVal1是含有原始输入值的参数
并使用它,而事实上并非如此。
该怎样解决这个问题呢?为 inputVa1换个名字行吗?不太可行。你可能想
把它重命名为 workingVal1,但这还不够,因为新的名字也无法反映出该变量的原
始数值来自于子程序外部。你也可能会更荒唐地把它重命名为
inputValThat BecomesWorkingVal,或索性就叫它x或者val,但这些方法都经
不住推敲。
更好的方法是明确地引入一些工作变量,从而避免当前或日后的麻烦。下面
这段代码演示了这一技术:
java示例:正确地使用输入参数
int Sample( int inputVal )
int workingval =inputval;
workingVal=workingVal CurrentMulti( workingval
workingVal =workingval CurrentAdd( workingval
如果在此处或其
他地方还可以使
用 inputVal最初传 return workingval;
入的值。
引入了新变量 workingVal,就澄清了 inputVal1角色,同时也消除了在错
误的时间误用 inputVal1的可能。(千万不要以此为就把变量命名为 inputval1
或 workingVal.般说来, inputvalworkingVal1和1都是极其糟糕的变量名,
上例中用到这两个名字只是为了能够明确这两个变量的角色。)
把输入值赋给工作变量,这种方式强调了数据是来自何方的。它也能避免对
于参数表中变量的值的意外修改。在C++中可以利用 const关键字,让编译器帮
助实施这一限制。当一个参数被标记为 const时,在子程序中就不能修改其值。
代码大全(第2版)

<==========================214end ==============================>
<==========================215start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看
178
第7章高质量的子程序
交叉参考关于在接口中对参数的假定加以说明如果你假定了传递给子程序的参数具有
接口假定的详
情,请参考第8章某种特征,那就要对这种假定加以说明。子程序内部和调用子程序的地方同
“防御式编程”时对所做的假定进行说明是值得的。不要等到把子程序写完之后再回过头去写
的介绍。关于代
码文档的详情,注释一你是不会记住所有这些假定的一种比用注释还好的方法,是在代码中
请参见第32章使用断言(assertions)
“自说明代码”。
应该对哪些接口参数的假定进行说明呢?
参数是仅用于输入的、要被修改的、还是仅用于输出的;
表示数量的参数的单位(英寸、英尺、米等);
如果没有用枚举类型的话,应说明状态代码和错误值的含义
所能接受的数值的范围;
不该出现的特定数值。
把子程序的参数个数限制在大约7个以内对于人的理解力来说,7是一个
神奇的数字。心理学研究发现,通常人类很难同时记住超过7个单位的信息( Miller
HATA《19562<7)这一发现已经用于各种领域之中,因此,假定人不能同时记住超过约7个
的子程序参数,也是合适的。
在实践中,子程序中参数的个数到底应该限制在多少,取决于你所使用的编
程语言如何支持复杂的数据类型。如果你使用的是一种支持结构化数据的现代编
程语言,你就可以传递一个含有13个成员的合成数据类型,并将它看做一个大数
据块。如果你使用的是一种更为原始的编程语言,那你可能需要分别传递全部13
个成员。
交叉参考关
如果你发现自己一直需要传递很多参数,这就说明子程序之间的耦合太过紧
如何考虑接口的密了。应该重新设计这个或这组子程序,降低其间的耦合度。如果你向很多不同
详细内容,请参
见第6.2节中的的子程序传递相同的数据,就请把这些子程序组成一个类,并把那些经常使用的
“好的抽象”数据用作类的内部数据。
考虑对参数采用某种表示输入、修改、输出的命名规则如果你觉得把输入、
修改、输出参数区分开很重要,那么就建立一种命名规则来对它们进行区分。你
可以给这些参数名字加上、m、。_前缀。如果不闲嗦,也可以用 Input
Modify或output_来当前缀
代码大全(第2版)

<==========================215end ==============================>
<==========================216start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.con.com!仅供试看
7.5如何使用子程序参数
179
为子程序传递用以维持其接口抽象的变量或对象关于如何把对象的成员传
给子程序这一问题,存在着两种互不相让的观点比如说你有一个对象,它通过
10个访问器子程序(access routine)暴露其中的数据,被调用的子程序只需要其
中的3项数据就能进行操作。
持第一种观点的人们认为,只应传递子程序所需的3项特定数据即可。他们
的论据是,这样做可以最大限度地减少子程序之间的关联,从而降低其耦合度,
使它们更容易读,更便于重用,等等。他们强调说,把整个对象传递给子程序就
破坏了封装的原则,因为这样做就是潜在地把所有10个访问器子程序都暴露给被
调用的那个了程序了。
持第:种观点的人们则认为应该传递整个对象。他们认为,如果在不修改子
程序接口的情况下,让被调用子程序能够灵活使用对象的其余成员,就可以保持
接口更稳定。他们争辩说,只传递3项特定的数据破坏了封装性,因为这样做就
是把特定的数据项暴露给被调用的那个子程序了。
我认为这两种规则都过于简单,并没有击中问题的要害:子程序的接口要表
达何种抽象?如果要表达的抽象是子程序期望3项特定的数据,但这3项数据只
是碰巧由同一个对象所提供的,那就应该单独传递这3项数据然而,如果子程
序接口要表达的抽象是想一直拥有某个特定对象,且该子程序要对这一对象执行
这样那样的操作,如果单独传递3项特定的数据,那就是破坏了接口的抽象。
如果你采用传递整个对象的做法,并发现自己是先创建对象,把被调用子程
序所需的3项数据填入该对象,在调用过子程序后又从对象中取出3项数据的值,
那就是一个证据,说明你应该只传递那3项数据而不是整个对象。(般说来,如
果在调用子程序之前出现进行装配(set up)的代码,或者在调用子程序之后出现
拆卸( take down)的代码,都是子程序设计不佳的表现。)
如果你发现自己经常需要修改子程序的参数表而每次修改的参数都是来自
于同一个对象,那就说明你应该传递整个对象而不是个别数据项了。
代码大全(第2版)

<==========================216end ==============================>
<==========================217start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
180
第7章高质量的子程序
使用具名参数在某些语言中,你可以显式地把形式参数( formal parameter)
和实际参数( actual parameter)对应起来。这使得参数的用法更具自我描述性,并
有助于避免因为用错参数而带来的错误。下面是用 Visual Basic语言写的一个示
例:
Visual Basic示例:显式地标识参数
Private Function Distance3d(
形式参数在这里 ByVal xDistance As Coordinate,
声明。
ByVal yDistance As Coordinate
ByVal zDistance As Coordinate
End Function
veloeito
Private Function Velocity(
ByVal latitude as Coordinate,
Byval longitude as Coordinate
,
ByVal elevation as Coordinate
实际参数在里→ Distance= Distance3d(xDistance:=latitude, yDistance:= longitude
和形式参数映射。
zDistance elevation
End Function
当你有超乎平均数量的同样类型的参数时,就可能发生参数放错位置且编译
器却检测不到的情况,这时上述技术就格外有用了。在很多场合下,显式地把参
数对应起来可能会有些矫枉过正,但在需要高安全性或高可靠性的情形下,花额
外的功夫把参数按照设想的方式对应起来是十分值得的。
确保实际参数与形式参数相匹配形式参数也称为“哑参数(dummy para
meters)”,是指在子程序定义中声明的变量。实际参数是指在实际的子程序调用中
用到的变量、常量或表达式。
一个常见的错误是在调用子程序时使用了类型错误的变量例如,在本该
使用浮点类型的地方用了整型。(只有当你使用像C这样的弱类型编程语言,并且
没有开启全部的编译器警告功能时,才会遇到这个问题;在C++和Java这样的强
类型语言中不存在该问题。)如果是仅用于输入的参数,这种情况很少会带来问题;
编译器在把参数传递给子程序之前,通常会将实际类型转换成形式类型。如果有
问题的话,编译器通常会给出警告。但在某些情况下,特别是当所用的参数既用
于输入也用于输出时,如果传错了参数类型,你就会遇上麻烦了。
请养成好的习惯,总要检查参数表中参数的类型,同时留意编译器给出的关
于参数类型不匹配的警告。
代码大全(第2版)

<==========================217end ==============================>
<==========================218start==============================>

该书下载自-书部落分享计算机经典巨著!-www. ! --www.shubulo.com!^ ^.com!仅供试看
7.6使用函数时要特别考虑的问题
181
7.6
Special Considerations in the Use of Functions
使用函数时要特别考虑的问题
现代的编程语言,如C++、Java、 Visual Basic等,都同时支持函数和过程
函数是指有返回值的子程序;过程是指没有返回值的子程序。在C++中,通常把
所有子程序都称为“函数”;然而,那些返回值类型为void的函数在语义上其实
就是过程。函数与过程的区别更多的是语义的区别,而不是语法的区别,你还是
要以语义为准。
When to Use a Function and When to Use a Procedure
什么时候使用函数,什么时候使用过程
语言纯化论者们认为,一个函数应该只有一个返回值,就像数学函数一样。这
意味着函数只能接受仅用于输入的参数,并只通过函数本身返回一项结果。函数永
远应该以它所返回的值来命名,就像sin()、 CustomerID(、 ScreenHeight
样。在另一方面,过程则可以根据所需,接受任意数量的输入、修改和输出参数。
一种常用的编程实践是让函数像过程一样执行并返回状态值。逻辑上,这种
东西的工作方式和过程一样,但是由于具有返回值,它又确实是一个函数。举例
来说,你可能有一个名为€ormatoutput€()的函数,它在类似下面这样的语句里
用到了一个 report对象:
if report. FormatOut.put formattedReport Success then ..
在这个例子中, report. Formatoutput()的工作方式就像是过程,因为它有
一个输出参数 formattedReport,但是因为它有返回值,所以从技术角度来看它
又是一个函数。这样使用函数是否正确呢?为支持这种用法,你可能保证了该函
数的返回值与函数的主要目标格式化输出无关,也与函数的名字
report. Formatoutput()无关。在这种意义下,尽管从技术角度来看它是个函数,
但执行起来却更像是一个过程。如果能够统一地使用这种技术,用返回值来表示
过程执行成功与否倒也不会让人感到困惑。
代替它的一种方法,就是写个用状态变量作为显式参数的过程,如下面这
段代码所示:
report. Formatoutput formattedReport, outputStatus
if outputstatus Success then ..
我更喜欢使用第二种编码风格,倒不是因为我对函数和过程之间的分别特别
敏感,而是因为这样做可以把对子程序的调用和对状态值的判断清楚地分开。把
对子程序的调用和对状态值的判断写在一行代码中,增加了该条语句的密度,也
相应地增加了其复杂度。下面这种使用函数的方式也是很好的:
1
utputStatus report. Formatoutput( formattedReport
f( outputstatus= Success)the.
代码大全(第2版

<==========================218end ==============================>
<==========================219start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! -www.shubulo.c!^^.com!仅供试看^
182
第7章高质量的子程序
简而言之,如果一个子程序的主要用途就是返回由其名字所指明的返回值,
那么就应该使用函数,否则就应该使用过程。
KEY POINT
Setting the Function's Return Value
设置函数的返回值
使用函数时总存在返回不正确的返回值的风险。当函数内有多条可能的执行
路径,而其中一条执行路径没有设置返回值时,这一错误就出现了。为了减少这
一风险,请按照下面给出的建议来做。
检查所有可能的返回路径在编写函数时,请在脑海里执行每一条执行路径,确
保在所有可能的情况下该函数都会返回值。在函数开头用一个默认值来初始化返回值
是个很好的做法这种方法能够在未正确地设置返回值时提供一张保险网。
不要返回指向局部数据的引用或指针一旦子程序执行结束,其局部数据就
都出了作用域,那么任何指向局部数据的引用或指针也随之失效。如果一个对象
需要返回有关其内部数据的信息,那就应该把这些信息保存为类的数据成员。然
后,它还应该提供可以返回这些数据成员的访问器子程序,而不是返回对局部数
据的引用或者指针。
Macro Routines and Inline Routines
宏子程序和内联子程序
交叉参考即使
用预处理器的宏语言(preprocessor macros)编写子程序还需要一些特别的考
你所使用的语言
没有支持宏的预虑。下面的这些规则和示例适用于在C++中使用预处理器的情形。如果你用的是
处理器,你也可以其他编程语言或预处理器,请对这些规则因地制宜地加以调整。
自己创建。更多详
细信息,请参见第把宏表达式整个包含在括号内由于宏和其参数会被最终展开到代码中,因
30.5节“打造你此请多加小心,确保代码是按照你所预期的方式被展开的。下面这个宏中包含了
自己的编程工
具”。
一个常见的错误:
C++示例:一个不能正确展开的宏
#define Cube(a)a*aa
如果传给这个宏的a不是不可分割的值,那它就不能正确地进行这一乘法计
算了。比如说你写的表达式是Cube(x+1),那么它会展开成x+1*x+1*x+1,而由
于乘法运算符的优先级高于加法运算符,这显然不是你所预期的结果。这个宏的
下面这种写法要好一些,但也不完美:
C
++示例:仍不能正确展开的宏
#define Cube(a)(a)*(a)*(a)
代码大全(第2版)

<==========================219end ==============================>
<==========================220start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看^
7.7宏子程序和内联子程序
183
这一次要好一些,但还是存在问题。如果在使用cube()的表达式里含有比乘
法运算符优先级更高的运算符,那么(a)*()*(a)也会再次失效。为了防止这种
情况的发生,你应该给整个表达式加上括号:
C++示例:可以正确展开的宏
define Cubea)(a)*(a)*(a))
把含有多条语句的宏用大括号括起来一个宏可以含有多条语句,如果你把
它当做一条语句使用就会出错。下面这个例子就是一个会带来麻烦的宏:
C++示例:一个无法工作的含有多条语句的宏
#define LookupEntry( key, index
index (key 10) 5:
CODING
index =min( index, MAX INDEX
HORROR
index=max index,min_INDEX
for( entryCount; entryCount numEntries; entryCount++
LookupEntry( entryCount, tableIndex entryCount)
这个宏之所以会带来麻烦,是因为它和常规函数的执行方式是不同的。按照
例中所示的形式,在for循环语句中只有宏的第一部分代码被执行:
index =(key-10)/5;
要避免这一问题,请把宏用大括号括起来:
C++语言示例:可以正确工作的含有多条语句的宏
define LookupEntry(key, index)
index (key 10) /5i
index=min( index, MAXINDEX
index =max( index, MIN_INDEX )
通常认为,用宏来代替函数调用的做法具有风险,而且不易理解这是一
种很糟糕的编程实践——因此,除非必要,否则还是应该避免使用这种技术。
用给子程序命名的方法来给展开后代码形同子程序的宏命名,以便在需要时
可以用子程序来替换宏C++语言中给宏命名的方式是全部使用大写字母。如果
能用子程序来代替宏,那在给宏命名的时候就应该采用给子程序命名的规则。这
样当你想用子程序代替宏的时候,除了需要修改相关的子程序之外,无须做任何
其他改动,反之亦然。
代码大全(第2版)

<==========================220end ==============================>
<==========================221start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看
184
第7章高质量的子程序
遵循这建议也会带来一些风险。如果你常常利用到++和--运算符的副作用
(side effects)(作为其他语句的一部分),那么当你误把宏当做子程序使用时就会
遇上麻烦。考虑到副作用还可能引发其他问题,这也可以成为避免利用副作用的
另一个原因。
Limitations on the Use of Macro Routines
宏子程序在使用上的限制
像C++这样的现代编程语言都提供了大量可以取代宏的方案:
const可以用于定义常量
inline可以用于定义可被编译为内嵌的代码(inline code)的函数
template可以用于以类型安全的方式定义各种标准操作,如min、max等
enum可以用于定义枚举类型
typedef可以用于定义简单的类型替换
正如C++的设计师 Bjarne Stroustrup所指出的“几乎每个宏都表明在编程语
言、程序或程序员身上存在问题…当你使用宏的时候,就甭指望调试器、交叉
NEY POINT
引用工具和剖测器(profiler)等工具能好好工作。(Stroustrup1997)宏对于支
持条件编译—见第8.6节“辅助调试的代码一非常有用,但对于细心的程
序员来说,除非万不得已,否则是不会用宏来代替子程序的。
Inline Routines
内联子程序
C++支持inline关键字。 inline子程序允许程序员在编写代码时把代码当成
子程序,但编译器在编译期间通常会把每一处调用 inline子程序的地方都转换为
插入内嵌的代码(inline code)。因为避免了子程序调用的开销,因此 inline机制可
以产生非常高效的代码。
节制使用 inlineinline子程序子程序违反了封装原则,因为C++要求程序员
把 inline子程序的实现代码写在头文件里,从而也就把这些实现细节暴露给了所
有使用该头文件的程序员。
inline子程序要求在调用子程序的每个地方都生成该子程序的全部代码,这样
无论 tinline子程序是长是短,都会增加整体代码的长度。这也会带来其自身的问
题。
代码大全(第2版)

<==========================221end ==============================>
<==========================222start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubulo.c.com!仅供试看^
7.7宏子程序和内联子程序
185
和为追求性能而使用的其他编程技巧一样,为性能原因而使用 inline子程序
的底线是:剖测(profile)代码并衡量性能上的改进。如果预期获得的性能收益不
能说明为“剖测代码以验证性能改进”操心是值得的,那也就没有理由再牺牲代
码质量而使用 inline子程序了。
CHECKLIST: High-Quality Routines
cc072核对表:高质量的子程序
交叉参考这是大局事项
一份针对子程序
质量所要考查事
口创建子程序的理由充分吗?
项的核对表关
于创建子程序的
口一个子程序中所有适于单独提出的部分是不是已经被提出到单独的子程
步骤列表,请参
序中了?
见第9章“伪代
码编程过程”中
口过程的名字中是否用了强烈、清晰的“动词十宾语”词组?函数的名字
的核对表。
是否描述了其返回值?
口子程序的名字是否描述了它所做的全部事情?
口是否给常用的操作建立了命名规则?
口子程序是否具有强烈的功能上的内聚性?即它是否做且只做一件事,并
且把它做得很好?
口子程序之间是否有较松的耦合?子程序与其他子程序之间的连接是否是
小的(small)、明确的( intimate)、可见的( viaible)和灵活的( flexible)?
口子程序的长度是否是由其功能和逻辑自然确定,而非遵循任何人为的编
码标准?
参数传递事宜
口整体来看,子程序的参数表是否表现出一种具有整体性且一致的接口抽象?
口子程序参数的排列顺序是否合理?是否与类似的子程序的参数排列顺序
相符?
口接口假定是否已在文档中说明?
口子程序的参数个数是否没超过7个?
口是否用到了每一个输入参数?
口是否用到了每一个输出参数?
口子程序是否避免了把输入参数用做工作变量?
口如果子程序是一个函数,那么它是否在所有可能的情况下都能返回一个
合法的值?
代大全(第2版)

<==========================222end ==============================>
<==========================223start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww ! --www.shubu.com!仅供试看
186
第7章高质量的子程序
Key Points
要点
创建子程序最主要的目的是提高程序的可管理性,当然也有其他一些好的理
由。其中,节省代码空间只是一个次要原因;提高可读性、可靠性和可修改
性等原因都更重要一些。
有时候,把一些简单的操作写成独立的子程序也非常有价值。
子程序可以按照其内聚性分为很多类,而你应该让大多数了程序具有功能上
的内聚性,这是最佳的一种内聚性。
子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分,那就说明这
个子程序设计得很差劲。如果名字糟糕而且又不准确,那么它就反映不出程
序是干什么的。不管怎样,糟糕的名字都意味着程序需要修改。
只有在某个子程序的主要目的是返回由其名字所描述的特定结果时,才应该
使用函数。
细心的程序员会非常谨慎地使用宏,而且只在万不得已才用。
代码大全(第2版)

<==========================223end ==============================>
<==========================224start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
Defensive Programming
第
章
防御式编程
cc2ecom/0861内容
8.1保护程序免遭非法输入数据的破坏:第188页
8.2断言:第189页
8.3错误处理技术:第194页
8.4异常:第198页
8.5隔离程序,使之包容由错误造成的损害:第203页
8.6辅助调试的代码:第205页
8.7确定在产品代码中该保留多少防御式代码:第209页
8.8对防御式编程采取防御的姿态:第210页
相关章节
信息隐藏:第5.3节中的“隐藏秘密(信息隐藏)”
为变更而设计:第5.3节中的“找出容易改变的区域”
软件架构:第3.5节
软件构建中的设计:第5章
■调试:第23章
防御式编程并不是说让你在编程时持“防备批评或攻击”的态度“它就是这
么工作!”这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维,那就是
KEY POINT你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你
也不会受到伤害。你要承担起保护自己的责任,哪怕是其他司机犯的错误。防御式编
程的主要思想是:子程序应该不因传入错误数据而被破坏,哪怕是由其他子程序产生
的错误数据。更一般地说,其核心想法是要承认程序都会有问题,都需要被修改,聪
明的程序员应该根据这一点来编程序。
本章就是要讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事
件以及其他程序员犯下的错误时保护你自己。如果你是一位有经验的程序员,那么
可以略过下面关于对输入数据进行处理的一节,而直接进入第8.2节“断言”。
代码大全(第2版)

<==========================224end ==============================>
<==========================225start==============================>

该书下载自-书部落分享计算机经典巨著--www. !--www.shubulo.com! ^.com!仅供试看^
188
第8章防御式编程
8.
Protecting Your Program from Invalid Inputs
保护程序免遭非法输入数据的破坏
在学校里你可能听说过“垃圾进,垃圾出( garbage in, garbage out)”这句话
这句话说的是软件开发领域的“出门概不退换”原则:让用户自己操心自己的事。
对已形成产品的软件言,仅仅“垃圾进,垃圾出”还不够。不管进来什么,
好的程序都不会生成垃圾,而是做到“垃圾进,什么都不出”“进来垃圾,出去
KEY POINT
是出错提示”或“不许垃圾进来”。按今天的标准来看,“垃圾进,垃圾出”已然
成为缺乏安全性的差劲程序的标志。
通常有三种方法来处理进来垃圾的情况。
检查所有来源于外部的数据的值当从文件用户、网络或其他外部接口中
获取数据时,应检查所获得的数据值,以确保它在允许的范围内。对于数值,要
确保它在可接受的取值范围内;对于字符串,要确保其不超长。如果字符串代表
的是某个特定范围内的数据(如金融交易ID或其他类似数据),那么要确认其取
值合乎用途,否则就应该拒绝接受。如果你在开发需要确保安全的应用程序,还
要格外注意那些狡猾的可能是攻击你的系统的数据,包括企图令缓冲区溢出的数
据、注入的SQL命令、注入的HTML或XML代码、整数溢出以及传递给系统调
用的数据,等等。
检查子程序所有输入参数的值检查子程序输入参数的值,事实上和检查来
源于外部的数值一样,只不过数据是来自于其他子程序而非外部接口。第8.5节
“隔离程序,使之包容由错误造成的损害”阐述了一种实用方法可用于确定哪些
子程序需要检查其输入数据。
决定如何处理错误的输入数据一旦检测到非法的参数,你该如何处理它
呢?根据情况的不同,你可以从十几种不同的方案中选择其一,在本章后面第8.3
节“错误处理技术”中会详细描述这些技术。
防御式编程是本书所介绍的其他提高软件质量技术的有益辅助手段。防御式
编码的最佳方式就是在一开始不要在代码中引入错误。使用迭代式设计、编码前
先写伪代码、写代码前先写测试用例、低层设计检查等活动,都有助于防止引入
错误。因此,要在防御式编程之前优先运用这些技术。所幸的是,你可以把防御
式编程和其他技术结合起来使用。
正如图8-1所示,防范看似微小的错误,收获可能远远超出你的想象本章
的剩余部分将介绍用于检查外部数据、检查输入参数和处理错误输入数据的许多
可选技术。
代码大全(第2版)

<==========================225end ==============================>
<==========================226start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^A.com!仅供试看^
8.2断言
189
图8-1西雅图90号州际浮桥的一部分在一场风暴中沉没了,原因是未遮盖浮箱,而在
风暴中进水,使得桥体过重而无法继续漂浮。在建设时要防范一些小事情,它
们的严重性往往会超过你的预期
8.2
Assertions
断言
断言( assertion)是指在开发期间使用的、让程序在运行时进行自检的代码(通
常是一个子程序或宏)。断言为真,则表明程序运行正常,而断言为假,则意味着
它已经在代码中发现了意料之外的错误。举例来说,如果系统假定一份客户信息
文件所含的记录数不能超过50000,那么程序中可以包含一个断定记录数小于等
于50000的断言。只要记录数小于等于50000,这一断言都会默默无语。然而一
旦记录数超过50000,它就会大声地“断言”说程序中存在一个错误。
断言对于大型的复杂程序或可靠性要求极高的程序来说尤其有用。通过使用
断言,程序员能更快速地排查出因修改代码或者别的原因,而弄进程序里的不匹
KEY POINT配的接口假定和错误等。
一个断言通常含有两个参数:一个描述假设为真时的情况的布尔表达式,和
一个断言为假时需要显示的信息。下面是假定变量 denominator(分母)的值应为
非零值时Java断言的写法:
代码大全(第2版)

<==========================226end ==============================>
<==========================227start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看^
190
第8章防御式编程
Java示例:断言
nominator=0:"denominator is unexpectedly equal to0."i
这个断言声明 denominator不会等于0。其中第一个参数, denominator
0,是个布尔表达式,其结果为true或者 false第二个参数是当第一个参数为
false时即断言为假时要打印的消息。
断言可以用于在代码中说明各种假定,澄清各种不希望的情形。可以用断言
检查如下这类假定:
输入参数或输出参数的取值处于预期的范围内;
子程序开始(或者结束)执行时文件或流是处于打开(或关闭)的状态;
■子程序开始(或者结束)执行时,文件或流的读写位置处于开头(或结尾)
处;
■文件或流已用只读、只写或可读可写方式打开;
仅用于输入的变量的值没有被子程序所修改;
指针非空;
传入子程序的数组或其他容器至少能容纳X个数据元素;
■表已初始化,存储着真实的数值;
■子程序开始(或结束)执行时,某个容器是空的(或满的);
一个经过高度优化的复杂子程序的运算结果和相对缓慢但代码清晰的子程序
的运算结果相一致。
当然,这里列出的只是一些基本假定,你在子程序中还可以包括更多可以用
断言来说明的假定。
正常情况下,你并不希望用户看到产品代码中的断言信息;断言主要是用于
开发和维护阶段。通常,断言只是在开发阶段被编译到目标代码中,而在生成产
品代码时并不编译进去。在开发阶段,断言可以帮助查清相互矛盾的假定、预料
之外的情况以及传给子程序的错误数据等。在生成产品代码时,可以不把断言编
译进目标代码里去,以免降低系统的性能。
代码大全(第2版)

<==========================227end ==============================>
<==========================228start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
8.2断言
191
Building Your Own Assertion Mechanism
建立自己的断言机制
交叉参考建立包括C++、Java和 Microsoft Visual Basic在内的很多语言都支持断言。如果
自己的断言子程你用的语言不直接支持断言语句,自己写也是很容易的。C++中标准的 assert宏并
序,是“深入一
种语言去编程”不支持文本信息。下面的例子给出了一个使用C++宏改进的 ASSERT实现
而不仅是“在一C++示例:一个实现断言的宏
的很好例子。关define ASSERT( condition, message
于二者的区别,
if(!(condition))(
请见第34.4节。
rorassertin
LogError( "Assertion failed:
#condition, message
URE
exit( EXIT_FAILURE
Guidelines for Using Assertions
使用断言的指导建议
下面是关于使用断言的一些指导性建议。
用错误处理代码来处理预期会发生的状况用断言来处理绝不应该发生的状
况断言是用来检查永远不该发生的情况,而错误处理代码(error-《rrorhandIigode)《)
是用来检查不太可能经常发生的非正常情况,这些情况是能在写代码时就预料到
的,且在产品代码中也要处理这些情况。错误处理通常用来检查有害的输入数据,
而断言是用于检查代码中的bug。
用错误处理代码来处理反常情况,程序就能够很从容地对错误做出反映。如
果在发生异常情况的时候触发了断言,那么要采取的更正的措施就不仅仅是对错
误做出恰当的反映了——而是应该修改程序的源代码并重新编译,然后发布软件
的新版本。
有种方式可以让你更好地理解断言,那就是把断言看做是可执行的注解
你不能依赖它来让代码正常工作,但与编程语言中的注释相比,它能更主动地对
程序中的假定做出说明。
避免把需要执行的代码放到断言中如果把代码写在断言里,那么当你关闭
断言功能时,编译器很可能就把这些代码除排在外了。比如说,你写了这么一个
断言:
代码大全(第2版)

<==========================228end ==============================>
<==========================229start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
192
第8章防御式编程
交叉参考你也 Visual Basic示例:一种危险的断言使用方法
可以把这个例子 Debug. Assert( PerformAction())Couldn't' perform action
看做是把多行语
句放入一行中而
引起的问题。第
这段代码的问题在于,如果未编译断言语句那么其中用于执行操作的代码
31.5节“每行只也就不会被编译。应该把需要执行的语句提取出来,并把其运算结果赋给状态变
写一个语句”中
有更多的例子。量,再对这些状态变量进行判断。下面这样使用断言就很安全:
Visual Basic示例:安全地使用断言
actionPerformed =PerformAction()
Debug. Assert( actionPerformed Couldn't perform action
推荐阅读要想
用断言来注解并验证前条件和后条件前条件( preconditions)和后条件
更深入地了解前
条件和后条件,(postconditions)是一种名为“契约式设计(design by contract)”的程序设计和开
请阅读( Object发方法的一部分( Meyer1997)。使用前条件和后条件时,每个子程序或类与程序
Oriented Soft-
ware Construc的其余部分都形成了一份契约
1997)一书。
前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为
真的属性。前条件是调用方代码对其所调用的代码要承担的义务。
后条件是子程序或类在执行结束后要确保为真的属性。后置条件是子程序或
类对调用方代码所承担的责任。
断言是用来说明前条件和后条件的有利工具。也可以用注释来说明前条件和
后条件,但断言却能动态地判断前条件和后条件是否为真。
在下面这个例子中,就使用了断言来说明 Velocity(速度)子程序的前条件和
后条件:
Visual Basic示例:使用断言来记述前条件和后条件
Private Function velocity
ByVal latitude As single,
ByVal longitude As Single,
ByVal elevation As Single
)As Single
'Preconditions
Debug. Assert(-90= latitude And latitude=90
_oaitda
Debug Assert= longitude And longitude<360
Debug. Assert-500 elevation And elevation<=75000
1译注: latitude是纬度, longitude是经度, elevation是海拔高度。
代码大全(第2版)

<==========================229end ==============================>
<==========================230start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !-www.shubu com!.com!仅供试看^
8.2断言
193
Postconditions
return
Debug. Assert 0 < returnVelocity And returnvelocity < 600
return value
Velocity returnVelocity
End Function
如果变量 latitude、 longitude和 elevation都是来源于系统外部,那么
就应该用错误处理代码来检查和处理非法的数值,而不是使用断言。而如果变量
的值是源于可信的系统内部,并且这段程序是基于这些值不会超出合法范围的假
定而设计,使用断言则是非常合适的。
交叉参考关于对于高健壮性的代码,应该先使用断言再处理错误对于每种可能出错的条
健壮性的更多内
容,请参考本章件,通常子程序要么使用断言,要么使用错误处理代码来进行处理,但是不会同
8.3节中的“健壮时使用二者。一些专家主张只须使用一处理方法即可(Meyer1997)
性与正确性”。
然而,现实世界中的程序和项目通常都很混乱,仅仅依赖断言还是不够的。
如果开发的是一个大型的、长期运行的系统,那么系统的不同部分可能会由不同
的设计人员来设计,耗时可能会超过5到1年不同设计师们将在不同的时期工
作,还跨越了多个版本。在系统开发的不同时间点,他们在设计时会关注不同的
技术。设计人员也可能在地理位置上相互分离,特别是当系统某些部分是外包给
别的公司做的时候。程序员在系统生命周期的不同时期会采用不同的编码规范。
在一个大型项目的开发团队里,有些程序员明显比其他人更谨慎,因此有的代码
部分的复查会比其他代码更严格一些。有些程序员所做的单元测试比其他人更彻
底。当测试团队分布在不同的地理位置,并且受到商业压力而导致每次发行版本
的测试覆盖范围都不尽相同时,你根本无法指望详尽的系统级别的回归测试。
在这种环境中,可能同时用断言和错误处理代码来处理同一个错误。以
Microsoft Word为例,在其代码中对应该始终为真的条件都加上了断言,但同时也
用错误处理代码处理了这些错误,以应对断言失败的情况。对于那些像Word这样
特大规模、复杂且生命周期很长的应用程序而言,断言是非常有用的,因为断言
可以帮助在开发阶段排查出尽可能多的错误。然而这样的应用程序实在太复杂了
(有着上百万行的源代码),而且都经历了多次的修改,以至于想要在软件交付之
前发现并纠正一切错误是不现实的,所以在发布的产品中错误也同样需要处理。
代码大全(第2版)

<==========================230end ==============================>
<==========================231start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
194
第8章防御式编程
下面就说明如何把这一规则应用到 Velocity例中去:
Visual Basic示例:使用断言来说明前条件和后条件
Private Function Velocity(
ByRef latitude As Single,
ByRef longitude As single,
ByRef elevation As Single
)As Single
Preconditions
这里是断言代码。Debug. Assert-90= latitude And latitude90
Debug. Assert < longitude And longitude 360
(500levation And levation>
Debug.Assert-500<= elevation And elevation<=75000)
Sanitize input data. Values should be within the ranges asserted
bove,
but if a value is not within its valid range, it will be changed to the
closest legal value
这里是在运行时f( latitude-90)Then
处理错误输入数
latitude =-90
据的代码。
ElseIf( latitude>90)hen
latitude =90
End If
If longitude 0 )Then
longitude=0
LElseIf( longitude>360)Then
8.3
Error-Handling Techniques
错误处理技术
断言可以用于处理代码中不应发生的错误。那么又该如何处理那些预料中可
能要发生的错误呢?根据所处情形的不同,你可以返回中立值( neutral value)、换
用下一个正确数据、返回与前次相同的值、换用最接近的有效值、在日志文件中
记录警告信息、返回一个错误码、调用错误处理子程序或对象、显示出错信息或
者关闭程序—或把这些技术结合起来使用。
下面就来详细说明这些可用的技术。
返回中立值有时,处理错误数据的最佳做法就是继续执行操作并简单地返
回一个没有危害的数值。比如说,数值计算可以返回0,字符串操作可以返回空
字符串,指针操作可以返回一个空指针,等等。如果视频游戏中的绘图子程序接
收到了一个错误的颜色输入,那么它可以用默认的背景色或前景色继续绘制。当
然,对于显示癌症病人光片的绘图子程序而言,最好还是不要显示某个“中立
值”。在这种情况下,关闭程序也比让它显示错误的病人数据要好。
代码大全(第2版)

<==========================231end ==============================>
<==========================232start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.co.com!仅供试看^
8.3错误处理技术
195
换用下一个正确的数据在处理数据流的时候,有时只需返回下一个正确的数据
即可。如果在读数据库记录并发现其中一条记录已经损坏时,你可以继续读下去直到
又找到一条正确记录为止。如果你以每秒100次的速度读取体温计的数据,那么如果
某一次得到的数据有误,你只需再等上1/100秒然后继续读取即可。
返回与前次相同的数据如果前面提到的体温计读取软件在某次读取中没有
获得数据,那么它可以简单地返回前一次的读取结果。根据这一应用领域的情况,
温度在1/100秒的时间内不会发生太大改变。而在视频游戏里,如果你发现要用
一种无效的颜色重绘屏幕的某个区域,那么可以简单地使用上一次绘图时使用的
颜色。但如果你正在管理自动取款机上的交易,你可能不希望用“和最后一次相
同的答案”了,因为那可是前一个用户的银行账号!
换用最接近的合法值在有些情况下,你可以选择返回最接近的那个合法值,
就像前面的 velocity例子里那样。在从已经校准的仪器上取值时,这种方法往
往是很合理的。比如说,温度计也许已经校准在0到100摄氏度之间。如果你检
测到一次小于0的读取结果,那你可以把它替换为0,即最接近的那个合法值。
如果发现结果大于100,那么你可以把它替换为100在操作字符串时,如果发现
某个字符串的长度小于0,你也可以用0代替。当我倒车时,汽车就是用这种方
法来处理错误的。因为车上的速度表无法显示负的速度,所以当我倒车时它只是
简单地显示0即最接近的合法值。
把警告信息记录到日志文件中在检测到错误数据的时候,你可以选择在日
志文件(log file)中记录一条警告信息,然后继续执行。这种方法可以同其他的
错误处理技术结合使用,比如说换用最接近的合法值、换用下一个正确的数据等。
如果你用到了日志文件,要考虑是否能够安全地公开它,或是否需要对其进行加
密或施加其他方式的保护。
返回一个错误码你可以决定只让系统的某些部分处理错误。其他部分则不
在本地(局部)处理错误,而只是简单地报告说有错误发生,并信任调用链上游
的某个子程序会处理该错误。通知系统其余部分已经发生错误可以采用下列方法
之一:
设置一个状态变量的值
用状态值作为函数的返回值
用语言内建的异常机制抛出一个异常
在这种情况下,与确定特定的错误报告机制相比,更为重要的是要决定系统里
的哪些部分应该直接处理错误,哪些部分只是报告所发生的错误。如果安全性很重
要,请确认调用方的子程序总会检查返回的错误码
代丹大全(第2版)

<==========================232end ==============================>
<==========================233start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.co!.com!仅供试看^
196
第8章防御式编程
调用错误处理子程序或对象另一种方法则是把错误处理都集中在一个全局
的错误处理子程序或对象中。这种方法的优点在于能把错误处理的职责集中到
起,从而让调试工作更为简单。而代价则是整个程序都要知道这个集中点并与之
紧密耦合。如果你想在其他系统中重用其中的某些代码,那就得把错误处理代码
一并带过去。
这种方法对代码的安全性有一个重要的影响。如果代码发生了缓冲区溢出,
那么攻击者很可能已经篡改了这一处理程序或对象的地址。这样一来,一旦在应
用程序运行期间发生缓冲区溢出,再使用这种方法就不再安全了。
当错误发生时显示出错消息这种方法可以把错误处理的开销减到最少,然
而它也可能会让用户界面中出现的信息散布到整个应用程序中。当你需要创建一
套统一协调的用户界面时,或当你想让用户界面部分与系统的其他部分清晰地分
开时,或当你想把软件本地化到另一种不同的语言时,都会面临挑战。还有,当
心不要告诉系统的潜在攻击者太多东西。攻击者有时能利用错误信息来发现如何
攻击这个系统。
用最妥当的方式在局部处理错误一些设计方案要求在局部解决所有遇到的
错误而具体使用何种错误处理方法,则留给设计和实现会遇到错误的这部分
系统的程序员来决定。
这种方法给予每个程序员很人的灵活度,但也带来显著的风险,即系统的整
体性能将无法满足对其正确性或可靠性的需求(马上还会更具体地讲这个问题)
根据开发人员最终用以处理特定错误的方法不同这样做也有可能导致与用户界
面相关的代码散布到整个系统中,从而又使程序面临那些与显示出错消息相关的
问题。
关闭程序有些系统一旦检测到错误发生就会关闭。这一方法适用于人身安
全攸关( safety-critical-)的应用程序。举例来说,如果用作控制治疗癌症病人的放
疗设备的软件接收到了错误的放射剂量输入数据,那么怎样处理这一错误最好
呢?应该使用与上一次相同的数值吗?应该用最接近的合法值吗?应该使用中立
值吗?在这种情况下,关闭程序是最佳的选择哪怕重启机器也比冒险施放错误
的放射剂量要好得多。
一种类似的做法可以用来提高 Microsoft Windows操作系统的安全性。在默认
情况下,即使系统的安全日志已经满了, Windows仍会继续运行。但你可以配置
Windows,让它在安全日志满的时候停止服务。在信息安全攸关( security-critical
的环境中这样做是明智的。
代码大全(第2版)

<==========================233end ==============================>
<==========================234start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
8.3错误处理技术
197
Robustness vs. Correctness
健壮性与正确性
正如前面视频游戏和X光机的例子告诉我们的,处理错误最恰当的方式要根
据出现错误的软件的类别而定。这两个例子还表明,错误处理方式有时更侧重于
正确性,而有时则更侧重于健壮性。开发人员倾向于非形式地使用这两个术语,
但严格来说,这两个术语在程度上是截然相反的。正确性( correctness)意味着永
不返回不准确的结果,哪怕不返回结果也比返回不准确的结果好然而,健壮性
( robustness)则意味着要不断尝试采取某些措施,以保证软件可以持续地运转下
去,哪怕有时做出一些不够准确的结果。
人身安全攸关的软件往往更倾向于正确性而非健壮性。不返回结果也比返回
错误的结果要好。放射线治疗仪就是体现这一原则的好例子。
消费类应用软件往往更注重健壮性而非正确性。通常只要返回一些结果就比
软件停止运行要强。我所用的字处理软件有时会在屏幕下方显示半行文字。如果
它检测到这一情况,难道我期望字处理软件退出吗?当然不。我知道等下次再按
Page Up或 Page Down键之后屏幕就会刷新,随后显示状态也就恢复正常了。
High-Level Design Implications of Error Processing
高层次设计对错误处理方式的影响
既然有这么多的选择,你就必须注意,应该在整个程序里采用一致的方式处
理非法的参数。对错误进行处理的方式会直接关系到软件能否满足在正确性、健
KEY POINT
壮性和其他非功能性指标方面的要求。确定一种通用的处理错误参数的方法,是
架构层次(或称高层次)的设计决策,需要在那里的某个层次上解决。
一旦确定了某种方法,就要确保始终如一地贯彻这一方法。如果你决定让
高层的代码来处理错误,而低层的代码只需简单地报告错误,那么就要确保高
层的代码真的处理了错误!有些语言允许你忽略“函数返回的是错误码”这一
事实在C++中,你无须对函数的返回值做任何处理但千万不要忽略错误
信息!检查函数的返回值。即使你认定某个函数绝对不会出错,也无论如何要去
检查一下。防御式编程全部的重点就在于防御那些你未曾预料到的错误。
这些指导建议对于系统函数和你自己写的函数都是成立的。除非你已确立了
一套不对系统调用进行错误检查的架构性指导建议,否则请在每个系统调用后检
查错误码。一旦检测到错误,就记下错误代号和它的描述信息。
代码大全(第2版)

<==========================234end ==============================>
<==========================235start==============================>

该书下载自-书部落-分享计算机经典巨著!--www !--www.shuby.com!仅供试看^
198
第8章防御式编程
8.4
Exceptions
异常
异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果
在一个子程序中遇到了预料之外的情况,但不知道该如何处理的话,它就可以抛
出一个异常,就好比是举起双手说“我不知道该怎么处理它我真希望有谁知
道该怎么办!”一样。对出错的前因后果不甚了解的代码,可以把对控制权转交给
系统中其他能更好地解释错误并采取措施的部分。
还可以用异常来清理一段代码中存在的杂乱逻辑,正如第17.3节中“用try
finally重写”一例所示。异常的基本结构是:子程序使用 throw抛出一个异常对象,
再被调用链上层其他子程序的try -catch-语句捕获。
几种流行的编程语言在实现异常机制时各有千秋。表8-1总结了其中三种语
言在这方面的主要差异:
表8-1支持几种流行的编程语言的表达式
跟异常相关的特性
C++
Java
Visual Basic
支持try- catch语句
支持
支持
支持
支持try- -catch
finally语句
不支持
支持
支持
std exception对象或
Exception
或
能抛出什么
excention派生类的或 ExceptionException
对象;对象指针;对象引用生类的对象
string或int等数据类型
派生类的对
象
如果是一个“受检
调用std:: unexpected()函异常(checked
数,该函数在默认情况下将调
exception)”则终
未捕获的异常
所造成的影响
用std:: terminate(),而这止正在执行的线终止程序执
一函数在默认情况下又将调程;如果是“运行
用 abort()
行时异常(runtime
exception)则不产
生任何影响
必须在类的接口中
定义可能会抛出的
否
是
否
异常
必须在类的接口中
定义可能会捕获的
否
是
否
异常
代码大全(第2版)

<==========================235end ==============================>
<==========================236start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo.c.com!仅供试看
8.4异常
199
把异常当做正常
异常和继承有一点是相同的,即:审慎明智地使用时,它们都可以降低复杂
处理逻辑的一部
分的那种程序,度;而草率粗心地使用时,只会让代码变得几乎无法理解。下面给出的一些建议
都会遭受与所有可以让你在使用异常时扬长避短,并避免与之相关的一些难题。
典型的意大利面
条式代码同样的
用异常通知程序的其他部分,发生了不可忽略的错误异常机制的优越之处
可读性和可维护
性问题。
在于它能提供一种无法被忽略的错误通知机制(Meyers1996)。其他的错误处理
Andy Hunt和机制有可能会导致错误在不知不觉中向外扩散,而异常则消除了这种可能性。
Dave Thomas
只在真正例外的情况下才抛出异常仅在真正例外的情况下才使用异常一
换句话说,就是仅在其他编码实践方法无法解决的情况下才使用异常。异常的应
用情形跟断言相似都是用来处理那些不仅罕见甚至永远不该发生的情况。
异常需要你做出一个取舍:一方面它是一种强大的用来处理预料之外的情况
的途径,另一方面程序的复杂度会因此增加。由于调用子程序的代码需要了解被
调用代码中可能会抛出的异常,因此异常弱化了封装性。同时,代码的复杂度也
有所增加,这与在第5章“软件构建中的设计”中提出的软件首要技术使命
管理复杂度是背道而驰的。
不能用异常来推卸责任如果某种的错误情况可以在局部处理,那就应该在
局部处理掉它。不要把本来可以在局部处理掉的错误当成一个未被捕获的异常抛
出去。
避免在构造函数和析构函数中抛出异常,除非你在同一地方把它们捕获当
从构造函数和析构函数里抛出异常时,处理异常的规则马上就会变得非常复杂
比如说在C++里,只有在对象已完全构造之后才可能调用析构函数,也就是说,
如果在构造函数的代码中抛出异常,就不会调用析构函数,从而造成潜在的资源
泄漏(Meyers1996, Stroustrup1 1997)。在析构函数中抛出异常也有类似复杂的规
则。
语言律师可能会认为记忆这些规则是小事一桩,但智力平凡的程序员很难记
住这些规则。所以,应该养成好编程习惯,不要一上来就写这类代码,从而轻松
地避免由此产生的额外的复杂度。
交叉参考关
于维护一致的
在恰当的抽象层次抛出异常子程序应在其接口中展现出一致的抽象,类也
接口抽象的详是如此。抛出的异常也是程序接口的一部分和其他具体的数据类型一样
情,请参见第
6.2节中的“好
的抽象”
代大全(第2版)

<==========================236end ==============================>
<==========================237start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
200
第8章防御式编程
当你决定把一个异常传给调用方时,请确保异常的抽象层次与子程序接口的
抽象层次是一致的。这个例子说明了应该避免什么样的做法:
ava反例:抛出抽象层次不一致的异常的类
class Employee
DING
HORRO
ROR
此处声明的异常→ public TaxId GetTaxid) throws EOFException
位于不一致的抽
象层次。
GetTaxId()把更低层的 EOFException(件结束, end of file)异常返回给
了它的调用方。它本身并不拥有这一异常,但却通过把更低层的异常传递给其
调用方,暴露了自身的一些实现细节。这就使得子程序的调用方代码不是与
Employee类的代码耦合,而是与比 Employee类层次更低的抛出 EOFException
异常的代码耦合起来了。这样做既破坏了封装性,也减低了代码的智力上的可
管理性(intellectual manageability)
与之相反, Get Taxid()代码应抛回一个与其所在类的接口相一致的异常,就
像下面这样:
Java示例:一个在一致的抽象层次上抛出异常的类
class Employee
这里声明的异常 ublic raxta cetraxta
public Taxid GetTaxId() throws EmployeeDataNotAvailable
象层次。
GetTaxid)里的异常处理代码可能只需要把一个o_disk_not_ready(磁盘
IO未就绪)异常映射为 EmployeeDataNotAvailable(雇员数据不可用)异常就
好了,因为这样一来就能充分地保持接口的抽象性。
在异常消息中加入关于导致异常发生的全部信息每个异常都是发生在代码
抛出异常时所遇到的特殊情况下。这一信息对于读取异常消息的人们来说是很有
价值的,因此要确保该消息中含有为理解异常抛出原因所需的信息。如果异常是
代码大全(第2版)

<==========================237end ==============================>
<==========================238start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww ! --www.shubulo.c!.com!仅供试看^
8.4异常
201
因为一个数组下标错误而抛出的,就应在异常消息中包含数组的上界、下界以及
非法的下标值等信息。
避免使用空的 catch语句有时你可能会试图敷衍一个不知该如何处理的异
常,比如这个例子:
java示例:忽略异常的错误做法
try
1/很多代码
catch( AnException exception)
这种做法就意味着:要么是try里的代码不对因为它无故抛出了一个异常;
要么是 catch里的代码不对,因为它没能处理一个有效的异常。确定一下错误产
生的根源,然后修改try或 catch二者其一的代码。
偶尔你也可能会遇到某个较低层次上的异常,它确实无法表现为调用方抽象
层次上的异常。如果确实如此,至少需要写清楚为什么采用空的 catch语句是可
行的。你也可以用注释或向日志文件中记录信息来对这一情况进行“文档化”,就
像下面这样:
ava例:忽略异常的正确做法
try
11 lots of code
catch AnException exception
LogError("Unexpected exception");
了解所用函数库可能抛出的异常如果你所用的编程语言不要求子程序或类
定义它可能抛出的异常,那你一定要了解所用的函数库都会抛出哪些异常。未能
捕获由函数库抛出的异常将会导致程序崩溃,就如同未能捕获由自己代码抛出的
异常一样。如果函数库没有说明它可能抛出哪些异常,可以通过编写一些原型代
码来演练该函数库,找出可能发生的异常。
考虑创建一个集中的异常报告机制有种方法可以确保异常处理的一致性,
即创建一个集中的异常报告机制。这个集中报告机制能够为一些与异常有关的信
息提供一个集中的存储,如所发生的异常种类、每个异常该被如何处理以及如何
格式化异常消息等。
代码大全(第2版)

<==========================238end ==============================>
<==========================239start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo...com!仅供试看^
202
第8章防御式编程
下面就是一个简单的异常处理器,它只是简单地打印出诊断信息:
深入阅读关于 Visual Basic示例:集中的异常报告机制(第一部分)
这一技术更详细 Sub ReportException(
的阐述,请参见
ByVal className,
(Practical Stand-
ards for Microsoft
Byval thisException As Exception
Visual Basic.NET)
(Foxall2 2003)
Dim message As String
Dim caption As String
message
ion:& thisException. Messagen.& ControlChars.crlf&
Class:& className& ControlChars.crlf&
n.nch+
"Routine:"& thisException. Targetsite.name& ControlChars.crlf
caption ="Exception"
MessageBox. Show message, caption MessageBoxButtons.OK,
MessageBoxIcon. Exclamation)
End Sub
你可以像这样在代码中使用这个通用的异常处理器:
Visual Basic示例:集中的异常报告机制(第二部分)
Try
Catch exceptionobject As Exception
ReportException( CLASS_name, exceptionobject)
End Try
这个版本的 Report Exception()代码非常简单。而在实际的应用程序中,你
可以根据异常处理的需要开发或简或繁的代码。
如果确定要创建一个集中的异常报告机制请一定要考虑第8.3节中“调用
错误处理子程序或对象”所讲到的和集中错误处理相关的事宜。
把项目中对异常的使用标准化为了保持异常处理尽可能便于管理,你可以
用以下几种途径把对异常的使用标准化。
如果你在用一种像C++一样的语言,其中允许抛出多种多样的对象、数据及
指针的话,那么就应该为到底可以抛出哪些种类的异常建立一个标准。为了
与其他语言相兼容,可以考虑只抛出从std:: exception基类派生出的对象。
代码大全(第2版)

<==========================239end ==============================>
<==========================240start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
8.5隔离程序,使之包容由错误造成的损害
203
考虑创建项目的特定异常类,它可用做项目中所有可能抛出的异常的基类。
这样就能把记录日志、报告错误等操作集中起来并标准化。
规定在何种场合允许代码使用 throw-catch-语句在局部对错误进行处理。
规定在何种场合允许代码抛出不在局部进行处理的异常。
确定是否要使用集中的异常报告机制。
规定是否允许在构造函数和析构函数中使用异常。
交叉参考关于
考虑异常的替换方案一些编程语言对异常的支持已有5~10年甚至更久的
可选方案,请参历史了,但关于如何才能安全使用异常的传统与经验仍然很少。
阅本章前面第
8.3节“错误处理
有些程序员用异常来处理错误,只是因为他所用的编程语言提供了这种特殊
技术”
的错误处理机制。你心里应该自始至终考虑各种各样的错误处理机制:在局部处
理错误、使用错误码来传递错误、在日志文件中记录调试信息、关闭系统或其他
的一些方式等。仅仅因为编程语言提供了异常处理机制而使用异常,是典型的“
用而用”;这也是典型的“在一种语言上编程”而非“深入一种语言去编程”的例
子。(有关这两者的区别,请参阅第4.3节“你在技术浪潮中的位置”和第34.4节
“以所用语言编程,但思路不受其约束”)
最后,请考虑你的程序是否真的需要处理异常就 Bjarne像 Stroustrup所指出
的,应对程序运行时发生的严重错误的最佳做法,有时就是释放所有已获得的资
源并终止程序执行,而让用户去重新用正确的输入数据再次运行程序(《Surostrup《
1997)。
8.5
Barricade Your Program to Contain the Damage
Caused by Errors
隔离程序,使之包容由错误造成的损害
隔栏(barricade)是一种容损策略(damage-containment- strategy)这与船体
外壳上装备隔离舱的原因是类似的。如果船只与冰山相撞导致船体破裂的话,隔
离舱就被封闭起来,从而保证船体的其余部位不会受到影响。这也与建筑物里的
防火墙很相像。在发生火灾时,建筑物里的防火墙能阻止火势从建筑物的一个部
位向其他部位蔓延。(隔栏过去叫“防火墙,但现在“防火墙”这一术语常用来
指代阻止恶意网络攻击的设备。)
以防御式编程为目的而进行隔离的一种方法,是把某些接口选定为“安全”
区域的边界。对穿越安全区域边界的数据进行合法性校验,并当数据非法时做
代码大全(第2版)

<==========================240end ==============================>
<==========================241start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. !--www.shubu.com!仅供试看^
204
第8章防御式编程
出敏锐的反映。图8-2展示了这一概念。
图形用户界面
内部类1内部类2
数据
内部类3内部类4
命令行界面
验证类1
内部类5内部类6
实时数据采集数据
验证类2
内部类7内部类8
外部文件
数据
验证类n
内部类9内部类10
其他外部对象
内部类1内部类n
假定此处的数据是
这些类要负责清理数据。
这些类可以假定数据
肮脏且不可信的
它们构成了隔栏
都是干净且可信的
图8-2让软件的某些部分处理“不干净的”数据,而让另一些部分处理“干净的”数
据,即可让大部分代码无须再担负检查错误数据的职责
也同样可以在类的层次采用这种方法。类的公用方法可以假设数据是不安全
的,它们要负责检查数据并进行清理。一旦类的公用方法接受了数据,那么类的
私用方法就可以假定数据都是安全的了。
也可以把这种方法看做是手术室里使用的一种术。任何东西在允许进入手
术室之前都要经过消毒处理。因此手术室内的任何东西都可以认为是安全的。这
其中最核心的设计决策是规定什么可以进入手术室,什么不可以进入,还有把手
术室的门设在哪里在编程中也就是规定,哪些子程序可认为是在安全区域里
的,哪些又是在安全区域外的,哪些负责清理数据完成这一工作最简单的方法
是在得到外部数据时立即进行清理,不过数据往往需要经过一层以上的清理,因
此多层清理有时也是必需的。
在输入数据时将其转换为恰当的类型输入的数据通常都是字符串或数字的
形式。这些数据有时要被映射为“是”或“否”这样的布尔类型,有时要被映射
为像 Color_red、 Color_ Green和 Color_Blue这样的枚举类型。在程序中长时
间传递类型不明的数据,会增加程序的复杂度和崩溃的可能性比如说有人在
需要输入颜色枚举值的地方输入了“是”。因此,应该在输入数据后立即将其转换
到恰当的类型。
代码大全(第2版)

<==========================241end ==============================>
<==========================242start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看
8.6辅助调试的代码
205
Relationship Between Barricades and Assertions
隔栏与断言的关系
隔栏的使用使断言和错误处理有了清晰的区分隔栏外部的程序应使用错误
处理技术,在那里对数据做的任何假定都是不安全的。而隔栏内部的程序里就应
使用断言技术,因为传进来的数据应该已在通过隔栏时被清理过了。如果隔栏内
部的某个子程序检测到了错误的数据,那么这应该是程序里的错误而不是数据里
的错误。
隔栏的使用还展示了“在架构层次上规定应该如何处理错误”的价值。规定
隔栏内外的代码是一个架构层次上的决策。
8.6
Debugging Aids
辅助调试的代码
防御式编程的另一重要方面是使用调试助手(辅助调试的代码),调试助手非
常强大,可以帮助快速地检测错误。
Don't Automatically Apply Production Constraints to the
Development Version
不要自动地把产品版的限制强加于开发版之上
课入阅读关于
程序员们常常有这样一个误区,即认为产品级软件的种种限制也适用于开发
使用调试代码来中的软件。产品级的软件要求能够快速地运行,而开发中的软件则允许运行缓慢
的更多内容,请产品级的软件要节约使用资源,而开发中的软件在使用资源时可以比较奢侈产
参阅 Writing品级的软件不应向用户暴露可能引起危险的操作,而开发中的软件则可以提供
Solid Code
(《Magure199《)些额外的、没有安全网的操作。
我曾参与编写的一个程序中大量地使用了四重链表( quadruply linked list)
链表的代码是很容易出错的,链表本身的结构很容易损坏。因此我给程序加了一
个菜单项来检测链表的完整性。
在调试模式下, Microsoft Word在空闲循环中加入了一些代码,它们每隔几秒
钟就检查一次 Document对象的完整性。这样既有助于快速检测到数据的损坏,也
方便了对错误的诊断。
应该在开发期间牺牲一些速度和对资源的使用来换取些可以让开发更顺
畅的内置工具。
KEY POINT
代码大全(第2版)

<==========================242end ==============================>
<==========================243start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con!.com!仅供试看^
206
第8章防御式编程
Introduce Debugging Aids Early
尽早引入辅助调试的代码
你越早引入辅助调试的代码,它能够提供的帮助也越大。通常,除非被某个
错误反复地纠缠,否则你是不愿意花精力去编写一些调试辅助的代码的。然而,
如果你一遇到问题马上就编写或使用前一个项目中用过的某个调试助手的话,它
就会自始至终在整个项目中帮助你。
Use Offensive Programming
采用进攻式编程
交叉参考关于
应该以这么一种方式来处理异常情况:在开发阶段让它显现出来,而在产品
处理异常情况的代码运行时让它能够自我恢复 Michael Howard和 David LeB lanc把这种方式称为
更多细节,请参
考第15.2节中的“进攻式编程(offensive programming)"(Howard and LeBlanc2003)
“使用case语
句的诀窍”。
假设你有一段case语句,期望用它处理5类事件在开发期间,应该让针对
默认情况的case分支(即 default case子句)显示警告信息说:“嗨!这儿还有一
种没有处理的情况!改程序吧!”然而,在最终的产品代码里,针对默认情况的处
理则应更稳妥一些,比如说可以在错误日志文件中记录该消息。
通常情况下死程下面列出一些可以让你进行进攻式编程的方法。
序所造成的损失
要比残废的程序
■确保断言语句使程序终止运行。不要让程序员养成坏习惯,一碰到已知问
少得多
题就按回车键把它跳过。让问题引起的麻烦越大越好,这样它才能被修复。
Andy Hunt和
Dave Thomas
完全填充分配到的所有内存,这样可以让你检测到内存分配错误。
完全填充已分配到的所有文件或流,这样可以让你排查出文件格式错误。
确保每一个case语句中的 default分支或else分支都能产生严重错误(比
如说让程序终止运行),或者至少让这些错误不会被忽视。
■在删除个对象之前把它填满垃圾数据。
让程序把它的错误日志文件用电子邮件发给你,这样你就能了解到在已发
布的软件中还发生了哪些错误如果这对于你所开发的软件适用的话。
有时候,最好的防守正是大胆进攻。在开发时惨痛地失败,能让你在发布产
品后不会败得太惨。
Plan to Remove Debugging Aids
计划移除调试辅助的代码
如果你是写程序给自己用,那么把调试用的代码都留在程序里可能并无大碍
但如果是商用软件,则此举会使软件的体积变大速度变慢,从而给程序造成巨
大的性能影响。要事先做好计划,避免调试用的代码和程序代码纠缠不清。下面
是一些可以采用的方法。
代码大全(第2版)

<==========================243end ==============================>
<==========================244start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
8.6辅助调试的代码
207
交叉参考关于
使用类似ant和make这样的版本控制工具和mae工具版本控制工具可以
版本控制的详细
情况,请参考第
从同一套源码编译出不同版本的程序。在开发模式下,你可以让mak工具把所有
28.2节“配置管的调试代码都包含进来一起编译。而在产品模式下,又可以让make工具把那些你
理。
不希望包含在商用版本中的调试代码排除在外。
使用内置的预处理器如果你所用的编程环境里有一个预处理器比如
C++开发环境你可以用编译器开关来包含或排除调试用的代码。你既可以直
接使用预处理器,也可以写一个能与预处理器指令同时使用的宏。下面是一个直
接使用预处理器编写代码的例子:
要想在编译时包C++示例:直接使用预处理器来控制调试用的代码
含调试用的代码,#define DEBUG
使用#define来定
义 XDEBUG符号。#if defined( DEBUG)
要想将其排除在/ debugging code
外,则不要定义
DEBUG符号。
#endif
这一用法可以有几种变化。比如说,除了可以直接定义 DEBUG以外,你还可
以给它赋一个值,然后就可以判断其数值,而不仅是去判断它是否已经定义了。
这么做可以让你区分不同级别的调试代码。你可能希望让某些调试代码永远留在
程序里,这时就可以用类似#if DEBUG>0这样的语句把这些代码括起来。另一
些调试代码可能只是针对一些特定的用途,你可以用类似#if DEBUG=
POINTERERRORR这样的语句把这些代码括起来。在另外一些地方,你可能想设
置调试级别,这时就可以写类似#if DEBUG> LEVEL这样的语句
如果你不喜欢让#if defined()一类语句散布在代码里的各处,那么可以写
一个预处理器宏来完成同样的任务。这里是一个例子:
C++示例:使用预处理器宏来控制调试用的代码
使用
#define DEBUG
#if defined( DEBUG fragmentcode_fragment
#define DebugCode( code
#else
#define DebugCode( code_fragment
#endif
根据是否定义 DebugCode(
DEBUG符号,可 statement1
选择是否编译此 statement2
处的代码。
statement n;
代码大全(第2版)

<==========================244end ==============================>
<==========================245start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看^
208
第8章防御式编程
和前面第一个使用预处理器的例子一样,这种方法在使用时也可以有多种变
化,这使得它能够处理更复杂的情况,而不仅仅是要么包含所有调试代码、要么
排除全部调试代码这么简单。
交叉参考关于编写你自己的预处理器如果某种语言没有包含一个预处理器,你也可以很
预处理器和自行容易自己写一个,用于包含或排除调试代码。首先确立一套声明调试代码的规则,
编写预处理器的
更多信息,请参考然后就遵循这个规则编写一个预编译器。例如,在Java里你可以写一个预编译器
第30.3节中的来处理#BEGIN DEBUG和#END DEBUG关键字写一个脚本来调用该预处理
器,然后再编译经过处理之后的代码。从长远看,这样做会为你节省时间,而且
也可以避免“不慎编译了未经过预处理的代码”的情况。
交叉参考关于使用调试存根( debuging stubs)很多情况下,你可以调用一段子程序进行
stub的详情,请调试检查。在开发阶段,该子程序可能要执行若干操作之后才能把控制权交还给
参阅第22.5节中
的“为测试各个子其调用方代码。而在产品代码里你可以用一个存根子程序(stub routine)来替
程序构造脚手换这个复杂的子程序,而这段stu子程序要么立即把控制权交还调用方,要么是
执行几项快速的操作就返回。这种方法仅会带来很小的性能损耗,并且比自己编
写预处理器要快一些。把开发版本和产品版本的stub子程序都保留起来,以便将
来可以随时在两者之间来回切换。
你可以先写一个检查传入的指针是否有效的子程序:
c++示例:一段使用调试stub的子程序
void DoSomething(
SOME_TYPE *pointer;
)
check parameters passed in
这行代码将调
CheckPointer pointer
用检查指针的
子程序。
在开发阶段, CheckPointer()子程序会对传入指针进行全面检查。这一检
测可能相当耗时,但一定要非常有效,比如说这样:
C++示例:在开发阶段检查指针的子程序
这个子程序检查 void CheckPointer( voidpointer)(
任何传入的指针执行第1项检查—可能是检查它不为NULL的
在开发阶段,可用
/执行第2项检
可能是检查它的地址是合法的
它来执行你能想
1/执行第3项检查—可能是检查它所指向的数据完好无损
到的任意多项的
检查。
/执行第n项检查
代码大全(第2版)

<==========================245end ==============================>
<==========================246start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com仅供试看^
8.7确定在产品代码中该保留多少防御式代码
209
当代码准备妥当,即将要编译为产品时,你可能不希望这项指针检查影响性
能。这时你就可以用这下面个子程序来代替前面的那段代码:
这个子程序仅是C++示例:在产品代码中检查指针的子程序
立即返回调用。 void Checkpointer( voidpointer
1/ no code; just return to caller
就计划移除调试代码而言,这里列出的方法还算不上完整,但它们应该已经
为你提供足够多的想法,并让你了解到该如何因地制宜地使用这些方法了。
Determining How Much Defensive Programming
8.7
to Leave in Production Code
确定在产品代码中该保留多少防御式代码
防御式编程中存在这么一种矛盾的观念,即在开发阶段你希望错误能引人注
意——你宁愿看它的脸色,也不想冒险地去忽视它。但在产品发布阶段,你却想
让错误能尽可能地偃旗息鼓,让程序能十分稳妥地恢复或停止。下面就给出一些
指导建议,帮助你来决定哪些防御式编程工具可以留在产品代码里,而哪些应该
排除在外。
保留那些检查重要错误的代码你需要确定程序的哪些部分可以承担未检测
出错误而造成的后果,而哪些部分不能承担比如说你在开发一个电子表格程序,
如果是在屏幕刷新部分的代码中存在未检测出的错误,你可能可以忍受,因为错
误造成的主要后果无非是把屏幕搞乱。但如果是在计算引擎部分的代码中存在问
题的话,你就无法接受了,因为这种错误可以导致用户的电子表格中出现难以察
觉的错误结果。对于大多数用户来说,他们宁愿忍受屏幕乱作一团,也不愿意因
为算错税额而被国税局审计。
去掉检查细微错误的代码如果一个错误带来的影响确实微乎其微的话,可
以把检查它的代码去掉。在前面的例子中,你可以把检查电子表格屏幕刷新的代
码去掉。这里的“去掉”并不是指永久地删除代码,而是指利用版本控制、预编
译器开关或其他技术手段来编译不包含这段特定代码的程序。如果程序所占的空
间不是问题,你也可以把错误检查代码保留下来,但应该让它不动声色地把错误
信息记录在日志文件里。
去掉可以导致程序硬性崩溃的代码正如我所说的,当你的程序在开发阶段
检测到了错误,你肯定想让它尽可能地引人注意,以便能修复它。实现这一目的
的最好方法通常就是让程序在检测到错误后打印出一份调试信息,然后崩溃退出。
这种方法甚至对于细微的错误也很有用。
代码大全(第2版)

<==========================246end ==============================>
<==========================247start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看^
210
第8章防御式编程
然而在生成产品的时候,软件的用户需要在程序崩溃之前有机会保存他们的
工作成果,为了让程序给他们留出足够的保存时间,用户甚至会忍受程序表现出
的一些怪异行为。相反,如果程序中的些代码导致了用户工作成果的丢失,那
么无论这些代码对帮助调试程序并最终改善程序质量有多大的贡献,用户也不会
心存感激的。因此,如果你的程序里存在着可能导致数据丢失的调试代码,一定
要把它们从最终软件产品中去掉。
保留可以让程序稳妥地崩溃的代码如果你的程序里有能够检测出潜在严重
错误的调试代码,那么应该保留那些能让程序稳妥地崩溃的代码。以火星探路者
号( Mars Pathfinder)为例,它的工程师有意地在其中保留了一些调试代码。在火
星探路者号着陆之后便发生了一个故障。喷气推进实验室(JPL)的工程师们得以
利用保留下来的辅助调试的代码诊断出问题所在,并把修复后的代码上传给火星
探路者号,从而使得火星探路者号圆满地完成了任务( March1999)
为你的技术支持人员记录错误信息可以考虑在产品代码中保留辅助调试用
的代码,但要改变它们的工作方式,以与最终产品软件相适应。如果你开发时
在代码里大量地使用了断言来中止程序的执行那么在发布产品时你可以考虑把
断言子程序改为向日志文件中记录信息,而不是彻底去掉这些代码。
确认留在代码中的错误消息是友好的如果你在程序中留下了内部错误消
息,请确认这些消息的用语对用户而言是友好的有一次,一个使用我早先编写
的程序的用户打电话跟我说,她得到了这样一条消息:“出现指针分配错误,Dog
Breath!”幸亏她还算有幽默感。有一种常用而且有效的方法,就是通知用户说发
生了“内部错误”,再留下可供报告该错误的电子邮件地址或电话号码即可。
8.8
Being Defensive About Defensive Programming
对防御式编程采取防御的姿态
什么东西太多了
过度的防御式编程也会引起问题。如果你在每一个能想到的地方用每一种能
都不是好事想到的方法检查从参数传入的数据,那么你的程序将会变得臃肿而缓慢更糟糕
威士忌酒除外。
Mark Twain的是,防御式编程引入的额外代码增加了软件的复杂度。防御式编程引入的代码
马克·吐温
也并非不会有缺陷,和其他代码一样,你同样能轻而易举地在防御式编程添加的
代码中找到错误尤其是当你随手编写这些代码时更是如此。因此,要考虑好
什么地方你需要进行防御,然后因地制宜地调整你进行防御式编程的优先级。
代码大全(第2版)

<==========================247end ==============================>
<==========================248start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
8.8对防御式编程采取防御的姿态
211
CHECKLIST: Defensive Programming
cc核对表:防御式编程
般事宜
口子程序是否保护自己免遭有害输入数据的破坏?
口你用断言来说明编程假定吗?其中包括了前条件和后条件吗?
口断言是否只是用来说明从不应该发生的情况?
口你是否在架构或高层设计中规定了一组特定的错误处理技术?
口你是否在架构或高层设计中规定了是让错误处理更倾向于健壮性还是
正确性?
口你是否建立了隔栏来遏制错误可能造成的破坏?是否减少了其他需要
关注错误处理的代码的数量?
口代码中用到辅助调试的代码了吗?
口如果需要启用或禁用添加的辅助助手的话,是否无须大动干戈?
口在防御式编程时引入的代码量是否适宜既不过多,也不过少?
口你在开发阶段是否采用了进攻式编程来使错误难以被忽视?
异常
口你在项目中定义了一套标准化的异常处理方案吗?
口是否考虑过异常之外的其他替代方案?
口如果可能的话,是否在局部处理了错误而不是把它当成一个异常抛到外
部?
口代码中是否避免了在构造函数和析构函数中抛出异常?
口所有的异常是否都与抛出它们的子程序处于同一抽象层次上?
口每个异常是否都包含了关于异常发生的所有背景信息?
口代码中是否没有使用空的 catch语句?(或者如果使用空的 catch语句确
实很合适,那么明确说明了吗?
代大全(第2版)

<==========================248end ==============================>
<==========================249start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com!^ ^.com!仅供试看
212
第8章防御式编程
安全事宜
口检查有害输入数据的代码是否也检查了故意的缓冲区溢出、SQL注入、
HTML注入、整数溢出以及其他恶意输入数据?
口是否检查了所有的错误返回码?
是否捕获了所有的异常?
口出错消息中是否避免出现有助于攻击者攻入系统所需的信息?
Additional Resources
更多资源
cc2e.com/0875请参阅下列有关防御式编程的资源:
Security
安全
Howard, Michael, and David LeBlanc. Writing Secure Code, 2d Ed. Redmond,
wA: Microsoft Press,2003. Howard和 LeBlanc在本书中涵盖了关于信任输入的安
全隐患。这本书让人大开眼界,它展现了到底有多少种方法能够攻破一个程序
其中一些与软件构建技术相关,而更多的则与之无关本书跨越了从需求分析、
设计、编码到测试的全部内容。
Assertions
断言
Maguire, Steve. Writing Solid Code ) Redmond, WA: Microsoft Press, 1993.
书中的第2章十分精彩地讨论了断言的使用,并列举了一些知名 Microsoft产品中
使用断言的有趣示例。
Stroustrup, Bjarne. The C++ Programming Language), 3d Ed. Reading, M
Addison Wesley,197第24.3.7.2节描述了在C++中实现断言的若干变化,包括断
言与前条件和后条件之间的关系。
Meyer, Bertrand. Object-Oriented Software Construction, 2d Ed. New York:
Prentice Hall PTR,1997这本书中有关于前条件和后条件的权威论述
Exceptions
异常
Meyer, Bertrand. Object-Oriented Software Construction), 2d Ed.New York:
Prentice Hall PTR,1997.本书第12章中有关于异常处理方法的详细讨论。
代码大全(第2版)

<==========================249end ==============================>
<==========================250start==============================>

该书下载自-书部落分享计算机经典巨著--www ! --www.shubu.com!仅供试看^
要点
213
Stroustrup, Bjarne. The C++ Programming Language), 3d Ed. Reading, Mass.:
Addison Wesley,1997.书中第14章有关于在C++中处理异常的详尽阐述。其中的
14.11小节还针对在C++中处理异常总结出了21项精彩的诀窍。
Meyers, Scott. (More Fffective C++: 35 New Ways to Improve Your Programs and
Designs》. Reading,mass: Addison Wesley.1996.书中第9-15项描述了在C+中进
行异常处理的若干细节问题。
Arnold, Ken, James Gosling, and David Holmes. The Java Programming
Language》,3ded. Boston,mass: Addison Wesley,2000.书中第8章探讨了在Java
中进行异常处理的问题。
Bloch, Joshua. Effective Java Programming Language Guide). Boston, Mass.:
Addison Wesley,2001.书中的第39~47页描述了java中异常处理的各种细节问题。
Foxall, James. (Practical Standards for Microsoft Visual Basic. NET). Redmond,
w: Microsoft Press,2003.本书第10章讲述了在 Visual Basic中的异常处理。
Key Points
要点
最终产品代码中对错误的处理方式要比“垃圾进,垃圾出”复杂得多。
防御式编程技术可以让错误更容易发现、更容易修改,并减少错误对产
品代码的破坏。
断言可以帮助人尽早发现错误,尤其是在大型系统和高可靠性的系统中,
以及快速变化的代码中。
关于如何处理错误输入的决策是一项关键的错误处理决策,也是一项关
键的高层设计决策。
异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使
用异常,它可以成为程序员们知识工具箱中的一项有益补充,同时也应
该在异常和其他错误处理手段之间进行权衡比较。
针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在
开发中添加有助于史快地排查错误的代码。
代码大全(第2版)

<==========================250end ==============================>
<==========================251start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^

<==========================251end ==============================>
<==========================252start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !-www.shubulo. com! ^.com!仅供试看^
The Pseudocode
Programming Process
第
章
伪代码编程过程
cce.com/093内容
9.1创建类和子程序的步骤概述:第216页
9.2伪代码:第218页
9.3通过伪代码编程过程创建子程序:第220页
9.4伪代码编程过程的替代方案:第232页
相关章节
创建高质量的类:第6章
高质量子程序的特征:第7章
软件构建中的设计:第5章
■注释风格:第32章
尽管可以认为本书是一本详尽描述创建类和子程序的编程过程的书,但这一
章将详细论述其中的具体步骤。本章将从微观上关注编程过程也就是关注创
建单独的类及其子程序的特定步骤,这些步骤对任何规模的项目来说都十分关键。
本章还将讲述伪代码编程过程(Pseudocode Programming Process,p),这种编
程过程有助于减少设计和编写文档所需的工作量,同时提高这两项工作的质量。
如果你是一名专家级程序员,那你也可以跳过这一章,不过建议你看一看本
章关于这些步骤的总结,并重温一下9.3节中关于使用伪代码编程过程创建子程
序的秘诀。伪代码编程过程的价值重大,却很少有程序员真正挖掘出该过程的全
部能量。
伪代码编程过程并不是创建类和程序的唯一过程。本章末尾的第9.4节中还
要介绍其他一些最流行的方法,包括测试先行开发(test- -first development)和契
约式设计(design by contract)等。
代码大全(第2版)

<==========================252end ==============================>
<==========================253start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
216
第9章伪代码编程过程
Summary of Steps in Building Classes and Routines
创建类和子程序的步骤概述
创建一个类可以有多种不同的方式,但一般而言这都是一个迭代过程,先对
一个类做总体设计,列出这个类内部的特定子程序,创建这些子程序,然后从整
体上复查这个类的构建结果。如图9-1所示,创建一个类也能变成杂乱无章的过
程,其原因与设计也同样杂乱无章同出一辙(这些原因在第5.1节“设计中的挑
战”中已经讲过)。
开始
创建类的总体设计
复审并测试整个类
创建类中的子程序
完成
图9-1一个类的创建过程可以千变万化,但基本上会以本图所示的顺序发生
Steps in Creating a Class
创建一个类的步骤
创建一个类的关键步骤如下:
创建类的总体设计设计一个类的过程中包含一些特有的设计任务定义
类的特定职责,定义类所要隐藏的“秘密”,以及精确地定义类的接口所代表的抽
象概念;决定这个类是否要从其他类派生而来以及是否允许其他类再从它派生:
指出这个类中关键的公用方法,标识并设计出类所需用到的重要数据成员。上述
这些设计任务可能需要反复迭代多次,直到能直截了当地设计出子程序为止。有
关的考虑和许多其他事项在第6章“可以工作的类”已有详细的讨论。
代码大全(第2版)

<==========================253end ==============================>
<==========================254start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看
9.1创建类和子程序的步骤概述
217
创建类中的子程序你在前述第一个步骤标识出类的主要子程序之后,还
需要创建这些子程序。在编写各个程序时通常还会引出更多的或重要、或次要的
子程序,创建这些新加入的子程序的过程往往还会反过来波及类的总体设计。
复审并测试整个类通常情况下,子程序在创建的同时也经过了测试。在整
个类可以工作之后,应该再对其整体进行复查和测试,以便发现那些在子程序的
独立测试层次上无法测出的问题。
Steps in Building a Routine
创建子程序的步骤
一个类的大部分子程序的实现都是简单的、直截了当的,例如成员访问子程
序(accessor routine,转发到其他对象的(pass-throughs)子程序等。另一些子程
序的实现可能更复杂,因此采用一种系统化的方法将更益于创建这些子程序。在
创建子程序的过程中涉及到的主要活动一也就是设计程序、检查设计、编写
子程序的代码、检查代码通常会以图9-2所示的顺序进行。
开始
设计子程序
检查设计
必要的话加以重复
复审井测试代码
编写子程序的代码
完成
图9-2这些是创建一个子程序所需经历的主要活动,常是以图示的顺序进行
专家们已经开发出很多创建子程序的方法,而我最喜欢的则是伪代码编程过
程。下一节就来介绍这个过程。
代丹大全(第2版)

<==========================254end ==============================>
<==========================255start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww ! --www.shubu.com!仅供试看^
218
第9章伪代码编程过程
9.2
Pseudocode for Pros
伪代码
“伪代码”这个术语是指某种用来描述算法、子程序、类或完整程序的工作
逻辑的、非形式的、类似于英语的记法。伪代码编程过程则是一种通过书写伪代
码而更高效地创建程序代码的专门方法。
由于伪代码看起来很像英语,你可能会很自然地认为,任何可以用来收集想法的
类似英语的描述,能起的作用都是大同小异的而实践中你则会发现,某些形式的伪
代码要比其他形式的更有用。下面是一些有效使用伪代码的指导原则。
■用类似英语的语句来精确描述特定的操作。
避免使用目标编程语言中的语法元素。伪代码能让你在一个比代码本身略高
的层次上进行设计。当用编程语言来构建时,你就又降到了更低的层次上,
这不但失去了在更高层次上设计时所能得到的主要好处,而且也会受限于不
必要的语法上的约束。
交叉参考关在本意(intent,意图)的层面上编写伪代码。用伪代码去描述解决问题的
于在本意层面
编写的注释的
方法的意图,而不是去写如何在目标语言中实现这个方法。
详情,请参见第
32.4节中的“注在一个足够低的层次上编写伪代码,以便可以近乎自动地从它生成代码。如
释种类”。
果伪代码的层次太高,就会掩盖代码中的问题细节。你应该不断地精化伪代
码,加入越来越多的细节,直到看起来已经很容易直接写出代码为止。
伪代码一经写好,你就可以依照它去生成代码了,同时还把伪代码变成编程
语言中的注释。这样就节省了大部分注释工作。如果伪代码是按上述各项原则写
成的,那么这些注释就会很完整也很有意义了。
下面是一个用伪代码做设计的示例,这里的伪代码几乎违背了上面所提到的
所有原则:
一段不好的伪代码示例
increment resource number by 1
allocate a dlg struct using malloc
HORROR
if malloc ( returns NULL then return 1
invoke oSrsrc_init to initialize a resource for the operating system
*hRsrcptr= resource number
return
这段伪代码的意图何在?很难说清吧?因为它写得太差了。之所以说这段所
谓的伪代码写得差,是因为它包含了许多目标语言编码的细节,比如说*hRsrcPtr
代码大全(第2版)

<==========================255end ==============================>
<==========================256start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看^
9.2伪代码
219
(用了C语言独特的指针写法),还有 malloc()(这是C语言中的一个函数)
这段伪代码太关注于如何编写代码而没有突出设计意图。它还深入到了编码的细
节——这个子程序是返回1还是返回0?如果换一个立场来考虑这段伪代码,看
看它能否转变为有用的注释,那么你就会明白它确实没有多大价值。
还是针对同样的功能所做的设计,下面这个例子所示的伪代码则大有改善:
一段好的伪代码示例 sin use
If another resource is available
Allocate a dialog box structure
If a dialog box structure could be allocated
Note that one more resource is in use
Initialize the resourceattn
store the resource number at the location provided by the caller
Endif
n
Endif
Return true if a new resource was created; else return false
这段伪代码比第一段要好,因为它都是用英语写的,也没有用到目标语言
中的任何语法元素。对于第一个示例,伪代码只能用C语言实现。但是在第二
个示例中,伪代码并没有限制对语言的选择。另外,第二段伪代码也是在意图
的层面上描述的。第二段伪代码意义何在?与第一段伪代码相比,你能更容易
理解它。
虽然第二段伪代码是用清晰的英语写的,但它已经足够地精确和详细,可以
方便地作为编程语言代码的基础。而一旦把这些伪代码语句转换成注释,它们将
很好地解释这段代码的用意。
使用这种风格的伪代码,可以得到下面这些好处。
伪代码使得评审更容易。你无须检查源代码就可以评审细节设计。伪代码使
得底层设计的评审工作更容易,同时减少了对代码本身进行评审的需要。
■伪代码支持反复迭代精化的思想。从一个高层设计开始,把这一设计精化为
伪代码,然后再把伪代码精化为源代码。这样持续不断地小步精化,使你可
以在把它推向更低的细节层次的同时,不断检查已形成的设计。这样做的结
果,使你可能在最高的层次上发现最高层次的错误,在中间的层次上发现中
间层次的错误,而在最低的层次上发现最低层次的错误避免其中的任何
错误变成真正的问题或者危害到更细节层次的工作。
代码大全(第2版)

<==========================256end ==============================>
<==========================257start==============================>

该书下载自-书部落-分享计算机经典巨著!www. ! -www.shubulo.com!仅供试看
220
第9章伪代码编程过程
深入阅读关于在伪代码使变更更加容易。短短几行伪代码要比整页的代码更容易修改。想想
代价最小的阶段进看,你是愿意在蓝图上改一条线呢,是愿意在墙面上动工呢?在软件领域,
行变化的好处,参
见 Andy Grove写
这种影响可能没有在物理过程中那么显著,但在产品最可塑的阶段进行变动
的( High Output的原则却是相同的。项目成功的关键因素之一,就是在“代价最小的阶段”
Management
Grove 1983
捕获到错误,这个阶段也就是向系统投入的工作量最少的阶段。在编写伪代
码阶段已投入的工作量远远少于完成编码测试和调试阶段之后投入的总工
作量,因此从经济的角度来说也应该尽早抓到错误。
伪代码能使给代码作注释的工作量减到最少。在典型的编码过程中,人们都
是先写出代码,然后再添加注释。而在伪代码编程过程中,伪代码中的语句
将会变为代码中的注释,所以实际上更多的工作是删除注释,而不是把它加
进来。
伪代码比其他形式的设计文档更容易维护使用其他方法时,设计和代码是
分离的,当其中之一变动的时候,两者就不再一致。而使用伪代码编程过程
时,伪代码中的语句将会转变为代码中的注释。因此只要维护代码间的这些
注释,那么这些伪代码所形成的设计文档就仍然是准确的。
作为进行详细设计的工具,很难有其他方法能与使用伪代码相媲美。一项调
查表明,程序员们更喜欢使用伪代码,因为它简化了用编程语言进行构建的工作,
且有助于发现细节设计中的不足之处,还能简化文档的编制以及修改的工作
(Ramsey, Atwood and Van Doren1983)。诚然,伪代码不是进行详细设计的唯一
工具,但是伪代码和伪代码编程过程却都会是你非常有用的具。先来试下吧,
下一节将告诉你具体该怎样做。
9.3
Constructing Routines by Using the PPP
通过伪代码编程过程创建子程序
本节将讲述如下这些与创建子程序有关的活动
■设计子程序
■编写子程序的代码
■检查代码
■收尾工作
■按照需要重复上述步骤
Design the Routine
设计子程序
交叉参考关于
设计的其他方面旦你明确了一个类有哪些子程序之后,为了创建类中较为复杂的程序,接
话题,请阅读第5下来要做的第一步工作就是去设计它比如说你要写一个子程序,它能根据错误
章至第8章。
代码大全(第2版)

<==========================257end ==============================>
<==========================258start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com!仅供试看^
9.3通过伪代码编程过程创建子程序
221
码输出错误信息,你称它为 ReporterrorMessage().下面是 Report Error-
Message()程序的一个非形式的规格说明(spec)
ReportErrorMessage)接收一个代表错误码的输入参数,输出与该错误码相
对应的错误信息。它应该能够处理无效的错误码如果程序是以交互式界面运行
的,那么 Rerort errorMessage()需要向用户显示错误信息;如果程序是以命令行
方式运行的,那么 Report ErrorMessage()应把错误信息记录在一个消息文件里。在
输出错误信息之后, Report. FrrorMessage(应回一个状态值,以表明其操作是成
功还是失败。
本章的其余部分将一直用这个子程序做示例。下面就来说明如何设计该子程
序。
交叉参考关
于检查先决条
检查先决条件在动手去做子程序本身的任何工作之前,应该先查看一下该
件方面的详情,子程序要做的工作是不是已经定义好了,是不是能够与整体设计相匹配。另外要
请参阅第3章结合项目的需求,检查这个程序是否是真正必需的,至少是间接需要的。
“三思而后行:
前期准备”以及
定义子程序要解决的问题陈述出该子程序将要解决的问题,叙述要足够详
第关的细,以便能去创建这个子程序。如果高层的设计已经足够详细,那么这项工作可
构建决策”。
能已经完成了。在这个高层的设计里至少应该详细说明下列信息。
■这一子程序将要隐藏的信息
传给这个子程序的各项输入
■从该子程序得到的输出
条件和关在调用程序之前确保有关的前条件成立(如输入数据的取值位于特定范围之内、
于前条件和后
条件的更多信
有关的流已经初始化、文件已经打开或者关闭、缓冲区已经填满或清空等)
息,请参见第在子程序将控制权交回调用方程序之前,确保其后条件的成立(如输出数据
8.2节中的“用
断来注解井
位于特定范围之内、流已经初始化、文件已经打开或者关闭、缓冲区已填满
验证前条件和或清空等)
后条件”。
下面看看在 ReportErrorMessage(示例中是如何考虑这些问题的。
该子程序隐藏了两项事实:错误信息的文本和当前的处理方式(交互式界面
或命令行)。
对于这个子程序,没有任何可保证的前条件
给该子程序的输入数据是一个错误码。
存在两种输出:首先是错误信息,其次是 Report Er rorMessage)返回给调
用方程序的状态值。
该子程序保证状态值或者为 Success,或者为 Failure
代大(第2版

<==========================258end ==============================>
<==========================259start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubulo..com!仅供试看^
222
第9章伪代码编程过程
交叉参考关
于为子程序命
为子程序命名给子程序命名看似不很重要但好的子程序名却是优秀子程
名的详情,请参序的标志之一,起个好名字也并不那么容易般来说,子程序应该有一个清晰、
阅第73节“好的无歧义的名字。如果你在给程序起个好名字的时候犯难,通常就表明这个子程序
子程序名字”
的目标还没明确。含混不清的名称就像竞选中的政客一样,看上去他好像说了些
什么,但是仔细一想,你又根本不知道他究竟说了什么。应该尽你所能让名称变
得更清晰,但如果是由于含混不清的设计而导致含混不清的名称,那么就要留意
这个警告信号了—回头去改善你的设计吧!
在这个例子中, Report ErrorMessage()这个名称很清楚,是个好名字。
深入阅读如
果想了解通过
决定如何测试子程序在你编写一个了程序的时候,要想一想怎么才能测试
先编写测试来它。这么做对于你一如果你做单元测试的话以及那些要独立地测试你写的
构建程序的另子程序的测试人员都有好处。
一种完全不同
的方法,请阅读在这个例子中,由于输入数据很简单,你可以计划采用所有合法的及一些非
Test-Driven
By Exament法的错误代码来测试 Report ErrorMessage()
Devalopment:
(测试驱动开在标准库中搜寻可用的功能要想提高代码的质量和生产率,有一个最重要
发:Beck的途径就是重用好的代码。如果你发现自苦苦设计的一段程序实在是过于复杂,
2003
那么请查看一下在你所用的编程语言、开发平台或者工具,看看其中是否提供该
程序的全部或部分功能。了解一下在你公司维护的代码库里是不是已经有这些功
能了。人们已经发明、评价并改善了很多的算法,它们已经过了充分测试,在文
献中也有所记录。与其在那些别人已经写成了博士论文的东西上浪费时间,还不
如花几分钟时间去看看别人已经写成的代码,从而确保你不会花冤枉功夫。
考虑错误处理考虑在子程序中所有可能出错的环节。比如说错误的输入数
值、从其他子程序返回的无效数据等。
子程序可以用多种方式来处理错误,你应该特别注意去选择处理错误的方式。
如果在程序架构中定义了出错处理策略,你只须遵循这一策略即可否则,你就
必须针对特定的子程序确定最佳的出错处理方式。
考虑效率问题对于效率问题,根据有关情况,你可以从下面两种处理方式
中选出一种。在第一种情况下,也是对于绝大多数系统而言,程序的效率并不是
十分紧要。这时你只要看看子程序的接口是否经过很好的抽象,看程序的代码是
否易读,这样在日后需要的时候你可以随时对它进行改进。如果封装做得很好,
你就可以用更好的算法,或者一段既快、又节省资源、用低级语言所写的实现代
码来替换原来既慢又耗费资源的、用高级语言所写的实现代码,同时还不会影响
其他的子程序。
代码大全(第2版)

<==========================259end ==============================>
<==========================260start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
9.3通过伪代码编程过程创建子程序
223
交叉参考有关
另一种情况只是在少数系统里出现在那里性能非常重要。性能问题可能
效率的详情,请
参阅第25章“代与稀缺的数据库连接、受限的内存、不可多得的句柄、严格的时限、或其他一些
码调整策略”,以稀有的资源相关。架构应当指明每个子程序(或者类)有多少资源可使用,以及
及第26章“代码
调整技术”。它们必须以多快的速度执行其操作。
根据所确定的资源及速度的目标来设计了程序。如果速度看上去更为重要,
那么就牺牲一部分资源来换取速度,反之亦然。在程序创建的起始阶段,先将其
调校到能达到预定的资源和速度,也是可以的。
除了在以上两种常见情况下采取推荐的做法之外,在每个子程序上为效率问
题卖力通常是白费功夫。最主要的优化还是在于完善高层的设计,而不是完善每
个子程序。通常,只有当能够证明高层设计确实无法满足系统的性能目标时,你
才需要进行微观的优化不过除非整个程序全部完成,否则你也不会知道这一
点。因此,不要在微不足道的点滴改进上浪费时间除非你知道确实有必要这样
去做。
研究算法和数据类型如果在可用的程序库里没有所需的功能,它也许会在
某本算法书里介绍过。因此,在你决定从头开始编写一段复杂的代码之前,查
下算法书看看有什么可用的内容。如果要采用一个已有明确定义的算法,则要保
证把这个算法正确地转换为你所使用的编程语言。
编写伪代码在完成了前述这些步骤之后,你可能还没写太多东西。其实这
些步骤的主要目的是为你确立一个思路,这在你真正编写程序的时候是很有帮助
的。
交叉参考这
里的讨论假定
在完成了前面这些准备步骤之后,就可以开始用高层次的伪代码来写程序了。
在编写子程序在你的代码编辑工具或集成开发环境里写伪代码就可以了,因为很快就要用这些
的伪代码版本伪代码作为编程语言写的实际编码的基础。
时使用了良好
的设计技术。关
于设计方面的
从最一般情况写起,向着更具体的细节展开工作。子程序最常见的部分是一
详情,请参见第段头部注释(header comment),用于描述这段程序应该做些什么,所以首先简要
5章“软件构建
中的设计”。
地用一句话来写下该子程序的目的。写出这句话将帮助你澄清对该子程序的理解。
如果连概要性的注释写起来都很困难,那就得提醒你自己,还得更好地理解这一
子程序在整个程序中的角色才行。一般说来,如果很难总结出一个子程序的角色
你可能就应该考虑是否什么环节出了问题。下面的例子是描述一个子程序的简要
的头部注释:
代玛大全(第2版)

<==========================260end ==============================>
<==========================261start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo. com!^.com!仅供试看^
224
第9章伪代码编程过程
一个子程序的头部注释示例
This routine outputs an error message based on an error code supplied by
the calling routine. The way it outputs the message depends on the current
indicating success or failure.
本子程序将根据调用方子程序所提供的错误码输出对应的错误信息用于输出信息的方式与当前的处
理状态有关,这将由子程序自己来判断。它会返回一个值来表明执行是成功还是失败。
写完这种一般性的注释之后,就可以为这个子程序编写高层次的伪代码。下
面是这个例子的伪代码:
一个子程序的伪代码示例
This routine outputs an error message based on an error code supplied by
the calling routine. The way it outputs the message depends on the current
processing state, which it retrieves on its own. It returns a value
本子程序将根据调用方子程序所提供的错误码输出对应的错误信息。用于输出信息的方式与当前的处
理状态有关,这将由子程序自己来判断。它会返回一个值来表明执行是成功还是失败。
set the default status to "fail"
look up the message based on the error code
+
if the error code is valid
if doing interactive processing, display the error message
interactively and declare success
if doing command line processing, log the error message to the
command line and declare success
e error code valid. notif
if the error code isn't valid, notify the user that an internal error
has been detected
return status information
需要再次强调的是,这段伪代码是在一个相当高的层次上编写的。它显然不是以
某种编程语言来写的。它用精确的英语表达了这段程序所要做的事情。
交叉参考关于
有效地使用变量
考虑数据你可以在整个过程中的几个不同环节对子程序所用的数据进行设
的详细情况,请计。在这个例子中,数据非常简单而且对数据的操作也不是该子程序的重点。
阅读第10章至如果对数据的操作是某个子程序的重点,那么值得在考虑子程序的逻辑之前,首
第13章。
先考虑清楚主要的数据部分。把关键的数据类型定义好,对于设计一个子程序的
逻辑是很有用的。
交叉参考关于检查伪代码在写完伪代码并设计完数据之后,花上几分钟时间复查你写的
评审技术的更多伪代码。然后抛开这些代码,想想你该如何向别人解释这些代码。
容,请见第21
章“协同构建”。找别人来看你写的代码,或者让他来听你的解释。你可能会想,让别人来看11
行伪代码是不是很傻?做了之后你就会惊讶的。因为与用编程语言写成的代码相
比,伪代码会让那些你自己想当然的,还有那些高层次的错误更加明显。而且,与
审阅35行的C++或Java代码相比,人们会更乐意来阅只有寥寥几行的伪代码。
代码大全(第2版)

<==========================261end ==============================>
<==========================262start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubr.com!仅供试看^
9.3通过伪代码编程过程创建子程序
225
请确认你能够很容易、很自然地理解这个子程序做些什么,以及它是怎样做
的。如果你在伪代码的层次上都无法从概念上理解它,那么在编程语言的层次上
岂不是更无法理解?而且,如果连你自己都理解不了它,还有谁能理解呢?
交叉参考关在伪代码中试验一些想法,留下最好的想法(迭代)在你开始编写代码之
于迭代方面的前,应尽可能用伪代码去尝试更多的想法。一旦你真正开始编码,你和你所写下
见第34.8节选的代码就会有感情,从而就更难以抛弃不好的设计再重头来过了。
代,反反复复,
一次又一次”
通常的想法是,用伪代码反复描述这个子程序,直到用伪代码写出的句子已
经足够简单了,你可以在每个句子下面填入代码,并把原来的伪代码变为代码的
文档为止。你最初尝试写出的一些伪代码可能还是层次太高,这就需要进一步分
解它。一定要进一步地分解它。如果还不确定该怎样编写代码,那么就继续在伪
代码上下功夫,直到你能确定为止。持续地精化和分解伪代码,直到你觉得再写
伪代码(而不是真正的代码)实在是浪费时间为止。
Code the Routine
编写子程序的代码
一旦一个子程序已经设计好,就该来构建它了。你可以按一种近乎标准化的
顺序来实施子程序构建的各个步骤,当然也可以根据需要灵活调整这些步骤。构
建子程序的步骤如图9-3所示。
以伪代码开始
↓
写出子程序的声明
编写第一条和最后一条语句,
然后将伪代码转换为高层次的注释
按需重复
每条注释下面填充代码
检查代码
收尾工作
完成
图9-3在构建程序的时候,你将实施所有这些步骤,但不一定要按照任何特定的顺序
代大全(第2版)

<==========================262end ==============================>
<==========================263start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !-www.shubulo.co!.com!仅供试看^
226
第9章伪代码编程过程
写出子程序的声明首先要写出子程序的接口(interface)声明也就是
C++中的函数( function)声明、Java中的方法( method)声明、 Microsoft Visual Basic
中的函数过程( function procedure)或子过程( procedure)声明,或者其他编
程语言中的类似声明等。把原有的头部注释变为编程语言中的注释。把它保留在
你写的伪代码的上方。下面是一个关于子程序的接口声明和头部注释的示例,这
段代码是用C++语言写的:
C++示例:向伪代码添加子程序接口声明和头部注释
这是头部注释,
已转换为C+风 supplied by the calling routine. The way it outputs the message
格的注释。
depends on the current processing state, which it retrieves
on its own. It returns a value indicating success or failure.
*/
这是接口语句。 Status ReportErrorMessage(
ErrorCode errorToReport
)
set the default status to "fail"
look up the message based on the error code
if the error code is valic
cocessin
。
if doing interactive processing, display the error message
interactively and declare success
if doing command line processing, log the error message to the
arror
user that
if the error code isn't' valid, notify the user that an
internal error has been detected
return status information
这里正好可以来说说关于接口假定(interface assumptions)的事情。在本例中,
接口变量 errorToReport的名字起得非常直截了当,已经表明了它的目的,因此
就不用再为它写文档了。
把伪代码转变为高层次的注释接下来,把第一条和最后一条语句写出来,
在C++中也就是“{”和“}”。然后把伪代码转变为注释。我们以这个例子来看
看:
C++示例:在伪代码首尾写出第一条和最后一条语句
/ This routine outputs an error message based on an error code
supplied by the calling routine. The way it outputs the message
depends on the current processing state which it retrieves.
on its own. It returns a value indicating success or fai
lure
*/
status
Status ReportErrorMessage
ErrorCode errorToReport
代码大全(第2版)

<==========================263end ==============================>
<==========================264start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看^
93通过伪代码编程过程创建子程序
227
从此往后的伪代 set the default status tofail
码语句已转换为1 look up the message based on the error code
C++注释。
/ if the error code is valid
if doing interactive processing, display the error message
11 interactively and declare success
/ if doing command line processing, log the error message
to the command line and declare success
if the error code isn't valid, notify the user that an
/1 internal error has been detected
return status information
此时,程序的特征已经很明显了。设计工作完成了,虽然看不到任何代码,
但你却能理解程序是怎么工作的。你应该能感觉到下一步再把伪代码转变为编
程语言的代码的工作应该是很机械化、很自然也是很容易的否则,你还得继续
用伪代码进行设计,直到你感觉设计方案很牢靠时为止。
交叉参考对这
在每条注释下面填充代码在伪代码注释中的每一句话下面填入代码。这个
个例子而言,因
为事情很小,所过程和写一篇期末论文差不多首先,你写出一个提纲,然后再把提纲中的每
以用写作隐喻个要点扩展为一个段落。每段伪代码注释都描述了一块或一段代码。就
(writing meta-
phor也会很管像文学著作中段落的长度一样,一段代码的长度也会根据所要表达的思想的不同而
用。关于在更大
的事情上应用这有长有短,其质量也与其表达的思想是否鲜明与集中相关。
个隐喻的反面意
见,请参见第2.3
在本例中,前两段伪代码注释可以展开成两行代码
节“软件中的书
法:写作代码”。C++示例:将伪代码注释表示为代码 ased on an error code supplied
by the calling routine. The way it outputs the message depends on the
current processing state, which it retrieves on its own. It returns a value
indicating success or failure.
*/
status ReportErrorMessage(
ErrorCode errorToReport
)theatofail
1/ set the default status to
这是填入的代码→ Status errorMessageStatus
s_Failure;
the
11 look up the message based on the error code
这里是一个新变量
Message errorMessage LookupErrorMessage errorToReport
errorMessage.
e error code
11 if doing interactive processing, display the error message
interactively and declare success
line processing, log the error message
1/ to the command line and declare success
代码大全(第2版)

<==========================264end ==============================>
<==========================265start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看^
228
第9章伪代码编程过程
if the error code isn't valid, notify the user that an
/ internal error has been detected
status
1/ return status information
这就是编码工作的开始。这里用到了 errorMessage变量,因此需要声明它。
看到这里你可能会说,用两行注释才换来两行代码的话总感觉有些不划算。然而
在这种方法里,重要的是这些注释所代表的语义内容(semantic content),而不是
它们所注释的代码行数。这些注释已经在那儿了而且也解释了代码的用意,因
此就把它们留在代码里吧。
在剩下的每段注释下面也需要分别填入代码:
C++示例:使用伪代码编程过程创建的完整的子程序
创
/ This routine outputs an error message based on an error code supplied
by the calling routine. The way it outputs the message depends on the
current processing state, which it retrieves on its own. It returns a value
indicating success or failure.
*/
status ReportErrorMessage(
ErrorCode errorToReport
)
/1 set the default status to "fail"
Status errorMessagestatus Status_Failure;
/ look up the message based on the error code
Message errorMessage LookupErrorMes errorToReport)
2
每条注释下都已经
if the error code is valid
填入了代码。
→if( errorMessage. ValidCode())h
/ determine the processing method
ProcessingMethod errorProcessingMethod
Current ProcessingMethod();
doing interactiver
error
/ if doing interactive processing, display the error message
/ interactively and declare success
if errorProcessingMethod = ProcessingMethod_Interactive )
Display InteractiveMessage( errorMessage. Text ( )
errorMessagestatus= statusSuccess
这段代码可以进一
if doing command line processing, log the error message
1/ to the command line and declare succe
cess
步分解为一个新的
else if errorProcessingMethod
ProcessingMethod_CommandLine
子程序:
DisplayCommand.
CommandLine messageLog; Com
LineMessage()
if( messageLog. Status()= nestatusok)
messageLog. AddToMessageQueue errorMessage.text())
messageLog. FlushMessageQueue()
errorMessagestatus status_Successi
代码大全(第2版)

<==========================265end ==============================>
<==========================266start==============================>

该书下载自-书部落-分享计算机经典巨著--www. :! --www.shubulo.com!^.com!仅供试看
9.3通过伪代码编程过程创建子程序
229
这段代码和注释是
else
新加入的,为了充
11 can't do anything because the routine is already
1/ error processing
实if测试。
else
,
s
这段代码和注释也
1/ can't do anything because the routine is already
是新加入的。
1/ error processing
that an
if the error code isn't valid notify the user that an
/ internal error has been detected
else
Display InteractiveMessage(
Ronort frrorme
"Internal Error: Invalid error code in ReportErrorMessage ()
);
return status i
/ return status information
return errorMessageStatus;
每一段注释产生出一行或多行代码。以这些注释为基础,每一代码块都形成
了一套完整的思想。这些注释仍保留下来,从一个更高的层次上对代码做出说明。
所有的变量都是在靠近第一次使用的地方进行声明和定义的。每段注释通常应该
展开为2~10行代码(由于这只是个用来演示的例子,因此其展开后的代码行数仅
仅是你在实际开发中会遇到的下限而已)
现在再次看看第221页上所写的规格,以及第224页上所写的最初的伪代码。
最初只有5句话的规格说明展开成了15行的伪代码(也要看你怎么计算行数了),
进而它又展开成了长达一页的子程序。尽管那个规格说明已然非常详尽,但创建
这个子程序仍然需要以伪代码和实际代码的形式做大量实质性的设计工作。这种
在较低层次的设计,也是“编码”并非一项简单任务的原因之一,同时也是本书
的主题之所以很重要的原因之一。
检查代码是否需要进一步分解有的时候,你会发现几行伪代码展开后形成
大量的代码。在这种情况下,你应该考虑采取以下两种方法中的一种。
交叉参考关于把这段注释下面的代码重构( refactor)成一个新的子程序。如果你发现由一
重构的详情,请
参见第24章“重
段伪代码发展形成的代码量超出了预期,那么就把这些代码重构为一个单独
构”
的子程序。写出调用这个新子程序的代码,包括为它起一个名字。如果你的
伪代码编程过程用得不错,那么参考伪代码给这一新子程序命名应该是不在
话下的。一旦你完成了最初正创建的那个子程序,你就可以投入这个新子程
序中,再次应用伪代码编程过程去构建它。
递归地( recursively)应用伪代码编程过程。与其在一行伪代码下面编写数
十行的代码,还不如花些时间把原来的那一行伪代码分解成更多行的伪代
码,然后再在新写出的伪代码下面填入代码。
代码大全(第2版)

<==========================266end ==============================>
<==========================267start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
230
第9章伪代码编程过程
Check the Code
检查代码
在设计并实现了一个子程序之后,第三大步骤便是检查你所构建的代码是否止
确。在这一阶段留下的任何错误,只能到以后的测试阶段才能发现。到那时再查找和
修正这些错误可就更昂贵了,因此你应该在此尽可能地发现所有的错误。
交叉参考关于
有的错误可能要一直到子程序完全写好之后才能够显现出来,这里面有很多
检查架构和需求种原因。伪代码里的错误可能在细节的实现逻辑中变得更明显。一个在伪代码时
详情,请见第3看上去很雅致的设计,可能用编程语言实现时变得不堪入目了。实现具体细节的
章“三思而后行:时候也可能会揭示出架构、高层次设计或者需求中存在的错误。最后,在代码中
前期准备”。也可能会有各种各样的常见编码错误人无完人嘛!考虑到上面列出的种种原
因,请在继续下去之前再次评审代码。
在脑海里检查程序中的错误第一种正式的程序检查方法是在脑海里检查。
前面提到的清理和非正式检查步骤就是两种在脑海里做检查的方法。另外还有
种是在脑海里执行每一条代码路径。在脑海中执行一个子程序是很难的,因此你
也更应该让写出来的子程序短小精悍。请确保你检查到了所有可能的执行路径、
端点和所有异常条件。你不但要自己检查(这叫做“桌面检查(desk checking)),
还要和一个或多个同伴一起检查——这可以叫做“同行评审(peer review)”、“详
查(walkk-through-)”,或者“审查(inspection)看你到底怎么做了。
编程爱好者和专业程序员之间最大的区别之一便是从迷信到理解的转变。这
里所说的“迷信”( superstition)并不是指一个程序会在月圆之时让你心生惊恐或
HARD DATA
产生什么莫名其妙的错误。指的是把对代码的感觉当作对它的理解。如果你发现
自己经常怀疑某些错误是由编译器或硬件造成的,那么你就仍然处于迷信的阶段。
多年以前的一份研究表明,只有约5%的错误是由硬件、编译器或操作系统的原因
造成的(Ostrand和 Weyuker,1984)。今天这一比例甚至可能更低。已经从迷信
转为理解的程序员们总会先怀疑是自己的工作出了问题,因为他们知道,正是他
们制造了那95%的错误。理解每一行代码所起的作用,理解为什么需要这行代码
没有什么东西会仅仅因为它看上去可行就是正确的。如果你不知道它为什么可以
工作,那么它很可能就是不能工作的一只是你还不知道罢了。
这里的底线是:只是能写出一个可以上作的子程序是不够的。如果你不知道
它为什么可以工作,那就去研究它,讨论它,用其他的设计方案作试验,直到你
KEY POINT
弄明白为止。
编译子程序完成检查之后,就可以编译这个程序了。在这么久之后才开始
编译程序,看上去效率不太高,因为代码早在几页之前就都写好了。不可否认,
如果你在此之前就去编译这个子程序,让计算机去检查那些未声明的变量、相互
冲突的命名等,那么你也许确实可以省去一些工作。
代码大全(第2版)

<==========================267end ==============================>
<==========================268start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
9.3通过伪代码编程过程创建子程序
231
然而,在整个构建过程的后期才开始编译能够给你带来很多的好处。主要的
原因是,当你编译新写的代码时,你心中的一块秒表也就开动了。第一次编译完
成以后,你就会开始给自己施压了:“只要再编译一次我就把它搞定啦!”这种“只
要再编译一次”的毛病会导致你对代码做出草率而可能带来错误的更改,从长远
看反而要花掉你更多的时间。到你已能让自己相信一个子程序是正确时再编译它,
可以避免在匆忙中完成代码。
这本书的一个目的就是告诉你怎样脱离那种先东拼西凑,然后通过运行来看
看代码是否工作的怪圈。在确信程序能工作之前就开始编译它,这通常就是上面
那种黑客思维的症状。如果你没有陷入这种“拼凑加编译(hacking--compiling-ad-)
的怪圈,那就在你觉得合适的时候再去编译吧。不过你要清楚,大多数人都是在
挣扎中通过“拼凑,编译,然后修改”的方法开发能工作的程序的。
下面就如何最大限度地发挥编译子程序所产生的功效给出些指导建议。
把编译器的警告级别调到最高。通过让编译器来检测错误,你可以很容易地
查出大量细微的错误。
使用验证工具( validators)可以通过使用类似lint这样的工具来对C语言
这类语言的编译器所作的检查结果进行补充检查验证具甚至可以检查
HTML或 JavaScript这样不可编译的代码。
消除产生错误消息和警告的所有根源。请重视由这些信息对你的代码所报告
的情况。通常,大量的警告信息暗示着代码的质量欠佳,你需要尽量理解所
得到的每一个警告。在实践中,你反复遇见的那些警告会产生下面两种影响
之一:要么你不理它们而任由它们掩饰着其他更为重要的警告信息,要么就
是它们变得十分讨厌。通常,通过重写代码来解决潜在问题并消除警告信息
是更保险也更省力的。
在调试器中逐行执行代码程序编译通过之后,要在调试器中逐行执行,以
确保每行代码都在按照你所期望的方式执行。遵循这个简单易行的方法,你就能
查出很多的错误。
交叉详情
测试代码使用你在开发该子程序期间计划写的或已写成的测试用例(test
见第22 cases)来测试代码。你可能需要开发一些脚手架( scaffolding)来支持你的测试用
也可参考第例也就是说,写一些对程序测试起辅助作用,而又不纳入最终的产品中的支
22.5节中的“为持代码。脚手架可以是一套用测试数据来调用你的子程序的测试夹具子程序,也
225
测试各个类构造可以是一些供你的子程序调用的存根(stub)
脚手架”
交叉参考详
消除程序中的错误一旦检测到错误,就一定要把它除掉。如果此时你开发
情请参阅第23的程序仍是漏洞百出,那么很可能它就永远这样漏洞百出了。如果你发现一段程
章“调试”。序的毛病不是一般的多,那请从头再来吧。不要修修补补了一重新写吧。修修
补补通常表明你还未能全面地理解程序,这样做也必将不时地产生错误。对于一
个毛病百出的程序而言,设计一个全新的方案是值得的。重写一个问题百出的程
序,让它以后再也不出任何错误—还有什么比这更让人满足呢?
代大全(第2版)

<==========================268end ==============================>
<==========================269start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubule.com!仅供试看
232
第9章伪代码编程过程
Clean Up Leftovers
收尾工作
在检查完代码中的错误之后,再按照本书所描述的优秀代码的一般特性来检
查你的代码。你可以实行若干扫尾步骤确保子程序的质量合乎标准。
检查子程序的接口。确认所有的输入、输出数据都参与了计算,并且所有的
参数也都用到了。更多的细节请参阅第7.5节“如何使用子程序参数”
检查整体的设计质量。确认下列事项:这个子程序只干一件事情,并且把这
件事情做得很好子程序之间是松散耦合(loosely coupled)的;子程序采
用了防御式(defensive)设计。更多详情,请参阅第7章“高质量的子程序”。
检查子程序中的变量。检查是否存在不准确的变量名称、未被用到的对象、
未经声明的变量,以及未经正确初始化的对象等。第10章到第13章会专门
讲述使用变量方面的详细内容。
检查子程序的语句和逻辑。检查是否存在“偏差1”(off-by-one)这样的错
误、死循环、错误的嵌套以及资源泄漏。第14章到第19章会详细讲述关于
语句方面的内容。
检查子程序的布局。确认你正确地使用了空白来明确子程序、表达式及参数
列表的逻辑结构。有关详情,请参见第31章“布局与风格”。
检查子程序的文档。确认那些由伪代码转化而来的注释仍然是准确无误的。
检查有关算法的描述、接ㄇ假定(interface assumptions)的说明、那些并非
显而易见的依赖性,以及关于难以理解的编码行为的解释等。冇关详情,请
参见第32章“自说明代码”。
除去余的注释。有些时候,当与被注释所描述的代码放在一起时,那些由
伪代码转变来的注释就显得多余了,尤其是在反复应用伪代码编程的过程
之中,处在命名良好的子程序的调用方代码前面的那些注释。
Repeat Steps as Needed
根据需要重复上述步骤
如果这个程序的质量不佳,那就回到伪代码那步去高质量的编程是一个
迭代的过程,所以不要犹豫,把构建的工作再做一遍。
9.4
Alternatives to the PPP
伪代码编程过程的替代方案
在我看来,伪代码编程过程是创建类和子程序的最佳方法。下面是其他专家
推荐的一些不同的方法。你既可以用这些方法来替代伪代码编程过程,也可以把
它们用作对伪代码编程过程的补充。
代码大全(第2版)

<==========================269end ==============================>
<==========================270start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
9.4伪代码编程过程的替代方案
233
测试先行开发(Test--first development)测试先行是一种流行的开发方法,
用该方法开发的时候,在任何代码之前先要写出测试用例(test cases)这种方法
在第22.2节中的“测试先行还是测试后行中有更具体的介绍。 Kent Beck写的
Test -Driven- Development: By Example》(Bck2003)是介绍该方法的一本好书。
重构(《rcfctoring《)重构也是一种开发方法该方法通过对代码进行一系列
保持语义的变换和调整来提高代码的质量。程序员要用不良代码的模式(patterns
of bad code)或说“臭味”(smells)识别出需要改进的那部分代码。第24章“重
构”会对这种方法展开更详细的说明。关于这一话题,也有一本好书,那就是 Martin
Fowler写的《 Refactoring: Improving the Design of Existing Code》(Fowler1999)
契约式设计(design by contract)契约式设计是这样一种开发方法,即认为
每一段程序都具有前条件(preconditions)和后条件(postconditions)这种方法
在第8.2节“用断言来注解并验证前条件和后条件”中也有介绍。有关契约式设
计最权威的参考书是 Bertrand Meyers写的《 Object-Oriente Software Construction》
(Meyer 1997).
东拼西凑(hacking)有些程序员总是试图通过东拼西凑来写出能工作的代
码,而不是采用一种像伪代码编程过程这样系统化的做法。如果你发现自己曾经
在写一段程序的时候陷入僵局并不得不重新来过的话,那么这可能表明伪代码编
程过程可能会更适合你。如果你发现自己在编写一段程序的时候会思路偏失,那
么这也同样表明伪代码编程过程可能会更为适用你是否曾经忘记过写一个类或
程序的某一部分?要是你使用伪代码编程过程的话这就不太可能发生了。如果
你感觉自己坐在电脑前面却无从下手,那么伪代码编程过程肯定会让你的程序生
涯变得更加轻松。
CHECKLIST: The Pseudocode Programming Process
cc2e.comv/0942
核对表:伪代码编程过程
交叉参考这
口是否检查过已满足所有的先决条件?
份列表的目的是
帮助检查看你在口定义好这个类要解决的问题了吗?
创建一个子程序
的时候是否遵循
口高层次的设计是否足够清晰?能给这个类和其中的每一个子程序起一个
了一套良好的步
骤。如果想关注
好的名字吗?
干程
序自身质
量,请参见第7
口考虑过该如何测试这个类及其中每一个子程序了吗?
章185页中的
高质量的子程
关于效率的问题,你主要从稳定的接口和可读的实现这两个角度考虑
序”的核对表。
吗?还是主要从满足资源和速度的预期目标的角度考虑过呢?
口在标准函数库或其他代码库中寻找过可用的子程序或者组件了吗?
口在参考书籍中查找过有用的算法了吗?
代大全(第2版)

<==========================270end ==============================>
<==========================271start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com.com!仅供试看
234
第9章伪代码编程过程
口是否用详尽的伪代码设计好每一个子程序?
口你在脑海里检查过伪代码吗?这些伪代码容易理解吗?
口关注过那些可能会让你重返设计的警告信息了吗?(比如说关于全局数
据的使用、些看上去更适合放在另一个类或子程序中的操作等。)
口是否把伪代码正确地翻译成代码了?
口你反复使用伪代码编程过程了吗?有没有根据需要把一些子程序拆分成
更小的子程序?
口在做出假定( assumptions)的时候有没有对它们加以说明?
口已经删除掉那些冗余的注释了吗?
你是否采取了几次迭代中最好的那个结果?还是在第一次迭代之后就停
止了?
口你完全理解你的代码了吗?这些代码是否容易理解?
Key Points
要点
创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认
识常常会反过来影响类的设计。
■编写好的伪代码需要使用易懂的英语,要避免使用特定编程语言中才有的特
性,同时要在意图的层面上写伪代码(即描述该做什么,而不是要怎么去做)
伪代码编程过程是一个行之有效的做详细设计的工具,它同时让编码工作更
容易。伪代码会直接转化为注释,从而确保了注释的准确度和实用性。
不要只停留在你所想到的第一个设计方案上反复使用伪代码做出多种方
案,然后选出其中最佳的一种方案再开始编码。
每一步完成后都要检查你的工作成果,还要鼓励其他人帮你来检查。这样你
就会在投入精力最少的时候,用最低的成本发现错误。
代码大全(第2版)

<==========================271end ==============================>
<==========================272start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看
第3部分
Variables
变量
本部分内容
■第10章使用变量的一般事项
237
■第11章变量名的力量
259
■第12章基本数据类型
291
■第13章不常见的数据类型
319
代码大全(第2版)

<==========================272end ==============================>
<==========================273start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo.c.com!仅供试看

<==========================273end ==============================>
<==========================274start==============================>

该书下载自-书部落-分享计算机经典巨著-www. !--www.shubulo.com!^.com!仅供试看个
General Issues in Using
Variables
第10章
使用变量的一般事项
cc2ec/1085内容
10.1数据认知:第238页
10.2轻松掌握变量定义:第239页
10.3变量初始化原则:第240页
10.4作用域:第244页
10.5持续性:第251页
10.6绑定时间:第252页
10.7数据类型和控制结构之间的关系:第254页
10.8为变量指定单一用途:第255页
相关章节
为变量命名:第11章
基本数据类型:第12章
不常见的数据类型:第13章
■格式化数据声明:第31.5节中的“数据声明的布局”
注释变量:第32.5节中的“注释数据声明”
利用构建活动来填补需求和架构中存在的细小间隙是一种行之有效的做法。
但把蓝图设计得精细到已经能完全展现出所有的细节则实在是一种低效做法。本
章将详细讲述构建活动中的基本组成成分,即变量的使用。
如果你是一位经验丰富的程序员,那么本章的内容将会对你格外有用。在全
面了解其他方法之前,你很可能已经开始使用某种危险的实践方法。即使之后认
识到这样做是不对的,你也可能出于惯性把这种方法延续下去。经验丰富的程序
员可能会觉得第10.6节所讲的“绑定时间”和第10.8节所讲的“为变量指定单一
用途”非常有意思。如果你还不确定自己是不是够得上一位“经验丰富的程序员”,
那么就通过做下一节的“数据认知测试”来确定吧。
代码大全(第2版)

<==========================274end ==============================>
<==========================275start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo.com!^.com!仅供试看
238
第10章使用变量的一般事项
我在本章中用“变量”一词同时指代对象和内置数据类型(uit-in data type),
如整数和数组等。“数据类型”一词通常是指内置数据类型,而“数据”一词则可
能代表对象,也可能代表内置数据类型。
Data Literacy
数据认知
创建有效数据的第步是了解所要创建数据的种类。积累大量的数据类型对
于程序员来说是至关重要的。有关数据类型的讲授超出了本书的范围,但下面的
“数据认知测试”将会告诉你可能还需要了解数据类型的哪些知识
The Data Literacy Test
数据认知测试
在你熟悉的概念前面写上1,在你认为自己知道其含义但却不确定的概念前
面写0.5。写完以后把分数加到一起,然后根据后面的记分表来解释分数所代表的
含义。
抽象数据类型( abstract data type)
文量( literal)
数组(array)
局部变量( local variable)
位图( bitmap)
查找表( lookup table)
布尔变量( boolean variable)
数据成员(member data)
B树(b-tree)
指针( pointer)
字符变量(character variable)
私用( private
容器类( container class)
retroactive synapse
双精度( double precision)
引用完整性( referential
integrity
elongated stream
浅( stack
枚举类型( enumerated type)
宇符串(string)
浮点( floating point
结构变量( structured
variable
堆(heap)
树(tree)
下标( index
typedef
整数( integer)
共用体( union)
链表( linked list)
value chain
具名常量( named constant)
变体( variant)
总分
代码大全(第2版)

<==========================275end ==============================>
<==========================276start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shub.com!仅供试看
10.2轻松掌握变量定义
239
你可以按照下列标准来评价自己的得分(标准并不严格)
你是一个写程序的新手,可能在学校里学第一年的计算机科学课程,或
0-4者在自学第一种编程语言。你可以从下面所列出的任意一本书中获益匪
浅。本书这一部分所讨论的大部分技术问题都是针对高级程序员的,所以
如果你读了某一本书后再来看这些内容一定会有更多收获。
15-19
你要么是一个中级程序员,要么是一个忘性很大的高级程序员。尽管你熟
悉其中的很多概念,但是阅读下面列出的某本书对你的帮助也会很大。
20—24你是一个专家级程序员,很可能已经拥有了下面的某一本书。
2529
你知道的数据类型要比我多,可以考虑自己写一本计算机方面的书了
(可要送我一本!)
你是个绣花枕头,而且还没有说真话。“elongated stream、“retroactive
3032 synapse”和“value chain”所指的都不是数据类型它们是我杜撰出来的。
请读第33章“个人性格”中的“诚实”一节。
Additional Resources on Data Types
有关数据类型的更多资源
下面的这些书都是学习数据结构的好资料:
Cormen, H. Thomas, Charles E. Leiseron, Ronald L. Rivest. Introduction to
Algorithms). New York, NY: McGraw Hill. 1990. 1
Sedgewick, Robert. <Algorithms in C++), Parts 1-4, 3d ed. Boston, MA:
Addison-Wesley, 1998.2
Sedgewick, Robert. Algorithms in C++, Parts 5, 3d ed. Boston, MA: Addison-
Wesley, 2002.
Making Variable Declarations Easy
10.2轻松掌握变量定义
交叉引用关于
变量声明的布局
本节将会向你讲述如何加快变量定义的工作。事实上,这是一个很简单的任
请阅第31.5节中务,你可能会觉得它过于简单,并不需要在本书里专门写一节出来。然而,创建
的“数据声明的布
关于对变变量的确占去了你很多时间,因此养成一个良好的习惯会为你在整个项目周期内
行说明
详情,请阅第32.5
的省去很多时间和麻烦。
节中的“注释数据
声明。
Implliclt Declarations
隐式声明
有些语言支持隐式变量声明。例如,当你在 Microsoft Visual Basic中使用一个
未声明变量的时候,编译器会自动为你声明该变量(取决于你的编译器设置)
1译注:《算法导论》(第二版影印版),高等教育出版社。
2译注:《算法V(C++实现)图算法》(第三版影印版)高等教育出版社
代大全(第2版)

<==========================276end ==============================>
<==========================277start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubu.com!仅供试看^
240
第10章使用变量的一般事项
隐式变量声明对于任何一种语言来说都是最具危险性的特性之一。如果你用
Visual Basic做过开发就会明白,当你绞尽脑汁想要明白变量 acctNo的值为什么
不正确,最终却发现是不慎将 acctNo写成 acctNum,而又将 acctNum重新初始
化为0时,你会有多么的沮丧。如果所用的语言不要求对变量预先声明,你就会
很容易犯这一类的错误。
如果所用的语言要求对变量做出声明,那么你必须要先犯下两个错误,程序
才会来找你的麻烦。首先你必须把acctNum和acct加入到程序里来,然后
KEY POINT
声明这两个变量。要出现这样的错误并不容易因此事实上,这也就避免了变量
混淆(synonymous-variables-)这类错误的发生。那些要求显式声明数据的编程语
言实际上是在提醒你要更加仔细地使用这些数据,而这一点也是它们的主要优势
之一。那么,如果你使用的编程语言支持隐式声明该怎么办呢?下面给出一些建
议。
关闭隐式声明有些编译器允许你把隐式声明功能关闭。比如你在 Visual
Basicoption里可以用 Explicit语句来强迫程序员在使用变量之前先做出声明。
声明全部的变量在你引入一个新变量的时候对它做出声明,哪怕编译器不
要求你一定要这样做。这样做虽然不会捕捉所有的错误,但至少能发现其中的一
部分。
交引用如果
遵循某种命名规则对像Nun和No这样的常见变量名后缀建立一套命名规
想了解关于缩写则,从而确保在需要一个变量时不会写成两个。
11.6节中的“写
的一般指导原
检查变量名使用编译器或第三方工具生成的交叉引用列cross-reference-
则”。
list)。很多编译器会把一个子程序内的全部变量都列出来,从而帮助你发现
acctNum和 acctNo它们同时还会列出那些声明了但是还没使用的变量。
10.3
Guidelines for Initializing Variables
变量初始化原则
不合理地初始化数据是产生编程错误的常见根源之一。掌握一些能够避免初
始化问题的行之有效的方法能帮助你节省很多调试时间。
KIY POImT
交叉引用关干
不恰当的变量初始化所导致的一系列问题都源于变量的默认初始值与你的预
基于数据初始化期不同。以下行为都会产生此类问题。
和使用模式的测
试方法,参见第从未对变量赋值。它的值只是程序启动时变量所处内存区域的值。
22.3节中的“数
据流测试”。变量值已经过期。变量在某个地方曾经被赋值,但该值已经不再有效。
变量的一部分被赋值,而另一部分没有。
代码大全(第2版)

<==========================277end ==============================>
<==========================278start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
10.3变量初始化原则
241
最后一条有几种可能的情况。你可能初始化了一个对象的部分成员,而不是
全部成员。也可能忘记事先分配内存,就去初始化一个未经初始化的指针所指的
“变量”。这就意味着你是随机选取了一块内存,然后对其赋值。这块内存可能存
放的是数据,也可能存放的是代码。甚至可能指向操作系统内部。指针操作错误
可能产生很奇怪的现象,并且每次都不相同这也导致了调试指针错误比调试
其他错误更困难。
下面给出一些避免产生初始化错误的建议。
在声明变量的时候初始化在声明变量的同时对其初始化是一种非常方便的
防御式编程方法,是一种很好的用于防范初始化错误的保险策略。在下面这一示
例里, studentGrades会在你每次调用其所属的子程序的时候初始化。
C++示例:在变量声明的同时初始化
float studentGrades[ MAX_STUDENTS 1= 0.0 }
交叉引用检查在靠近变量第一次使用的位置初始化它包括 Visual Basic在内的一些语言
输入参数是防御不支持在声明变量的同时进行初始化。这就会导致出现下面这种编码风格,即
式编程的一种形
式。详细内容参多个变量的声明语句集中放在一个地方,它们的初始化语句集中放在另一个地
见第8章防御式方—这些语句离真正使用变量的语句都还很远。
编程”。
Visual Basic示例:糟糕的初始化
declare all variables
Dim account Index As Integer
Dim total As Double
CODING
Dim done As Boolean
HORROR
initiaih
initialize all variables
accountIndex=0
total=0.0
done =False
cina accountt
'code using accountIndex
'code using total
code using done
While Not done
代码大全(第2版)

<==========================278end ==============================>
<==========================279start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubu.com!仅供试看^
242
第10章使用变量的一般事项
更好的做法是在尽可能靠近第一次使用变量的位置初始化该变量:
Visual Basic示例:良好的初始化
Dim accountIndex As Integer
account Index=
'code using accountIndex
totalDim在靠近首次 total As Double
使用的地方被声 total=0.0
明和初始化。
code using total
次使用的地方被 done False
done在靠近首 im done As Boolea
声明和初始化。 de using done
While Not done
第二个示例在多个方面优于第一个。在第一个示例中,当使用done变量的代
码开始执行的时候,done很可能已经被修改了。即便你在第一次写这个程序的时
候不会这样,后续的修改也可能会导致出现这样的错误。这种方法的另一个问题
是,一旦把所有的初始化代码都放在一起,也可能会让人产生误解,认为所有这
些变量都会在子程序中一直使用而事实上done只是在后面才被用到。最后,
随着对程序的不断修改(可能会这样,即使只是为了调试),一些循环可能会包含
使用了done的代码,因此done就需要重新初始化。对于这种情况,第二个示例
需要做的改动就会少很多。第一个示例中的代码更容易产生恼人的初始化错误。
交叉参考关于这是就近原则(Principle of Proximity)的一个例子,即把相关的操作放在一
如何将相关操作起。这一原则也适用于让注释靠近它所描述的代码,让控制循环的代码靠近循环
放在一起的详
情,见第10.4节本身,以及把语句写成直线的代码等各个领域。
“作用域”。
理想情况下,在靠近第一次使用变量的位置声明和定义该变量声明指定了
变量的类型,定义为变量指定特定的取值在允许这样做的语言,如C++和Java
中,变量应该在靠近第一次使用的位置进行声明和定义。在理想情况下,每个变
量都应该在声明的同时被定义,如下所示:
Java示例:良好的初始化
int account Index =
1/ code using accountIndex
代码大全(第2版)

<==========================279end ==============================>
<==========================280start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! -www.shubul.com!仅供试看^
10.3变量初始化原则
243
total在靠近首次
使用的地方被声 double tota=0.0
/ code using total
明和初始化。
done也在靠近首
次使用的地方声 boolean done dfalse
明和初始化。
code using done
while(done)
交叉引用关于
在可能的情况下使用 final或者 const通过在Java里把变量声明为 final,
将相关操作放在或者在C++里把变量声明为cons,你可以防止该变量在初始化之后再被赋值。
法,见第14.2节fina1和,42na1const《cascostant输入参数以及任何初始化
“顺序无关的语后其值不再发生改变的局部变量时非常有用。
句”
特别注意计数器和累加器i、j、k、sum和 total等变量常用做计数器
(counter)或累加器(accumulator)在下一次使用这些变量之前忘记重置其值也
是一种常见错误。
在类的构造函数里初始化该类的数据成员正如子程序的变量应该在每一个
子程序内部初始化一样,类的数据也应该在其构造函数中初始化。如果在构造函
数里面分配了内存,那么就应该在析构函数中释放这些内存。
检查是否需要重新初始化问问你自己的变量是否需要重新初始化,这或者
是由于子程序内的某个循环需要多次使用该变量,或者是由于该变量会在多次子
程序调用之间维持其值,因此需要在每次调用时重新赋值。如果的确需要重新初
始化,那么要确保初始化语句位于那些重复执行的代码内部。
一次性初始化具名常量;用可执行代码来初始化变量如果你想用变量来模
拟具名常量,那么在程序开始处对常量做一次初始化即可。你可以用一个
Startup()子程序去初始化它们。对于真正的变量,则应在靠近它们使用的位置
用可执行代码(executable code)对其初始化。对程序常做的修改之一就是把一个
原本只调用一次的子程序修改为可以调用多次。那些由系统级的 startup()子程
序进行初始化的变量不会再由该子程序重新初始化。
使用编译器设置来自动初始化所有变量如果你用的编译器支持自动初始化
所有变量的选项,那么请把它打开。这是一种靠编译器完成初始化工作的简单方
式。然而,当你把代码移植到另一台机器或者编译器的时候,依赖特定的编译器
设置就会带来问题。确保记下了你所使用的编译器设置;依赖于特定编译器设置
的编程假定是很难以其他方式表露出来。
利用编译器的警告信息很多编译器会在你使用了未经初始化的变量的时候
发出警告。
代码大全(第2版)

<==========================280end ==============================>
<==========================281start==============================>

该书下载自-书部落分享计算机经典巨著-- !--www.shubu.com!仅供试看^
244
第10章使用变量的一般事项
交叉参考关于检查输入参数的合法性另一种颇有价值的初始化方法是检查输入参数的合
检查输入参数的
具体做法,请参考法性。在你把输入数值赋给任何对象之前,要确保这些数值是合理的
第8.1节“保护程
使用内存访问检查工具来检查错误的指针在有些操作系统里,操作系统的
序免非法输入
数据的破坏”以及代码会负责检查那些非法的内存引用;而另一些操作系统则不会这么做,需要自己
第8章防御式编来开发相应的功能。然而,你也不一定非得要自行开发,因为你可以购买内存访问
程”的其余部检查工具(memory-access checker)来检测你的程序中的内存操作
在程序开始时初始化工作内存把工作内存( working memory)初始化为一
个已知数值将会有助于发现初始化错误。可以采用下面的任意一种方法。
可以用某种在程序运行前预先填充内存的工具(memory filler)来把程序的
工作内存填充为一个可以预料的值。对于某些检测目的而言,0是个很好的
填充值,因为它会确保那些尚未初始化的指针指向内存底端,很容易就能检
测出误用未初始化的指针的情况。对于 Intel x86处理器来说,0xcc是一个
不错的数值,因为它是断点中断(int03h)的机器码。如果你在调试器中运
行程序并且试图执行一段数据而不是执行代码的时候,就会陷入断点。使用
0xC的另一项好处是它可以很容易从内存转储(memory dump)的信息中
识别出来一而且它很少有合法的用途。作为另一种选择, Brian Kemighan
和 Rob Pike建议使用 OxDEADBEEF这一常量来填充内存,因为在调试器里很
容易识别它(1999)。
如果使用内存填充具,那么可以偶尔改变一下用来填充内存的值。有时,
这么“晃动”一下程序也许可以发现一些在背景环境保持不变的情况下无法
察觉出来的错误。
■可以让程序在启动时初始化工作内存。前面所述的使用在程序运行时预先填
充内存的工具的目的是要暴露缺陷,而这种方法的目的则是隐藏缺陷。通过
每次把工作内存赋以同样的值,就能保证程序不会因内存初始值的随机性而
受到影响。
10.4
Scope
作用域
“作用域”可以看作是一种衡量变量的知名度的方法:它的名气有多大?作
用域或者可见性( visibility)指的是变量在程序内的可见和可引用的范围。一个作
用域受限的或者作用域很小的变量只能在程序的很小范围内可见比如说,循
环下标变量能用于一个循环的小范围内。一个作用域大的变量则在程序的很多
地方都是可见的比如说,程序所到处都用到的一个记录员工信息的表。
不同的语言处理作用域的方式也有所不同。在一些早期的语言里,所有的变
量都是全局变量。因此你无法控制变量的作用域,从而也就带来了很多的问题。
代码大全(第2版)

<==========================281end ==============================>
<==========================282start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看^
10.4作用域
245
在C++及与之相似的语言里,变量可以只对某一个代码块可见(花括号围起来的
一段代码)、也可以对子程序、类(可能还包括其派生类)或者整个程序可见。在
Java和C#中,变量还可以在一个包(package或者命名空间(namespace,组
类的集合)的范围内可见。
下面是一些使用作用域的规则。
Localize References to Variables
使变量引用局部化
那些介于同一变量多个引用点之间的代码可称为“攻击窗口(window of
vulnerability)”。可能会有新代码加到这种窗口中,不当地修改了这个变量,或
者阅读代码的人可能会忘记该变量应有的值。一般而言,把对一个变量的引用局
部化,即把引用点尽可能集中在一起总是一种很好的做法。
把变量的引用点集中起来,这么做目的十分明确,但这种想法只适合有正式
度量手段来判断集中程度的场合。衡量一个变量的不同引用点的靠近程度的一种
方法是计算该变量的“跨度(span)”。下面举一个例子:
ava示例:变量跨度
a=0
b=0;
c=0;
=b+c;
在上例中,对a的第一次引用和第二次引用之间存在两行代码,因此变量
的跨度是2。在两次对b的引用之间存在一行代码,因此变量b的跨度为1,同理
c变量的跨度是0下面再举一例:
Java示例:跨度0和跨度1
a=0
c=0
b a 1i
b=b /c;
深入阅读关于
在上面这个示例中,第一次对b的引用和第二次对b的引用之间存在一行代
变量跨度的更多码,其跨度为1。第二次和第三次对b的引用之间没有代码间隔,因此跨度为0
内容,请参考
《SofwareEngb《平均跨度可以通过对各个跨度计算平均值而获得。在第二个示例中,对于b
ineering Metrics而言,(1+0)/2算得的平均跨度是05当把变量的引用点靠在一起的时候,也就
and Models
《软件工程的使得代码的阅读者能每次只关注于一部分代码而如果这些引用点之间的距离非
度量标准与模
型>, Conte,,,常远,那你就要迫使阅读者的目光在程序里跳来跳去。因此,把变量的引用点集
Dunsmore,and中起来的主要好处是提高程序的可读性。
Shen1986)。
代码大全(第2版)

<==========================282end ==============================>
<==========================283start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.co!.com!仅供试看^
246
第10章使用变量的一般事项
Keep Variables"Live"for as Short a Time as Possible
尽可能缩短变量的“存活”时间
与变量跨度相关的一个概念是“存活时间(live time)”,即一个变量存在期间
所跨越的语句总数。变量的存活时间开始于引用它的第一条语句,结束于引用它
的最后一条语句。
与跨度不同的是,存活时间不受第一次和最后一次引用变量之间变量使用次
数的影响。如果该变量在第1行被第一次引用,在第25行被最后一次引用,那么
它的存活时间就是25条语句。如果对该变量只有这两行引用,那么它的平均跨度
就是23行语句。如果第1行到第25行之间的每条语句都使用了该变量,那么它
的平均跨度就是0行语句,不过它的存活时间仍然是25行语句。图10-1同时说
明了跨度和存活时间。
长存活时间
长存活时间
短跨度
长跨度
短存活时间
短跨度
图10-1“长存活时间”意味着一个变量历经了许多语句,而“短存活时间”意味着
它只历经很少的语句。“跨度”则表明了对一个变量引用的集中程度
与跨度类似,保持较低的存活时间也是我们的目标,应使得对象的存活时间
尽可能短。与追求较小跨度的原因相同,保持短的存活时间的主要好处也是减小
攻击窗口。这样,在你真正想要修改一个变量的那些位置之间的区域,该变量被
代码大全(第2版)

<==========================283end ==============================>
<==========================284start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看^
10.4作用域
247
错误或无意修改的可能性就降低了。
缩短变量存活时间的另一个好处是使你能对自己的代码有更准确的认识。如
果一个变量在第10行赋值,却要到第45行才再次使用它,那么介于这两个引用
点之间的那一长段距离就暗示说该变量在第10行到第45行的范围内一直在使用。
如果该变量是在第44行赋值,在第45行使用,那么不会有任何有关该变量使用
的暗示产生,你在思考这个变量的时候也就能集中于更小范围的代码了。
短的变量存活时间同样减少了初始化错误的可能。在修改程序的时候,常会
把直线型代码(顺序代码)修改为循环,这样就很容易忘记远离循环位置的那些
初始化代码。通过把初始化代码和循环代码放在一起,就减少了由于修改语句而
导致初始化错误的可能性。
变量存活时间短还会使代码更具可读性。阅读者在同一时间内需要考虑的代
码行数越少,也就越容易理解代码。同理,如果变量的存活时间越短,当你希望
在编辑和调试的过程中查看有某个变量的全部引用点的时候,需要在屏幕上显示
的代码数量也就会越少。
最后,当需要把一个大的子程序拆分成多个小的子程序时,短的变量存活时
间也很有价值。如果对变量的多次引用靠得非常近,那么把相关的代码片断重构
为单独的子程序就会非常容易了。
Measuring the Live Time of a Variable
测量变量的生存时间
你可以计算某一变量最初引用点和最后引用点之间的代码行数(包含最初和
最后一条语句),以此将生存时间这一概念形式化。下面就是一个生存时间过长的
例子:
java示例:变量的生存时间过长
//initialize all variables
2 recordIndex =0;
3 total=
4 done= faise;
26 while recordIndex recordCount )
27... 1:
最后一次引用28 recordIndex= recordIndex+1;
recordIndexo
64 while
最后一次引用
totalo
最后一次引用
done.
代码大全(第2版)

<==========================284end ==============================>
<==========================285start==============================>

该书下载自-书部落-分享计算机经典巨著!- !--www.shubu.com!仅供试看^
248
第10章使用变量的一般事项
本例中出现的变量的生存时间如下:
recordIndex
(第28行-第2行+1)=27
total
(第69行-第3行+1)=67
done
(第70行-第4行+1)=67
平均生存时间
(27+67+67)/3≈54
下面重写了该示例,从而使得变量引用点之间的距离更近了:
ava示例:变量的生存时间
recordindex 2s recordindex;
初始化从第3行移26 while( recordIndex< recordcount)
到了这里。
27
28 recordIndex= recordIndex+1
对 totald和done的62 total=0:
otal-o:
初始化分别从第63done= false;
4行和第5行移到64 while(done
了这里。
69if total projectedTotal
70
done true;
示例中变量的生存时间如下:
recordIndex
(第28行-第25行+1)=4
total
(第69行第62行+1)=8
done
(第70行-第63行+1)=8
平均生存时间
(4+8+8)/3≈7
直观上看,第二个例子似乎要好于第一个,因为变量的初始化位置离变量的
变量“生存”的更
多内容,请参考使用位置非常近。计算得出二者的变量平均生存时间的差异也非常显著:54比7
《SoftWareEngI《
and ing Metrics的比分为我们选择第二段代码提供了非常好的定量支持。
dels《软
件工程的度量标那么,能通过一项数字来区分存活时间的好坏吗?区分开跨度的优劣吗?研
准与模型》),
contshen sgmore,究人员目前还得不出定量数据,不过都认可同时减少变量跨度和生存时间是个好
and Shen 1986).
主意。
如果你用跨度和生存时间的概念来考察全局变量就会发现全局变量的跨度
和生存时间都很长—这也是要避免使用全局变量的好理由之一。
代码大全(第2版)

<==========================285end ==============================>
<==========================286start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co.com!仅供试看^
10.4作用域
249
General Guidelines for Minimizing Scope
减小作用域的一般原则
以下是一些你可以用来减小作用域的特别有用的原则。
交叉参考关于在循环开始之前再去初始化该循环里使用的变量,而不是在该循环所属的子
在靠近变量使用程序的开始处初始化这些变量这样做以后,当你需要修改循环的时候,会更容
的位置对其初始
化的详细情况,见易记起要对循环的初始化代码做相应的修改。在你随后又修改了程序,并在最初
10.3节“变量初的循环之外增加一层循环之后这样的初始化对整个新循环的每一趟执行都生效,
始化原则”。
而不是仅对其第一趟执行有效。
交叉参考关于
这种变量声明和
直到变量即将被使用时再为其赋值你很可能经历过这样的麻烦,即绞尽脑
定义方式的描述,汁想要找出某个变量究竟是在什么地方赋值的。让变量的赋值位置越明显越好。
见第10.3节中的C++和Java等语言支持如下初始化变量的方式:
“理想情况下,在
靠近第一次使用C++示例:良好的变量声明与初始化
变量的位置声明 int receiptIndex=0
和定义该变量。 float dailyReceipts TodaysReceipts()
double totalReceipts= TotalReceipts( dailyReceipts
交叉参考关于
把相关语句放到一起下面这个例子展示了一个用于总结每日收入的子程
把相关语句集中序,它说明了该怎样把变量的引用点集中起来,以便能更容易找到它们。第一个
放置的详情,参见
第14.2节“顺序例子违背了这一原则:
无关的语句”。C++示例:使用两套变量使人困惑的做法
void SummarizeData( ..
这些语句使用了两 GetNewData( newData,numNewData);
组变量。
total0ldData Sum( oldData, numolaData
totalNewDatasum( newData, numNewDatai
BrintoldDatasummary( o1dData, totaloldData, numoldData i
PrintNewDataSummary newData, totalNewData, numNewData)
SaveolddataSummary( totaloldData, numoldData )
SaveNewDataSummary( totalNewData, numNewData
请注意,在这个例子中,你需要同时跟踪 oldData、 newData、 numolddatas、
numNewData、 totaloldData及 totalNewData小段代码里就有6个变量。
代码大全(第2版)

<==========================286end ==============================>
<==========================287start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
250
第10章使用变量的一般事项
下面这个例子演示如何把每个代码块包含的变量数减少到3个:
C++示例:使用两套变量更容易理解的做法
使用 oldDataGetoldData oldData,numoldData)
组语句。
totaloldData Sum( oldData, numoldData laData)
PrintoldDatasummary( oldData, totaloldData, nu
)
使用 newData GetNewData newData, numNewData
一组语句。
totalNewData =Sum( newData, numNewData
PrintNewDataSummary newData, totalNewDat, numNewData
L SaveNewDataSummary totalNewData, numNewData )
在把这段代码拆分开以后,得到的两段代码都比原代码短,并且各自含有更
少的变量。它们很容易理解,如果你需要把代码拆分成单独的子程序,那么从含
有更少变量的更短小的代码中所拆得的子程序将会更好。
把相关语句组提取成单独的子程序在其他条件相同的情况下,一个更短的
子程序中的变量通常比更长的子程序中的变量有更小的跨度和存活时间。把相关
的一组语句拆分成单独的、更小的子程序,从而缩小变量的作用域。
交叉引用关于开始时采用最严格的可见性,然后根据需要扩展变量的作用域减少变量作
全局变量的更多用域的方法之一就是尽量使变量局部化。与扩充一个作用域小的变量的作用域相
内容局数据”。比,缩减一个已经有很大作用域的变量的作用域是非常困难的换句话说,把
容,见第13.3
节
全局变量转变为类成员变量要比把类成员变量转变成全局变量难得多。把一个
protected数据成员转变为 private数据成员的难度也比逆变化要大。这样一来,当
对变量的作用域犹豫不决的时候,你应该倾向于选择该变量所能具有的最小的作
用域:首选将变量局限于某个特定的循环然后是局限于某个子程序,其次成为
类的 private变量, protected变量,再其次对包(package)可见(如果你用的编程
语言支持包),最后在不得已的情况下再把它作为全局变量。
Comments on Minimizing Scope
有关缩小变量作用域的说明
程序员采用哪种缩小变量作用域的方法,取决于他如何看待“方便性”和“智
力上的可管理性(intellectual manageability)”。有的程序员把很多变量定义为全局
的,因为全局变量访问起来非常方便,而且无须再去考虑与参数列表和类作用域
有关的规则。他们更看重能在任意时间里访问变量所带来的便捷,而不是由此而
带来的风险。
代码大全(第2版)

<==========================287end ==============================>
<==========================288start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww ! --www.shubu.com!仅供试看^
10.5持续性
251
交叉参考缩小
其他程序员更愿意尽可能地使变量局部化,因为这样有助于提高智力上的可
作用域与信息隐管理性。你能够隐藏的信息越多,在同一时间所需要考虑的信息就越少。你需要
藏相关。详情请
见第5.3节中的考虑的信息越少,则忘记某一项信息而犯错误的几率也就越小。
“隐藏秘密(信
息隐藏”
“方便性”和“智力可管理性”两种理念之间的区别,归根结底来源于侧重
写程序还是读程序之间的区别。使作用域最大化可能真的会让程序写起来比较容
易,但相对于子程序功能划分明确的程序,一个允许任何其子程序在任何时间使
用任何变量的程序是更难于理解的。对于这种程序,你不能只去理解一个子程序
你还必须要理解其他所有使用了相同全局数据的子程序才行。这种程序无论阅读、
调试还是修改起来都很困难。
交叉参考使用由此可见,你应该把每个变量定义成只对需要看到它的、最小范围的代码段
访问器子程序的
具体做法见第可见。如果你能把变量的作用域限定到一个单独的循环或者子程序,那是再好不
133节“用访问过的了。如果你无法把作用域限定在子程序里,那么就把可见性限定到某个
器子程序来取代
全局数据”
类内部的那些子程序。如果你无法把变量的作用域限定在对该变量承担最主要的
责任的那个类里面,那么就创建一些访问器子程序来让其他类共享该变量的数据。
这样你就会发现自己极少(如果有的话)需要使用赤裸裸的全局数据。
10.5
Persistence
持续性
“持续性”是对一项数据的生命期的另一种描述。持续性具有多种形态:
特定代码段或子程序的生命期在C++或ava中的for循环里声明的变量就
是这种持续性的例子。
只要你允许,它就会持续下去。在Java,用new创建的变量会一直持续到
它成为垃圾被回收为止。在C++里,用new创建的变量会一直持续到你
delete掉它
程序的生命期。大多数语言的全局变量都属于这一类,C+和Java里的
static变量也是如此
永远持续。这一类变量可能包括你存储在数据库中、能够在程序的多次执行
之间存留的数据。举例而言,如果你有一套户可以自定义屏幕颜色的交互
式程序,就可以把用户指定的颜色保存在文件里,然后在每次程序加载的时
候把它读入。
与持久性相关的最主要问题是变量实际生命期比你想象的要短。变量就像冰
箱里的牛奶样。按理说它应该能保存一星期,但有时它又能保存一个月,而有
代大全(第2版)

<==========================288end ==============================>
<==========================289start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo.c.com!仅供试看^
252
第10章使用变量的一般事项
时保存五天就会变酸。变量的生命期也一样难以预料。如果你试图在一个变量正
常的生命期结束之后访问它的数据,那么它的数值还会保持吗?有的时候变量中
保存的数值已经发酸了,你通过收到错误提示获知这一点。而有时,计算机会把
旧的数值留在变量里,使你误认为自己用对了变量。
为了避免上述问题,可以采取以下措施。
交叉参考在访在程序中加入调试代码或者断言来检查那些关键变量的合理取值。如果变量
问器子程序中加
取值变得不合理,就发出警告信息通知你去寻找是否有不正确的初始化。
便,请阅第13.3准备抛弃变量时给它们赋上“不合理的数值”。例如,你可以在删除一个指
节中的“访问器子
程序的优势”。
针后把它的值设为null
■编写代码时要假设数据并没有持续性例如,如果某个变量在你退出某个子
程序的时候具有特定的值,那么当你下一次进入该子程序的时候就不要假定
该变量还有同样的值。这项原则并不适用于某些语言中确保变量在子程序多
次调用间维持其值的特性,例如C++和Java中的 static
■养成在使用所有数据之前声明和初始化的习惯。如果你发现某项数据的使用
位置与初始化位置相去甚远,那么就要小心了。
Binding Time
绑定时间
对程序维护和更改有很深远影响的一个话题就是“绑定时间”:把变量和它的
值绑定在一起的时间(Thimbleby1988)。这一绑定是发生在编写代码的时候还是
在编译程序时?是在程序加载的时候还是运行的时候?抑或其他时间?
采用越晚的绑定时间会越有利。通常而言你把绑定时间定义得越晚,你的
代码里就包含了越多的灵活性。下面的例子演示了在可能的最早时间,即编写代
码时做绑定:
java示例:在编写代码时绑定其值的变量
titleBar. color =OxFF: / OxFF is hex value for color blue
由于0xFF是硬编码(hard-coded)在程序里的数值,在编写代码的时候它就
会被绑定到 titleBar. Color变量上。这种硬编码技术通常总是很糟糕的,因为
一旦要修改这个0xFF,那么这个新值就无法同代码中其他那些必需和它一样的
0xFF值保持一致了。
下面是一个绑定时间稍微靠后的例子,也就是在代码编译的时候进行绑定:
代码大全(第2版)

<==========================289end ==============================>
<==========================290start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! -www.shubulo.c.com!仅供试看^
10.6绑定时间
253
java示例:在编译时绑定其值的变量
private static final int COLOR_BLUE OxFF:
private static final int TITLEBAR_COLOR =COLOR_BLUE;
titleBar. color TITLE_BAR_COLOR:
TITLE_BAR_COLOR是一个具名常量,编译器会在编译的时候把它替换为一个
数值。如果你用的语言支持这种特性,那么这种方法几乎总要好于硬编码。由于
TITLE_BARCOLOR比0FF更能反映出所代表的信息,因此增加了可读性。它也
使得修改标题栏颜色变得更容易,因为一处改动就能对所有位置生效。同时也不
会影响运行期的性能。
下面举一个晚期绑定的例子,即在运行期绑定:
Java示例:在运行时绑定其值的变量
titleBar.color= ReadTitleBarcolor();
ReadTitleBarColor()是一个能在程序运行期间读入数值的子程序,数值来
源可能是 Microsoft Windows的注册表,也可能来自于一份Java属性文件。
与硬编码相比,上述代码更具可读性和灵活性。无须通过修改程序来改变
titleBar. Color,只需要简单修改 ReadTitleBarColor()子程序要读取的数据
源内容即可。这种方法常用于允许用户自定义应用程序环境的交互式应用程序。
还有另一种绑定时间,即在 ReadTitleBarColor()被调用时进行绑定。这个
子程序要么在程序加载时被一次性调用,要么在每次创建窗体的时候被调用,要
么在每次重绘窗体的时候被调用—这里每种方案的绑定时间都要比前一种晚。
下面对本例中变量与数值相绑定的时间进行一下总结。(具体情况可能会根据
场合的不同而有所变化。)
编码时(使用神秘数值)
■编译时(使用具名常量)
加载时(从 Windows注册表、 Java属性文件等外部数据源中读取数据
对象实例化时(例如在每次窗体创建的时候读取数据)
即时(例如在每次窗体重绘的时候读取数据)
代码大全(第2版)

<==========================290end ==============================>
<==========================291start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor ^.com!仅供试看
254
第10章使用变量的一般事项
一般而言,绑定时间越早灵活性就会越差,但复杂度也会越低。就前两种方
案而言,使用具名常量要在很多方面好于使用神秘数值( magic number),只要养
成了这样的编程习惯,你就可以享受具名常量所带来的灵活性。除此之外,希望
获得的灵活性越强,那么支持这种灵活性的代码就会越复杂,出错几率也会越高
由于成功的软件开发需要依赖于将代码的复杂程度降低到最小,因此一个熟练的
程序员会按照需要引入足够的灵活性来满足软件需求,但是却不会增加需求范围
之外的任何灵活性以及相应的复杂度。
Relationship Between Data Types and Control
10.7
Structures
数据类型和控制结构之间的关系
数据类型和控制结构之间以一种定义明确的方式相互结合,这种方式最早是
由英国计算机科学家 Michael Jackson所描述的(1975)本节将就数据和
控制流之间的常规关系做一个概要性的分析。
Jackson描绘出了三种类型的数据和相应控制结构之间的关系。
交叉考关于
序列型数据翻译为程序中的顺序语句序列型数据( sequential data)是由
顺序语句的详些按照特定顺序使用的数据组成的,如图102所示。如果你在一行中写有五条语
“组织直线型代句,每条语句都负责处理一项不同的数据那么它们就是顺序语句。如果你从文
码”
件中读取了员工的姓名、社会安全号码、住址、电话号码和年龄,你的程序中就
会有负责从文件中读取这些序列型数据的一系列语句。
图10-2序列型数据就是按照一种确定顺序处理的数据
交叉参考关于
选择型数据翻译为程序中的if和case语句一般来说,选择型数据(selective
条件语句的详data)指的是一组数据,这组数据在任一特定时刻有且仅有一项被使用,如图10-3
情,见第15章使
用条件语句”。所示。相应的程序语句必须做出实际的选择,这些语句由if -then- else或case
组成。如果你在开发一套员工薪资程序,可能就需要根据员工付费方式的不同(如
按小时付费和支付固定薪酬)来做不同的处理同样,代码中的模式是符合数据
中的模式的。
代码大全(第2版)

<==========================291end ==============================>
<==========================292start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看^
10.8为变量指定单一用途
255
图10-3选择型数据允许你使用这一项或者那一项,但不会同时使用两者
交叉参考关于
迭代型数据翻译成程序中的for、 repeat、whil等循环结构迭代型数据
循环语句的详
情,见第16章(,6《iteaiveda104《)是需要反复进行操作的同类型的数据,如图10-4所示。迭代型数
“控制循环”。据通常保存为容器中的元素、文件中的记录或者数组中的元素。你可能会从文件
中读出一连串社会安全号码。迭代型数据与负责读取数据的迭代型代码(即循环)
相对应。
图10-4迭代型数据是重复性的
你使用的实际数据可能结合了序列型、选择型和迭代型数据。可以把这些简
单的构造块(《buiIdingbIock《)组合起来以便描述更复杂的数据类型。
0.8
Using Each Variable for Exactly One Purpose
为变量指定单一用途
通过使用一些巧妙的方法,可以给一个变量赋予多种职责。不过你最好还是
远离这些奇技淫巧。
KEY POINT
每个变量只用于单一用途有的时候,在两个不同位置把同一变量用于不同的用
途似乎颇具吸引力。常见的情况是这个变量的命名对于其中某项用途来说不适当,或
者在两个场合使用同一个“临时”变量(其名字通常是毫无帮助的x或者temp)
代码大全(第2版)

<==========================292end ==============================>
<==========================293start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
256
第10章使用变量的一般事项
下面例子显示了一个用于两种用途的临时变量:
C++示例:同一变量用于两种用途糟糕的实践
Compute roots of quadratic equation.
/ This code assumes that (*b-4*a*c) is positive.
DING
temp =Sqrt( b*b -4*a*c
CODIN
HORROR
root[ =(-b+ temp )/ 2* a
/ swap the roots
root01=root1
交叉参考子程
序的每个参数的
问题是:前几行代码中的temp与后几行代码中的temp之间有什么关系?答
用途也应当是唯案是:这两个temp之间毫无关系。在这两个位置使用同一个变量,会使得本无联
一的。第7.5节
“如何使用子程系的两者看上去似乎彼此相关。如果为两种用途各建一个变量,就能增加代码的
序参数”详细讨可读性。下面是改进后的代码:
论了子程序参数
的使用。
C++示例:两个变量用于两种用途良好的实践
1/ Compute roots of a quadratic equation.
This code assumes that (b*b-4+a*c) is positive.
discriminant -=Sart( b**a*c
root[o=(-b+ discriminant(2a)
root[=(-b- discriminant )/(2* a
swan the roote
/1 swap the roots
oldRoot root [01
root [] =root [1]
root [1] =oldRoot;
避免让代码具有隐含含义把同一变量用于多个用途的另外一种方式是当变
量代表不同事物时让其具有不同的取值集合。例如:
变量 pageCount的取值可能表示已打印纸张的数量,除非它等于-1,在这
种情况下表明有错误发生;
CODING
HORROR
变量 customerId可能代表某个客户账号,除非它的取值大于50000,在
这种情况下,你通过减去500000来得到过期账户的号码;
变量 bytesWritten可能表示写入输出文件的字节数,除非它的取值为负,
在这种情况下它表示的是用于输出的磁盘驱动器的号码。
代码大全(第2版)

<==========================293end ==============================>
<==========================294start==============================>

该书下载自-书部落-分享计算机经典巨著!www. !--www.shubul.com!仅供试看^
10.8为变量指定单一用途
257
应该避免使用具有这种隐含含义的变量。这种滥用在技术领域里被称为“混
合耦合(hybrid coupling)"(age- -Jones1988)。这样的变量用于两种以上的用途,
也就意味着其类型对于其中的任何一项任务而言都是错误的。在 pageCount例
中, pagecount在正常情况下表示纸张的数目;这种情况下它是一个整数。然而
当 pageCount等于-1时,它表明有错误发生了;整数类型客串了布尔类型!
即使你对这种双重用途很清楚,别人也会感到模糊。使用两个变量保存两种
信息,能带来更多的清晰度。同时,没有人吝惜你多用的那一点存储空间。
确保使用了所有已声明的变量与同一变量多种用途相反的是声明了变量却
不使用。Card、 Church和 Agresti所做的一份研究表明,未引用的变量数量与错误
HARD DATA率呈正相关(1986)。请养成检查代码以确认使用了所有声明过的变量的习惯。一
些编译器和工具(如lint)会就未用到的变量给出警告。
cc20.com/1092  checklist: general  considerations In Using Data
交叉参考关于核对表:使用数据的一般事项
针对特点数据类
型的核对表,请看
第12章中的“基初始化变量
于如何为变量命口每一个子程序都检查其输入参数的正确性吗?
名的检查表,请看
第11章中的“变
口变量声明位置靠近变量第一次使用的位置吗?
量名的力量”
口尽可能地在声明变量的同时初始化变量吗?
如果无法同时声明和初始化变量,有没有在靠近第一次使用变量的位置
声明变量?
计数器和累加器经过了适当的初始化吗?如果需要再一次使用,之前重
新初始化了吗?
口适当地重新初始化“需要重复执行的代码里的变量”了吗?
口代码在通过编译器编译的时候是不是没有警告信息?(你启用了所有可
用的警告选项了吗?)
口如果你用的语言允许隐式声明,你为由此可能引发的问题做好补偿措施
了吗?
使用数据的其他事项
口如果可能,所有变量都被定义为具有最小的作用域吗?
口各变量的引用点都尽可能集中在一起吗?对同一变量的两次相邻引用,
或者变量的整个生命期都这样做了吗?
口控制结构符合数据类型吗?
所有声明的变量都用到了吗?
代大全(第2版)

<==========================294end ==============================>
<==========================295start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com!^ ^.com!仅供试看
258
第10章使用变的一般事项
口变量都在合适的时间绑定了吗?也就是说,你有意识地在晚期绑定
所带来的灵活性和增加的复杂度之间做出平衡了吗?
口每个变量都有且仅有一项用途吗?
口每个变量的含义都很明确且没有隐含含义吗?
Key Points
要点
数据初始化过程很容易出错,所以请用本章描述的初始化方法来避免由于非
预期的初始值而造成的错误。
最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在
子程序或类的范围之内避免使用全局数据。
把使用和同变量的语句尽可能集中在一起。
早期绑定会减低灵活性,但有助于减小复杂度。晚期绑定可以增加灵活性,
同时增加复杂度。
把每个变量用于唯一的用途。
代码大全(第2版

<==========================295end ==============================>
<==========================296start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
The Power of Variable Names
第11章
变量名的力量
cc2.com/1184内容
11.1选择好变量名的注意事项:第259页
11.2为特定类型的数据命名:第264页
11.3命名规则的力量:第270页
11.4非正式命名规则:第272页
11.5标准前缀:第279页
11.6创建具备可读性的短名字:第282页
11.7应该避免的名字:第285页
相关章节
子程序名字:第7.3节
■类的名字:第6.2节
使用变量的一般事项:第10章
格式化数据声明:第31.5节中的“数据声明的布局”
注释变量:第32.5节中的“注释数据声明”
尽管讨论如何为变量取好的名字与讨论如何高效编程同样重要,我却还没看到
任何资料能将创建好的名字的诸多注意事项涵盖一二。很多编程教科书只用几段的
篇幅讲讲如何选择缩写,几句老生常谈,指望你自己解决这个问题。而我却要反其
道而行之:就如何取一个好的名字给你大量的信息,多得你可能根本都不会用到!
本章所述原则主要适用于为变量对象和基本数据一命名。不过它们也
适用于为类、包、文件以及其他的编程实体命名。有关如何为子程序命名请参阅
第7.3节“好的子程序名字”。
Considerations in Choosing Good Names
选择好变量名的注意事项
你可不能像给狗取名字那样给变量命名仅仅因为它很可爱或者听上去不
错。狗和狗的名字不一样,它们是不同的东西,变量和变量名就本质而言却是同
一事物。这样一来,变量的好与坏就在很大程度上取决于它的命名的好坏。在给
变量命名的时候需要小心谨慎。
代码大全(第2版)

<==========================296end ==============================>
<==========================297start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
260
第11章变量名的力量
下面举一个使用了不良变量名的例子:
Java示例:糟糕的变量名
xxxfido+ SalesTax(fido)
x=x+ LateFee(x1,x+xxxi
HORROR x Interest( x1, x
这段代码究竟在做什么?x1、xx和xxx代表什么?fido又是什么意思?假
如说有人告诉你这段代码基于一项余额和一组新开销来计算一位顾客的支付总
额,那么你应该使用哪个变量来为该顾客的那组新的花销打印账单呢?
下面是这些代码的另一种写法,它可以使上述问题回答起来非常容易:
java示例:良好的变量名t
balance balance last paymenti
monthlyTotalnewPurchases+ SalesTax
balance balance+ LateFee( customerID, balance+ monthlyTotal
balance balance+ Interest customerID, balance)
从上述两段代码的比较中可以看出,一个好的变量名是可读的、易记的和恰
如其分的。你可以通过应用多条原则来实现这些目标。
The Most Important Naming Consideration
最重要的命名注意事项
为变量命名时最重要的考虑事项是,该名字要完全、准确地描述出该变量
所代表的事物。获得好名字的一种实用技巧就是用文字表达变量所代表的是什
KEY POINT
么。通常,对变量的描述就是最佳的变量名这种名字很容易阅读,因为其中
并不包含晦涩的缩写,同时也没有歧义。因为它是对该事物的完整描述,因此
不会和其他事物混淆。另外,由于这一名字与所表达的概念相似,因此也很容
易记忆。
对于一个表示美国奥林匹克代表团成员数量的变量,你可能会把它命名为
numberof PeopleOnTheUsolympicTeam表示运动场中坐椅数量的变量可能会
命名为 numberof Seat sInThestadium。表示某国代表团在现代奥运会上获得的
最高分数的变量可能会命名为 maximumNumberof
表示当前利率的变量最好命名为rate或 interestRate,而不是r或x你明
白了吧。
代码大全(第2版)

<==========================297end ==============================>
<==========================298start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看
11.1选择好变量名的注意事项
261
请留意上述这些命名所共有的两个特征。首先,它们都很容易理解。事实上
它们根本不需要什么解释,因为你可以很轻松地读懂它们。不过第二点,有些名
字太长了长得很不实用。下面我很快就会讲到变量名的长度问题。
表11-1中给出了更多变量名称的例子,其中有好的也有差的。
表11-1更多变量名的例子,其中有好的也有差的
变量用途
好名字,好描述
坏名字,差描述
到期的支票
written,ct, checks, CHKTTL,,
累计额
runningTotal, checkTotal
x1,x2
高速列车的 velocity, trainVelocity,velt,v,tv,x,x,x2,train
运行速度 velocityInMph
当前日期 current Date, todaysDate cd, current,c,x,x1,x2,date
每页的行数1 linesPerPage
1pp, lines, 1, x, x1, x2
currentDate和 todaysDate都是很好的名字,因为它们都完全而且准确地
描述出了“当前日期”这一概念。事实上,这两个名字都用了非常直白的词。程
序员们有时候会忽视这些普通词语,而它们往往却是最明确的。cd和c是很糟的
命名,因为它们太短,同时又不具有描述性。 current也很糟,因为它并没有告
诉你是当前什么。date看上去不错,但经过最后推敲它也只是个坏名字,因为这
里所说的日期并不是所有的日期均可,而只是特指当前日期;而date本身并未表
达出这层含义。、1和x2永远是坏名字传统上用代表一个未知量;如果
不希望你的变量所代表的是一个未知量,那么请考虑取一个更好的名字吧。
名字应该尽可能地明确。像x、temp、i这些名字都泛泛得可以用于多种目的,
它们并没有像应该的那样提供足够信息,因此通常都是命名上的败笔。
KEY POINT
Problem Orientation
以问题为导向
一个好记的名字反映的通常都是问题,而不是解决方案。一个好名字通常表
达的是“什么”(what),而不是“如何”(how)一般而言,如果一个名字反映了
计算的某些方面而不是问题本身,那么它反映的就是“how”而非“what”了。请
避免选取这样的名字,而应该在名字中反映出问题本身。
一条员工数据记录可以称作 inputRec或者 employeeData inputRec是一
个反映输入、记录这些计算概念的计算机术语 employeeData则直指问题领域,
与计算的世界无关。与此类似,对一个用于表示打印机状态的位域来说, bitFlag
就要比 printerReady更具计算机特征。在财务软件里, calcval1的计算痕迹也
要比sum更明显。
代码大全(第2版)

<==========================298end ==============================>
<==========================299start==============================>

该书下载自书部落分享计算机经典巨著!--www. !--www.shubulo.com!^ .com!仅供试看
262
第11章变量名的力量
Optimum Name Length
最适当的名字长度
变量名的最佳长度似乎应该介于x和 maximumNumk-
Olympics之间。太短的名字无法传达足够的信息如x1和x2这样的名字所存
在的问题是,即使你知道了x代表什么,你也无法获知x1和x2之间的关系。太
长的名字很难写,同时也会使程序的视觉结构变得模糊不清。
Gorla、 Benander和 Benander发现,当变量名的平均长度在10到16个字符
的时候,调试程序所需花费的气力是最小的(1990)平均名字长度在8到20个
HARD DATA字符的程序也几乎同样容易调试这项原则并不意味着你应该尽量把变量名控制
在9到15或者10到16个字符长。它强调的是,如果你查看自己写的代码时发现
了很多更短的名字,那么你需要认真检查,确保这些名字含义足够清晰。
你可能已经通过 Goldilocks--and-the- Three--Beas(金发姑娘与三只小熊的经典
通话,寓意权衡比较)的方法理解了如何为变量命名,正如表11-2所示。
表11-2变量名太长、太短或刚好合适的示例
一
太长:
numberof PeopleOnTheUsolympicTcam
numberofSeatsInThestadium
aximumNumberofPointsInModernolympics
太短:
n,rp,ntm
n, ms, nsisa
m,m,max, points
正好:
numTeamMembers, teamMembercount
numSeatsInStadium, seatCount
teamPointsMax, point sRecord
The Effect of Scope on Variable Names
变量名对作用域的影响
交叉参考关于短的变量名总是不好吗?不不总是这样。当你把一个变量名取得很短的时
作用域的详细讨
论,见第10.4候,如i,这一长度本身就对该变量做出了一些说明也就是说,该变量代表
“作用域”的是一个临时的数据,它的作用域非常有限。
阅读该变量的程序员应该会明白,这一数值只会用于几行代码之内。当你把
变量命名为的时候,你就是在表示,“这是一个普通的循环计数器或者数组下标,
在这几行代码之外它没任何作用。
”
w.j.Hansen所做的一项研究表明,较长的名字适用于很少用到的变量或者全
同变量,而较短的名字则适用于局部变量或者循环变量(Shneiderman1980)不
过,短的变量名常常会带来一些麻烦,因此,作为一项防御式编程策略,一些细
代码大全(第2版)

<==========================299end ==============================>