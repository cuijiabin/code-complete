<==========================100start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. --www.shubulo.co.com!仅供试看^
4.1选择编程语言
63
某些语言更能表达编程中的各种概念。你可以将自然语言(如英语)和编程
语言(如Java和C++)做一个类比。对于自然语言,语言学家Sapir和 Whorf对
“语言的表达能力”和“思考的能力”之间的关系提出了一个假说。 Sapir-Whorf-
假说是,你思考的能力取决于你是否知道能够表达该思想的词汇。如果你不知道
这些词汇,就无法表达出这种思想,甚至可能不能形成这种思想(Whorf1956)
程序员同样受到所用编程语言的影响。在一种编程语言中可用来表达编程思
想的词汇,亳无疑问地决定了你将如何表达你的思想,甚至可能决定了你能表达
什么样的思想。
编程语言影响程序员的思维的证据随处可见典型的故事类似下面的样子:
“我们用C++编写一个新系统,但是大多数程序员没有太多C++经验。他们具有
Fortran语言背景他们编写出能用C++编译的代码,但实际上编写的是伪装成C++
的 Fortran代码。他们扭曲C++来模拟Fortran的不良特性(例如goto语句和全局
数据)并且忽略了C++丰富的面向对象能力”这种现象多年来在整个行业当中随
处可见(Hanson1984, Yourdon1986a)
Language Descriptions
语言描述
某些语言的发展历史(和它的总体能力)很有意思以下描述了现今最常见
的若干种语言。
Ada
Ada
Ada是种通用的高级编程语言,基于 Pascal它开发受到美国国防部的资助
尤其适合实时及嵌入式系统。Ada强调数据抽象与信息隐藏,强制要求程序员区分每
个类(class)和包(package)的公用(public)部分和私用(private)部分。选择“ada”
作为语言的名称,是为了纪念Ada Lovelace一位数学家,人家将她尊为世界上首
位程序员。2目前Ada主要用在事、航天及航空电子系统中。
Assembly Language
汇编语言
汇编语言一又称“汇编”——是一类低级语言,它的每条语句对应一条机器指
令。因为其语句对应于特定机器的指令,所以一汇编语言是针对一种特定处理器的
例如,针对 Intel CPU或者针对 Motorola CPU.汇编被认为是第二代语言。大多
数程序员避免使用汇编,除非为了冲破“执行速度或“代码大小”的限制
2译注:Ada是英国诗人拜伦之女。
代大全(第2版)

<==========================100end ==============================>
<==========================101start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
64
第4章关键的“构建”决策
cc
C是一种通用(general purpose)的中级语言(mid--level language),它最初与
UNIX操作系统紧密关联。C具有某些高级语言的特征,例如结构化的数据、结构
化的控制流程、机器无关性以及一套丰富的运算符。它也被称为“可移植的汇编
语言(protable assembly language)”,因为其中大量使用指针和地址,具有某些低
级的构件(如位操作),而且是弱类型的(weakly typed)
C语言是20世纪70年代在 Bell Labs开发的其最初设计为在 DEC PDP--11
小型机上使用,这种机器的操作系统、C编译器和UNIX应用程序全都用C编写
1988年,C语言的ANSI标准发布,该标准1999年又做了修订。在20世纪80年
代和90年代,C语言是微型计算机和工作站程序设计的事实标准。
c++
++
C++是一种面向对象(object-oriented)的语言,基于C语言,它是20世纪
80年代 Bell在 Laboratories开发的。除了与C兼容之外,C++还提供了类、多态、
异常处理、模板,而且提供比C语言更健壮的类型检查功能。它还提供了一套内
容广泛而强大的标准库。
C#
c#是一种通用的面向对象语言和编程环境,由 Microsoft开发,语法类似C、
C++和Java,它提供了大量的工具,帮助在 Microsoft平台上进行开发。
Cobol
Cobol
Cobol是一种像英语的编程语言,原本是为了美国国防部的使用在1959-1961
年间开发的。 Cobol主要适于商业应用,而且今天仍然是用得最广泛的语言之
其流行程度仅次于 Visual Basic( Feiman and Driver2002)这些年来obol一直在
更新,已经包含了数学函数和面向对象的能力。“Cobol”是“COmmon
Business-Oriented Language(面向商业的通用语言)的首字母缩写。
Fortran
Fortran
Fortran是第一个高级计算机语言,引入了“变量”和“高级循环”的概念。
“Fortran”代表“FORmula TRANslation(公式翻译),最早开发于20世纪50年
代,而且有若干重要的修订版,包括1977年的 Fortran77,加入了块结构的
if-then-else语句和字符及字符串处理功能 Fortran90加入了用户定义的数据类型、
指针、类,以及一套丰富的数组运算。 Fortran主用在科学和工程应用中
代码大全(第2版)

<==========================101end ==============================>
<==========================102start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
4.1选择编程语言
65
Java
Java
Java是一种面向对象的语言,语法类似C和C+,由 Sun Microsystems,inc.开发
Java设计为能在任何平台上运行,办法是将Jav源代码转变为字节码(byte code),
然后让后者在各个平台上的虚拟机环境中运行ava广泛用于web应用的编程
JavaScript
JavaScript
JavaScript是一种解释执行的脚本语言,最初与Jva略有关系。它主要用于做
客户端编程,例如为Web页面增加简单的功能及在线应用程序。
Perl
Perl
Perl是一种处理字符串的语言,基于C和若干UNIX工具程序。Per常用于
系统管理任务,诸如创建生成脚本(《bui1dscits《,也用于生成及处理报表。它也
可用来创建Web应用程序,例如 Slashdot“Perl”“Practical Extraction and Report
Language(实用摘要及报告语言)”的首字母缩写。
PHP
PHP
PHP是一种开源的脚本语言,具有与Perl、 Bourne Shell、 JavaScript、C类
似的语法。PHP能在所有主要的操作系统上运行,用来执行服务器端的交互功
能。它也能嵌入Web页面中,用来访问及呈现数据库信息。“PHP”原来代表
“Personal Home Page(个人主页)”,现在代表“php: Hypertext Processorphp
超文本处理器)”。
Python
Python
Python是一种解释性的、交互式的面向对象语言能在多种环境中运行。它
最常见的用处是编写脚本和小型Web应用程序,也支持创建更大型的程序。
SQL
SQL
SQL语言是查询、更新、管理关系数据库的事实标准“SQL”代表“Structured
Query Language(结构化查询语言)”。与本节列出的其他语言不同,SQL是“声
明式”语言,意思是说,它不是定义一系列操作,而是定义某些操作的结果。
Visual Basic
Visual Basic
最初的 Basic是20世纪60年代在 Dartmouth学院开发的一种高级语言 BASIC
是“Beginner'sall- purpose Symbolic Instruction Code(初学者通用符号指令码)
代码大全(第2版)

<==========================102end ==============================>
<==========================103start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
66
第4章关键的“构建”决策
的首字母缩写。 Visual Basic是一种高级的面向对象的可视化 Basic语言,由
Microsoft开发,最初设计是为了创建 Microsoft Windows应用程序,它经过扩展,
可以定制桌面应用程序(如Microsoft Office)、创建Web程序,以及其他应用。
专家们报告说,在21世纪初期,使用 Visual Basic的专业开发人员比用其他任何
语言的都多(Feiman and Driver2002)
Programming Conventions
编程约定
交叉引用关于
在高质量软件中,你可以看到“架构的概念完整性”与“其底层实现”之间
“约定的威力的的关系。“实现”必须与(指导该实现的)“架构”保持致,并且这种一致性是
更多细节,见第
11.3115节内在的、固有的。这正是变量名称、类的名称、子程序名称、格式约定、注释约
定等这些针对“构建活动”的指导方针的关键所在。
在一个复杂的程序中,架构上的指导方针使得程序的结构平衡,针对“构建
活动”的指导方针则提供了底层的协调,将每个类(class)都衔接到一种完整的
设计(comprehensive design)中,成为其可靠的部件任何大型的程序都需要
个控制结构,该结构可以统一编程语言的细节。大型结构的部分魅力在于,各个
具体部件都能反映整体架构的内涵。假如没有一种统一的规则,你创作出来的东
西将会充斥着各种不同的风格,显得混乱而邋这些不同的风格将使你的大脑
承受沉重负担一而这仅是为了理解不同编程风格之间的(本质上是随意的)
差异。成功编程的一个关键就在于避免随意地变化,这样你的大脑可以专注于那
些真正需要的变化。关于这方面的更多信息,见第5.2节“软件的首要技术使命:
管理复杂度”。
如果你有一个很好的绘画设计,但是其中一部分是古典主义的,一部分是印
象主义的,部分是立体主义的,这将会是什么样的呢?无论你再怎么遵循这个
宏伟的设计去做,它都不可能具有“概念完整性”,它看起来就像是一幅拼贴画。
程序也同样需要底层的完整性。
在“构建”开始之前,讲清楚你使用的编程约定。编码约定的细节要达到这
样的精确度:在编写完软件之后,几乎不可能改变(翻新)软件所遵循的编码约
KY POINT定本书随处都有这样的约定细节。
Your Location on the Technology Wave
你在技术浪潮中的位置
在我的职业生涯中,我看到了PC之星的升起和大型机之星的陨落,我看到
图形用户界面程序代替了字符界面程序,我还看到了Web的崛起和 Windows的衰
代码大全(第2版)

<==========================103end ==============================>
<==========================104start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubulo.com!仅供试看^
4.3你在技术浪潮中的位置
67
落。我只能假设当你读到这本书的时候,又会有某些新的技术蒸蒸日上,而我今
天(2004年)所知道的Web编程将会慢慢消失。这些技术周期(或者说是技术浪
潮)意味着不同的编程实践,编程实践取决于你在技术浪潮中所处的位置。
在成熟的技术环境下浪潮的末尾,例如21世纪最初10年的中期的网络
编程我们受益于丰富的软件开发基础设施。在浪潮的后期,我们有大量的编
程语言可供选择,拥有能对这些语言的代码进行完善的错误检查的工具、强大的
调试工具以及自动的可靠的性能优化工具。编译器几乎没有bug各种工具都有
很好的文档,它们来自具提供商、第三方书籍文章以及大量的Web资源。各种
工具集成在一起,因此可以在单个开发环境里面设计用户界面、数据库、报表、
业务逻辑等。如果确实遇到问题了,很容易就可以在常见问题列表(FAQ)中找
到对工具的各种古怪行为的描述。此外,还有许多顾问可供咨询,训练课程也随
处可见。
在技术浪潮的前期例如20世纪90年代中期的网络编程情况正好相
反。可选择的编程语言非常少,而那些语言往往有很多bug并且文档也很糟糕
程序员花费了大量时间,仅仅是为了弄清楚语言如何工作,而非编写新的代码。
程序员还花费无数的时间来绕过(work around)语言产品的bug、下层操作系统
的bug以及其他工具的bug。浪潮早期的编程工具往往很原始可能根本没有调
试器,编译器优化在某些程序员的眼中还仅是一种对未来的期盼。工具供应商经
常修订编译器的版本,而每一个新的版本似乎都破坏了你代码中的某些重要部分
具还没有集成起来,所以你往往需要使用不同的工具完成用户界面、数据库、
报表、业务逻辑的设计。不同工具很可能互不兼容,你需要花费大量的精力,与
编译器和函数库的新发布版本所带来的冲击抗衡而这么做仅仅为了保持代码现
有的功能。如果你遇到了麻烦,在网上可以找到某种形式的参考文献,但它不总
是可靠的;而且如果可用的文献是一本指南,那么每次你遇到麻烦的时候,你总
觉得像是第一个遇到这种问题的人。
这些评论看起来似乎在建议:应该避免在浪潮的早期搞编程,但这并不是我
的意思。一些最具创造力的应用程序就是从浪潮早期的程序中涌现出来的,例如
Turbo Pascal、 Lotus1 123、 Microsoft Word、 Mosaic浏览器。关键在于,“你如何面
对自己的编程工作”,取决于你在技术浪潮中所处的位置。如果处在浪潮的后期,
你就可以计划用大部分时间稳定持续地编写新功能。如果你处在浪潮的前期,可
以预期你将要花很大部分时间,用来找出文档中未加说明的编程语言特性、调
试程序库代码缺陷带来的错误、修订代码以适应厂商提供的新版本函数库等。
如果你正在一个很初级(简陋)的环境下工作你会发现,与成熟的环境相
比,本书介绍的编程实践将更有帮助。正如 David Gries所言,编程工具不应该决
代大全(第2版)

<==========================104end ==============================>
<==========================105start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
68
第4章关键的“构建”决策
定你的编程思路(1981) Gries对“在一种语言上编程( programming in language)
和“深入一种语言去编程(programming into language)”做了区分“在一种语
言上编程”的程序员将他们的思想限制于“语言直接支持的那些构件”。如果语言
工具是初级的,那么程序员的思想也是初级的。
“深入一种语言去编程”的程序员首先决定他要表达的思想是什么,然后决
定如何使用特定语言提供的工具来表达这些思想。
Example of Programming into a Language
“深入一种语言去编程”的例子
在 Visual Basic的早期,我想把产品中的业务逻辑、用户界面、数据库分离开,
但没能做到,因为语言中没有任何内置的方法能做到这一点。我知道如果不小心
处理的话,过段时间某些 Visual Basic“窗体form”就会包含业务逻辑,某些会
包含数据库代码,而一些窗体可能两者都不包含最后我可能再也记不清楚哪
段代码放在哪个地方了。当时我刚刚完成了一个C+项目,该项目里没能很好地
分离这些功能,我不想再用另一种语言尝试一遍这种令人头痛的事情。
因此,我采用了一种设计约定,即只允许frm文件(窗体文件)从数据库读
取数据或者将数据存入数据库。不允许数据直接通向程序的其他部分。每个窗体
都有一个 IsFormCompleted()子程序,其他子程序调用它来判断当前激活的那个
窗体是否已经保存了自己的数据。 IsFormCompleted()是窗体允许拥有的唯一的
公用( public)子程序。同时不允许窗体包含任何业务逻辑。所有其他代码必须放
在对应的bas文件中,包括检查窗体中数据的有效性的代码。
Visual Basic并不鼓励这种方法,它鼓励程序员把尽可能多的代码放在frm文
件中,并且,“在frm文件中回调对应的.bs文件中的子程序”也不容易。
这一约定虽然非常简单,但是随着项目的深入,我发现它给了我很大帮助;
假如没有这一约定,我将写出很多纠缠而费解的代码。假如没有这一约定,我也
许就会加载某个窗体之后不显示它,只为调用其中检查数据有效性的子程序;或
者我也许会将窗体中的代码复制到其他地方然后维护这些分布在各处的功能相
的代码。 IsFormCompleted()约定同样使得事情变得简单。因为每个窗体都以
完全相同的方式工作,我不需要预测 IsFormCompleted)的语义每次用到它
都代表相同的意思。
代码大全(第2版)

<==========================105end ==============================>
<==========================106start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
4.4选择主要的构建实践方法
69
Visual Basic并不直接支持这种约定,但是我使用了这一简单的编程约定一
深入一种语言去编程—补偿了语言当时的结构缺陷,并且使得该项目易于管理。
理解“在一种语言上编程”和“深入一种语言去编程”的区别对于理解本
书是至关重要的。大多数重要的编程原则并不依赖特定的语言,而依赖于你使用
KEY POIT语言的方式。如果你使用的语言缺乏你希望用的构件,或者倾向于出现其他种类
的问题,那就应该试着去弥补它。发明你自己的编码约定、标准、类库以及其他
改进措施。
4.4选择主要的构建实践方法
Selection of Major Construction Practices
“构建”有一部分准备工作,就是决定在这么多的可选的实践方法中,你
想要强调哪些。某些项目使用结对编程以及测试驱动开发,而其他项目使用单
人开发和形式化检查。这两种技术组合都有可能发挥作用,取决于项目的特定
环境。
下面的核对表总结了在“构建”过程中,应该有意识地使用或者排斥的特定
编程实践。这些实践的细节遍布全书。
Checklist: Major Construction Practices
cc2e.com/0496
核对表:主要的构建实践
编码
口你有没有确定,多少设计工作将要预先进行,多少设计工作在键盘上进
行(在编写代码的同时)?
口你有没有规定诸如名称、注释、代码格式等“编码约定”?
口你有没有规定特定的由软件架构确定的编码实践,比如如何处理错误条
件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循
哪些标准、在编码时考虑多少性能因素等?
口你有没有找到自己在技术浪潮中的位置,并相应调整自己的措施?如果
必要,你是否知道如何“深入一种语言去编程”,而不受限于语言(仪
仅“在一种语言上编程”)?
团队工作
口你有没有定义一套集成工序即,你有没有定义一套特定的步骤,规
定程序员在把代码 check in(签入)到主源码(代码库)中之前,必须
履行这些步骤?
口程序员是结对编程、还是独自编程,或者这二者的某种组合?
代大全(第2版)

<==========================106end ==============================>
<==========================107start==============================>

该书下载自-书部落-分享计算机经典巨著- ! --www.shubulo.com^.com!仅供试看
70
第4章关键的“构建决策
交叉引用关于质量保证
质量保证的更多
细节,请见第20口程序员在编写代码之前,是否先为之编写测试用例?
章“软件质量概
述”。
口程序员会为自己的代码写单元测试吗(无论先写还是后写)?
口程序员在 check in代码之前,会用调试器单步跟踪整个代码流程吗?
口程序员在 check in代码之前,是否进行集成测试(integration--tes)?
口程序员会复审(review)或检查别人的代码吗?
交叉引用关于工具
工具的更多细节,
请见第30章“编口你是否选用了某种版本控制工具?
程工具”
口你是否选定了一种语言,以及语言的版本或编译器版本?
口你是否选择了某个编程框架( framework,j2ee或 Microsoft.T)
或者明确地决定不使用编程框架?
口你是否决定允许使用非标准的语言特性?
口你是否选定并拥有了其他将要用到的工具编辑器、重构工具、调试
器、测试框架(test framework)、语法检查器等?
Key Points
要点
每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
在开始编程之前,做好一些约定(convention)。“改变代码使之符合这些
约定”是近乎不可能的。
“构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择
最适合你的项目的实践方法。
问问你自己,你采用的编程实践是对你所用的编程语言的正确响应,还是受
它的控制?请记得“深入一种语言去编程”,不要仅“在一种语言上编程”。
你在技术浪潮中的位置决定了哪种方法是有效的甚至是可能用到的确
定你在技术浪潮中的位置,并相应调整计划和预期目标。
代码大全(第2版)

<==========================107end ==============================>
<==========================108start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
第2部分
Creating High-Quality Code
创建高质量的代码
本部分内容
■第5章软件构建中的设计
.73
■第6章可以工作的类
.125
■第7章高质量的子程序
161
■第8章防御式编程
.187
■第9章伪代码编程过程
215
代码大全(第2版)

<==========================108end ==============================>
<==========================109start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看

<==========================109end ==============================>
<==========================110start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
Design in Construction
第5章
软件构建中的设计
ce.com/0578内容
5.1设计中的挑战:第74页
5.2关键的设计概念:第77页
5.3设计构造块:启发式方法:第87页
5.4设计实践:第110页
■5.5对流行的设计方法的评论:第118页
相关章节
软件架构:第3.5节
可以工作的类:第6章
高质量的子程序:第7章
■防御式编程:第8章
■重构:第24章
■程序规模对构建的影响:第27章
或许有人会认为设计并不是软件构建中的一个活动。然而在小型项目里,有
很多活动都算作构建活动,其中也常常包含了设计。在一些更大的项目里,正规
的架构可能只是解决了系统级的事项,而特意把大部分的设计工作留到构建阶段
去做。在另外一些大型项目中,设计可能会详细到能够让编码工作近乎机械化,
但很少有如此完整的设计—程序员通常也要对部分程序进行设计,也许是正式
的,也许不是。
交叉参考有关
大型项目和小型
在小型的、非正式的项目里,很多的设计工作是程序员坐在键盘前完成的。
项目中所要求的这里的“设计”可能就是指在编写具体代码之前先用伪代码写出一个类的接口,
不同层次的正规也可能就是在编码之前画出几个类之间的关系图,还可能就是询问另一位程序员
性,请详见第27
章“程序规模对用哪个设计模式会更好。无论是以何种方式来进行设计,小型项目也能和大型项
构建的影响”。目一样从精心的设计之中获益,而如果能认识到设计是一项明确的活动,你就更
会获益匪浅。
代码大全(第2版)

<==========================110end ==============================>
<==========================111start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
74
第5章软件构建中的设计
设计是个庞大的话题,而这一章只能涵盖其中的少数侧面。一个好的类或子
程序的设计在很大程度上是由系统的架构所决定的,因此,请确保第3.5节中所
论述过的架构先决条件已经满足。更多的设计工作是在个别的类和子程序这个层
次上完成的,第6章“可以工作的类”,以及第7章“高质量的子程序中会分别
予以介绍。
如果你对软件设计方面的话题已经很熟悉,可以只看这些重点部分—第5.1
节关于设计中的挑战,以及第5.3节中关键的启发式方法。
Design Challenges
设计中的挑战
交叉参考关于
“软件设计”一词意味着去构思、创造或发明一套方案,把一份计算机软件
启发式过程和确的规格说明书要求转变为可实际运行的软件设计就是把需求分析和编码调试连
别,请参见第2在一起的活动。好的高层次设计能提供一个可以稳妥容纳多个较低层次设计的结
章“用隐响来更构。好的设计对于小型项目非常有用,对于大型项目就更是不可或缺。
充分地理解软件
开发”。
设计也会面临大量的挑战,这正是本节将要概述的内容。
Design Is a Wicked Problem
设计是一个险恶的问题
希望软件设计师
根据 Horst Rittel和 Melvin Webber的定义,“险恶的(wicked)”问题就是那
用种理性的不种只有通过解决或部分解决才能被明确的问题(1973)这个看似矛盾的定义其实
会犯错的方式从
需求说明中推导是在暗示说,你必须首先把这个问题“解决”一遍以便能够明确地定义它,然后
有哪个系统是用发中存在数十年了(Peters and Tripp1976这一
根木就不现实。没再次解决该问题,从而形成一个可行的方案。这一过程已经如影随形地在软件开
这种方式设计出
来的,以后也不可
在我所了解的世界中,最引人注目的一个关于这类险恶问题的例子,就是原
能有即便是教科来 Tacoma Narrows大桥的设计问题了。在建这座大桥的那个时期,设计一座桥梁
书和论文中的小
型程序开发也是时考虑的主要问题就是它是否足够结实以承受设计负荷。然而对于 Tacoma
不的。它们都 Narrows这座桥而言,大风给它带来了出乎意料的横向谐波。在1940年狂风大作
是经过修订和修
饰的,直到作者让的某一天,这种谐波越来越大且不可控制,从而让大桥最终坍塌,如图5-1所示。
我们看到他想要
做到的结果,因而
这是一个险恶问题的好例子,因为直到这座桥坍塌,工程师们才知道应该充
是不可能在实际分地考虑空气动力学的因素。只有通过建造这座大桥(即解决这个问题),他们才
中发生的过程。能学会从这一问题中应该额外考虑的环节,从而才能建造出到现在依然立不倒
Dayld Pomas和
Paul Clarments的另一座桥梁。
代码大全(第2版)

<==========================111end ==============================>
<==========================112start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^.com!仅供试看^
5.1设计中的挑战
75
图5-1 Tacoma Narrows大桥一个险恶问题的实例
你在学校中所开发的程序和你在职业生涯中所开发的程序的主要差异就在
于,学校里的程序所解决的设计问题很少(如果有的话)是险恶的。学校里给你
的编程作业都是为了让你能从头到尾直线前进而设计的。如果有位老师给你一份
编程作业,你刚完成设计时他就把作业的要求改了,然后就在你将要提交完整的
程序时,他又对作业的要求再次改动,这时你肯定会十分生气。然而这一过程正
是在专业编程中每日可见的真实情形。
Design Is a Sloppy Process(Even If it Produces a Tidy Result)
设计是个了无章法的过程(即使它能得出清爽的成果)
深入阅读关软件设计的成果应该是组织良好、干净利落的,然而形成这个设计的过程却
于这一观点的更
完整的解释,请并非如此清爽
参阅“一种理性
的设计过程:如
说设计了无章法,是因为在此过程中你会采取很多错误的步骤,多次误入歧
何/为何要仿制
它( Rational途你会犯很多的错误。事实上,犯错正是设计的关键所在在设计阶段犯
Design Process:
Fake Why to错并加以改正,其代价要比在编码后才发现同样的错误并彻底修改低得多。说设
ake it, Parnas
and Clements计了无章法,还因为优、劣设计之间的差异往往非常微妙。
1986)。
代码大全(第2版)

<==========================112end ==============================>
<==========================113start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
76
第5章软件构建中的设计
交叉参考关于这另外,说设计了无章法,还因为你很难判断设计何时算是“足够好”了。设
一问题的更好答计到什么细节才算够?有多少设计需要用形式化的设计符号完成,又有多少设计
案,请参见本章后
面第5.4节“要做可以留到编码时再做?什么时候才算完成?因为设计永无止境,因此对上述问题
多少设计才够”。最常见的回答是“到你没时间再做了为止”
Design Is About Tradeoffs and Priorities
设计就是确定取舍和调整顺序的过程
在一个理想的世界中,每一套系统都能即刻完成运行,不消耗任何存储空间,不
占用任何网络带宽,没有任何错误,也无须任何成本即可生成。而在现实世界里,设
计者工作的一个关键内容便是去衡量彼此冲突的各项设计特性,并尽力在其中寻求平
衡。如果快速的反应速度比缩减开发时间更重要,那么设计者会选取一套设计方案。
而如果缩减开发时间更重要,那么好的设计者又要巧妙地形成另一套不同的设计方案。
Design Involves Restrictions
设计受到诸多限制
设计的要点,一部分是在创造可能发生的事情,而另一部分又是在限制可能发生
的事情。如果人们在建造房屋时拥有无限的时间、资源和空间,那么你会看到房屋不
可思议地随意蔓延,每幢楼都有上百间屋子,一只鞋子就可以占用一间屋子。如果毫
无约束,软件最后也会是这样的结果。正是由于建造房屋时有限资源的限制,才会促
使产生简单的方案,并最终改善这一解决方案。软件设计的目标也如此
Design Is Nondeterministic
设计是不确定的
如果你让三个人去设计一套同样的程序,他们很可能会做出三套截然不同的
设计,而每套设计都很不错。剥猫的皮可能有不止一种方法,但设计计算机程序
却通常有数十种方法。
Design Is a Heuristic Process
设计是一个启发式过程
正因为设计过程充满了不确定性,因此设计技术也就趋于具有探索性“经验
法则”或者“试试没准能行的办法”—而不是保证能产生预期结果的可重复的过程。
KEY POINT
设计过程中总会有试验和犯错误。在一件工作或一件工作的某个方面十分奏效的设计
工具或技术,不一定在下一个项目中适用。没有任何工具是用之四海而皆灵的。
Design Is Emergent
设计是自然而然形成的
cc2e.com/0539
把设计的这些特性综合归纳起来,我们可以说设计是“自然而然形成的”。设
计不是在谁的头脑中直接跳出来的。它是在不断的设计评估、非正式讨论、写试
验代码以及修改试验代码中演化和完善的。
代码大全(第2版)

<==========================113end ==============================>
<==========================114start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo.com!^ .com!仅供试看
5.2关键的设计概念
77
深入阅读软件并
几乎所有的系统都在其开发的起始阶段经历过某种程度的设计变更,而当它
变化而变化的结们进入后续版本后通常都会进行更大的改变。软件的性质决定了这些改变在多大
非是唯会随时间
构物理结构也会程度上是有益且可被接受的。
凌变参阅Hw
Buildings Leam
(Brand 1995).
Key Design Concepts
5.2关键的设计概念
好的设计源于对一小批关键设计概念的理解。这一节将会讨论“复杂度”所
扮演的角色、设计应具有的特征,以及设计的层次。
Software's Primary Technical Imperative: Managing Complexity
软件的首要技术使命:管理复杂度
叉参考关于为了理解管理复杂度的重要性,我们有必要引用 Fred Brooks的那篇具有里程
杂度除到碑意义的文章——《没有银弹:软件工程中本质性和偶然性》(1987)
之外还会影
的编程事宜,请参
见第34.1节“征 and Essential Difficulties
服复杂性”。偶然的难题和本质的难题
Brooks认为,两类不同的问题导致软件开发变得困难一本质的问题和偶然
的问题。关于这两个术语, Brooks引用了亚里士多德时代的一个哲学传统。在哲
学界,本质的(essential)属性是一件事物必须具备、如果不具备就不再是该事物
的属性。汽车必须具有引擎、轮子和车门,不然就不能称其为汽车。如果不具备
这其中任何一个本质的属性,它就不再是一辆汽车。
偶然的(accidental)属性则是指一件事物碰巧具有的属性,有没有这些属性都
并不影响这件事物本身。一辆汽车可能有台V8发动机,或是涡轮增压四缸发动机,
或其他什么种类的发动机,无论这些细节如何,它总是一辆汽车一辆汽车也可能
是两门或四门的;它可能有粗劣或豪华的轮毂。所有这些细节都是次要的偶然属性。
你也可以把偶然属性想成是附属的、任意的、非必要的或偶然出现的性质。
交叉参考偶然 Brooks观察到,软件开发中部分的偶然性难题在很久以前就已得到解决了。
性难题在开发的比如说,与笨拙的语法相关的那些偶然性难题大多已在从汇编语言到第三代编程
初期比开发的晚
期更突出。更多内语言的演进过程中被解决了,而且这类问题的重要性也渐渐下降了。与非交互式
容请参见第4.3计算机相关的偶然性难题也随着分时(time e- share)操作系统取代批模式
节“你在技术浪湖
中的位量”。(batch-m-mode)系统而被解决。集成编程环境更是进一步解决了由于开发工具之
间无法很好地协作而带来的效率问题。
代码大全(第2版)

<==========================114end ==============================>
<==========================115start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看
78
第5章软件构建中的设计
Brooks论述说,在软件开发剩下的那些本质性困难上的进展将会变得相对缓
慢。究其原因,是因为从本质上说软件开发就是不断地去发掘错综复杂、相互连
接的整套概念的所有细节。其本质性的困难来自很多方面:必须去面对复杂、无
序的现实世界;精确而完整地识别出各种依赖关系与例外情况;设计出完全正确
而不是大致正确的解决方案;诸如此类。即使我们能发明出一种与现实中亟待解
决的问题有着相同术语的编程语言,但是人们要想清楚地认清现实世界到底如何
运作仍有很多挑战,因此编程仍会十分困难。当软件要解决更大规模的现实问题
时,现实的实体(entities)之间的交互行为就变得更为复杂,这些转而又增加软
件解决方案的本质性困难。
所有这些本质性困难的根源都在于复杂性不论是本质的,还是偶然的
Importance of Managing Complexity
管理复杂度的重要性
有两种设计软件
的方式:一种方法
在对导致软件项目失败的原因进行调查时,人们很少把技术原因归为项目失
是让设计非常简败的首要因素。项目的失败大多数都是由差强人意的需求、规划和管理所导致的。
单看上去明显没
有缺陷;另一种方但是,当项目确由技术因素导致失败时,其原因通常就是失控的复杂度。有关的
法是让设计非常软件变得极端复杂,让人无法知道它究竟是做什么的。当没人知道对一处代码的
复杂,看上去没有
明显的缺陷。改动会对其他代码带来什么影响时,项目也就快停止进展了。
C. A. R Hoare
管理复杂度是软件开发中最为重要的技术话题在我看来,软件的首要技术
使命便是管理复杂度,它实在是太重要了。
KIY POINT
复杂度并不是软件开发中的什么新特征。计算机先驱 Edsger Dijkstra指出,
计算是唯一的一种职业,在其中,人的思维需要从一个字节大幅跨越到几百兆字
节—跨越比例为10分之1,也就是九个数量级(Dijkstra1 1989)这一比例大得
惊人。 Dijkstra是这样描述的:“在语义的层次量上相比,一般的数学理论几乎是
平坦的。由于提出了对很深的概念层次的需要自动化的计算机使我们面临着一
种本质上全新的智力挑战,是史无前例的挑战。”当然,从1989年以来软件变得
更为复杂了, Dijkstra所说的1比10的比例今天很可能已经变成了1比1015
代码大全(第2版)

<==========================115end ==============================>
<==========================116start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
5.2关键的设计概念
79
你已陷入复杂
Dijkstra还指出,没有谁的大脑能容得下一个现代的计算机程序(Dijkstra
的沼泽的一个现1972),也就是说,作为软件开发人员,我们不应该试着在同一时间把整个程序都
象就是,你发现自
顽固地用一种塞进自己的大脑,而应该试着以某种方式去组织程序,以便能够在一个时刻可以
明显毫无作用的专注于一个特定的部分。这么做的目的是尽量减少在任一时间所要考虑的程序量。
任何外人眼里。这你可以把它想做是一种心理上的杂耍(边抛边接:通过轮流抛接使两个或两个以
就像是一个遇到上物体同时保持于空中)一程序要求你在空中保持的(精神上的)球越多,你
车子抛锚的蠢货
一样他把水
就越可能漏掉其中的某一个,从而导致设计或编码的错误。
放到电池里然后
把烟灰缸倒掉。
在软件架构的层次上,可以通过把整个系统分解为多个子系统来降低问题的
. Plauger复杂度。人类更易于理解许多项简单的信息,而不是一项复杂的信息。所有软件
设计技术的目标都是把复杂问题分解成简单的部分。子系统间的相互依赖越少,
你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相
互分离,从而使你能在每个时刻只专注于一件事情在更高汇聚的层次,包
packages)提供了相同的好处。
保持子程序的短小精悍也能帮助你减少思考的负担。从问题的领域着手,而
不是从底层实现细节入手去编写程序,在最抽象的层次上工作,也能减少人的脑
力负担。
受着人类固有限制影响的程序员的底线,就是要写出既让自己容易理解,也
能让别人容易看懂,面且很少有错误的程序代码。
How to Attack Complexity
如何应对复杂度
高代价、低效率的设计源于下面三种根源:
用复杂的方法解决简单的问题;
用简单但错误的方法解决复杂的问题:
用不恰当的复杂方法解决复杂的问题。
正如 Dijkstra所指出的,现代的软件本身就很复杂,无论你多努力,最终都
会与存于现实世界问题本身的某种程度的复杂性不期而遇。这就意味着要用下面
这两种方法来管理复杂度:
把任何人在同一时间需要处理的本质()复杂度的量减到最少
不要让偶然性(accidental)的复杂度无谓地快速增长。
Y POINT
一旦你能理解软件开发中任何其他技术目标都不如管理复杂度重要时,众多
设计上的考虑就都变得直截了当了。
代丹大全(第2版)

<==========================116end ==============================>
<==========================117start==============================>

该书下载自书部落分享计算机经典巨著
80
第5章软件构建中的设计
Desirable Characteristics of a Design
理想的设计特征
当我解决问题的
时候,我从来不考
虑美感。我只想着
高质量的设计具有很多常见的特征。如果你能实现所有这些目标,你的设计
如何才能解决它。就真的非常好了。这些目标之间有时会相互抵触,但这也正是设计中的挑战所在
但一旦解决了问
题,如果解决方法在一系列相互竞争的目标之中做出套最好的折中方案。有些高质量设计的
就知道做错了。特征也同样是高质量程序的特征如可靠性和性能等。而有些则只是设计范畴内
. Buckminster的特征。
Fuller
交叉参考这些特下面就列出一些设计范畴内的特征:
征都是和软件质量
的基本特性相关的
关于这些基本特性
取小的复杂度( Minimal complexity)正如刚刚说过的,设计的首要目标就
的更多内容,请参见是要让复杂度最小。要避免做出“聪明的”设计,因为“聪明的”设计常常都是
第20.1节“软件质
量的特性”
难以理解的。应该做出简单且易于理解的设计。如果你的设计方案不能让你在专
注于程序的一部分时安心地忽视其他部分的话,这一设计就没有什么作用了。
易于维护(Easc of maintenance)易于维护意味着在设计时为做维护工作的
程序员着想。请时刻想着这些维护程序员可能会就你写的代码而提出的问题。把
这些程序员当成你的听众,进而设计出能自明的(self-explanatory)系统来
松散耦合(loose coupling)松散耦合意味着在设计时让程序的各个组成部
分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则,设
计出相互关联尽可能最少的类。减少关联也就减少了集成、测试与维护时的工作
量。
可扩展性(extensibility)可扩展性是说你能增强系统的功能而无须破坏其
底层结构。你可以改动系统的某一部分而不会影响到其他部分。越是可能发生的
改动,越不会给系统造成什么破坏。
可重用性(reusability)可重用性意味着所设计的系统的组成部分能在其他
系统中重复使用。
高扇入(high fan--in)高扇入就是说让大量的类使用某个给定的类。这意味
着设计出的系统很好地利用了在较低层次上的工具类(utility classes)
代码大全(第2版)

<==========================117end ==============================>
<==========================118start==============================>

该书下载自书部落分享计算机经典巨著
5.2关键的设计概念
81
低扇出( low fan--out)低扇出就是说让一个类里少量或适中地使用其他的类。
高扇出(超过约7个)说明一个类使用了大量其他的类,因此可能变得过于复杂。
研究发现,无论考虑某个子程序调用其他子程序的量,还是考虑某个类使用其他
类的量,低扇出的原则都是有益的(Card and Glass 1990 Basili Briand and Melo
1996)
可移植性portability)可移植性是说应该这样设计系统,使它能很方便地
移植到其他环境中。
精简性( leanness)精简性意味着设计出的系统没有多余的部分(Wirh1995,
McConnell 11997)。伏尔泰曾说,一本书的完成,不在它不能再加入任何内容的时
候,而在不能再删去任何内容的时候。在软件领域中,这一观点就更正确,因为
任何多余的代码也需要开发、复审和测试,并且当修改了其他代码之后还要重新
考虑它们。软件的后续版本也要和这些多余代码保持向后兼容。要问这个关键的
问题:“这虽然简单,但把它加进来之后会损害什么呢?”
层次性( stratification)层次性意味着尽量保持系统各个分解层的层次性,
使你能在任意的层面上观察系统,并得到某种具有一致性的看法。设计出来的系
统应该能在任意层次上观察而不需要进入其他层次。
交叉参考关于举例来说,假设你正在编写一个新系统,其中用到很多设计不佳的旧代码,
在旧有系统上进
行工作的更多内这时你就应该为新系统编写一个负责同旧代码交互的层。在设计这一层时,要让
容,请参见第24.5它能隐藏旧代码的低劣质量,同时为新的层次提供一组一致的服务。这样,你的
节“重构的策略”。
系统的其他部分就只需与这一层进行交互而无须直接同旧代码打交道了。在这
个例了中,层次化设计的益处有:(1)它把低劣代码的烂泥潭禁闭起来;(2)如
果你最终能抛弃或者重构旧代码,那时就不必修改除交互层之外的任何新代码。
交叉种特标准技术(Standard techniques)一个系统所依赖的外来的、占怪的东西越
别有价值的标准化
就是使用设计模多,别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的、常用的方
式在第5.3节查
阅常用的设计模法,让整个系统给人一种熟悉的感觉。
式”中会有论述。
代码大全(第2版)

<==========================118end ==============================>
<==========================119start==============================>

该书下载自-书部落-分享计算机经典--www. ! --www.shubulo.com!^.com!仅供试看^
82
第5章软件构建中的设计
Levels of Design
设计的层次
需要在一个软件系统中的若干不同细节层次上进行设计。有些设计技术适用
于所有的层次,而有些只适用于某些层次上。图5-2展示了这些层次。
①软件系统
②分解为子系统和包
③分解为包中的类
④分解为类中的数据和子程序
⑤子程序内部
图5-2一个程序中的设计层次。系统①首先被组织为子系统②。子系统被进一步分
解为类③,然后类又被分解为子程序和数据④。每个子程序的内部也需要进
行设计⑤
Level 1: Software System
第1层:软件系统
换言之—整个公
第一个层次就是整个系统。有的程序员直接从系统层次就开始设计类,但是
司的巨大成功基于往往先从子系统或者包(package这些类的更高组织层次来思考会更有益处。
这条如岩石般坚固
的原则:他们的基 Level2: Division into Subsystems or Packages
础设计缺陷完全被
其表层的设计缺陷第2层:分解为子系统或包
所隐藏。
-Douglas Adams
在这一层次上设计的主要成果是识别出所有的主要子系统。这些子系统可能
会很大,比如说数据库、用户界面、业务规则、命令解释器、报表引擎等。这一
层的主要设计活动就是确定如何把程序分为主要的子系统,并定义清楚允许各子
系统如何使用其他子系统。对于任何至少需要几周时间才能完成的项目,在这一
代码大全(第2版)

<==========================119end ==============================>
<==========================120start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com! ^^.com!l仅供试看
5.2关键的设计概念
83
层次上进行划分通常都是必需的。在每个子系统的内部可能要用到不同的设计方
法请对系统中的每一部分选用最恰当的方法。在图5-2中,这一层次的设计
是用②注明的。
在这一层次中,有一点特别重要,即不同子系统之间相互通信的规则。如果
所有的子系统都能同其他子系统通信,你就完全失去了把它们分开所带来的好处。
应该通过限制子系统之间的通信来让每个子系统更有存在意义。
举例来说,在图5-3中,你把一个系统划分成六个子系统。在没有定义任何
规则时,热力学第二定律就会发生作用,整个系统的熵将会增加。熵之所以增加
的一种原因是,如果不对子系统间的通信释加任何限制,那么它们之间的通信就
会肆意地发生,如图5-4所示。
用户界面
图形
数据存储
应用程序级
的类
业务规则
企业级的工具
图5-3一个有六个子系统的系统示例
用户界面
图形
数据存储
应用程序级
的类
业务规则
企业级的工具
图5-4当子系统之间的通信没有任何限制时就会像这个样子
代码大全(第2版)

<==========================120end ==============================>
<==========================121start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看^
84
第5章软件构建中的设计
正如你所看到的,这里的每个子系统最终都会直接与所有其他子系统进行通
信,从而为我们提出一些重要的问题:
一个开发人员需要理解系统中多少个不同的部分哪怕只理解一丁点
儿——才能在图形子系统中改动某些东西?
当你想在另一个系统中试图使用业务规则时会发生什么?
当你想在系统中加入一套新的用户界面时比如说为了进行测试而开发
的命令行界面会发生什么?
当你想把数据存储放到一台远程计算机上,又会发生什么?
你可以把子系统之间的连线当成水管。当你想去掉某个子系统时,势必会有
不少水管连在上面。你需要断开再重新连接的水管数量越多,弄出来的水就会越
多。你肯定想把系统的架构设计成这样:如果想把某个子系统取走重用时,不用
重新连接太多水管,重新连接起来也不会太难。
有先见之明的话,所有这些问题就不会花太多额外功夫。只有当“确需了解”
最好还有合理的理由—时,才应该允许子系统之间的通信。如果你还拿不准
该如何设计的话,那么就应该先对子系统之间的通信加以限制,等日后需要时再放
松,这要比先不限制,等子系统之间已经有了上百个调用时再加以限制要容易得多。
图5-5就展示了施加少量通信规则后可以把图5-4中的系统变成什么样子。
用户界面
图形
数据存储
应用程序级
的类
业务规则
企业级的工具
图5-5施加若干通信规则后,子系统之间的交互得以显著地简化
为了让子系统之间的连接简单易懂且易于维护,就要尽量简化子系统之间的
交互关系。最简单的交互关系是让一个子系统去调用另一个子系统中的子程序;
稍微复杂一点的交互关系是在一个子系统中包含另一个子系统中的类;而最复杂
的交互关系是让一个子系统中的类继承自另一个子系统中的类。
代码大全(第2版)

<==========================121end ==============================>
<==========================122start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor.com!仅供试看
5.2关键的设计概念
85
有一条很好的基本原则,即,像图5-5这样的系统层设计图应该是无环图
(acyclic graph)。换句话说,程序中不应该有任何环形关系,比如说A类使用了
B类、B类使用了C类、而C类又使用了A类这种情况。
对于大型程序或系列程序而言,在子系统这一层次上进行设计是至关重要
的。如果你觉得自己要写的程序小到可以跳过在子系统层次上进行设计这一步骤,
那么只要确保跳过这层设计的决定是经过深思熟虑的。
常用的子系统有些种类的子系统会在不同的系统中反复出现。下面几种就
较为常见。
交叉关于
业务规则业务规则是指那些在计算机系统中编入的法律、规则、政策以及
用表格表示业务过程。如果你在开发一套薪资系统,你可能要把美国国税局关于允许扣提的金额
逻辑,以简化编
程,请见第18章和估算的税率编到你的系统中。在薪资系统中还可能出现的规则包括与工会签订
“表驱动法”。的有关加班率、休假安排以及节假日薪水的合同,等等。如果你要写一个能计算
车险费率的程序,那么业务规则可能会包括政府有关责任范围的法令、保险赔率
表以及保险业条款等。
用户界面应创建一个子系统,把用户界面组件同其他部分隔离开,以便使
用户界面的演化不会破坏程序的其余部分。在大多数情况下,用户界面子系统会
使用多个附属的子系统或类来处理用户界面、命令行接口、菜单操作、窗体管理、
帮助系统,等等。
数据库访问你可以把对数据库进行访问的实现细节隐藏起来,让程序的绝
大部分可以不必关心处理底层结构的繁琐细节,并能像在业务层次一样处理数据。
隐藏实现细节的子系统可以为系统提供有价值的抽象层,从而减少程序的复杂度。
它把和数据库相关的操作集中起来,减少了在对数据进行操作时发生错误的几率。
同时,它还能让数据库的设计结构更易于变化,做这种修改时无须修改程序的主
要部分。
对系统的依赖性把对操作系统的依赖因素归到一个子系统里,就如同把对
硬件的依赖因素封装起来一样。比如说,你在开发一个运行于 Microsoft Windows
操作系统上的程序,可为什么一定要把自己局限于 Windows的环境呢?把所有与
Windows相关的系统调用都隔离起来,放到一个 Windows接口子系统中,这样一
来,如果日后你想把程序移植到 Mac OS或 Linux操作系统时,只要修改接口子系
统就可以了。自己实现这一接口子系统可能会太复杂了,但一些商业代码库都已
经提供了这一子系统的现成实现。
代码大全(第2版)

<==========================122end ==============================>
<==========================123start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
86
第5章软件构建中的设计
Level 3: Division into Classes
第3层:分解为类
深入阅读关在这一层次上的设计包括识别出系统中所有的类。例如,数据库接口子系统
干数据库设可能会被进一步划分成数据访问类、持久化框架类以及数据库元数据。图5-2中
请参阅Agile
Database
的第3层就展示了第2层中一个子系统是如何被分解为类的,当然这也暗示着第
Techniques)2层的其他三个子系统也被分解为类了。
(Ambler 2003).
当定义子系统中的类时,也就同时定义了这些类与系统的其余部分打交道的
细节。尤其是要确定好类的接口。总的来说,这一层的主要设计任务是把所有的
子系统进行适当的分解,并确保分解出的细节都恰到好处,能够用单个的类实现。
交叉参考关于对于工作期需要超过几天的项目而言,通常就需要把子系统分解为类了。如
高质量的类的具果项目很大,这种分解就会与第2层的程序分解有明显的区别;相反,如果项目
体特性,请见第6
章“可以工作的很小,你也可以直接从第1层的系统全局视图直接进入到第3层的类视图。
类”
类与对象的比较面向对象设计的一个核心概念就是对象(object)与类
(class)的区分。对象是指运行期间在程序中实际存在的具体实体( enity),而类
是指在程序源码中存在的静态事物。对象是动态的,它拥有你在程序运行期间所
能得到的具体的值和属性。例如,你可以定义一个名为 Person的类,它具有姓名
年龄、性别等属性。在程序运行期间,你可以有 nancy、hank、 diane、tony等对
象——它们是类的具体实例。如果你熟悉数据库术语的话,类与对象的关系就如
同“模式(schema)”与“实例(instance)”一样你可以把类看做是蛋糕模具
而把对象看做是蛋糕。在本书中,对这两个术语的使用并非十分正规,一般情况
也会或多或少互换地使用类和对象这两个术语。
Level 4: Division into Routines
第4层:分解成子程序
这一层的设计包括把每个类细分为子程序。在第3层中定义出的类接口已经
定义了其中一些子程序,而第4层的设计将细化出类的私用(private)子程序
当你查看类里面子程序的细节时,就会发现很多子程序都很简单,但也有些子程
序是由更多层次化组织的子程序所组成的,这就需要更多的设计工作了。
完整地定义出类内部的子程序,常常会有助于更好地理解类的接口,反过来,
这又有助于对类的接口进行进一步修改,也就是说再次返回第3层的设计
这一层次的分解和设计通常是留给程序员个人来完成的,它对于用时超过几
小时的项目而言就是必需做的了。虽然不用非常正式地完成这一步骤,但至少也
要在脑中完成。
代码大全(第2版)

<==========================123end ==============================>
<==========================124start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
5.3设计构造块:启发式方法
87
Level 5: Internal Routine Design
第5层:子程序内部的设计
交叉参考关于在子程序层次上进行设计就是为每个子程序布置详细的功能。子程序内部的
创建高质量的子设计工作通常是由负责该子程序的开发人员来完成的。这里的设计工作包括编写
程序的具体做
法,请见第7章伪代码、选择算法、组织子程序内部的代码块,以及用编程语言编写代码。这一
“高质量的子程层的设计工作总是需要做的,尽管有时做得很不在意或者很差劲,有时则是经过
序”和第8章“防
御式编程”。深思熟虑而出色完成的。在图5-2中的第5步就是这一层的设计工作。
5.3
Design Building Blocks: Heuristics
设计构造块:启发式方法
软件开发人员希望我们能给出明确的答案:“只要做了A、B、C,就一定会
得到X、Y、Z的结果。”我们在学会一些神秘技术并用它们实现了预期结果后会
感觉骄傲,也会因为某些方法并未应验而感觉懊恼。对于具体的编程工作来说,
期待确定性的行为是很正常的一无论这种对细节的关注会给程序带来好处还是
坏处。然而对于软件设计来说却并非如此。
由于软件设计是非确定性的,因此,灵活熟练地运用一组有效的启发式方法(试
探法),便成了合理的软件设计的核心工作。下面将几小节将阐述一些启发式方法,
也即一些思考问题的方法,它们有时能够产生优秀设计成果。你可以把启发式方法
看做是指引试错( trail and error)法中“试验”部分的指导书,你也一定曾经用过其
中一些方法。因此,以下部分会依据软件的首要技术使命管理复杂度的原
则来讲解每一种启发式方法。
Find Real-World Objects
找出现实世界中的对象
先别问系统做什在确定设计方案时,首选且最流行的一种做法便是“常规的”面向对象设计方法,
么,问问它想模仿
什么!
此方法的要点是辨识现实世界中的对象(object,体)以及人造的(synthetic)对象
-Bertrand Meyer
使用对象进行设计的步骤是:
交叉参考关于辨识对象及其属性(方法( method)和数据(data))
设计和使用类的确定可以对各个对象进行的操作。
更多细节,请见第
6章“可以工作的确定各个对象能对其他对象进行的操作。
类”。
确定对象的哪些部分对其他对象可见—哪些部分可以是公用(public)的,
哪些部分应该是私用(private)的
定义每个对象的公开接口(public interface)。
代码大全(第2版)

<==========================124end ==============================>
<==========================125start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
88
第5章软件构建中的设计
这些步骤并无须以特定顺序来完成,它们也经常会被反复执行。迭代是非常
重要的。下面来总结一下每一个步骤:
辨识对象及其属性计算机程序通常都是基于现实世界的实体例如,你可
以基于现实世界中的雇员(Employee)、顾客(Client)工作时间记录卡(Timecard)
以及账单(Bill)等实体来开发一套按时间计费的(tmee-billing-)系统图5-6显
示了这样一套收费系统的面向对象视图。
Client
Emplayee
name
name
billingAddress
title
billingRate
current BillingAmiount
GetHoursForMonthO
EnterPayment(
hillingEmployee
1client ToBill
clientToBill
+bills
Timecard
Bill
hours
billDate
date
0..1
projeclCode
billingRecords
BillForClient(
图5-6收费系统由四种主要的对象构成,这些对象在本例中进行了一定的简化
辨识对象的属性并不比辨识对象本身更困难。每个对象都有一些与计算机程
序相关的特征。例如,在这个收费系统里,每个雇员对象都具有名字(name)职
务(title)和费率( billingRate)等属性;而顾客对象则具有名字(name)账单寄
送地址( billingAddress)以及账户余额(accountBalance)等属性;账单对象具有
收费金额、顾客名字、支付日期(billDate):如此等等。
图形用户界面系统中的对象可能包括窗体、对话框、按钮、字体以及画图工
具等。相比于“把软件中的对象一一映射为现实世界中的对象”,深入挖掘问题领
域可能会得出更好的设计方案,不过从现实世界中的对象入手的确是不错的起点。
定义可对对象执行的操作在每个对象之上都可以执行多种操作。在图5-6
所示的收费系统里,雇员对象可能需要修改职务或者费率,顾客对象可能需要修
改名字或者账单寄送地址,等等。
确定可以每个对象可以对其他对象进行的操作这一步骤的目的显而易见。
对象之间最常见的两种关系是包含(containment)和继承( inheritance)哪些对
象可以包含其他对象?哪些对象又可以从其他对象继承?图5-6中,一个Timecard
代码大全(第2版)

<==========================125end ==============================>
<==========================126start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo..com!仅供试看^
5.3设计构造块:启发式方法
89
对象可以包含一个 Employee对象和一个 Client对象,一个Bill对象可以包含一个
或多个 Timecard对象。另外,一份账单可以标示是否已经给某位顾客开过账单了,
而顾客也可以签付一份账单。史复杂的系统中还会包含其他更多的交互关系。
交叉参考关于确定对象的哪些部分对其他对象可见一项关键的设计决策就是明确对象的
类和信息隐藏的
详细情况,见第
哪些部分应该是公开的(public),哪些部分又应该是不公开的(private)对数据
5.3节中的“隐藏和方法都要做这一决策。
秘密(信息隐
藏)”。
定义每个对象的接口在编程语言的层次上为每个对象定义具有正式语法的
接口。对象对其他对象暴露的数据及方法都被称为该对象的“公开接口public
interface”,而对象通过继承关系向其派生对象暴露的部分则被称为“受保护的接
口protected interface”。要考虑这两种不同的接口。
经过上述这些步骤得到了一个高层次的、面向对象的系统组织结构之后,你
可以用这两种方法来迭代:在高层次的系统组织结构上进行迭代,以便更好地组
织类的结构:或者在每一个已经定义好的类上进行迭代,把每个类的设计细化。
Form Consistent Abstractions
形成一致的抽象
抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能
力—在不同的层次处理不同的细节。任何时候当你在对一个聚合物品(aggregate
工作时,你就是在用抽象了。当你把一个东西称为“房子”而不是由玻璃、木材
和钉子构成的组合体时,你就是在用抽象了。当你把一组房屋称为“城镇”时,
你还是在使用抽象。
基类也是一种抽象,它使你能集中精力关注一组派生类所具有的共同特性,
并在基类的层次上忽略各个具体派生类的细节。一个好的接口也是一种抽象,它
能让你关注于接口本身而不是类的内部工作方式。一个设计良好的子程序接口也
在较低的层次上提供了同样的好处,而设计良好的包(package和系统的接口
则在更高的层次上提供了同样的好处。
以复杂度的观点看,抽象的主要好处就在于它使你能忽略无关的细节。大多
数现实世界中的物体(object,对象)都已经是某种抽象了。正如上面所提到的,
房屋是门、窗、墙、线路、管道、隔板等物体及其特定的组织方式所形成的抽象。
同样,门是一块长方形材料加上合叶和把手以及一种特定的组织方式的抽象。而
门把手又是铜、镍、铁、钢等的一种特定形式的抽象。
大(第2版)

<==========================126end ==============================>
<==========================127start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..cm!仅供试看^
90
第5章软件构建中的设计
人们一直都在使用抽象。如果每天你开门的时候都要单独考虑那些木纤维、
油漆分子以及铁原子的话,你就别想再出入房间了。正如图5-7所示,抽象是我
们用来得以处理现实世界中复杂度的一种重要手段。
图5-7抽象可以让你用一种简化的观点来考虑复杂的概念
交叉参考关于
软件开发人员有时就是在木材纤维、油漆分子以及铁原子这一层次来构建系
在类的设计中使
用抽象的详情,统,系统因此变得异常复杂,难以通过人的智力去管理。当程序员没有给出足够
见第6.2节中的高层的编程抽象时,系统有时就会被卡在门口了。
“好的抽象”。
优秀的程序员会在子程序接口的层次上、在类接口的层次上以及包接口的层
次上换句话说,在门把手的层次上、门的层次上以及房屋的层次上—进行
抽象,这样才能更快、更稳妥地进行开发。
Encapsulate Implementation Details
封装实现细节
封装填补了抽象留下的空白。抽象是说:“可以让你从高层的细节来看待一个
对象。”而封装则说:“除此之外,你不能看到对象的任何其他细节层次。”
继续刚才关于房屋材质的比喻:封装是说,你可以从房屋的外面看,但不能
靠得太近去把门的细节都看清楚。可以让你知道哪里有门,让你知道门是开着的
还是关着的,但不能让你知道门是木质的、纤维玻璃的、钢质的还是其他什么材
质的,当然就更不能让你看到每一根木纤维。
如图5-8所示,封装帮助你管理复杂度的方法是不让你看到那些复杂度。在
第6.2节中的“良好的封装”中还会对进一步阐述这一话题,讨论如何把它应用
于类的设计。
代码大全(第2版)

<==========================127end ==============================>
<==========================128start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^ ^.com!仅供试看^
5.3设计构造块:启发式方法
91
日
图5-8封装是说,不只是让你能用简化的视图来看复杂的概念,同时还不能让你看
到复杂概念的任何细节。你能看得到的就是你能全部——得到的
Inherit-When Inheritance Simplifies the Design
当继承能简化设计时就继承
在设计软件系统时,你经常会发现一些大同小异的对象。比如说,在一套账
务系统中包含有全职员工和兼职员工,两者的大多数数据是相同的,只是某些数
据不同。在面向对象编程时,你可以定义一个代表普通员工的通用(general)类
型,然后把全职员工定义为普通员工——除了有一些不同之处;同样,把兼职员
工也定义为普通员工—除了一些不同之处。当一项针对员工的操作与具体的员
工类别无关时,这一操作就可以仅针对通用员工类型来进行。当该操作需要区别
全职员工与兼职员工时,就需要按照不同的方法来处理了。
定义这种对象之间的相同点和不同点就叫“继承因为特殊的全职员工类型
和特殊的兼职员工类型都从基本员工类型继承了某些特征。
继承的好处在于它能很好地辅佐抽象的概念。抽象是从不同的细节层次来看
对象的。回想一下前面讲过的,门从某个层次上看是不同种类的分子,而从另外
的层次上看则是木纤维,再从另外一层上看它又是能够阻挡盗贼的东西。木头具
有一些属性,比如说,你可以用锯来锯断木头,或用乳胶来粘合它们。三合板或
雪松木除了具有木头的基本属性之外,还有一些它们自己特有的属性。
继承能简化编程的工作,因为你可以写一个基本的子程序来处理只依赖于门的
基本属性的事项,另外写一些特定的子程序来处理依赖特定种类的门的特定操作。
有些操作,如Open()或 close(),对于任何种类的门都能用,无论它是防盗门、
室内门、户外门、玻璃门、法式门还是滑动玻璃门。编程语言如果能支持像Open()
代码大全(第2版)

<==========================128end ==============================>
<==========================129start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.c.com!仅供试看
92
第5章软件构建中的设计
或 close()这样在运行期间才能确定所针对的对象的实际类型的操作,这种能力
叫做“多态polymorphism”。面向对象编程语言,如C++、Java以及较新版本的
Microsoft Visual Basic都支持继承和多态
继承是面向对象编程中最强大的工具之一。如果使用得当,它能带来极大自
益处,然而如果使用不当,它也有极大的弊端。详见第6.3节中的“继承(有一
个的关系)”。
Hide Secrets(Information Hiding)
隐藏秘密(信息隐藏)
信息隐藏是结构化程序设计与面向对象设计的基础之结构化设计里面的
“黑盒子”概念就是来源于信息隐藏。在面向对象设计中,它又引出了封装和模
块化的概念,并与抽象的概念紧密相关。信息隐藏是软件开发中一个开拓性的概
念,这一节将会就此进行深入论述。
1972年,《1972DavidParnas《发表的一篇题为《论将系统分解为模块的准则》的论
文首次让公众注意到信息隐藏这一概念。信息隐藏被认为是具有“保密”的特征,
软件开发者把一个地方的设计和实现决策隐藏起来使程序的其他部分看不到它
们。
在《人月神话》的20周年纪念版中,《20,redBrooks,《总结说,旧版中存在几处
错误,其中之一便是对信息隐藏的批评。他说“Parnas是对的,而我在信息隐藏
方面的观点才是错误的。”(Brooks1995) Barry Boehm撰文称,信息隐藏是减少
重复工作的强大技术。他同时指出,信息隐藏在不断增长的、大量变化的环境中
尤其有用(Boehm1987)
信息隐藏是软件的首要技术使命中格外重要的一种启发式方法,因为它强调
的就是隐藏复杂度,这一点无论是从它的名称还是其实施细节上都能看得很清楚。
Secrets and the Right to Privacy
秘密和隐私权
当信息被隐藏后,每个类(或者包和子程序)都代表了某种对其他类保密的
设计或构建决策。隐藏起来的秘密可能是某个易变的区域,或者某种文件格式,
或某种数据类型的实现方式,或某个需要隔离的区域,在这个区域中发生的错误
不会给程序其余部分带来太大损失。在这里,类的职责就是把这部分信息隐藏起
来,并保护自己的隐私权。对系统的非重大改动可能会影响到某个类中的几个子
代码大全(第2版)

<==========================129end ==============================>
<==========================130start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor!^.com!仅供试看^
5.3设计构造块:启发式方法
93
程序,但它们不应该波及到类接口的外面。
类的接口的奋斗
在设计一个类的时候,一项关键性的决策就是确定类的哪些特性应该对外可
目标是完备且最见,而哪些特性应该隐藏起来。一个类可能有25个子程序,但只暴露了其中的5
Scott Meyers个,其余20个则仅限于在类的内部使用。一个类在内部可能用到了多种数据类型,
却不对外暴露有关它们的任何信息。在类的设计中,这一方面也称为“可见性
(visibility)”,因为它要确定的就是类的哪些特性对外界是“可见的”或能“暴露”
给外界。
类的接口应该尽可能少地暴露其内部工作机制。如图5-9所示,类很像是冰
山:八分之七都是位于水面以下,而你只能看到水面上的八分之一。
图5-9好的类接口就像是冰山的尖儿一样,让类的大部分内容都不会暴露出来
设计类的接口与设计其他环节一样,都是一个迭代的过程。如果你第一次没
有得到合适的接口,那么就多试几次,直到设计稳定下来。如果设计仍不稳定,
那你就需要换种方法再尝试。
An Example of Information Hiding
信息隐藏的一个例子
假设你有一个程序,其中的每个对象都是通过一个名为id的成员变量来保存
一种唯一的ID。一种设计方法是用一个整数来表示ID,同时用一个名为g maxId
的全局变量来保存目前已分配的ID的最大值每当创建新的对象时,你只要在该
对象的构造函数里简单地使用id=++g_maxId这条语句,就肯定能获得一个唯
一的ID值,这种做法会让对象在创建时执行的代码量最少。可这样设计可能有问
题吗?
代码大全(第2版)

<==========================130end ==============================>
<==========================131start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
94
第5章软件构建中的设计
好多地方都可能会出错。如果你想把某些范围的ID留做它用该怎么办?如果
你想使用非连续ID来提高安全性又该怎么办如果你想重新使用已销毁对象的
ID呢?如果你想增加一个断言来确保所分配的I值不会超过预期的最大范围
呢?如果程序中到处都是id=++maxId这种语句的话,一旦上面说的任何一
种情况出现,你就需要修改所有这些语句。另外,如果你的程序是多线程的话,
这种方法也不是线程安全的( thread-safe)
创建新ID的方法就是一种你应该隐藏起来的设计决策。如果你在程序中到处
使用++maxId的话,你就暴露了创建新ID的方法,也就是通过简单递增
maxId.相反,如果你在程序中都使用语句id Newid),那就把创建新
的方法隐藏起来了。你可以在 Newid()子程序中仍然只用一行代码, return
(++gmaxId),或者其他与之等价的方法。但如果日后你想把某些范围的ID留做
它用,或者重用旧的ID时,只要对 Newrd()子程序的内部加以改动即可,无须改
动几十个甚至成百个id= NewId()语句无论 NewId()内部做了多么复杂的改动,
这些改动都不会影响到程序的其他部分。
现在再假设你发现需要把D的类型由整数改为字符串。如果你已经在程序内
部大量地使用了 int id这样的变量声明的话,那么即使改用 NewId程序也无济
于事。你还得深入到程序内部,进行几十次甚至几百次的修改。
因此,另一个需要隐藏的秘密就是ID的类型。对外界透露ID是个整型变量
的做法,实质上是在鼓励程序员们对ID使用针对整数的操作,如>、<、=等等。
在C++里,你可以简单地使用 typedef来把ID定义为 IdType个可以解释
为int的用户自定义类型——而避免将其直接定义成int类型在C++和其他语
言中,你也可以创建一个简单的 IdType类。再强调一下,隐藏设计决策对于减少
“改动所影响的代码量”而言是全关重要的。
信息隐藏在设计的所有层次上都有很大作用一从用具名常量替代字面量
(literal),到创建数据类型,再到类的设计子程序的设计以及子系统的设计等
KEY POINT等
Two Categories of Secrets
两种秘密
信息隐藏中所说的秘密主要分为两大类:
隐藏复杂度,这样你就不用再去应付它,除非你要特别关注的时候
隐藏变化源,这样当变化发生时,其影响就能被限制在局部范围内复杂度
代码大全(第2版)

<==========================131end ==============================>
<==========================132start==============================>

该书下载自书部落-分享计算机经典巨著!--www. ! --www.shul.com!仅供试看^
5.3设计构造块:启发式方法
95
的根源包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法等等。本
章后面会详细论述这些变化源。
Barriers to Information Hiding
信息隐藏的障碍
深入阅读本节在少数情况下,信息隐藏是根本不可能的。不过大多数让信息无法隐藏的障
的部分内容改写
自“设计易于扩碍都是由于惯用某些技术而导致的心理障碍。
展和收缩的软
件( Designing
信息过度分散信息隐藏的常见障碍之一是信息在系统内过度分散。你可能
。。
Software for把100这个数字直接写到了程序里,这样会导致对它的引用过于分散。最好是把
Extension and这部分信息隐藏起来,比如说写入一个叫 MAX EMPLOYEES的常量中,而对这个常
Cantraction,
Parnas 1979).
量的值进行改动只要在一处进行即可
信息过度分散的另一例子是在系统内部到处都有与人机交互相关的内容。
旦交互方式改变一比如说从图形用户界面变为命令行界面那么几乎所有代
码都需要改动。最好是把与人机交互逻辑集中到一个单独的类、包或者子系统中,
这样,改动就不会给系统带来全局性的影响了。
交叉参考关
再举一个关于全局数据项的例子——比如说一个在程序全局范围内都可以访
来访问全局数据问的、含有1000个元素的员工数据数组。如果程序直接使用该全局数据,那么
的具体做法,见关于该数据项的实现细节—比如它是个数组,可以存放最多1000个元素这些
第13.3节中的信息一就会在程序中到处分散而如果程序仪是通过访问器子程序(access
“用访问器子程
序来取代全局数 routines)来使用该数据的话,就只有访问器子程序才知道其实现细节了。
据”。
循环依赖一种更为隐的信息隐藏障碍则是循环依赖,比如说A类中的子
程序调用了B类中的子程序,然后B类中的子程序又调用A类中的子程序。
要避免形成这种循环依赖。它会让系统难于测试,因为你既无法单独测试A
类,也无法单独测试B类,除非另一个类至少已经部分就绪。
把类内数据误认为全局数据如果你是个谨慎的程序员,那么有效地隐藏信
息的障碍之一就是把类内数据误认为是全局数据并避免使用它,因为你想避免全
局数据可能带来的问题。全局变量会让你陷入很多编程陷阱,而类内数据可能带
来的风险则要小得多。
全局数据通常会受困于两类问题:一种是子程序在全局数据之上执行操作,
但却不知道还有其他的子程序也在用这些全局数据进行操作;另一种是子程序知
道其他的子程序也在用全局数据进行操作,但却无法明确地知道都进行了哪些操
作。而类内数据就不会遇到这两种问题,因为只有类内部的少数子程序才能直接
访问这些数据。这些子程序不但知道有其他子程序在操纵这些数据,而且也明确
知道具体是哪些子程序在执行这些操作。
代码大全(第2版)

<==========================132end ==============================>
<==========================133start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看
9
第5章软件构建中的设计
当然,上述观点所基于的前提是:你的系统使用了设计良好的、体积小巧的
类。如果你的程序被设计为使用了很多体积庞大、包含众多子程序的类的话,那
么类数据和全局数据之间的区别就变得模糊起来,类内数据也将开始受困于全局
数据所面临的那些问题了。
交叉参考代码
可以察觉的性能损耗信息隐藏的最后一个障碍是试图在系统架构层和编码
级的性能优化在
第25章“代码调层均避免性能上的损耗。你不必在任何一层去担心。因为在架构层按照信息隐藏
整策略”和第26的目标去设计系统并不会与按照性能目标去设计相冲突。如果你紧记信息隐藏和
章“代码调整方性能这两点,那么就可以达到这两个月标。
更常见的担心来自于编码层。你可能会认为,由于有了额外层次的对象实例
化和子程序调用等,间接访问对象会带来性能上的损耗。事实上,这种担心为时
尚早,因为你能够衡量系统的性能,并且找出妨碍性能的瓶颈所在之前,在编码
层能为性能目标所做的最好准备,便是做出高度模块化的设计来。等你日后找出
了性能的瓶颈,你就可以针对个别的类或者子程序进行优化而不会影响系统的剩
余部分了。
Value of Information Hlding
信息隐藏的价值
信息隐藏是少数几个得到公认的、在实践中证明了其自身价值的理论技术,
并且已经有很长一段时间了(Boehm1987a)几年前人们就发现,那些运用了信
HARD DATA息隐藏技术的大型项目与没有应用这一技术的项目相比,修改起来大约容易4倍
( Korson and Vaishnavi 11986)而且,信息隐藏还是结构化程序设计和面向对象设
计的根基之一。
信息隐藏有着独特的启发力,它能够激发出有效的设计方案。传统的面向对
象设计通过把周围世界建模为对象来激发设计但是这种基于对象的思考却不能
帮助你避免把D声明为int而不是 IdType.面向对象设计者会这样问,“能否把
ID看作是一个对象?”取决于这个项目的编码标准,如果回答了“是的”,那么
可能就意味着程序员必须要写构造函数、析构函数、拷贝操作符和赋值操作符;
注释掉所有的原有语句,然后放回源码控制系统里大多数的程序员可能会决定
说,“不,没必要为了一个ID而新建一个类,我还是用int得了。”
看看都发生了什么。一个能够简单地把ID的数据类型隐藏起来的有用的设计
方案甚至都没有被考虑。可是如果设计者改变一下问法“如果应该被隐藏起
来该怎样呢?”,那么他很可能会用 IdType来取代int,即用一个简单的类型声明
来隐藏ID的类型。在这个例子里,面向对象设计与信息隐藏之间的差异,要比规
章与临时制度之间的差异还要微妙。面向对象设计也会和信息隐藏一样接受这种
设计方案。两者间的区别更多地是在于,按照信息隐藏的原则来思考,能够激发
代码大全(第2版)

<==========================133end ==============================>
<==========================134start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! --www.shubulo.co.com!仅供试看^
5.3设计构造块:启发式方法
97
和促进某些设计决策的形成,而仅仅按照对象原则思考却不会。其差异也很有启
发性。
信息隐藏同样有助于设计类的公开接口。在设计类的理论与实践之间有着很
大的差距,有很多类的设计者认为,把什么内容放在类的公开接口里,就等同于
找出使用最方便的那个接口,这通常就导致类内部过多的内容被暴露出来。以我
看来,一些程序员宁愿把一个类的私用数据都暴露出来,也不愿多写十行代码来
保护类的秘密不被泄漏。
问题“这个类需要隐藏些什么?”正切中了接口设计的核心。如果你能在给
类的公开接口中增加函数或者数据而不牺牲该类的隐密性,那么就做下去,否则
请停住。
在设计的所有层面上,都可以通过询问该隐藏些什么来促成好的设计决策。
这一问题可以在构建层面( construction level)上协助你用具名常量来取代字面量,
可以在类的内部生成好的子程序和参数名称,还有助于指导在系统层上做出有关
类和子系统分解以及交互设计的决策。
请养成问“我该隐藏些什么?”的习惯,你会惊奇地发现,有很多很棘手的
设计难题都会在你面前化解。
KEY POINT
Identify Areas Likely to Change
找出容易改变的区域
课入阅读本节
对优秀的设计师一份研究表明,他们所共有的一项特质就是都有对变化的预
中描述的方法改期能力(Gas1995)。好的程序设计所面临的最重要挑战之一就是适应变化。目
写自“设计易于扩
展和收缩的软件”标应该是把不稳定的区域隔离出来从而把变化所带来的影响限制在一个子程序、
Designing Sof类或者包的内部。下面给出你应该采取的应对各种变动的措施:
tware for Ease of
EXlensi0n《and
Contraction,
1.找出看起来容易变化的项目。如果需求做得很好,那么其中就应该包含一
Parnas1 1979)。份潜在变化的清单,以及其中每一项变化发生的可能性。在这种情况下,找出潜
在的变化就非常容易了。如果需求中没有包括潜在的变化,请参考后面有关“在
任何项目中都容易发生变化的区域”的讨论。
2.把容易变化的项目分离出来。把第一步中找出的容易变化的组件单独划分
成类,或者和其他容易同时发生变化的组件划分到同一个类中。
3.把看起来容易变化的项目隔离开来。设法设计好类之间的接口,使其对潜
在的变化不敏感。设计好类的接口,把变化限制在类的内部,且不会影响类的外
部。任何使用了这个将会发生变化的类的其他类都不会察觉到变化的存在。类的
接口应该肩负起保护类的隐私的职责。
代大全(第2版)

<==========================134end ==============================>
<==========================135start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
98
第5章软件构建中的设计
下面是一些容易发生变化的区域:
交叉参考主动业务规则业务规则很容易成为软件频繁变化的根源。国会改变了税率结构,
应对变更的最有
力的技术之一,
工会重新谈判合同的内容,保险公司改变了它的税率表如果你遵循信息隐藏
是表驱动技术。的原则,那么基于这些业务规则的逻辑就不应该遍布于整个程序,而是仅仅隐藏
详情请见第18于系统的某个角落,直到需要对它进行改动,才会把它拎出来
“表驱动法”
对硬件的依赖性与屏幕、打印机、键盘、鼠标、硬盘、声音设施以及通信
设计等之间的接口都是硬件依赖的例子。请把对硬件的依赖隔离在它们自身的子
系统或者类中。这种隔离会非常有利于你把程序移植到新的硬件环境下。另外,
当你为可能变化的硬件开发程序时,这样做也会有很大帮助。你可以写软件来模
拟与特定硬件的交互,在硬件尚不稳定或者不可用的时候,让硬件接口子系统使
用该模拟器,当硬件可用的时候再把硬件接口子系统与模拟器切断,最终连接到
真正的硬件设备上。
输入和输出在做比纯硬件接口层稍高一些层面上的设计时,输入输出也是
一个容易变化的区域。如果你的程序创建了自己的数据文件,那么该文件格式就
可能会随软件开发的不断深化而变化。用户层的输入和输出格式也会改变输
出页面上字段( fields)的位置、数量和排列顺序等都可能会变。因此,检查所有
的外部接口,看看有那些可能的变化通常是个不错的主意。
非标准的语言特性大多数编程语言的实现中都包含了一些便利的、非标准
的扩展。对这些扩展的应用就像双刃剑一样,因为它们可能在其他的环境中不可
用,不论该环境是一套不同的硬件、不同发行商所发行的语言版本,还是同一发
行商发行的同一语言的新版本。
如果你用了编程语言的非标准扩展,请把这样的扩展单独隐藏在某个类里,
以便当你转移到新的环境后可以用自己写的代码去取代它。与此类似,如果你使
用了并非在所有环境中都可用的子程序库(函数库,请把这些子程序库隐藏在一
个接口的后面,为新环境做好准备。
困难的设计区域和构建区域把困难的设计区域和构建区域隐藏起来也是很
好的想法,因为这些代码可能因为设计得很差而需要重新做。请把它们隔离起来,
把其拙劣的设计和“构建”对系统其余部分的可能影响降至最低。
状态变量状态变量用于表示程序的状态,与大多数其他的数据相比,这种
东西更容易改变。在一个典型的应用场景里,你可能一开始用布尔变量来定义出
代码大全(第2版)

<==========================135end ==============================>
<==========================136start==============================>

该书下载自书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
5.3设计构造块:启发式方法
99
错状态,然后又发现用具有 ErrorType_none、 ErrorType_Warning和
ErrorTypeFatal等值的枚举类型来表示该状态更好。
你可以在使用状态变量时增加至少两层的灵活性和可读性:
不要使用布尔变量作为状态变量,请换用枚举类型给状态变量增加一个新
的状态是很常见的,给校举类型增加一个新的状态只需要重新编译一次,而
无须对每一行检查该状态变量的代码都做一次全面修订。
使用访问器子程序(access routine)取代对状态变量的直接检查。通过检查
访问器子程序而不是检查状态变量,使程序能够去测试更复杂的状态情况。
例如,如果你想联合检查某一错误状态eror-state-)变量和当前功能状态
(current-function-state-)变量,那么如果该条测试语句隐藏在一段子程序里,
这就很容易做到:而如果把该测试语句硬编码到程序各处,则会困难重重。
数据量的限制当你定义了一个具有100个元素的数组的时候,你实质上是
在向外界透露一些它们并不需要知道的信息保护好你的隐私!信息隐藏并不总
是像创建新类一样复杂,有的时候它就像使用具名常量 MAXEMPLOYEES来隐藏
100一样简单。
Anticipating Different Degrees of Change
预料不同程度的变化
交叉参考本节描
述的预料变化的方
当你在考虑系统中的潜在变化时,应该设法设计好你的系统,让这些变化的
法不涉及提前设计影响或范围与发生该变化的可能性成反比。如果一种变化很可能发生,那么要确
和提前编码。关于保系统能够很容易地对它做出响应。只有那些极不可能发生的变化才能导致系统
这两种实践方法,中多于一个类发生的明显变化。优秀的设计者还能够很好地预料应对变化所需的
请见24.2节中的
“程序中的一些代成本。相比,如果某个变化特别容易发生而又容易做出计划,你就应该在如何对
某个时候才会用到付它上多下些功夫,不要把精力过多浪费在那些不太可能发生而且又很难做出计
的”。
划的变化上。
深入海读本处的
找出容易发生变化的区域的一个好办法是:首先找出程序中可能对用户有用
讨之来自“论一族的最小子集。这一子集构成了系统的核心,不容易发生改变。接下来,用微小的
程序的设计与开
发”一文所描述的步伐扩充这个系统。这里的增量可以非常微小,小到看似微不足道。当你考虑功
方法( On the
design and
能上的改变时,同时也要考虑质的变化:比如说让程序变成线程安全的,使程序
development of
program families,
能够本地化等。这些潜在的改进区域就构成了系统中的潜在变化。请依照信息隐
Pamas1976)。藏的原则来设计这些区域。通过首先定义清楚核心,你可以认清哪些组件属于附
加功能,这时就可以把它们提取出来,并把它们的可能改进隐藏起来。
代码大全(第2版)

<==========================136end ==============================>
<==========================137start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^.com!仅供试看^
100
第5章软件构建中的设计
Keep Coupling Loose
保持松散耦合
耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度。耦合度设
计的目标是创建出小的、直接的、清晰的类或子程序,使它们与其他类或子程序
之间关系尽可能地灵活,这就被称作“松散耦合”松散耦合这一概念同时适用于
类和子程序,所以在下面的讨论中我会使用“模块”一词来同时指代类和子程序。
模块之间的好的耦合关系会松散到恰好能使个模块能够很容易地被其他模
块使用。火车模型之间通过环钩彼此相连,把两辆列车连起来非常容易只用
把它们钩起来就可以了。设想如果你必须要把它们用螺丝拧在一起,或者要连很
多的线缆,或者只能连接某些特定种类的车辆,那么连接工作会是多么复杂。火
车模型之间之所以能够相连,就是因为这种连接尽可能的简单。在软件中,也请
确保模块之间的连接关系尽可能的简单。
请尽量使你创建的模块不依赖或者很少依赖其他模块让模块之间的关系像商业
合作者一样彼此分离,而不是像连体婴儿那样紧密相连。像sin)这样的子程序是松
散耦合的,因为它需要知道的东西也就是一个传入的、代表角度的数值。而诸如
InitVars(var,var2,var3,m,var这样的子程序则耦合得过于紧密了,因
为对于调用端必须传入的各个参数,调用它的模块实际上知道在 InitVars()的内部
会做些什么。如果两个类都依赖于对方对同一个全局变量的使用情况,那么它们之间
的耦合关系就更为紧密了。
Coupling Criteria
耦合标准
接下来是一些在衡量模块之间耦合度时可采用的标准
规模这里的规模指的是模块之间的连接数。对于耦合度来说,小就是美,因
为只要做很少的事情,就可以把其他模块与一个有着很小的接口的模块连接起来
只有一个参数的子程序与调用它的子程序之间的耦合关系比有六个参数的程序
与它的调用方之间的耦合关系更为松散。包含4个定义明确的公用方法(public
method)的类与它的调用方的耦合关系,比包含37个公用方法的类与它的调用方
的耦合关系为松散。
可见性可见性指的是两个模块之间的连接的显著程度。开发程序与在中央情
报局里工作不一样,你不能靠鬼鬼祟祟来获得信任。而是应该像登广告一样,通过
把模块之间的连接关系变得广为人知而获取信任。通过参数表传递数据便是一种明
显的连接,因而值得提倡。通过修改全局数据而使另一模块能够使用该数据则是一
种“鬼鬼祟祟”的做法,因此是很不好的设计。如果把与全局数据之间的连接写入
文档,那么就会使得这些连接相对明显些,因而会比上面的做法稍微好些。
灵活性灵活性指的是模块之间的连接是否容易改动。理想状态下,你会更
喜欢计算机上的热插拔USB连接器,而不喜欢用电烙铁焊接裸导线的连接方式。
在一定程度上,灵活性是其他几个耦合特性综合作用的结果,但是也的确有所不
代码大全(第2版)

<==========================137end ==============================>
<==========================138start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubulo.c.com!仅供试看
5.3设计构造块:启发式方法
101
同。假设你有一段子程序,通过输入雇用日期和工作级别来查询员工每年获得的
休假数量。这段子程序被命名为 LookupvacationBene().假设在另一个模块
里已经有了一个 employee对象,其中包含了雇用日期和工作级别,以及其他
些信息,该模块把这种对象传给LookupVacationBenefit()
按照其他耦合标准,这两个模块间的耦合关系看上去是很松散的。这两个模
块之间的 employee连接是可见的,而且这里只存在一个连接。现在假设你需要
在第三个模块中使用 LookupVacationBenefit()这一模块中没有employee对
象,但却包含雇用日期和工作级别。这样, LookupvacationBene(一下子就
变得不太友好了,它无法和新的模块协同工作。
要使第三个模块能使用 LookupVacationBenefit(),
它就必须了解
Employee类它可能去临时拼凑一个只包含两个字段的 employee对象,但是这
就需要了解 LookupVacationBenefit()的内部机制,也就是说,只有这两个字段
才是 LookupVacationBenefit()所需的。这样的解决方案非常牵强,而且也十分
H陋。第二种解决方案可能是对 LookupVacationBenefit)做出修改,使它以雇
用日期和工作级别作为参数,而不用 employee论怎样,原有的那个模块与过
去相比都已经变得更不灵活了。
从这个故事得到的好消息是,可以让一个不友好的模块变友好,只要把它变
得更灵活在这个例子里,这件事是通过明确以雇用日期和工作级别取代
employee作为参数来实现的。
简而言之,一个模块越容易被其他模块所调用,那么它们之间的耦合关系就
会越松散。这种设计非常不错,因为它更灵活,并且更易于维护。因此,在创建
系统架构时,请按照“尽可能缩减相互连接的准则来分解程序。如果把程序看
做是一块木材,那么就请延着木材的纹理把它劈开。
Kinds of Coupling
耦合的种类
下面是你会遇到的最常见的几种耦合:
简单数据参数耦合( simpl-parameter-dat- coupling)当两个模块之间通过
参数来传递数据,并且所有的数据都是简单数据类型( primitive data type)的时候,
这两个模块之间的耦合关系就是简单数据参数耦合的。这种耦合关系是正常的,
可以接受的。
简单对象耦合( simple-object- coupling)如果一个模块实例化一个对象,那
么它们之间的耦合关系就是简单对象耦合的。这种耦合关系也很不错。
对象参数耦合(object-parameter- coupling)如果 object11要求 object22传
给它一个 object33,那么这两个模块就是对象参数耦合的。与 objectl1仅要求
Object22传递给它简单数据类型相比,这种耦合关系要更紧密一些,因为它要求
Obiect22了解 Object3
代大全(第2版)

<==========================138end ==============================>
<==========================139start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shub.com!仅供试看
102
第5章软件构建中的设计
语义上的耦合最难缠的耦合关系是这样发生的一个模块不仅使用了另一
模块的语法元素( syntactic element),而且还使用了有关那个模块内部工作细节的
语义知识( semantic knowledge)。这是一些例子:
Modulel向 Module2传递了一个控制标志,用它告诉 Module2该做什么。这
种方法要求 Modulel1对 Module22的内部工作细节有所了解,也就是说需要
了解 Module2对控制标志的使用。如果 Module22把这个控制标志定义成
种特定的数据类型(枚举类型或者对象),那么这种使用方法还说得过去。
Module22在 Modulel修改了某个全局数据之后使用该全局数据这种方式就
要求 Module2假设 Modulel对该数据所做出的修改符合 Module22的需要,
并且 Modulel已经在恰当的时间被调用过。
Module的接口要求它的 Module1.Initialize子程序必须在它的
Modulel.Routine()之前得到调用 Module2知道1. Routine无论如何
都会调用 Module1 Initialize(),所以它在实例化 Modulel之后只是调用了
Modulel. Routine(),而没有先去调用 Module1.Initialize()
Module1把 ObjectModule2传给2.由于 Module1知道 Module2只用了 Object
的7个方法( method)中的3个,因此它只部分地初始化 Object只包含
那3个方法所需的数据。
Module1把 BaseObject传给 Module22由于 Module22知道 Modulel实际上
传给它的是 DerivedObject,所以它把 BaseObject转换成 DerivedObject,并
且调用了 DerivedObject特有的方法(method)。
语义上的耦合是非常危险的,因为更改被调用的模块中的代码可能会破坏调
用它的模块,破坏的方式是编译器完全无法检查的。类似这样的代码崩溃时,其
方式是非常微妙的,看起来与被使用的模块中的代码更改毫无关系,因此会使得
调试工作变得无比困难。
松散耦合的关键之处在于,一个有效的模块提供出了一层附加的抽象
旦你写好了它,你就可以想当然地去用它。这样就降低了整体系统的复杂度,使
得你可以在同一时间只关注一件事。如果对一个模块的使用要求你同时关注好
件事—其内部工作的细节、对全局数据的修改、不确定的功能点等那么就
失去了抽象的能力,模块所具有的管理复杂度的能力也削弱或完全丧失了。
类和子程序是用于降低复杂度的首选和最重要的智力工具。如果它们没帮助
你简化工作,那么它们就是失职的。
代码大全(第2版)

<==========================139end ==============================>
<==========================140start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
5.3设计构造块:启发式方法
103
Look for Common Design Patterns
查阅常用的设计模式
cc2cm/05设计模式精炼了众多现成的解决方案,可用于解决很多软件开发中最常见的
问题。有些软件问题要求全新的解决方案,但是大多数问题都和过去遇到过的问
题类似,因此可以使用类似的解决方案或者模式加以解决。常见的模式包括适配
器(Adapter)、桥接(Bridge)、装饰器(Decorator)外观(Facade)、工厂方法
(PaIyMchod《ObseveSigIeton《Stategy)观察者(Observer)单件(Sinleton)、策略(Strategy)及
模板方法( Template Method)由 Erich Gamma Richard Helm、 Ralph Johnson和
JohnVlssieas《1995所著的《设计模式》(1995)一书是讲述设计模式的最权威著作。
与完全定制的设计方案相比,设计模式提供了下列益处。
设计模式通过提供现成的抽象来减少复杂度如果你说,“这段代码使用
Factory Method来创建派生类的实例,”那么你项目中的其他程序员就会明白,这
段代码涉及到了一组相当丰富的交互关系以及编程协议。在你提及到了 Factory
Method这个设计模式时,所有相关的信息都被唤醒了。
Factory Method是一个模式,它允许你在对一个特定基类的任意派生类做实例
化的时候无须关注具体派生类的情况,除了在 Factory Method内部你可以在《重
构》( Fowler1999)一书的“用工厂方法取代构造函数”一节里看到关于应用Factory
Method的不错的讨论。
你不需要把你代码中的设计思路逐行地讲解给其他的程序员,他们就可以理
解你的代码里的设计思路。
设计模式通过把常见解决方案的细节予以制度化来减少出错软件设计问题
中总包含着一些比较微妙的地方,只有当它们被解决了一两次(或者三四次甚至
更多)之后才能完全显露出来。因为设计模式代表了些解决常见问题的标准做
法,积聚了多年来人们尝试解决那些问题的智慧同时也包含着对人们在解决这
些问题时所犯错误的更正。
如此看来,应用设计模式和“用程序库取代自己编写的代码”在概念上有相
似之处。不可否认的是,每个人都曾经自己写过几次快速排序算法,但你自己写
的版本一写就对的可能性又有多少呢?与之相似,大量的设计问题都与旧有问题
相关。因此说,为了解决这些问题,你最好是选取那些现已存在的设计方案,而
不是自己去独创一套。
设计模式通过提供多种设计方案而带来启发性的价值一个熟悉常见设计模
式的设计者能很轻松地找出一些模式来,并且问“选用哪一种设计模式才适合我
这里的设计问题?”从一组熟悉的设计方案中寻找,肯定比自己从头开始创造一
个设计方案来得容易。对于读者来说,与理解完全定制的代码相比,他们也会更
容易理解那些采用了自己熟悉的设计模式的代码。
代大全(第2版)

<==========================140end ==============================>
<==========================141start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com!.com!仅供试看^个
104
第5章软件构建中的设计
设计模式通过把设计对话提升到一个更高的层次上来简化交流除了在管理
复杂度方面的益处之外,设计模式还能够让设计者在更高一层的粒度上进行思考
与讨论,从而加速设计交流过程。如果你说“我拿不准在这里是用 Creator(创建
者)还是 Factory Method,”你其实已经言简意赅地传递了非常多的设计决策
如果你和你的听众都熟悉这些模式的话。设想下,如果你还要深入细节地去解
释 Creator模式和 Factory Method模式的代码细节然后再去对这两者做出比较,
那该会有多费时!
如果你还对设计模式不熟悉,那么表5-1总结出一些常见设计模式,希望能
引起你的兴趣。
表5-1常见设计模式
模式
描述
Abstract Factory
通过指定对象组的种类而非单个对象的类型来支持创建
(抽象工厂)
一组相关的对象
Adapter(适配器)
把一个类的接口转变成为另一个接口
Bridge(桥接)
把接口和实现分离开来,使它们可以独立地变化
创建一个包含其他同类对象的对象,使得客户代码可以
Composite(组合)
与最上层对象交互而无须考虑所有的细节对象
给一个对象动态地添加职责,而无须为了每一种可能的
Decrorator(装饰器)
职责配置情况去创建特定的子类(派生类)
Facade(外观)
为没有提供一致接口的代码提供一个一致的接口
做特定基类的派生类的实例化时,除了在 Factory
Factory Method
Method内部之外均无须了解各派生对象的具体类型
Iterator(迭代器)
提供一个服务对象来顺序地访问一组元素中的各个元素
使一组相关对象相互同步,方法是让另一个对象负责:
Observer(观察者)在这组对象中的任何一个发生改变时,由它把这种变化
通知给这个组里的所有对象
Singleton(单件)
为有且仅有一个实例的类提供一种全局访问功能
Strategy(策略)
定义一组算法或者行为,使得它们可以动态地相互替换
Template Method
定义一个操作的算法结构,但是把部分实现的细节留给
(模板方法)
子类(派生类)
如果你此前没接触过设计模式,那么对表-1内容的反映可能是“当然,我
已经了解其中的多数想法了”。这一反应也是设计模式之所以有价值的很大理由。
大多数经验丰富的程序员对模式都很熟悉,给这些模式加上容易辨认的名字,是
为了能够更高效、更有效地开展交流。
代码大全(第2版)

<==========================141end ==============================>
<==========================142start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo. com! ^.com!仅供试看
5.3设计构造块:启发式方法
105
应用模式的一个潜在的陷阱是强迫让代码适用于某个模式。有时候,对代码
进行一些微小的更改以便符合某个广为人知的模式,会使这段代码更容易理解。
但是,如果一段代码做出巨大改动,迫使它去符合某个标准模式,有时反而会把
问题复杂化。
应用模式的另个潜在陷阱是“为了模式而模式”( feature--it-is)不要仅仅因
为想试用某个模式、不考虑该模式是否合适就去应用它。
总之,设计模式是一种非常强人的管理复杂度的工具你可以阅读本章后面
所列出的任意一本好书来获取更多更深入的信息
Other Heuristics
其他的启发式方法
以上部分描述了软件设计中的主要的启发式方法。以下会再给出一些不太常
用、但值得提的启发式方法
Aim for Strong Cohesion
高内聚性
内聚性源于结构化设计,并且经常与耦合度结合在一起讨论。内聚性指的是类内
部的子程序或者子程序内的所有代码在支持一个中心目标上的紧密程度这个类
的目标是否集中。包含一组密切相关的功能的类被称为有着高内聚性,而这种启发式
方法的目标就是使内聚性尽可能地高。内聚性是用来管理复杂度的有用工具,因为当
一个类的代码越集中在个中心标的时候,你就越容易记住这些代码的功能所在。
多年来,在子程序的层面上考虑内聚性一直被认为是一种很有用的启发式方
法,今天还是如此。在类的层面上,内聚性已经更多地被包含在设计良好的抽象这
一概念之内,而后者的内涵更为广阔。在本章的前面部分和第6章中都对后者展开
了讨论。在子程序层上,抽象也同样有用,但是它与内聚性的细节程度差不多。
Build Hierarchies
构造分层结构
分层结构指的是一种分层的信息结构,其中最通用的或者最抽象的概念表
位于层次关系的最上面,而越来越详细的具有特定意义的概念表示放在更低的层
次中。在软件中,在类的层次结构中可以看到分层的组织结构,以及如图5-2中
的第四层所表示的,子程序调用也具有分层结构。
分层结构用作管理复杂信息的重要具已经至少有2000年了亚里士多德用
分层结构来组织动物王国。人类也常常使用大纲来组织复杂的信息(就像这本书
一样)。研究人员发现,人类常常把分层结构看作是管理复杂信息的一种很自然的
方法。当他们画复杂的对象的时候,比如说是一座房屋,他们总是一层层地去画。
首先画出房屋的轮廓,然后画窗口和门,接下来画进一步的细节。而不是一块砖、
一片瓦、一根钉地去画(Simon1996)。
代码大全(第2版)

<==========================142end ==============================>
<==========================143start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
106
第5章软件构建中的设计
分层结构是实现软件的首要技术使命的有用工具,因为它使你能够只关注于
当前正在关注的那一层细节。其他的细节并没有完全消失,它们只是被放到了另
一层次上,这样你就可以在需要的时候去考虑它们,而不是在所有的时间都要考
虑所有的细节。
Formaiize Class Contracts
严格描述类契约
参关于契在另一更为细节的层次上,把每个类的接口看作是与程序的其余部分之间的一
约的更多讨项契约会有助于史好地洞察程序。通常,这种契约会类似于“如果你承诺提供数据
言来注解并验证前X,y和,并且答应让这些数据具有特征a,b和c,我就承诺基于约束8,9和10
条件和后条件”。来执行操作1,2和3。”在这里,由类的客户向该类所做出的承诺通常被称为“前
条件(preconditions)”,而该对象向其客户所做的承诺称为“后条件(postconditions)
契约对于管理复杂度而言非常有益,因为至少从理论上来说,该对象可以很
安全地忽略掉契约范围之外的任何行为。当然在实际中,有关情况会复杂得多。
Assign Responsibilities
分配职责
另一个启发式方法是去想该怎样为对象分配职责问每一个对象该对什么负
责,类似于问这个对象应该隐藏些什么信息,不过我认为这一问题能够带来更为
广阔的答案,从而使这种方法具有特殊的价值。
Design for Test
为测试而设计
有一种思考过程能带来很有趣的对设计的理解,那就是问:如果为了便于测
试而设计这个系统,那么系统会是什么样子?你需要把用户界面与程序的其余部
分分离开来以便能够独立地检查它们吗?你需要设法组织好每一个子系统,使它
与其他子系统之间的依赖关系最小吗?为测试而设计很容易产生更为规整的类接
口,而这通常是非常有益处的。
Avoid Fallure
避免失误
土木工程教授《HenryPeoski,《写了一本很有意思的书,《设计范例:工程中失
误与判断的案例史》(《Design Paradigms Case Histories of Error and Judgment ir
Engineering》, Petroski1994),其中记录了桥梁设计的失误史 Petroski认为,很
多很宏伟的桥梁建设最后却失败了,其原因在于只关注了此前的成功案例,而没
有充分考虑可能的失败模式。他断定,像 Tacoma Narrows大桥这样的失败案例是
本可以被避免的,如果设计者仔细地考虑了桥梁倒塌的可能方式,而不仅是照搬
其他的成功先例所具有的属性的话。
代码大全(第2版)

<==========================143end ==============================>
<==========================144start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
5.3设计构造块:启发式方法
107
过去儿年里许多著名的系统出现了代价高昂的安全性故障,由此我们应该得
到一点共识:必须设法把 Petroski有关设计失误的洞见应用到软件领域中。
Choose Binding Time Consciously
有意识地选择绑定时间
交叉参考关于绑绑定时间指的是把特定的值绑定到某一变量的时间做早绑定的代码通常比较简
定时间的更多讨
论,见第10.6节“绑单,但是也会比较缺乏灵活性有时候你可以通过问类似这样的问题来获得更好的
定时间”。理解:如果我早期绑定这些值会怎样?如果晚些绑定又该如何?如果我在此处就初
始化这张表会怎样?如果我在运行期间从用户那里读入这个变量的值又该怎样?
Make Central Points of Control
创建中央控制点
pj .. Plauger表示,他最关心的就是“唯个正确位置的原则( the Principle of
One Right Place)对于每段有作用的代码,应该只有唯一的一个地方可以看
到它,并且也只能在一个正确的位置去做可能的维护性修改”( Plauger1993)控
制可以被集中在类、子程序、预处理宏以及# include文件里至一个具名常量
也是这种中央控制点的例子。
之所以这么做有助于降低复杂度,其原因在于为了找到某样事物,你需要
查找的地方越少,那么改起它来就会越容易、越安全。
Consider Using Brute Force
考虑使用蛮力突破
拿不准时,用蛮力
蛮力也是一种强人的启发式工具。可不要小看它一个可行的蛮力解决方案
解决
要好于一个优雅但却不能用的解决方案,因为优雅的方案可能要花很长时间才能
Butter Lampson调通。举例来说, Donald Knuth在叙述查找算法的历史时指出,尽管第一篇有关
二分法查找(折半查找)算法的文章在1946就发布了,可16年后才有人发表
了能正确查找各种规模的列表的算法(Knuth998)二分法查找算法是很优雅,
可往往一个蛮力的、顺序的查找算法就足够了。
Draw a Diagram
画一个图
画图是另一种强大的启发式方法。一幅图得上一千句话。你肯定想省下这
一千句话中的大部分,因为使用一幅画的关键一点就是,图能够在一个更高的抽
象层次上表达问题。有些时候你需要去处理问题的细节,可在另一些时间里,你
却需要能够从更一般性的角度出发去工作。
Keep Your Design Modular
保持设计的模块化
模块化的目标是使得每个子程序或者类看上去像个“黑盒子”你知道进去什
么,也知道出来什么,但是你不知道在里面发生了什么。黑盒子有着如此简洁的
代码大全(第2版)

<==========================144end ==============================>
<==========================145start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^ ^.com!仅供试看
108
第5章软件构建中的设计
接口设计和定义明确的功能,对于给定任何特定的输入,你都能准确预期相应的
输出结果。
模块化这一概念和信息隐藏、封装以及其他的设计启发密切相关。但在一些
时候,如果你去考虑如何把一堆黑盒子组装成系统,也许会获得单纯使用信息隐
藏和封装技术所无法获得的深刻理解,因此这个概念值得放进你的设计工具箱中。
Summary of Design Heuristics
关于设计启发的总结
更令人打
的是
下面是对主要的设计中的启发式方法的总结:
一个程序员能以两
种或三种不同的方寻找现实世界的对象(object,物体)
式来完成同一个任
务
,有时是不知不形成一致的抽象
觉的,但更常见的
是为了做修改,或
封装实现细节
者为了提供优雅的
在可能的情况下继承
解决方案。
A.r. Brown和藏住秘密(信息隐藏)
W.A.Sampson
■找出容易改变的区域
■保持松散耦合
探寻通用的设计模式
下列的启发式方法有时也很有用:
■高内聚性
■构造分层结构
严格描述类契约
分配职责
为测试而设计
避免失误
有意识地选择绑定时间
创建中央控制点
考虑使用蛮力
画一个图
保持设计模块化
代码大全(第2版)

<==========================145end ==============================>
<==========================146start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
5.3设计构造块:启发式方法
109
Guidelines for Using Heuristics
使用启发式方法的原则
软件中的设计方法可以从其他领域中的设计方法借鉴许多东西。最早有关解
决问题的探索方法的著作之一便是G波利亚写的《怎样解题》(《《《HowtoSoIveIr)》
1957)。 Polya提出的解决问题的一般方法是针对数学领域的。图5-10对他所提出
的方法做出了总结,改编自他的书中一份类似的总结。
cc2ecm/05921.理解问题。你必须要理解问题。
未知量是什么?现有的数据是什么?条件是什么?能够满足这些条件吗?这
些条件足以决定出未知量吗?还是并不够?或者其中有冗余?甚至是矛盾的?
画一幅图,引进一些合适的记号,把条件的不同部分分离开。你能把它们
一一写下吗?
2.设计一个计划。找出现有数据和未知量之间的联系。如果你找不出居中的联系,
那么可能还得考虑些辅助性的问题。最终你应该能得出一份解决方案的计划来。
在此之前你遇见过这一问题吗?或者曾经遇见过与此差别不大的问题?
你知道某个相关的问题吗?你知道一个可能会有用的定理吗?
盯住那个未知量!试着想出一个有着相同或者类似的未知量的问题来。一定
有一个和你的问题相关的而且此前已被解决过的问题,你能用它吗?你能用它的
结果吗?或者用它的方法?为了让它有用你需要再引入一些辅助的元素吗?
你能再重述这个问题吗?你能再次用与以前都不同的方式重述这个问题
吗?回过头去考虑一下定义吧。
如果你还是解决不了提出的这个问题,那么试着先去解决一些相关的问题。
你能设想出一个更容易解决的与此有关的问题吗?一个更一般的问题?一个更特
殊的问题?一个类似的问题?你能解决这个问题的一部分吗?只留下一部分条件
而去掉其他条件,未知量能够确定多少,它又能怎样变化?你能从这些数据中得
出有用信息吗?你能找出其他适合用于确定未知量的数据吗?你能修改未知量或
者已知数据,或者必要时修改两者,以便新的未知量和新的数据更加接近吗?
你使用了全部的数据吗?你使用了所有的条件吗?你考虑了该问题所涉
及的所有核心概念了吗?
3.执行这一计划。请执行你的计划。
执行你的求解计划,检查每一步。你能清楚地看到每一步都是正确的吗?
你能证明它是正确的吗?
4.回顾。检视整个的解。
你能核对结果吗?你能核对论据吗?你能用不同的方法来得出这个结果
吗?你能一眼就看出来吗?
你能在其他问题上使用这一结果或方法吗?
图5-10G.波利亚在数学领域发展的一套解决问题的方法,它同样可以用于解决软
件设计中的问题(Polya1957)
代码大全(第2版)

<==========================146end ==============================>
<==========================147start==============================>

该书下载自-书部落-分享计算机经典巨著!www. ! --www.shubul.com!仅供试看^
110
第5章软件构建中的设计
最有效的原则之一就是不要卡在单一的方法上。如果用UML画设计图不可
行,那么就直接用英语来写。写段简短的测试程序。尝试一种截然不同的方法。
想出一种蛮力解决方案。用铅笔画出轮廓和草图来指导思维。如果这些方法都不
行,那么就先离开这个问题。可以去散散步,或者去想一想其他的事情,然后再
回来重新面对这个问题。如果你尽了全力还没能取得突破,那么暂时不要去想它
反而会比穷思苦想的效果要好。
你无须马上解决整个设计难题。旦被卡住了,那么请记住回过头来时有一
处地方需要做决策,但眼下你还没有足够的信息来解决这个问题。为什么要在最
后的20%设计环节冥思苦想,如果后来能轻易地找到答案呢?为什么在自己还缺
少经验时一定要去做出一些不好的设计、而不等到日后自己经验丰富时再做出更
好的决策呢?有些人如果在一个设计循环过后没有把所有的问题都解决,就会感
到很不舒服。实际上,如果你尝试了一些设计方案,但没有很好的解决问题的时
候,更自然的方式是让那些问题留在末解决的状态,等到你拥有更多信息之后再
去做(Zahniser1992,Beck2000)
5.4
Design Practices
设计实践
前面几节关注的都是与设计特性相关的启发式方法你希望完成后的整体
设计成为什么样子。这一节将会讲解一些设计实践的启发式方法,一些你可能采
用而且常常可以获得良好结果的工作步骤
Iterate
迭代
你可能有过这样的经验:有时候你会从开发某个程序中学到很多的知识,多
得让你想带着写第一遍时所获得的体会再写一遍这种现象也同样出现在设计活
动中,只是设计的周期更短,向下进行的压力更大,因此你只能负担不多的几次
设计循环。
设计是一种迭代过程。你并非只能从A点进行到B点,而是可以从A点到达
B点,再从B点返回到A点
KEY POINT
当你在备选的设计方案之中循环并且尝试些不同的做法时,你将同时从高
层和低层的不同视角去审视问题。你从高层视角中得出的大范围图景会有助于你
把相关的底层细节纳入考虑。你从底层视角中所获得的细节也会为你的高层决策
奠定基础。这种高低层面之间的互动被认为是一种良性的原动力,它所创建的结
代码大全(第2版)

<==========================147end ==============================>
<==========================148start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
5.4设计实践
111
构要远远稳定于单纯自上而下或者自下而上创建的结构
很多程序员——或者说很多人——对在高层和低层思考之间的升降感到困惑。
从系统的一个视角转到另一个视角,从智力上来说是很费力的,但对于创建有效
的设计方案而言却是极其重要的。如果你想获得愉悦的、提高智力灵活性的练
习,请阅读本章后面“更多资源”一节里提到的《 Conceptual Blockbusting》
书(Adams2001)
交叉参考重构当你首次尝试得出了一个看上去足够好的设计方案后,请不要停下!第二
是试验代码的个尝试几乎肯定会好于第一个而你也会从每次尝试中都有所收获,这有助于改
他实现方案的安
全途径详情见第善整体设计。在经历了100次研究灯丝材料的失败以后,有人问爱迪生,因为
24章“重构”。他什么也没有发现,会不会感到时间全都浪费了。“当然不会”,爱迪生大概是这
样回答的,“因为我已经发现了1000种材料是不能用的。”在大多数情况下,用
一种方法来解决问题会为你带来一些新的洞察力从而帮助你使用另一种更好的
方法来解决问题。
Divide and Conquer
分而治之
正如 Edsger Dijkstra所说,没有人的头脑能大到装得下一个复杂程序的全部
细节,这对设计也同样有效。把程序分解为不同的关注区域,然后分别处理每
个区域。如果你在某个区域里碰上了死胡同,那么就迭代!
增量式地改进是一种管理复杂度的强大工具。正如 Polya在数学问题求解中所
建议的那样——理解问题、形成计划、执行计划,而后再回顾你的做法(Polya1957)
Top-Down and Bottom-Up Design Approaches
自上而下和自下而上的设计方法
“自上而下”和“自下而上”听起来有点陈旧,不过它们确实为创建面向对
象设计方案提供了很有价值的认识。自上而下的设计从某个很高的抽象层次开始
你定义出基类或其他不那么特殊的设计元素。在开发这一设计的过程中,你逐渐
增加细节的层次,找出派生类、合作类以及其他更细节的设计元素。
下而上的设计始于细节,向一般性延伸。这种设计通常是从寻找具体对象
开始,最后从细节之中生成对象以及基类。
有些人坚持认为从一般性出发向具体延伸是最佳做法,而有些人则表示除非
你已经解决了大量的细节问题,否则无法真正地定义出一些一般性的设计原则。
下面是这两种观点各自的论据。
代码大全(第2版)

<==========================148end ==============================>
<==========================149start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
112
第5章软件构建中的设计
Argument for Top Down
自上而下的论据
居于自上而下方法背后的指导原则是这样的一种观点:人的大脑在同一时间
只能集中关注一定量的细节。如果你从一般的类出发,一步步地把它们分解成为
更具体的类,你的大脑就不会被迫同时处理过多的细节。
这种分而治之的过程从某些意义上来说也是迭代的首先,说它是迭代的,
因为你通常不会在完成一层分解之后停下来你还会继续分解几层。其次,说它
是迭代的,还因为你通常不会满足于你的第一次尝试。你用一种方法来分解程序。
在分解过程的不同阶段,你需要就采用什么方法去分解子系统做出选择,给出继
承关系树,形成对象的组合。你做出选择然后看看是什么结果。接下来,你又换
用另一种方法重新开始分解,以便看新方法是否效果更佳。这样尝试几次以后,
你就会很清楚哪些方法会奏效,以及它们能够奏效的原因。
如何确定分解的程度呢?持续分解,直到看起来在层直接编码要比分解
更容易。一直做到设计思路已显而易见而且非常容易,以致你对继续分解下去已
经产生了厌倦。那时候你就完成了分解工作。如果设计思路还不明了,那么请再
多做些。如果目前的解决方案对你来说都有些棘手,那么当日后他人再去面对的
时候也肯定会感到负担重重
Argument for Bottom Up
自下而上的论据
有时候自上而下的方法会显得过于抽象,很难入手去做。如果你倾向于用一种
更实在的方法,那么可以尝试自下而上的方法。问你自己,“我对这个系统该做的
事情知道些什么?”毫无疑问,你可以回答这个问题。你可能会找出一些能够分配
给具体类的低层的职责。例如,你知道一个系统需要对报表进行格式化,为报表计
算数据,把标题居中,在屏幕上显示报表,以及打印该报表等等。一旦你找出了一
些低层的职责,你通常会感到,再从顶上去观察系统已经舒服些了
在另一些情况中,设计问题里的一些主要属性是由底层决定的。你可能
需要去与硬件设备打交道,它们的接口需求决定了你的设计里很大的一部分。
下面是在做自下而上合成的时候你需要考虑的一些因素:
问你自己,对系统需要做的事项,你知道些什么。
根据上面的问题,找出具体的对象和职责
找出通用的对象(common objects),把它们按照适当方式组织起来
系统、包、对象组合,或者继承看哪种方式合适。
在更上面一层继续工作,或者回到最上层尝试向下设计
代码大全(第2版)

<==========================149end ==============================>
<==========================150start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
5.4设计实践
113
No Argument, Really
其实并没有争议
自上而下策略和自下而上策略的最关键区别在于,前者是一种分解
(decomposition)策略而后者是一种合成(composition)策略前者从一般性的
问题出发,把该问题分解成可控的部分。后者从可控的部分出发,去构造一个通
用的方案。这两种方法都有各自的强项和弱项,如果你想在设计中采用它们的时
候,就需要予以考虑
自上而下设计的强项是它很简单,因为人们是很善于把一些大的事物分解为
小的组件,而程序员则更是精于此道。
自上而下设计的另一强项是你可以推迟构建的细节。软件系统常常会受到构
建细节变化(例如文件结构或者报表格式的变化)的骚扰,因此,尽早知道应该
把这些细节信息隐藏在继承体系的底层类中,是非常有益的。
自下而上设计的一个强项是通常能够较早找出所需的功能,从而带来紧凑的、
结构合理的设计。如果类似的系统已经做过,那么白下而上设计让你能审视已有
的系统,并提出“我能重用些什么?”一类的问题,由此出发开始新系统的设计。
自下而上设计的一个弱项是很难完全独立地使用它。大多数人都很善于把大
概念分解为小概念,而不擅长从小概念中得出大概念这就像在自己组装玩具:
我想自己已经组装完了,可为什么盒子里还有零件呢?所幸的是,完全不必仪使
用自下向上这一种设计方法。
自下而上设计的另一弱项是,有时候你发现自己无法使用手头已有的零件来
构造整个系统。你不可能用砖块来建造飞机。你可能要先做高层设计,才能知道
底层需要什么零件。
总而言之,自上而下设计通常比较容易上手但是有时候会受底层复杂度的
影响,这种影响甚至有时会使事情变得比实际的情况更复杂自下而上设计开始
起来比较复杂,但是在早期鉴别出系统的复杂度,却有助于设计出更好的高层类
当然这样做的前提是复杂度没有先把整个系统破坏掉!
最后要说的是,白上而下和自下而上设计并不是互相排斥的你会受益于
二者的相互协作。设计是一个启发式(试探)的过程,这意味着没有任何解决方
案能够保证万无一失。设计过程中充满了反复的试验,请多尝试些设计方法,直
到找到最佳的一种。
代码大全(第2版)

<==========================150end ==============================>
<==========================151start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
114
第5章软件构建中的设计
Experimental Prototyping
建立试验性原型
cc2cm/059有些时候,除非你更好地了解了一些实现细节,否则很难判断一种设计方法
是否奏效。比如说,在知道它能满足性能要求之前,你很难判断某种数据库的组
织结构是否适用。在选定系统使用的图形界面(GU)程序库之前,你也很可能
判断不出某一特定了系统的设计是否到位。这些都是软件设计中本质性“险恶
( wickedness)”的例子除非你部分地解决了某设计问题,否则你无法完整
地定义出该设计问题。
有一种技术能够低成本地解决这个问题,那就是建立试验性原型。“建立原型
(prototyping)”一词对不同人来说具有不同的含义(McConnel996)。在这里,
建立原型指的是“写出用于回答特定设计问题的、量最少且能够随时扔掉的代码”
这项活动。
如果开发人员没有把握住用最少代码回答提问的原则,那么原型方法的功效
就会大打折扣。假设说,设计问题是“我们选定的数据库框架能否支撑所需的交
易量?”你不需要为了这一问题而编写任何产品代码,你也不需要去了解数据库
的详情。你只需要了解能估计出问题范围的最少信息有多少张表、表中有多
少条记录,等等。接下来你就可以用 Tablel、 Table22、 Columnl1、 Column2等名字
写出最简单的原型代码,往表里随意填入些数据然后做你所需要的性能测试。
当有关设计的问题不够特殊的时候,原型同样也会失效诸如“这样的数据
库框架能否工作?”的设计问题并没有为建立原型提供多少指引。而像“这个数
据库框架能不能在X、Y和Z的前提下支持每秒1000次交易?”这样的问题则能
为建立原型提供更坚实的基础。
最后的一个可能会给原型带来风险的做法是开发人员不把原型代码当作可
抛弃的代码。我发现,如果开发人员相信某段代码将被用在最终产品里,那么他
根本不可能写出最少数量的代码来。这样做最终其实是在实现整个系统,而不是
在开发原型。相反,如果你建立了这样的概念,那就是一旦回答了所提出的问题,
这段代码就可以被扔掉,那么你就可以把上述风险减到最小避免产生这一问题
的一种做法是用与产品代码不同的技术来开发原型。你可以用 Python来为java
设计做原型,或者用 Microsoft PowerPoint模拟用户界面。如果你必须要用同
种技术来开发原型,那么可以采纳一个非常实用的标准:在原型中的类或者包的
名称之前加上 prototype前缀。这样至少能保证程序员在试图拓展原型代码之前能
够三思(Stephens2003)
代码大全(第2版)

<==========================151end ==============================>
<==========================152start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看
5.4设计实践
115
一依照上述原则加以应用,那么原型就会成为设计者手中用来处理险恶设
计问题的有力工具。如果不遵照上述原则,那么原型就会给设计再平添许多风险。
Collaborative Design
合作设计
交叉参考关干在设计过程中,三个臭皮匠顶得上一个诸葛亮,而不论组织形式的正式与否。
合作开发的详情
见第21章“协同构
构合作可以以下面任意一种方式展开。
建”
你随便走到一名同事的办公桌前,向他征求一些想法。
你和同事坐在会议室里,在白板上画出可选的设计方案。
你和同事坐在键盘前面,用你们的编程语言做出详细的设计,换句话说,你
们可以采用结对编程,第21章“协同构建”中对结对编程有描述。
你约一名或者多名同事来开会,和他们过一遍你的设计想法。
你按照第21章中给出的结构来安排一次正式检查( formal inspection)c
你身边没有人能检查你的工作,因此当你做完一些初始工作后,把它们全放
进抽屉,一星期后再来回顾。这时你会把该忘的都忘了,正好可以给自己做
一次不错的检查。
你向公司以外的人求助:在某个特定的论坛或者新闻组里提问。
如果这样做的目标是保证质量,那么我倾向于推荐高度结构化的检查实践
一正式检察,其原因在第21章中解释。但是如果目标是提高创造力并且引入更
多的备选设计方案,而不仅仅是找到缺陷的话,那么结构化程度较低的一些方法则
比较适宜。在你确定选用了某一特定设计方案之后,转而使用一种更为正规的检查
方式非常可取,但是这也要取决于你的项目本身的情况。
How Much Design Is Enough
要做多少设计才够
我们试图赶紧做
完设计,然后在项
有些时候,编码之前只制订出系统架构的一个最小梗概。而在另一些时候,
目后期留出足够开发团队会把设计做得非常详细,使编码变成了一种近乎机械式的工作。那么在
的时间来暴那编码前到底需要做多少设计呢?
些因为“快速通过
设计流程”而造成有一个问题与此相关,那就是上述设计应该做得有多正规。你需要正式的、
的问题。
-Glenford Myers
精美的设计图表,还是只需要给画在白板上的设计草图排个数码照片作为设计文
档呢?
代码大全(第2版)

<==========================152end ==============================>
<==========================153start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor.com!仅供试看^
116
第5章软件构建中的设计
对于实施正式编码阶段前的设计工作量和设计文档的正规程度,很难有个准
确的定论。有很多因素,如团队的经验、系统的预定寿命、想要得到的可靠度、
项目的规模和团队的大小等等都需要考虑进去。表5-2总结了这些因素是如何影
响设计活动的。
表5-2设计文档的正规化以及所需的细节层次
因素
开始构建之前的设计文档正规程度
所需的细化程度
设计或构建团队在应用程序领域
低
有很丰富的经验
设计或构建团队有很丰富的经验,
低中
中
但是在这个应用程序领域缺乏经验
设计或构建团队缺乏经验
中到高
低到中
设计或构建团队人员变动适中或者较高
应用程序是安全攸关的
应用程序是使命攸关的
项目是小型的
项目是大型的
软件预期的生命周期很短
(几星期或者几个月)
中高中低中低中
高到低中低中
软件预期的生命周期很长
(几个月或者几年)
对于一个特定的项目来说,这其中的两个或者更多因素可能起着关键作用。
在某些情况下,从这些因素也可能得出有矛盾的建议。比如说,你带一支经验非
常丰富的团队开发对安全性要求很高的软件这时,你可能宁愿采用更高的设计
细化程序以及更正规的设计文档。也就是说,在这种情况下,你需要去评估每一
项因素的重要性,然后根据结果来做出重要性的权衡。
如果设计层次的问题是留给程序员个人去解决的话,那么,当设计下降到你
曾经完成过的某项任务的层次,或者变成了对这样一项任务的简单修改或扩充的
时候,你很可能就会停止设计而马上开始编码。
代码大全(第2版)

<==========================153end ==============================>
<==========================154start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看
5.4设计实践
117
如果在编码之前我还判断不了应该在做多深入的设计,那么我宁愿去做更详
细的设计。最大的设计失误来自于我误认为自己已经做得很充分,可事后却发现
还是做得不够,没能发现其他一些设计挑战。换句话说,最大的设计问题通常不
是来自于那些我认为是很困难的,并且在其中做出了不好的设计的区域;而是来
自于那些我认为是很简单的,而没有做出任何设计的区域。我几乎没有遇到过因
为做了太多设计而受损害的项目。
我从来没有遇到
另一方面,我偶尔会看到一些项目因太过于专注对设计进行文档化而导致失
读17000页败 Gresham法则是这么说的,“程序化的活动容易把非程序化的活动驱逐出去”
档,如果真有这样(Simon1965)。过早地去润色设计方案就是这一法则所描述的例子。我宁愿看到
的人,我想把他杀有80%的设计精力用于创建和探索大量的备选设计方案,而20%的精力用于创建
掉,让他从人类基
因库中消失
并不是很精美的文档,也不愿看到把20%的精力花在创建平庸的设计方案上,而
Joseph Castelio
把80%的精力用于对不良的设计进行抛光润色。
Capturing Your Design Work
记录你的设计成果
cc/050传统记录设计成果的方式是把它写成正式的设计文档。然而,你还可以用
很多种方法来记录这一成果,而这些方法对于那些小型的、非正式的项目或者只
需要轻量级的记录设计成果的方式的项目而言效果都很不错。
坏消息是,就我们
把设计文档插入到代码里在代码注释中写明关键的设计决策,这种注释通
看来,我们从没找常放在文件或者类的开始位置。如果你同时使用类似于 JavaDoc这样的文档提取
从没找到一种能以工具,那么这种方法会确保设计文档对于开发这部分代码的程序员来说是立等可
完全理性的方式设取的,同时也有助于程序员保持代码和设计文档之间的相当不错的同步。
计软件的设计过
程。好消息是,我
用Wiki来记录设计讨论和决策把你们的设计讨论写到项目的iki里去
们可以伪造一个这(Wiki是指一组可以由项目组所有员用网络浏览器轻松编辑的网页)尽管文字
种过程
David Pamas录入要比交谈麻烦一些,但这样会自动地记录下你们的设计讨论和设计决策。如
和 FPaul Clements果使用Wiki,你可以用图片来弥补文字讨论的不足,并链接支持该设计决策的网
站、白皮书及其他材料。如果你的开发团队在地理位置上是分布式的,那么这种
技术会非常有帮助。
写总结邮件每次就设计展开讨论过后,请采取这种做法,即指派某人来写
出刚才讨论的纲要一特别是那些决定下来的事项然后发送给整个项目组
在项目的公共电子邮件文件夹里保留一份备份。
代码大全(第2版)

<==========================154end ==============================>
<==========================155start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
118
第5章软件构建中的设计
使用数码相机在对设计进行文档化时有一个很常见的障碍,那就是用流行
的画图工具画设计图表太麻烦。不过文档化可不仅限于“用漂亮的格式、正规的
符号来记录设计”和“不做任何设计文档”这两种选择。
把白板上画出的图表照成相片然后嵌入到传统的文档里,这样做可以带来事
半功倍的效果,因为它的工作量只是用画图具画设计图表的1%,而它的收益却
能达到保存设计图表的80%。
保留设计挂图没有哪条法律规定你只把设计文档记录在标准的A4尺寸的
纸上。如果你把设计记录在大的挂图上,那么你只需把这些挂图保存在方便的地
方即可,或者采用更好的做法,把它们张帖在项目上作区域的墙上,让大家能够
很容易地随时查阅和修改。
cc2e.com/0513
使用CRC(类、职责、合作者)卡片另外一种技术含量较低的文档记录方
案是使用索引卡片。在每张卡片上,设计者写下类的名称、职责和合作者(与这
个类合作的其他类)。一个设计团队便按照这些卡片的内容展开工作,直到他们认
为已经创建出一个好的设计方案为止。到那个时候,你只需把这些卡片保留下来,
留待日后引用。索引卡片非常便宜,不吓人,易于携带,并且有助于促进团队合
作(Beck1991)
在适当的细节层创建UML图一种流行的绘制设计图的方法是由对象管理
组织(Object Management Group)定义的统一建模语言(UML)( Fowler2 2004)
本章前面的图5-6便是UML类图的一个例子。UML提供了一套丰富的、形式化
的表示法,可用于设计实体(entity)及其关系relationship)你可以用非正式的
UML图来帮助讨论和发现设计思路。从最简单的草图开始,直到你最终选定了一
套设计方案,才往其中增加细节。由于UML是标准化的,因此在交流设计观念
时大家都能理解它,同时还能加快团队共同讨论各种设计方案的速度。
上述这些技术也可以以各种不同的组合形式使用,所以请在不同的项目上、
甚至在同一个项目内部的不同区域里组合使用这些技术。
5.5
Comments on Popular Methodologies
对流行的设计方法的评论
综观软件设计的历史,你可以看到大量的、相互矛盾的设计方法被各自的支
持者们所鼓吹。当我在20世纪90年代早期发表《代码大全》第1版时,设计方
案的信徒们正在鼓吹说在着手编码之前,应该完善设计的每一处细节。这种推荐
事实上根本没有任何意义。
代码大全(第2版

<==========================155end ==============================>
<==========================156start==============================>

该书下载自-书部落-分享计算机经典巨著!--www ! --www.shubu.com!仅供试看^
更多资源
119
有一些人鼓吹软
当我在21世纪前十年的中期撰写现在这个版本时,一些软件学者正在争辩说
件是一项遵守纪
律的活动,他们花根本不需要做任何的设计。“预先做大量的设计(Big Design Up Front)是bduF”
了相当多的精力他们说,“BDUF很不好。你在着手写代码之前最好不要做丝毫的设计!”
来让我们感到愧
。我们耗尽毕生十年之内,设计的钟摆就从“计切”摆动到了“不做设计”不过,bDUF
精力也到不了“足的替换方案却不是不做预先设计,而是预先做一点设计(Little Design Up Front,
够结构化”或“足LDUF),或者预先做足够的设计(Enough Design Up Front,enu
够面向对象”的极
乐世界。我们都背那么你怎样才能判断出需要多少设计才够呢?这是一个主观判断,没有人能完
负着“在可塑性很美地回答它。不过,在你没有足够的信心去判断最佳设计量的时候,请记住有两种
强的年纪学过
Basic的原罪。情况一定是不对的:设计所有的细节和不做任何设计。这两个由位于立场两端的极
但是,我敢打赌我端主义者所倡导的做法,恰恰被证明是仅有的两个永远是错误的做法。
们中的大多数人
都是比那些纯化
正如 Plauger所言,“你在应用某种设计方法时越教条化,你所能解决的现
论者更优秀的设实问题就会越少”( Plauger1993)请把设计看成是一个险恶的、杂乱的和启发式的
计师,尽管他们不过程。不要停留于你所想到的第一套解决方案而是去寻求合作,探求简洁性,在
愿意承认这一点。
.J. Plauger需要的时候做出原型,迭代,并进一步迭代。你将对自己的设计成果感到满意。
Additional Resources
更多资源
cc2e.com/0520
软件设计是个非常富饶的领域,有大量的资源可以使用,你面临的挑战是找
出哪些资源最有用。下面就此给出一些建议
Software Design, General
软件设计,一般性问题
Weisfeld,matt. The Object-Oriented Thought Process《面向对象的思考过
程(第二版)》),2ded.SAMS,2004.这是一本易于理解的介绍面向对象编程的书。
如果你已经很熟悉面向对象编程,那么可能需要一本更高级的书,不过如果你刚
刚涉足面向对象领域,那么这本书介绍了面向对象的一些基本概念,包括对象、
类、接口、继承、多态、重载、覆盖、抽象类、聚合和联合、构造函数和析构函
数、异常等等。
Riel, Arthur.《 Object-Oriented- Design HeuristicsOOD启思录》) Reading
MA: Addison-Wesley-,1996.这本书关注在类这一层次上的设计,非常容易理解。
Plauger, P.J. Programming on Purpose: Essays on Software Design
Englewood Cliffs NJ: PTR Prentice Hall,1993.从这本书里学到的有关软件设计
的好点子和我从所有读过的其他书中学到的一样多 Plauger精通大量的设计方法,
他很注重实效,同时也是个伟大的作家。
代码大全(第2版)

<==========================156end ==============================>
<==========================157start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
120
第5章软件构建中的设计
Meyer, Bertrand.《 Object-Oriented- Software Construction》《面向对象软件构
造》,2ded. New York,ny Prentice Hall PTR,997. Meyer在这里极力提倡彻底的
面向对象编程。
Raymond, Eric.《 The Art of UNIX Programming》(《UNIX编程艺术》) Boston
MA: Addison-Wesley-,2004.这本书从Unix的角度很好地研究了软件设计。第1.6
节用12页的篇幅简明扼要论述了17项关键的Unix设计原则
Larman, Craig. <Applying UML and Patterns: An Introduction to Object-Oriented
Analysis and Design and the Unified Process《uml和模式应用》),2ded
Englewood Cliffs, NJ Prentice Hall,200.这是一本很流行的基于统一过程
( Unified Process)介绍面向对象设计的著作书中同时还讨论了面向对象分析。
Software Design Theory
软件设计理论
Parnas, David L., and Paul C. Clements. "A Rational Design Process: How and
Why to Fake It"(一种理性的设计过程:如何以及为何去仿制它) IEEE Transactions
on Software Engineering SE-,no.2February1986):251257.这篇经典文章描
述了在程序的设计理想和实际之间的巨大差距关键之处在没有人真正经历过理
性的、有序的设计过程,但是以此为目标的确能在最后产生出更好的设计方案。
我不知道是否有全面论述信息隐藏的资料。大多数的软件工程书里都只是简
单地提了一下,通常都是在讲述面向对象技术的语境中提及下面列出的 Parnas
的三篇文章,是他关于这一想法的学术论文大概也是到目前为止有关信息隐藏
的最好的资料了:
Parnas, David L. "On the Criteria to Be Used in Decomposing Systems into
Modules."(论将系统分解为模块的准则)《 Communications of the ACM》5,no.
12(December1972):1053—1058.
Parnas, David L. "Designing Software for Ease of Extension and Contraction."
(设计易于扩展和收缩的软件)《 IEEE Transactions on Software Engineering》
se-,no.2(March1979):128138
Parnas, David., Paul. Clements,andd.m. Weiss.“The Modular Structure of
”(复杂系统的模块化架)《 KIEEE Transactions on Software
Engineering> SE-11, no. 3 (March 1985): 259 266.
Design Patterns
设计模式
Gamma, Erich,etal.《 Design Patterns(《设计模式》). Reading,MA:
Addison-Wesley-,1995.这本由“四人组(Go)”写成的著作是设计模式领域的开
山之作。
Shalloway,alan, and James. Trott.《 Design Patterns Explained》《设计模式精
解》) Boston,ma: Addison-Wesley-,202.这本书对设计模式做了深入浅出的介绍。
1译注:这就是那篇提出抽象数据类型(ADT)的著名论文
代码大全(第2版)

<==========================157end ==============================>
<==========================158start==============================>

该书下载自书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^ ^.com!仅供试看
更多资源
121
Design in General
广义的设计
Adams, James L. Conceptual Blockbusting: A Guide to Better Ideas), 4th ed.
Cambridge, MA Perseus Publishing,20尽管这本书不是专门讲解软件设计的,
但斯坦福大学用它来向工科学生讲解设计。哪怕你从不做任何的设计,这本书也
对创新思维过程做了非常棒的描述。书中包含了很多有效设计所需的思维训练,
同时还给出并且很好地评荐了一份有关设计和创造性思维的书目。如果你喜欢解
决问题,那么你会喜欢这本书的
Polya, G How to Solve It: A New Aspect of Mathematical Method), 2d ed.
Princeton, NJ Princeton University Press957.这本书讲解了数学领域中的启发式方
法和问题求解,但是也同样适用于软件开发。 Polya的这本书首次在数学问题求解
领域内引入启发式方法。他在书中清楚地区分了用于探索问题的杂乱无章的启发式
方法,和一旦找到解决方案后如何呈现解法的整理方法。这本书读起来并不容易,
可是如果你对启发式方法感兴趣,那么不管你想不想,最终都会去读它。 Polya在
书中明确说明,问题求解并不是一个确定性的活动,如果你固执在某一种方法之上
那么无异于作茧自缚。曾经有一段时间, Microsoft把这本书送给了她的所有新员
Michalewicz, Zbigniew, and David. Fogel.《 How to Solve It: Modern
Heuric《.BeriaSpringerVerIg,200(《如何求解问题现代启发式方法》erlin:spiger-verag00
这本书对 Polya的书做出了更新,相比之下更容易阅读,而且包含了一些非数学
领域的例子。
Simon, Herbert. The Sciences of the Artificial), 3d ed. Cambridge, MA: MIT
Pres,1996.这本书对与自然界相关的科学(生物学、地质学等)和与人造世界相
关的科学(商业、建筑以及计算机科学)之间的差异做了非常精彩的描述。接下
来,书中讨论了与人造世界相关的科学的特征,并着重强调了设计科学。对于那
些渴望在软件开发或者任何“人造的”领域内工作的人来说,这都是一本很好的
学院派论著,值得一读。
Glass, Robert L. Software Creativity). Englewood Cliffs, NJ: Prentice Hall PTR
1995.软件开发更多地是由理论指导还是由实践指导?软件开发从根本上而言是
创造性的还是确定性的?软件开发人员需要什么样的智力资质?这本书针对软件
开发的本质展开了有趣的讨论,并且特意关注了设计。
Petroski, Henry. Design Paradigms: Case Histories of Error and Judgment in
Engineering》. Cambridge: Cambridge University Press194.这本书主要讨论土木
工程领域(特别是桥梁设计)的情况,作者的观点是:成功的设计至少应该同等
地依赖于从过去的失败中学习和从过去的成功中学习。
代码大全(第2版)

<==========================158end ==============================>
<==========================159start==============================>

该书下载自书部落-分享计算机经典巨著--www. !--www.shubulo.com!^.com!仅供试看
122
第5章软件构建中的设计
Standards
标准
IEEE Std 1016-1998, Recommended Practice for Software Design Descriptions.
这份文档包含了用于描述软件设计的IEEE-ANS标准。它说明了应该把哪些放入
软件设计文档中。
IEEE Std 1471-2000. Recommended Practice for Architectural Description of
Software Intensive Systems. Los Alamitos,ca: IEEE Computer Society Press这份文
档是用于创建软件架构规范的IEEE-ANSI指南。
CHECKLIST Design in Construction
cc26.com05270核对表:软件构造中的设计
设计实践
你已经做过多次迭代,并且从众多尝试结果中选择最佳的一种,而不是
简单选择第一次尝试的结果吗?
口你尝试用多种方案来分解系统,以确定最佳方案吗?
口你同时用自下而上和自上而下的方法来解决设计问题吗?
口为了解决某些特定的问题,你对系统中的风险部分或者不熟悉的部分创
建过原型、写出数量最少的可抛弃的代码吗?
口你的设计方案被其他人检查了吗(无论正式与否)?
口你一直在展开设计,直到实施细节跃然纸上了吗?
口你用某种适当的技术—比如说Wiki、电子邮件、挂图、数码照片、UML、
CRC卡或者在代码写注释来保留设计成果吗?
设计目标
口你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项?
口你的设计被划分为层次吗?
口你对把这一程序分解成为子程序、包和类的方式感到满意吗?
口你把对这个类分解成为子程序的方法感到满意吗?
口类与类之间的交互关系是否已设计为最小化了?
代码大全(第2版)

<==========================159end ==============================>
<==========================160start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww ! -www.shubulo...com!仅供试看^
要点
123
口类和子程序是否被设计为能够在其他的系统中重用?
口程序是不是易于维护?
口设计是否精简?设计出来的每一部分都绝对必要吗?
口设计中是否采用了标准的技术?是否避免使用怪异且难以理解的元素?
口整体而言,你的设计是否有助于最小化偶然性的和本质性的复杂度吗?
Key Points
要点
软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对
此最有帮助。
简单性可以通过两种方式来获取:一是减少在同一时间所关注的本质性复杂
度的量,二是避免生成不必要的偶然的复杂度。
设计是一种启发式的过程。固执于某一种单一方法会损害创新能力,从而损
害你的程序。
好的设计都是迭代的。你尝试设计的可能性越多,你的最终设计方案就会变
得越好
信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么?”能够解
决很多困难的设计问题。
很多有用有趣的、关于设计的信息存在于本书之外。这里所给出的观点只是
对这些有价值资源的一点提示而已。
代码大全(第2版)

<==========================160end ==============================>
<==========================161start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo...com!仅供试看^

<==========================161end ==============================>
<==========================162start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo..com!仅供试看^
Working Classes
第6章
可以工作的类
cc2e.com/0665/66内容
6.1类的基础:抽象数据类型(ADTs):第126页
6.2良好的类接口:第133页
6.3有关设计和实现的问题:第143页
6.4创建类的原因:第152页
6.5与具体编程语言相关的问题:第156页
6.6超越类:包:第156页
相关章节
软件构建中的设计:第5章
软件架构:第3.5节
高质量的子程序:第7章
■伪代码编程过程:第9章
■重构:第24章
在计算时代的早期,程序员基于语句思考编程问题到了20世纪七八十年代
程序员开始基于子程序去思考编程。进入21世纪,程序员以类为基础思考编程问
题。
类是由一组数据和子程序构成的集合,这些数据和子程序共同拥有一组内聚
的、明确定义的职责。类也可以只是由一组子程序构成的集合,这些子程序提供
KEY POINT一组内聚的服务,哪怕其中并未涉及共用的数据。成为高效程序员的一个关键就
在于,当你开发程序任一部分的代码时,都能安全地忽视程序中尽可能多的其余
部分。而类就是实现这一目标的首要工具。
本章将就如何创建高质量的类提供一些精辟的建议。如果你是刚刚开始接触
面向对象的概念,那会觉得本章的内容比较难懂。所以请一定先阅读第5章“软
件构建中的设计”,然后再阅读第6.1节“类的基础:抽象数据类型(ADTs)”。之
后,你就应该可以比较轻松地阅读剩余各节了。如果你已经对类的基础知识比较
熟悉,那么可以略读第6.1节后深入阅读第6.2节关于类接口的论述。另外,在本
章最后“更多资源”中还包含对其他一些初级读物、高级读物以及与特定编程语
言相关的资料介绍。
代码大全(第2版)

<==========================162end ==============================>
<==========================163start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
126
第6章可以工作的类
Class Foundations: Abstract Data Types(ADTs)
类的基础:抽象数据类型(ADTs)
抽象数据类型(ADTT, abstract data type)是指一些数据以及对这些数据所进行
的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的,也允
许程序的其余部分改变这些数据。“抽象数据类型”概念中“数据”一词的用法有
些随意。一个ADT可能是一个图形窗体以及所有能影响该窗体的操作;也可以是
一个文件以及对这个文件进行的操作;或者是一张保险费率表以及相关操作等。
交叉参考首先要想理解面向对象编程首先要理解ADT。不懂ADT的程序员开发出来的
考虑ADT,而后类只是名义上的“类”而已——实际上这种“类”只不过就是把一些稍有点儿关
个“深入一种语系的数据和子程序堆在一起。然而在理解ADT之后,程序员就能写出在一开始很
言去编程而不是容易实现、日后也易于修改的类来。
在一种语言上
编程”的例子。
传统的编程教科书在讲到抽象数据类型时,总会用一些数学中的事情打岔。
请参阅第4.3节这些书往往会像这么写:“你可以把抽象数据类型想成一个定义有一组操作的数学
“你在技术浪潮
中的位置”以及第模型。”这种书会给人一种感觉,好像你从不会真正用到抽象数据类型似的除
344节“以所用非拿它来催眠。
语言编程,但思赔
不受其约束”
把抽象数据类型解释得这么空洞是完全丢了重点。抽象数据类型可以让你像
在现实世界中一样操作实体,而不必在低层的实现上摆弄实体,这多令人兴奋啊。
你不用再向链表中插入一个节点了,而是可以在电子表格中添加一个数据单元格,
或向一组窗体类型中添加一个新类型,或给火车模型加挂一节车厢。深入挖掘能
在问题领域工作(而非在底层实现领域工作)的能量吧!
Example of the Need for an ADT
需要用到ADT的例子
为了展开讨论,这里先举一个例子,看看ADT在什么情况下会非常有用。有
了例子之后我们将继续深入细节探讨。
假设你正在写一个程序,它能用不同的字体、字号和文字属性(如粗体、斜体
等)来控制显示在屏幕上的文本。程序的一部分功能是控制文本的字体。如果你用
一个ADT,你就能有捆绑在相关数据上的…组操作字体的子程序有关的数据包
括字体名称、字号和文字属性等。这些子程序和数据集合为一体,就是一个ADT。
如果不使用ADT,你就只能用一种拼凑的方法来操纵字体了。举例来说,如
果你要把字体大小改为12磅(point),即高度碰巧为16个像素(pixel),你就要
写类似这样的代码:
currentFont.size =16
代码大宝(第2版)

<==========================163end ==============================>
<==========================164start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
6.1类的基础:抽象数据类型(ADTs)
127
如果你已经开发了一套子程序库,那么代码可能会稍微好看一些:
currentFont. size PointsToPixels(12)
或者你还可以给该属性起一个更特定的名字,比如说:
currentFont. sizeOnPixels PointsToPixels(12)
但你不能同时使用 currentFont. sizeInPixels和 currentFont. sizeInPoints,
因为如果同时使用这两项数据成员, current Font就无从判断到底该用哪一个了。
而且,如果你在程序的很多地方都需要修改字体的大小,那么这类语句就会散布
在整个程序之中。
如果你需要把字体设为粗体,你或许会写出下面的语句,这里用到了一个按
位or运算符和一个16进制常量0x02:
currentFont. attribute Current Font. attribute or0x02
如果你够幸运的话,也可能代码会比这样还要干净些但使用拼凑方法的话,你
能得到的最好结果也就是写成这样:
currentFont. attribute CurrentFc. attribute or BOLD
或者是这样:
current Font. bold =True
就修改字体大小而言,这些做法都存在一个限制,即要求调用方代码直接控制数
据成员,这无疑限制了currentFont的使用
如果你这么编写程序的话,程序中的很多地方就会充斥着类似的代码。
Benefits of Using ADTs
使用ADT的益处
问题并不在于拼凑法是种不好的编程习惯。而是说你可以采用一种更好的编
程方法来替代这种方法,从而获得下面这些好处。
可以隐藏实现细节把关于字体数据类型的信息隐藏起来,意味着如果数据
类型发生改变,你只需在一处修改而不会影响到整个程序例如,除非你把实现
细节隐藏在一个ADT中,否则当你需要把字体类型从粗体的第一种表示变成第二
种表示时,就不可避免地要更改程序中所有设置粗体字体的语句,而不能仅在一
处进行修改。把信息隐藏起来能保护程序的其余部分不受影响。即使你想把在内
存里存储的数据改为在外存里存储,或者你想把所有操作字体的子程序用另一种
语言重写,也都不会影响程序的其余部分。
代大全(第2版)

<==========================164end ==============================>
<==========================165start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
128
第6章可以工作的类
改动不会影响到整个程序如果想让字体更丰富,而且能支持更多操作(例
如变成小型大写字母、变成上标、添加删除线等)时,你只需在程序的一处进行
修改即可。这一改动也不会影响到程序的其余部分
让接口能提供更多信息像 currentFont.size=16这样的语句是不够明
确的,因为此处16的单位既可能是像素也可能是磅。语句所处的上下文环境并不
能告诉你到底是哪一种单位。把所有相似的操作都集中到一个ADT里,就可以让
你基于磅数或像素数来定义整个接口,或者把二者明确地区分开,从而有助于避
免混淆。
更容易提高性能如果你想提高操作字体时的性能,就可以重新编写出一些
更好的子程序,而不用来回修改整个程序。
让程序的正确性更显而易见验证像
currentFont. attribute= current
Font. attribute or0x02这样的语句是否正确是很枯燥的,你可以替换成像
currentFont Set Boldon()这样的语句,验证它是否正确就会更容易一些。对于
前者,你可能会写错结构体或数据项的名字,或者用错运算符(用了and而不是
or),也可能会写错数值(写成了0x20而不是0x02)。但对于后者,在调用
currentFont. Set BoldOn()时,唯一可能出错的地方就是写错方法(成员函数)
名字,因此识别它是否正确就更容易一些。
程序更具自我说明性你可以改进像 currentFont. attribute or0x02这
样的语句把0x02换成BOLD或“0x02所代表的具体含义”,但无论怎样修改,
其可读性都不如 current Font. SetBol don()这条语句
Woodfield、 Dunsmore和hen曾做过这样一项研究,他们让一些计算机科学
专业的研究生和高年级本科生回答关于两个程序的问题:第一个程序按功能分解
MARD DATA为8个子程序,而第二个程序分解为抽象数据类型中的8个子程序(1981)结果,
按那些使用抽象数据类型程序的学生的得分比使用按功能划分的程序的学生高出
超过30%。
无须在程序内到处传递数据在刚才那个例子里,你必须直接修改 current
Font的值,或把它传给每一个要操作字体的子程序。如果你使用了抽象数据类型,
那么就不用再在程序里到处传递 currentFont了,也无须把它变成全局数据aDT
中可以用一个结构体来保存curreno€AD的数据,而只有ADT里的子程序才能
直接访问这些数据。ADT之外的子程序则不必再关心这些数据。
你可以像在现实世界中那样操作实体,而不用在底层实现上操作它你可以
定义一些针对字体的操作,这样,程序的绝大部分就能完全以“真实世界中的字
体”这个概念来操作,而不再用数组访问、结构体定义、True与 False等这些底
层的实现概念了。
代码大全(第2版

<==========================165end ==============================>
<==========================166start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
6.1类的基础:抽象数据类型(ADTs)
129
这样一来,为了定义一个抽象数据类型,你只需定义一些用来控制字体的子
程序多半就像这样:
currentfon
currentFont. Set sizeInPoints(sizeInPoints)
currentFont.. SetsizeInPixels(sizeInPixels)
()
currentFont. SetGBeldon
currentFont. Set Boldoff()
currentFont.. Set italicon (
eurrentront Set Italicoff (
这些子程序里的代码可能很短一很可能就像你此前看到的那个用拼凑法控
制字体时所写的代码。这里的区别在于,你已经把对字体的操作都隔离到一组子
o程序里了。这样就为需要操作字体的其他部分程序提供了更好的抽象层,同时它
也可以在针对字体的操作发生变化时提供一层保护。
More Examples of ADTs
更多的ADT示例
假设你开发了一套软件来控制一个核反应堆的冷却系统。你可以为这个冷却
系统规定如下一些操作,从而将其视作一个抽象数据类型:
coolingsystem. SetCirculationkate(rate
coolingSystem. Openvalve(valveNumber)
coolingSystem. CloscValve (valveNumber)
实现上述各操作的代码由具体环境决定。程序的其余部分可以用这些函数来
操纵冷却系统,无须为数据结构的实现、限制及变化等内部细节而操心。
下面再举一些抽象数据类型以及它们可能提供的操作:
巡航控制
搅拌机
油罐
设置速度
开启
填充油罐
获取当前设置
关闭
排空油罐
恢复之前的速度
设置速度
获取油罐容积
解散
启动“即时粉碎器”获取油罐状态
停止“即时粉碎器”
列表
堆栈
初始化列表
灯光
初始化堆栈
向列表中插入条目
开启
向堆栈中推入条目
从列表中删除条目
关闭
从堆栈中弹出条目
读取列表中的下一个条目
读取栈顶条目
代码大全(第2版)

<==========================166end ==============================>
<==========================167start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看
130
第6章可以工作的类
帮助屏幕
菜单
文件
添加帮助项
开始新的菜单
打开文件
删除帮助项
删除菜单
读取文件
设置当前帮助项
添加菜单项
写入文件
显示帮助屏幕
删除菜单项
设置当前文件位置
关闭帮助显示
激活菜单项
关闭文件
显示帮助索引
禁用菜单项
返回前一屏幕
显示菜单
电梯
隐藏菜单
到上一层
指针
获取菜单选项
到下一层
获取新分配内存的指针
到指定层
用现有指针释放内存
报告当前楼层
更改已分配内存的大小
回到底层
通过研究这些例子,你可以得出一些指导建议,下面就来说明这些指导建议:
把常见的底层数据类型创建为ADT并使用这些ADT,而不再使用底层数据
类型大多数关于ADT的论述中都会关注于把常见的底层数据类型表示为ADT。
从前面的例子中可以看到,堆栈、列表、队列以及几乎所有常见的底层数据类型
都可以用ADT来表示。
你可能会问:“这个堆栈、列表或队列又是代表什么呢?”如果堆栈代表的是
一组员工,就该把它看做是一些员工而不是堆栈;如果列表代表的是一个出场演
员名单,就该把它看做是出场演员名单而不是列表;如果队列代表的是电子表格
中的一组单元格,就该把它看做是一组单元格而不是一个一般的队列。也就是说,
要尽可能选择最高的抽象层次。
把像文件这样的常用对象当成ADT大部分编程语言中都包含有一些抽象数
据类型,你可能对它们已经比较熟悉了,而只是可能并未将其视作ADT。文件操
作是个很好的例子。在向磁盘写入内容时操作系统负责把读/写磁头定位到磁盘
上的特定物理位置,如果扇区的空间用完了,还要重新分配新扇区,并负责解释
那些神秘的错误代码。操作系统提供了第一层次的抽象以及在该层次上的ADT
高层语言则提供了第二层次的抽象以及在这一更高层次上的ADT高级语言可以
让你无须纠缠于调用操作系统API以及管理数据缓冲区等繁琐细节,从而让你可
以把一块磁盘空间视作一个“文件”
你可以采用类似的做法对ADT进行分层。如果你想在某一层次用ADT来提
供数据结构的操作(比如说在堆栈中压入和弹出数据),没问题。而你也可以在这
一抽象层次之上再创建一个针对现实世界中的问题的抽象层次。
代码大全(第2版)

<==========================167end ==============================>
<==========================168start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubu.com!仅供试看
6.1类的基础:抽象数据类型(ADTs)
131
简单的事物也可当做ADT为了证明抽象数据类型的实用价值,你不一定非
要使用庞杂的数据类型。在前面的一组例子中,有一盏只支持两种操作(开启、
关闭)的灯。你可能会觉得把简单的“开”、“关”操作放到单独的子程序中有些
浪费功夫,不过即使这样简单的操作也可以通过使用ADT而获益。把灯和与之相
关的操作放到一个ADT里,可以提高代码的自我说明能力,让代码更易于修改,
还能把改动可能引起的后果封闭在 TurnLighton)和Turntightoff)两个子程
序内,并减少了需要到处传递的数据的项数
不要让ADT依赖于其存储介质假设你有一张保险费率表,它太大了,因此
只能保存到磁盘上。你可能想把它称做一个“费率文件”然后编出类似
RateFile.read(这样的访问器子程序(access routine)然而当你把它称做一个
“文件”时,已经暴露了过多的数据信息。一旦对程序进行修改,把这张表存到
内存中而不是磁盘上,把它当做文件的那些代码将变成不正确,而且产生误导并
使人迷惑。因此,请尽量让类和访问器子程序的名字与存储数据的方式无关,并
只提及抽象数据类型本身,比如说“保险费率表”。这样一来,前面这个类和访问
器子程序的名字就可能是 rateTable.ead(),或更简单的 rates.read()
Handling Multiple Instances of Data with ADTs in Non-Object-
Oriented Environments
在非面向对象环境中用ADT处理多份数据实例
面向对象的编程语言能自动支持对同一ADT的多份实例的处理。如果你只是
在面向对象的环境中工作,那你根本就不用自己操心处理多个实例的实现细节了,
恭喜你(你可以直接去读下一节“ADT和类”)!
如果你是在像C语言这样的非面向对象的环境中工作,你就必须自己手工实
现支持处理多个实例的技术。一般来说,这就意味着你要为ADT添加一些用来创
建和删除实例的服务操作,同时需要重新设计ADT的其他服务操作,使其能够支
持多个实例。
前面字体那个ADT原来只是提供这些操作:
current Font. SetSize(sizeInPoint s
currentFont. Set Boldon(
currentFont. Set Boldoff()
current Font Set Italicon()
current Font. Set Italicoff()
current Font. Set TypeFace (faceName)
代大全(第2版)

<==========================168end ==============================>
<==========================169start==============================>

该书下载自书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^ ^.com!仅供试看^
132
第6章可以工作的类
在非面向对象的环境里,这些操作不能附着在某个类上,因此很可能要写成:
SetCurrentFontSize( sizeTnPoints
SetCurrent Font Beldofr
Bold
)
Setcur
SetCurrentFont ItalicOn (
SetCurrentFontItalicoff()
rent
SetCurrentFont TypeFace faceName
如果你想一次使用更多的字体,那么就需要增加一些服务操作来创建和删除
字体的实例了,比如说这样:
CreateFont (fontId)
DeleteFont( fontId)
SetCurrentFont (fontId)
这里引入了一个 font Id变量,这是用来在创建和使用多个字体实例时分别控制每
个实例的一种处理方法。对于其他操作,你可以采用下列三种方法之一对ADT的
接口进行处理:
做法1:每次使用ADT服务子程序时都明确地指明实例在这种情况下没有“当
前字体”的概念。你把fontId传给每个用来操作字体的子程序。 Font ADT的
服务子程序负责跟踪所有底层的数据,而调用方代码只需使用不同的 fontId
即可区分多份实例这种方法需要为每个Fon子程序都加上一个 fontId参数
做法2:明确地向ADT服务子程序提供所要用到的数据。采用这种方法时,
你要在调用ADT服务的子程序里声明一个该ADT所要用到的数据换句话
说,你要声明一个Font数据类型,并把它传给ADT中的每一个服务子程序。
你在设计时必须要让ADT的每个服务子程序在被调用时都使用这个传入的
Font数据类型。用这种方法时,调用方代码无须使用 font Id,因为它总是
自己跟踪字体数据。(虽然从Font数据类型即可直接取得所有数据,但你仍
然应该仅通过ADT的服务子程序来访问它。这称为保持结构体“封闭”)
这种方法的优点是,ADT中的服务子程序不需要根据 font Id来查询字
体的信息。而它的缺点则是向程序的其余部分暴露了字体内部的数据,从而
增加了调用方代码可能利用ADT内部实现细节的可能性,而这些细节本应
该隐藏在ADT的内部。
做法3:使用隐含实例(需要倍加小心)。设计一个新的服务子程序,通过
调用它来让某一个特定的字体实例成为当前实例比方说
SetCurrent Font(fontId)一旦设置了当前字体,其他所有服务子程序在
被调用时都会使用这个当前字体。用这种方法也无须为其他服务子程序添加
fontId参数。对于简单的应用程序而言,这么可以让使用多个实例更为
顺畅。然而对于复杂的应用程序来说,这种在系统范围内对状态的依赖性就
代码大全(第2版)

<==========================169end ==============================>
<==========================170start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com! .com!仅供试看^个
6.2良好的类接口
133
意味着,你必须在用到字体操作的所有代码中跟踪当前的字体实例。这样一
来,复杂度有可能会急剧增长,对于任何规模的应用程序来说,还有一些更
好的替代方案。
在抽象数据类型的内部,你还可以选择更多处理多个实例的方法;但在抽象数据
类型的外部,如果你使用非面向对象的编程语言,能选择的方法也就是这些了。
ADTs and Classes
ADT和类
抽象数据类型构成了“类class”这一概念的基础。支持类的编程语言里,你
可以把每个抽象数据类型用它自己的类实现。类还涉及到继承和多态这两个额外的
概念。因此,考虑类的一种方式,就是把它看做是抽象数据类型再加上继承和多态
两个概念。
6.2
Good Class Interfaces
良好的类接口
创建高质量的类,第一步,可能也是最重要的一步,就是创建一个好的接口。
这也包括了创建一个可以通过接口来展现的合理的抽象,并确保细节仍被隐藏在
抽象背后。
Good Abstraction
好的抽象
正如第5.3节“形成一致的抽象”中所述,抽象是一种以简化的形式来看待
复杂操作的能力。类的接口为隐藏在其后的具体实现提供了一种抽象。类的接口
应能提供一组明显相关的子程序。
交叉参考本书
你可以有一个实现雇员(Employee)这一实体的类。其中可能包含雇员的姓
代码示例都是用名、地址、电话号码等数据,以及一些用来初始化并使用雇员的服务子程序。看
一种风格相似的上去可能是这样的:
编码约定来格式C++示例:展现良好抽象的类接口
化的。关于这种 class Employee(
约定的细节(以public:
及关于多种编码
/ public constructors and destructors
风格的论述)请Employee()
参见第11.4节中Employee(
的“混合语言编
FullName name,
程的注意事项”
string address,
String workphone,
string homephone,
TaxId taxidNumber,
Jobclassification jobclass
)
1.
virtual ~Employee (
/ public routines
代码大全(第2版)

<==========================170end ==============================>
<==========================171start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
134
第6章可以工作的类
FullName GetName() const;
string GetAddress ( consti
string GetWorkPhone ( consti
String GetHomePhone( const;
Taxid Get TaxIdNumber ( consti
Jobclassification GetJobclassific const
private:
在类的内部还可能会有支持这些服务的其他子程序和数据,但类的使用者并
不需要了解它们。类接口的抽象能力非常有价值,因为接口中的每个子程序都在
朝着这个一致的目标而工作。
一个没有经过良好抽象的类可能会包含有大量混杂的函数,就像下面这个例
子一样:
C++示例:展现不良抽象的类接口
class Program{
public:
CODING
HORROR
/1 public routines
void Initializecommandstack()
void PushCommand( Command command
void ShutdownCommandstack();
void InitializeReportFormatting()
void FormatReport Report report
void PrintReport Report report )
void InitializeGlobalData();
void ShutdownGlobalData()
private:
}
假设有这么一个类,其中有很多个子程序,有用来操作命令栈的,有用来格
式化报表的,有用来打印报表的,还有用来初始化全局数据的。在命令栈、报表
和全局数据之间很难看出什么联系。类的接口不能展现出一种一致的抽象,因此
它的内聚性就很弱。应该把这些子程序重新组织到几个职能更专一的类里去,在
这些类的接口中提供更好的抽象。
如果这些子程序是一个叫做 Program类的一部分,那么可以这样来修改它,
以提供一种一致的抽象:
代码大全(第2版)

<==========================171end ==============================>
<==========================172start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shub.com!仅供试看^
6.2良好的类接口
135
+示例:能更好展现抽象的类接口
class Program
public:
1/ public routines
void InitializeUserInterface();
void ShutDownUserInterface()
void InitializeReports()
void shutDownReports():
private:
;
在清理这一接口时,把原有的一些子程序转移到其他更合适的类里面,而把
另一些转为 InitializeUserInterface()和其他子程序中使用的私用子程序。
这种对类的抽象进行评估的方法是基于类所具有的公用(public)子程序所构
成的集合——即类的接口。即使类的整体表现一种良好的抽象,类内部的子程序
也未必就能个个表现出良好的抽象,也同样要把它们设计得可以表现出很好的抽
象。你可以在第7.2节“在子程序层上设计里获得相关的指导建议。
为了追求设计优秀,这里给出一些创建类的抽象接口的指导建议:
类的接口应该展现一致的抽象层次在考虑类的时候有一种很好的方法,就
是把类看做一种用来实现抽象数据类型(ADT,见第6.1节)的机制。每一个类
应该实现一个ADT,并且仅实现这个ADT如果你发现某个类实现了不止一个
ADT,或者你不能确定究竟它实现了何种ADT,你就应该把这个类重新组织为一
个或多个定义更加明确的ADT。
在下面这个例子中,类的接口不够协调,因为它的抽象层次不一致:
++示例:混合了不同层次抽象的类接口
class EmployeeCensus: public ListContainer
CODING
public:
HORROR
这些子程序的抽象在
11 public
void AddEmployee Employee employee
雇员”这一层次上void RemoveEmployee( Employee employee);
这些子程序的抽象在
“列表”这一层次上。
代码大全(第2版)

<==========================172end ==============================>
<==========================173start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com!^.com!仅供试看^个
136
第6章可以工作的类
这个类展现了两个ADT: Employee和 ListContainer.出现这种混合的抽
象,通常是源于程序员使用容器类或其他类库来实现内部逻辑,但却没有把“使
用类库”这一事实隐藏起来。请自问一下,是否应该把使用容器类这一事实也归
入到抽象之中?这通常都是属于应该对程序其余部分隐藏起来的实现细节,就像
下面这样:
+示例:有着一致抽象层次的类接口
class EmployeeCensus
public:
public routines
void AddEmployee( Employee employee
所有这些子程序的抽 void RemoveEmployee( Employee employee)
象现在都是在“雇员mployee Next Employee()
这一层次上了
Employee FirstEmployee (
_Employee LastEmployee (
private:
ListContainer ListContainer m_EmployeeList;
这一实现细节现在已
经被隐藏起来了。
有的程序员可能会认为从 ListContainer继承更方便,因为它支持多态,可
以传递给以 ListContainer对象为参数的外部查询函数或排序函数来使用。然而
这一观点却经不起对“继承”合理性的主要测试:“继承体现了‘是一个(isa)
关系吗?”如果从ListContainer中继承,就意味着 EmployeeCensus“是一个”
ListContainer,这显然不对。如果 EmployeeCensus对象的抽象是它能够被搜
索或排序,这些功能就应该被明确而一致地包含在类的接口之中。
如果把类的公用子程序看做是潜水艇上用来防止进水的气锁阀(air lock),那
么类中不一致的公用子程序就相当于是漏水的仪表盘。这些漏水的仪表盘可能不
会让水像打开气锁阀那样迅速进入,但只要有足够的时间,它们还是能让潜艇沉
没。实际上,这就是混杂抽象层次的后果。在修改程序时,混杂的抽象层次会让
程序越来越难以理解,整个程序也会逐步堕落直到变得无法维护。
一定要理解类所实现的抽象是什么一些类非常相像,你必须非常仔细地理
解类的接口应该捕捉的抽象到底是哪一个我曾经开发过这样一个程序,用户可
KEY POINT以用表格的形式来编辑信息。我们想用一个简单的栅格(grid)控件,但它却不能
给数据输入单元格换颜色,因此我们决定用一个能提供这一功能的电子表格
( spreadsheet)控件
代码大全(第2版)

<==========================173end ==============================>
<==========================174start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! -www.shubulo..com!仅供试看^
6.2良好的类接口
137
电子表格控件要比栅格控件复杂得多,它提供了150个子程序,而栅格控件
只有15个。由于我们的目标是使用一个栅格控件而不是电子表格控件,因此我们
让一位程序员写一个包裹类(wrapper class),隐藏起“把电子表格控件用做栅格
控件”这一事实。这位程序员强烈抱怨,认为这样做是在毫无必要地增加成本,
是官僚作风,然后就走了。几天以后,他带来了写好的包裹类,而这个类竟然忠
实地把电子表格控件所拥有的全部150个子程序都暴露出来了!
这并不是我们想要的。我们要的是一个栅格控件的接口,这个接口封装了“背
后实际是在用一个更为复杂的电子表格控件”的事实。那位程序员应该只暴露那
15个栅格控件的子程序,再加上第16个支持设置单元格颜色的子程序。他把全
部150个子程序都暴露出来,也就意味着一旦想要修改底层实现细节,我们就得
支持150个公用子程序。这位程序员没有实现我们所需要的封装,也给他自己带
来了大量无谓的工作。
根据具体情况的不同,正确的抽象可能是一个电子表格控件,也可能是一个
栅格控件。当你不得不在两个相似的抽象之间做出选择时,请确保你的选择是正
确的。
提供成对的服务大多数操作都有和其相应的、相等的以及相反的操作。如
果有一个操作用来把灯打开,那很可能也需要另一个操作来把灯关闭。如果有一
个操作用来向列表中添加项目,那很可能也需要另一个操作来从列表中删除项目。
如果有一个操作用来激活菜单项,那很可能也需要另一个操作来屏蔽菜单项。在
设计一个类的时候,要检查每一个公用子程序决定是否需要另一个与其互补的
操作。不要盲月地创建相反操作,但你一定要考虑,看看是否需要它。
把不相关的信息转移到其他类中有时你会发现,某类中一半子程序使用
着该类的一半数据,而另一半子程序则使用另一半数据。这时你其实已经把两个
类混在一起使用了,把它们拆开吧!
尽可能让接口可编程,而不是表达语义每个接口都由一个可编程(program
matic的部分和一个语义(semantic)部分组成。可编程的部分由接口中的数据
类型和其他属性构成,编译器能强制性地要求它们(在编译时检查错误)而语义
部分则由“本接口将会被怎样使用”的假定组成,而这些是无法通过编译器来强
制实施的。语义接口中包含的考虑比如“RoutineA必须在 RoutineB之前被调用
或“如果dataMember未经初始化就传给 RoutineA的话,将会导致 Rout ineA崩
溃”。语义接口应通过注释说明,但要尽可能让接口不依赖于这些说明。一个接口
中任何无法通过编译器强制实施的部分,就是一个可能被误用的部分。要想办法
把语义接口的元素转换为编程接口的元素,比如说用 Asserts(断言)或其他的技
术
代码大全(第2版)

<==========================174end ==============================>
<==========================175start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.c.com!仅供试看^
138
第6章可以工作的类
交叉参考关于谨防在修改时破坏接口的抽象在对类进行修改和扩展的过程中,你常常会
如何在修改代码
时保持代码质量发现额外所需的一些功能。这些功能并不十分适应于原有的类接口,可看上去却
的建议,请参见也很难用另一种方法来实现。举例来说,你可能会发现 Employee类演变成了下
第24章“重构”。
面这个样子:
C+语言示例:在维护时被破坏的类接口
class Employee
public:
CODING
HORROR
public routines
FullName GetName() const;
Address GetAddress ( const;.
PhoneNumber GetWorkPhone) const;
bool IsJobclassificationvalid Jobclassific jobclass)
bool IszipCodevalid Address address)
bool IsPhoneNumbervalid( PhoneNumbe phoneNumber)
SqlQuery Get QueryTocreateNewEmployee ( consti
SqlQuery GetQueryToModi fyEmployee() const;
SqlQuery GetQueryToRetrieveEmploy() const;
private:
;
前面代码示例中的清晰抽象,现在已经变成了由一些零散功能组成的大杂烩。
在雇工和检查邮政编码、电话号码或职位的子程序之间并不存在什么逻辑上的关
联,那些暴露SQL语句查询细节的子程序所处的抽象层次比 Employee类也要低
得多,它们都破坏了 Employee类的抽象。
不要添加与接口抽象不一致的公用成员每次你向类的接口中添加子程序
时,问问“这个子程序与现有接口所提供的抽象一致吗?”如果发现不一致,就
要换另一种方法来进行修改,以便能够保持抽象的完整性。
同时考虑抽象性和内聚性抽象性和内聚性这两个概念之间的关系非常紧
密—一个呈现出很好的抽象的类接口通常也有很高的内聚性。而具有很强内聚
性的类往往也会呈现为很好的抽象,尽管这种关系并不如前者那么强。
我发现,关注类的接口所表现出来的抽象,比关注类的内聚性更有助于深入
地理解类的设计。如果你发现某个类的内聚性很弱,也不知道该怎么改,那就换
一种方法,问问你自己这个类是否表现为一致的抽象。
代码大全(第2版)

<==========================175end ==============================>
<==========================176start==============================>

该书下载自书部落分享计算机经典巨著!www. !--www.shubulo.com!^.com!仅供试看
6.2良好的类接口
139
Good Encapsulation
良好的封装
交叉参考关于
正如第5.3节中所论述的,封装是一个比抽象更强的概念。抽象通过提供一个
封装的更多内容
请参见第5.3节
可以让你忽略实现细节的模型来管理复杂度,而封装则强制阻止你看到细节即
中的“封装实现便你想这么做。
细节”。
这两个概念之所以相关,是因为没有封装时,抽象往往很容易被打破。依我
的经验,要么就是封装与抽象两者皆有,要么就是两者皆失。除此之外没有其他
可能。
设计精良的模块
尽可能地限制类和成员的可访问性让可访问性 accessibility)尽可能低是
和设计精糕的模促成封装的原则之一。当你在犹豫某个子程序的可访问性应该设为公用(public)
别,就是对其他私用(private)抑或受保护(protected)时,经验之举是应该采用最严格且可行的
模块隐藏本模块访问级别(Meyers1998, Bloch2001)我认为这是一个很好的指导建议,但我认
内部数据和其他
实现细节的程度。为还有更重要的建议,即考虑“采用哪种方式能最好地保护接口抽象的完整性?”
Joshua Bloch如果暴露一个子程序不会让抽象变得不一致的话,这么做就很可能是可行的。如
果你不确定,那么多隐藏通常比少隐藏要好。
不要公开暴露成员数据暴露成员数据会破坏封装性,从而限制你对这个抽
象的控制能力。正如 Arthur Riel所指出的,一个Point类如果暴露了下面这些成
员的话:
float x;
float z;
它就破坏了封装性,因为调用方代码可以自由地使用 Point类里面的数据,而
Point类却甚至连这些数据什么时候被改动过都不知道(R1996)然而,如果
Point类暴露的是这些方法的话:
float Getx()
float GetY()
float Getz()
void setx(float x)
void SetY(float y);
void Setz(float z);
那它还是封装完好的。你无法得知底层实现用的是不是 float、y、z,也不会知
道 Point是不是把这些数据保存为 double然后再转换成 float,也不可能知道
Point是不是把它们保存在月亮上,然后再从外层空间中的卫星上把它们找回来。
避免把私用的实现细节放入类的接口中做到真正的封装以后,程序员们是
根本看不到任何实现细节的。无论是在字面上还是在喻意上,它们都被隐藏了起
来。然而,包括C++在内的一些流行编程语言却从语言结构上要求程序员在类的
代码大全(第2版)

<==========================176end ==============================>
<==========================177start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
140
第6章可以工作的类
接口中透露实现细节。下面就是一个例子:
C++示例:暴露了类内部的实现细节
class Employee
public:
Employee(
FullName name,
string address,
String workPhone,
String homePhone,
TaxId taxIdNumber,
Jobclassification jobclass
);
FullName GetName ()const:
string GetAddress) const
private:
细节露了实现 string Name
这里暴
int m_jobclass;
把 private段的声明放到类的头文件中,上去似乎只是小小地违背了原则,
但它实际是在鼓励程序员们查阅实现细节在这个例子中,客户代码本意是要使
用 Address类型来表示地址信息,但头文件中却把“地址信息用String来保存”
的这一实现细节暴露了出来。
ScottMeyers《ctivC++234在effectiveC++》一书第2版中的第34条里介绍了可以解决
这个问题的一个惯用技法(Meyers1998。他建议你把类的接口与类的实现隔离
开,并在类的声明中包含一个指针,让该指针指向类的实现,但不能包含任何其
他实现细节。
C++示例:隐藏类的实现细节
class Employee
public:
Employee(...)
FullName GetName() const;
string GetAddress) const
这样就把实现细节 private
EmployeeImplementation *m_impler
隐藏在指针之后了。
代码大全(第2版)

<==========================177end ==============================>
<==========================178start==============================>

该书下载自-书部落-分享计算机经典著-www. ! --www.shubulo.com! ^.com!仅供试看
6.2良好的类接口
141
现在你就可以把实现细节放到 EmpioyeeImplementation类里了,这个类只
对 Employee类可见,而对使用 Employee类的代码来说则是不可见的。
如果你已经在项目里写了很多没有采用这种方法的代码,你可能会觉得把大
量的现有代码改成使用这种方法是不值得的。但是当你读到那些暴露了其实现细
节的代码时,你就应该顶住诱惑,不要到类接口的私用部分去寻找关于实现细节
的线索。
不要对类的使用者做出任何假设类的设计和实现应该符合在类的接口中所
隐含的契约。它不应该对接口会被如何使用或不会被如何使用做出任何假设
除非在接口中有过明确说明。像下面这样一段注释就显示出这个类过多地假定了
它的使用者:
-请把x,y和初始化为1.0,因为如果把它们
-初始化为0,0的话, Derivedclass就会崩溃
避免使用友元类(friendcIas《State)有些场合下,比如说State模式中,按照正
确的方式使用友元类会有助于管理复杂度(Gamma et al.1995)但在一般情况下
友元类会破坏封装,因为它让你在同一时刻需要考虑更多的代码量,从而增加了
复杂度。
不要因为一个子程序里仅使用公用子程序,就把它归入公开接口一个子程
序仅仅使用公用的了程序这一事实并不是十分重要的考虑要素。相反,应该问的
问题是,把这个子程序暴露给外界后,接口所展示的抽象是否还是一致的。
让阅读代码比编写代码更方便阅读代码的次数要比编写代码多得多,即使
在开发的初期也是如此。因此,为了让编写代码更方便而降低代码的可读性是非
常不经济的。尤其是在创建类的接口时,即使某个子程序与接口的抽象不很相配,
有时人们也往往把这个子程序加到接口里,从而让正开发的这个类的某处调用代
码能更方便地使用它。然而,这段子程序的添加正是代码走下坡路的开始,所以
还是不要走出这一步为好。
如果必须要看到
要格外警惕从语义上破坏封装性我曾认为,只要学会避免语法错误,就能
底层实现才能理稳操胜券。然而我很快就发现,学会避免语法错误仅仪是个开始,接踵而来的是
解发生的事情,
那还算不上抽象。无以计数的编码错误,而其中大多数错误都比语法错误难于诊断和更正
~RJ Plauger
比较起来,语义上的封装性和语法上的封装性二者的难度相差无几。从语法
的角度说,要想避免窥探另一个类的内部实现细节,只要把它内部的子程序和数
据都声明为 private就可以了,这是相对容易办到的。然而,要想达到语义上的
代大全(第2版)

<==========================178end ==============================>
<==========================179start==============================>

该书下载自-书部落-分享计算机经典巨著ww. !--www.shubulo.com! ^.co!仅供试看
142
第6章可以工作的类
封装性就完全是另一码事儿了。下面是一些类的调用方代码从语义上破坏其封装
性的例子。
不去调用A类 Initializeoperations的(子程序,因为你知道A类的
PerformFirstOperation)子程序会自动调用它。
不在调用 employee. Retrive(database之前去调用database. Connect()
子程序,因为你知道在未建立数据库连接的时候 employee. Retrieve()会
去连接数据库的。
不去调用A类 Terminate的()子程序,因为你知道A类 PerformFinal的
Operation()子程序已经调过它了。
即便在 ubjectA离开作用域之后,你仍去使用由 ObjectA创建的、指向
ObjectB的指针或引用,因为你知道 Objecta把放置在静态存储
空间中了,因此 objectB肯定还可以用。
使用 ClassB. MAXIMUM_ELEMENTS而不用 ClassA. MAXIMUMErEMENTS因
为你知道它们两个的值是相等的。
上面这些例子的问题都在于,它们让调用方代码不是依赖于类的公开接口,
而是依赖于类的私用实现。每当你发现自己是通过查看类的内部实现来得知该如
EY POINT何使用这个类的时候,你就不是在针对接口编程了,而是在透过接口针对内部实
现编程了。如果你透过接口来编程的话,封装性就被破坏了,而一旦封装性开始
到破坏,抽象能力也就快遭殃了。
如果仅仅根据类的接口文档还是无法得知如何使用一个类的话,正确的做法
不是拉出这个类的源代码,从中查看其内部实现。这是个好的初衷,但却是个错
误的决断。正确的做法应该是去联系类的作者,告诉他“我不知道该怎么用这个
类。”而对于类的作者来说,正确的做法不是面对面地告诉你答案,而是从代码库
中 check out(签出)类的接口文件,修改类的接口文档,再把文件 check in(签
入)回去,然后告诉你“看看现在你知不知道该怎么用它了”你希望让这一次对
话出现在接口代码里,这样就能留下来让以后的程序员也能看到。你不希望让这
一次对话只存在于自己的脑海里,这样会给使用该类的调用方代码烙下语义上的
微妙依赖性。你也不想让这一次对话只在个人之间进行,这样只能让你的代码获
益,而对其他人没有好处。
留意过于紧密的耦合关系“耦合(coupling)”是指两个类之间关联的紧密程度
通常,这种关联越松(loose)越好。根据这一概念可以得出以下一些指导建议:
尽可能地限制类和成员的可访问性。
避免友元类,因为它们之间是紧密耦合的。
代码大全(第2版

<==========================179end ==============================>
<==========================180start==============================>

该书下载自-书部落-分享计算机经典巨著!--www ! --www.shubu.com!仅供试看^
6.3有关设计和实现的问题
143
在基类中把数据声明为 private而不是 protected,以降低派生类和基类之
间耦合的程度。
避免在类的公开接口中暴露成员数据。
要对从语义上破坏封装性保持警惕。
察觉“Demeter(得墨心耳)法则”(见本章第6.3节)。
耦合性与抽象和封装性着非常密切的联系。紧密的耦合性总是发生在抽象
不严谨或封装性遭到破坏的时候。如果一个类提供了一套不完整的服务,其他的
子程序就可能要去直接读写该类的内部数据这样一来就把类给拆开了,把它从
一个黑盒子变成了一个玻璃盒子,从而事实上消除了类的封装性。
6.3
Design and Implementation Issues
有关设计和实现的问题
给类定义合理的接口,对于创建高质量程序起到了关键作用。然而,类内部
的设计和实现也同样重要。这一节就来论述关于包含、继承、成员函数和数据成
员、类之间的耦合性、构造函数、值对象与引用对象等的问题。
Containment has a" Relationships)
包含(“有一个”的关系)
包含是一个非常简单的概念,它表示一个类含有一个基本数据元素或对象。与包
含相比,关于继承的论述要多得多,这是因为继承需要更多的技巧,而且更容易出错,
KEY POINT
而不是因为继承要比包含更好。包含才是面向对象编程中的主力技术
通过包含来实现“有一个/hasa”的关系可以把包含想成是“有一个”关系。
比如说,一名雇员“有一个”姓名、“有一个”电话号码、“有一个”税收ID等。
通常,你可以让姓名、电话号码和税收ID成为 Employee类的数据成员,从而建
立这种关系。
在万不得已时通过 private继承来实现“有一个的关系在某些情况下,你
会发现根本无法用把一个对象当做另一对象的成员的办法来实现包含关系。一些
专家建议此时可采用 private继承自所要包含的对象的办法( Meyers1998、 Sutter
2000)。这么做的主要原因是要让外层的包含类能够访问内层被包含类的 protected
成员函数与数据成员。然而在实践中,这种做法会在派生类与基类之间形成一种
过于紧密的关系,从而破坏了封装性。而,这种做法也往往会带来一些设计上
的错误,而这些错误是可以用“private继承”之外的其他方法解决的。
惕有超过约7个数据成员的类研究表明人们在做其他事情时能记住的
离散项目的个数是7±2(Miller 11956)。如果一个类包含有超过约7个数据成员,
代大全(第2版)

<==========================180end ==============================>
<==========================181start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shub.com!仅供试看
144
第6章可以工作的类
请考虑要不要把它分解为几个更小的类(Riel1996)如果数据成员都是整型或字
符串这种简单数据类型,你可以按7±2的上限来考虑;反之,如果数据成员都是
复杂对象的话,就应按7±2的下限来考虑了。
Inheritance
“isa Relationships)
继承(“是一个”关系)
继承的概念是说一个类是另一个类的一种特化( specialization)继承的目的
在于,通过“定义能为两个或更多个派生类提供共有元素的基类”的方式写出更
精简的代码。其中的共有元素可以是子程序接口、内部实现、数据成员或数据类
型等。继承能把这些共有的元素集中在一个基类中,从而有助于避免在多处出现
重复的代码和数据。
当决定使用继承时,你必须要做如下几项决策。
对于每一个成员函数而言,它应该对派生类可见吗?它应该有默认的实现
吗?这一默认的实现能被覆盖(override)吗?
对于每一个数据成员而言(包括变量、具名常量、枚举等),它应该对派生
类可见吗?
下面就来详细解释如何考虑这些事项。
用C++进行面向
用 public继承来实现“是一个…”的关系当程序员决定通过继承一个现
对象编程时的一
个最重要的法则有类的方式创建一个新类时,他是在表明这个新的类是现有类的一个更为特殊的
就是: public继承版本。基类既对派生类将会做什么设定了预期,也对派生类能怎么运作提出了限
代表的是“是一
个的关系制(Meyers1998)
把这一法则印在
脑中。
如果派生类不准备完全遵守由基类定义的同一个接口契约,继承就不是正确
Scot Meyers的实现技术了。请考虑换用包含的方式,或者对继承体系的上层做修改。
要么使用继承并进行详细说明,要么就不要用它继承给程序增加了复杂度,
因此它是一种危险的技术。正如Java专家 Joshua Bloch所说,“要么使用继承并进
行详细说明,要么就不要用它。”如果某个类并未设计为可被继承,就应该把它的
成员定义成non- -virtual(C++)、 final(ava)或non--overridable(Microsoft Visual
Basic),这样你就无法继承它了。
遵循 Liskov替换原则(Liskov Substitution Principle,lsp) Barbara Liskov
在一篇面向对象编程的开创性论文中提出,除非派生类真的“是一个”更特殊的
基类,否则不应该从基类继承(Liskov1988) Andy Hunt和 Dave Thomas把lsp
总结为:“派生类必须能通过基类的接口而被使用,且使用者无须了解两者之间的
差异。”(Hunt and Thomas2000)
代码大全(第2版)

<==========================181end ==============================>
<==========================182start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com.com!仅供试看^
6.3有关设计和实现的问题
145
换句话说,对于基类中定义的所有子程序,用在它的任何一个派生类中时的
含义都应该是相同的。
如果你有一个 Account基类以及 CheckingAccount、 SavingsAccount
AutoLoanAccount三个派生类,那么程序员应该能调用这三个 Account派生类中
从 Account继承而来的任何一个子程序,而无须关心到底用的是 Account的哪
个派生类的对象。
如果程序遵循 Liskov替换原则,继承就能成为降低复杂度的一个强大工具,
因为它能让程序员关注于对象的一般特性而不必担心细节。如果程序员必须要不
断地思考不同派生类的实现在语义上的差异,继承就只会增加复杂度了。假如说
程序员必须要记得:“如果我调用的是CheckingAccoun或 SavingsAccount中的
InterestRate()方法的话,它返回的是银行应付给消费者的利息;但如果我调用
的是 AutoLoanAccount中的 InterestRate()方法就必须记得变号,因为它返回
的是消费者要向银行支付的利息。”根据LS,在这个例子中 AutoloanAccount
就不应该从 Account继承而来,因为它的 InterestRate()方法的语义同基类中
InterestRate()方法的语义是不同的。
确保只继承需要继承的部分派生类可以继承成员函数的接口和/或实现。表
6-1显示了子程序可以被实现和覆盖(override)的几种形式。
表6-1继承而来的子程序的几种形式
可覆盖的
不可覆盖的
提供默认实现可覆盖的子程序
不可覆盖的子程序
未提供默认实现抽象且可覆盖的子程序
不会用到(一个未经定义但又不让
覆盖的子程序是没有意义的)
正如此表所示,继承而来的子程序有三种基本情况。
■抽象且可覆盖的子程序是指派生类只继承了该子程序的接口,但不继承其实
现。
■可覆盖的子程序是指派生类继承了该子程序的接口及其默认实现,并且可以
覆盖该默认实现。
不可覆盖的子程序是指派生类继承了该子程序的接口及其默认实现,但不能
覆盖该默认实现。
代码大全(第2版)

<==========================182end ==============================>
<==========================183start==============================>

该书下载自-书部落-分享计算机经典巨著!- ! --www.shubulo.com!^.com!仅供试看
146
第6章可以工作的类
当你选择通过继承的方式来实现一个新的类时,请针对每一个子程序仔细考
虑你所希望的继承方式。仅仅是因为要继承接口所以才继承实现,或仅仅是因为
要继承实现所以才继承接口,这两类情况都值得注意。如果你只是想使用一个类
的实现而不是接口,那么就应该采用包含方式,而不该用继承。
不要“覆盖”一个不可覆盖的成员函数C++Java两种语言都允许程序
“覆盖”那些不可覆盖的成员函数。如果一个成员函数在基类中是私用(private)
的话,其派生类可以创建一个同名的成员函数对于阅读派生类代码的程序员来
说,这个函数是令人困惑的,因为它看上去似平应该多态的,但事实上却非如
此,只是同名而已。换种方法来说,本指导建议就是“派生类中的成员函数不要
与基类中不可覆盖的成员函数的重名。”
把共用的接口、数据及操作放到继承树中尽可能高的位置接口、数据和操
作在继承体系中的位置越高,派生类使用它们的时候就越容易。多高就算太高了
呢?根据抽象性来决定吧。如果你发现把一个子程序移到更高的层次后会破坏该
层对象的抽象性,就该停手了。
只有一个实例的类是值得怀疑的只需要一个实例,这可能表明设计中把对
象和类混为一谈了。考虑一下能否只创建一个新的对象而不是一个新的类。派生
类中的差异能否用数据而不是新的类来表达呢单件( Singleton)模式则是本条
指导方针的一个特例。
只有一个派生类的基类也值得怀疑每当我看到只有一个派生类的基类时,
我就怀疑某个程序员又在进行“提前设计”了一也就是试图去预测未来的需要,
而又常常没有真正了解未来到底需要什么。为未来要做的工作着手进行准备的最
好方法,并不是创建几层额外的、“没准以后哪天就能用得上的”基类,而是让
眼下的工作成果尽可能地清晰、简单、直截了当。也就是说,不要创建任何并非
绝对必要的继承结构。
派生后覆盖了某个子程序,但在其中没做任何操作这种情况也值得怀疑这
通常表明基类的设计中有错误。举例来说,假设你有一个Cat(猫)类,它有一个
Scratch()(抓)成员函数,可是最终你发现有些猫的爪尖儿没了,不能抓了。
你可能想从Cat类派生一个叫 scratchlesscat(不能抓的猫)的类,然后覆盖
Scratch)方法让它什么都不做。但这种做法有这么几个问题。
它修改了cat类的接口所表达的语义,因此破坏了Cat类所代表的抽象(即
接口契约)。
当你从它进一步派生出其他派生类时,采用这一做法会迅速失控。如果你又发
现有只猫没有尾巴该怎么办?或者有只猫不捉老鼠呢?再或者有只猫不喝牛
奶?最终你会派生出一堆类似 ScratchlessTaillessMic
(不能抓、没尾巴、不捉老鼠、不喝牛奶的猫)这样的派生类来。
代码大全(第2版)

<==========================183end ==============================>
<==========================184start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor ^.com!仅供试看^
6.3有关设计和实现的问题
147
采用这种做法一段时间后,代码会逐渐变得混乱而难以维护,因为基类的接
口和行为几乎无法让人理解其派生类的行为。
修正这一问题的位置不是在派生类,而是在最初的Cat类中。应该创建一个
Claw(爪子)类并让Cat类包含它。问题的根源在于做了所有猫都能抓的假设,
因此应该从源头上解决问题,而不是到发现问题的地方修补。
避免让继承体系过深面向对象的编程方法提供了大量可以用来管理复杂度
的技术。然而每种强大的工具都有其危险之处,甚至有些面向对象技术还有增加
而不是降低复杂度的趋势。
在《 Object-Oriented- Design Heuristics))》(《面向对象设计的启发式方法》,1996)
这本优秀著作中, Arthur Riel建议把继承层次限制在最多6层之内。 Arthur是基
于“神奇数字7±2”这一理论得出这一建议的,但我仍觉得这样过于乐观了。依
我的经验,大多数人在脑中同时应付超过2到3层继承时就有麻烦了。用那个“神
奇数字7±2”用来限制一个基类的派生类总数而不是继承层次的层数可
能更为合适。
人们已经发现,过深的继承层次会显著导致错误率的增长(Basili, Briand and
elo1996)。每个曾经调试过复杂继承关系的人都应该知道个中原因。过深的继
承层次增加了复杂度,而这恰恰与继承所应解决的问题相反。请牢牢记住首要的
技术使命。请确保你在用继承来避免代码重复并使复杂度最小。
尽量使用多态,避免大量的类型检查频繁重复出现的case语句有时是在暗
示,采用继承可能是种更好的设计选择尽管并不总是如此。下面就是一段迫
切需要采用更为面向对象的方法的典型代码示例:
C++示例:多半应该用多态来替代的case语句
switch shape. type )
case Shape circle:
shape. Drawcircle();
break;
case shape_Square:
shape. DrawSquare();
break;
代码大全(第2版)

<==========================184end ==============================>
<==========================185start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看^个
148
第6章可以工作的类
在这个例子中,对 shape. Drawcircle()和shap. Drawsquare()的调用应该
用一个叫 shape.Draw()的方法来替代,因为无论形状是圆还是方都可以调用这个
方法来绘制。
另外,case语句有时也用来把种类确实不同的对象或行为分开。下面就是一
个在面向对象编程中合理采用case语句的例子:
c+示例:也许不该用多态来替代的case语句
switch ui. Command()
OpenFile()
break;
case Command_Print:
Print();
break;
case Command_Save:
Save
break;
case Command_Exit:
ShutDown();
break;
此时也可以创建一个基类并派生一些派生类,再用多态的 DoCommand()方法
来实现每一种命令(就像 Command模式的做法一样)。但在像这个例子一样简单
的场合中, DoCommand()意义实在不大,因此采用case语句才是更容易理解的方
案。
让所有数据都是 private(而非protected)正如Joshua Bloch所言,“继承会
破坏封装”(Bloch2001)。当你从一个对象继承时,你就拥有了能够访问该对象中
的 protected子程序和 protected数据的特权。如果派生类真的需要访问基类的属性,
就应提供 protected访问器函数(accessor function)
Multiple Inheritance
在C++的多重继多重继承
承中有一个毋庸
置
的事
实就是,
它打开了一个潘
继承是一种强大的工具。就像用电锯取代手锯来伐木一样,当小心使用时,
多拉的盒子,里
它非常有用,但在还没能了解应该注意的事项的人手中,它也会变得非常危险。
面是单继承所没
有的复杂度
°
-Scott Meyers
代码大全(第2版)

<==========================185end ==============================>
<==========================186start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shub.com!仅供试看^
6.3有关设计和实现的问题
149
如果把继承比做是电锯,那么多重继承就是20世纪50年代的那种既没有防
护罩、也不能自动停机的危险电锯。有时这种工具的确有用,但在大多数情况下,
你最好还是把它放在仓库里为妙至少在这儿它不会造成任何破坏。
虽然有些专家建议广泛使用多重继承(Meyr1997),但以我的经验而言,多
重继承的用途主要是定义“混合体(mixins)”,也就是一些能给对象增加一组属
性的简单类。之所以称其为混合体,是因为它们可以把一些属性“混合”到派生
类里面。“混合体”可以是形如Displayable(显示), Persistant(持久化),
Serializable(可序列化)或 Sortable(可排序)这样的类。它们几乎总是抽
象的,也不打算独立于其他对象而被单独实例化。
混合体需要使用多重继承,但只要所有的混合体之间保持完全独立,它们也
不会导致典型的菱形继承( diamond-inheritance-问题通过把一些属性夹
(chunking)在一起,还能使设计方案更容易理解。程序员会更容易理解一个用
了 Displayable和 Persistent混合体的对象因为这样只需要实现两个属性
即可—而较难理解一个需要实现11个更具体的子程序的对象。
java和 Visual Basic语言也都认可混合体的价值,因为它们允许多重接口继承,
但只能继承一个类的实现。而C++则同时支持接口和实现的多重继承。程序员在
决定使用多重继承之前,应该仔细地考虑其他替代方案,并谨慎地评估它可能对
系统的复杂度和可理解性产生的影响。
Why Are There So Many Rules for inheritance
为什么有这么多关于继承的规则
这一节给出了许多规则,它们能帮你远离与继承相关的麻烦。所有这些规则
背后的潜台词都是在说,继承往往会让你和程序员的首要技术使命(即管理复杂
KEY POINT
度)背道而驰。从控制复杂度的角度说,你应该对继承持有非常歧视的态度。下
面来总结一下何时可以使用继承,何时又该使用包含:
交叉参考关于如果多个类共享数据而非行为应该创建这些类可以包含的共用对象。
复杂度的更多内
容,请参见第5.2如果多个类共享行为而非数据,应该让它们从共同的基类继承而来,并在基
节中的“软件的首
类里定义共用的子程序。
要技术使命:管理
复杂度”
如果多个类既共享数据也共享行为,应该让它们从一个共同的基类继承而
来,并在基类里定义共用的数据和子程序。
当你想由基类控制接口时,使用继承;当你想自己控制接口时,使用包含。
代大全(第2版)

<==========================186end ==============================>
<==========================187start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
150
第6章可以工作的类
Member Functions and Data
成员函数和数据成员
交叉参考关于下面就有效地实现成员函数和数据成员给出一些指导建议。
子程序的总体论
述,请参见第7章让类中子程序的数量尽可能少一份针对C+程序的研究发现,类里面的子
“高质量的子程程序的数量越多,则出错率也就越高(Basili, Briand, and Mel1996)然而,也
序”
发现其他一些竞争因素产生的影响更显著,包括过深的继承体系、在一个类中调
用了大量的子程序,以及类之间的强耦合等。请在保持子程序数量最少和其他这
些因素之间评估利弊。
禁止隐式地产生你不需要的成员函数和运算符有时你会发现应该禁止某些
成员函数比如说你想禁止赋值,或不想让某个对象被构造。你可能会觉得,
既然编译器是自动生成这些运算符的,你也就只能对它们放行。但是在这种情况
下,你完全可以通过把构造函数、赋值运算符或其他成员函数或运算符定义为
private,从而禁止调用方代码访问它们(把构造函数定义为 private也是定义单件
类( singleton class)时所用的标准技术,本章后面还会讲到)。
减少类所调用的不同子程序的数量一份研究发现,类里面的错误数量与类所
调用的子程序的总数是统计相关的(Basili Briand, and Melo1996)同一研究还
发现,类所用到的其他类的数量越高,其出错率也往往会越高。这些概念有时也
称为“扇入fan in”
推荐阅读关于
对其他类的子程序的间接调用要尽可能少直接的关联已经够危险了。而间接的
Demeter法则的关联如 account. Contact Person(. DaytimeContactInfo). PhoneNumber(
更多内容,推荐
阅读( Pragmate往更加危险。研究人员就此总结出了一条“Demeter法则”( Lieberherr and
Programmer Holland1 1989),基本上就是说A对象可以任意调用它自己的所有子程序。如果A
对象创建了一个B对象,它也可以调用B对的任何(公用)子程序,但是它应
Patterms Laman该避免再调用由B对象所提供的对象中的子程序。在前面 account这个例子中,
200就是说 account. Cont act Person()这一调是合适的,但 account. Contact Per
amentals of Object-
Page-Jones son DaytimecontactInfo)则不合适。
2000
这只是一种简化的解释。更多详细信息请参阅本章后面的“更多资源”一节。
一般来说,应尽量减小类和类之间相互合作的范围尽量让下面这几个数字
最小:
所实例化的对象的种类
在被实例化对象上直接调用的不同子程序的数量
■
调用由其他对象返回的对象的子程序的数量
代码大全(第2版)

<==========================187end ==============================>
<==========================188start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubulo.c.com!仅供试看^
6.3有关设计和实现的问题
151
Constructors
构造函数
接下来给出一些只适用于构造函数( constructor)的指导建议。针对构造函数
的这些建议对于不同的语言(C++、Java和 Visual Basic)都差不多。但对于析构
函数( destructor)而言则略有不同,因此请查阅本章“更多资源”中列出的关于
析构函数的资料。
如果可能,应该在所有的构造函数中初始化所有的数据成员在所有的构造
函数中初始化所有的数据成员是一个不难做到的防御式编程实践。
推荐阅读在
用私用(private)构造函数来强制实现单件属性(singleton property)如果
C++中实现这一目
的的代码十分类你想定义一个类,并需要强制规定它只能有唯一一个对象实例的话,可以把该类
似。详情请参阅所有的构造函数都隐藏起来,然后对外提供一个 static的 Get Instance()子程
<More Effective
Meyers(序来访问该类的唯一实例。它的工作方式如下例所示:
1998)中的第26Java示例:用私用构造函数来实现 Singleton(单件)
号条款。
public class Maxrd
/ constructors and destructors
这里就是私用构造函 private MaxId()
数。
/ public routines
这里是提供对唯实public static MaxId Get Instance()
例进行访问的公用方
return minstance;
法。
这是唯一实例。
private members
private static final Maxid m_instance =new MaxId()
仅在初始化 static对象m_instance时才会调用私用构造函数。用这种方法
后,当你需要引用MaxId单件时就只需要简单地引用 MaxId. Get Instance()即可
优先采用深层复本(deep copies),除非论证可行,才采用浅层复本(shallow
copies)在设计副杂对象的时候,你需要做出一项主要决策,即应为对象实现深
拷贝(得到深层复本)还是浅拷贝(得到浅层复本)。对象的深层复本是对象成员
数据逐项副制(member-wise- copy)的结果;而其浅层复本则往往只是指向或引用
同一个实际对象,当然,“深”和“浅”的具体含义可以有些出入。
实现浅层复本的动机一般是为了改善性能。尽管把大型的对象副制出多份复
本从美学上看十分令人不快,但这样做很少会导致显著的性能损失。某几个对象
可能会引起性能问题,但众所周知,程序员们很不擅长推测真正招致问题的代码
(详见第25章“代码调整策略”)。
代码大全(第2版)

<==========================188end ==============================>
<==========================189start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
152
第6章可以工作的类
为了不确定的性能提高而增加复杂度是不妥的,因此,在面临选择实现深拷
贝还是浅拷贝时,一种合理的方式便是优先实现深拷贝除非能够论证浅拷贝
更好。
深层复本在开发和维护方面都要比浅层复本简单。实现浅拷贝除了要用到两
种方法都需要的代码之外,还要增加很多代码用于引用计数、确保安全地复制对
象、安全地比较对象以及安全地删除对象等。而这些代码是很容易出错的,除非
你有充分的理由,否则就应该避免它们。
如果你发现确实需要实现浅拷贝的话,ScottMeers写的《,ScotMeyers《MoreEjectiveC++X++》
(1996)一书的第29号调款就C++中的这个问题进行了精辟的阐述 Martin Fowler
在《《Refqctoring/1999《》(《重构》,1999)一书中也论述了在深拷贝和浅拷贝之间相互转
换的具体步骤(Fowler把这两种复本对象分别称为引用对象( reference object)和
值对象( value object) )))
Reasons to Create a Class
6.4创建类的原因
交叉参创建
类的理由和创建
如果你完全相信所读到的内容,你可能会得到这么一个概念,即认为创建类
子程序的理由有
的唯一理由就是要为现实世界中的物体(object,对象建模。而实际上,创建类
共同之处。请参的理由远远不止这一个。下面就列出一些创建类的合理原因。
见第7.1节
为现实世界中的对象建模为现实世界中的对象建模也许不是创建类的唯一
交理由,但它仍是个很好的理由请为你程序中需要建模的每一个出现在现实世界中
识别现实对象的
更多话题,见第的对象类型创建一个类。把该对象所需的数据添加到类里面,然后编写一些服务子
5.3节中的“寻程序来为对象的行为建模。请参阅第6.1节中关于ADT的讨论以及其中的例子。
找现实世界中的
对象”。
为抽象的对象建模创建类的另一个理的原因是要建立抽象对象的模型,
所谓的抽象对象并不是一个现实世界中的具体对象,但它却能为另外一些具体的
对象提供一种抽象。经典的 Shape(形状)对象就是一个很好的例子 Circle(圆)
和 Square(正方形)都是真实存在的,但 Shape则是对其他具体形状的一种抽象。
在程序设计中,抽象并不是像 Shape一样现成就有的,因此我们必须努力工
作以得出一些清晰的抽象。“从现实世界的实体中提炼出抽象的概念”这一过程是
不确定的,不同的设计者会抽象出不同的共性(generalities)来举例来说,假如
我们并不了解诸如圆、正方形和三角形这样的几何形状,就可能会得出一些更不
寻常的形状,比如说南瓜的形状、大头菜的形状或是 Pontiac Aztek似的形状
得出恰当的抽象对象是面向对象设计中的一项主要挑战。
降低复杂度创建类的一个最重要的理由便是降低程序的复杂度。创建一个
类来把信息隐藏起来,这样你就无须再去考虑它们当然,当你写到这个类的时
y候还是要考虑这些信息的。但类写好后,你就应该能够忘掉这些细节,并能在无
代码大全(第2版)

<==========================189end ==============================>
<==========================190start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
64创建类的原因
153
须了解其内部工作原理的情况下使用这个类。其他那些创建类的原因缩减代
码空间、提高可维护性以及提高正确性——都是很好的,但一旦失去了类的抽象
能力,那么复杂的应用程序对于我们的智力而言将是无法管理的了。
隔离复杂度无论复杂度表现为何种形态复杂的算法、大型数据集、或
错综复杂的通讯协议等都容易引发错误。一旦错误发生,只要它还在类的局
部而未扩散到整个程序中,找到它就会比较容易修正错误时引起的改动不会影
响到其他代码,因为只有一个类需要修改,不会碰到其他代码。如果你找到了一
种更好、更简单或更可靠的算法,而原有的算法已经用类隔离起来的话,就可以
很容易地把它替换掉。在开发过程中,这样做可以让你更容易地尝试更多设计方
案,保留最好的一种方案。
隐藏实现细节想把实现细节隐藏起来的这种愿望本身便是创建类的一个绝
佳理由,无论实现细节是像访问数据库那般复杂,还是像决定用数值还是字符串
来存储某个特定数据成员那般寻常。
限制变动的影响范围把容易变动的部分隔离开来,这样就能把变动所带来
的影响限制在一个或少数几个类的范围内。把最容易变动的部分设计成最容易修
改的。容易变动的部分有硬件依赖性、输入/输出、复杂数据类型、业务逻辑等
在第5.3节的“隐藏秘密(信息隐藏)”中介绍了几种常见的引起变化的根源。
交叉参考关于
隐藏全局数据如果你需要用到全局数据,就可以把它的实现细节隐藏到某
使用全局数据的个类的接口背后。与直接使用全局数据相比,通过访问器子程序access routine
13.3节“全局数来操控全局数据有很多好处。你可以改变数据结构而无须修改程序本身你可以
据”
监视对这些数据的访问。“使用访问器子程序”的这条纪律还会促使你去思考有关
数据是否就应该是全局的;经常你会豁然开朗地发现,“全局数据”原来只是对象
的数据而已。
让参数传递更顺畅如果你需要把一个参数在多个子程序之间传递,这有可
能表明应该把这些子程序重构到一个类里,把这个参数当做对象数据来共享。实
质上,让参数传递得更顺畅并不是目标,但把大量的数据到处传递是在暗示换一
种类的组织方式可能会更好。
交叉关于
建立中心控制点在一个地方来控制一项任务是个好主意。控制可以表现为
信息隐藏的更多很多形式。了解一张表中记录的数目一种形式;对文件、数据库连接、打印机
详细内容,请参
见第5.3节中的等设备进行的控制又是一种。用一个类来读写数据库则是集中控制的又一种形式。
“隐藏秘密(倍如果需要把数据库转换为平坦的文件或者内存数据,有关改动也只会影响一个类。
息隐藏
代大全(第2版)

<==========================190end ==============================>
<==========================191start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看
154
第6章可以工作的类
集中控制这一概念和信息隐藏有些相似,但它具有独特的启发式功用,值得
把它放到你的编程工具箱中。
让代码更易于重用将代码放入精心分解(wll-)的一组类中,比起
把代码全部塞进某个更大的类里面,前者更容易在其他程序中重用。如果有一部
分代码,它们只是在程序里的一个地方调用,只要它可以被理解为一个较大类的
一部分,而且这部分代码可能会在其他程序中用到,就可以把它提出来形成一个
单独的类。
美国NASA的软件工程实验室(Software Engineering Laboratory)曾经研究
了10个积极追求代码重用的项目(McGarry Waligora, and McDermott 11989)研
HARO DATA究结果表明,无论采用面向对象的设计方法还是以功能为导向的(functionally
oriented)设计方法,在最初的项目中都没能太多地重用之前项目中的代码,因为
之前的项目尚未形成充分的代码基础(code base)然而到了后来,以功能为导向
进行设计(functional design)的项目能重用之前项目中约35%的代码。而使用面
向对象方法的项目则能重用之前项目中超过70的代码。如果提前规划一下就能
让你少写70%的代码,那当然要这样做了!
交叉参考关于
值得注意的是,NASA这种创建可重用的类的方法并未涉及“为重用而设计”
现最少所器功NASA在其项目结束时挑出了可供重用的备选代码然后,他们进行了必要的工
能的详情,参见
第24.2节中的作来让这些代码可以重用,这些工作或被当做是主项目后期的个特殊项目,或
“程序中的一些
代码似乎是在将被当做是新项目的第一个步骤。这种方有助于避免“镀金”增加一些并不
来的某个时候才实际需要的、但却会增加不必要的复杂度的功能。
会用到的”
为程序族做计划如果你预计到某个程序会被修改,你可以把预计要被改动
的部分放到单独的类里,同其他部分隔离开,这是个好主意。之后你就可以只修
改这个类或用新的类来取代它,而不会影响到程序的其余部分了。仔细考虑整个
程序族( family of programs)的可能情况,而不单是考虑单一程序的可能情况,
这又是一种用于预先应对各种变化的强有力的启发式方法(Parnas1976)
几年前我管理过一个团队,我们为客户开发一系列用于保险销售的程序。我
们必须按照客户特定的保险费率、报价表格式等来定制每个程序。然而这些程序
的很多部分都是相同的:用来输入潜在客户的信息的类、用来把信息存到客户数
据库的类、用来查询费率的类、计算一个组的全部费率的类,等等。开发团队对
程序的结构进行了规划,把每个能根据客户要求进行变化的部分都放到单独的类
里面。按照开始的编程任务来计算的话,我们可能要花大约三个月的时间,但在
有了新客户之后,我们仅仅需要为该客户开发出一些新类,然后让这些新类同其
余代码一起工作。定制一套软件只用几天的工夫!
代码大全(第2版)

<==========================191end ==============================>
<==========================192start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww ! --www.shubulo.c.com!仅供试看
6.4创建类的原因
155
把相关操作包装到一起即便你无法隐藏信息共享数据或规划灵活性,你仍然
可以把相关的操作合理地分组,比如分为三角函数、统计函数、字符串处理子程序、
位操作子程序以及图形了程序,等等。类是把相关操作组合在一起的一种方法。除此
之外,根据你所使用的编程语言不同,你还可以使用包(package)命名空间
namespace)或头文件等方法。
实现某种特定的重构第24章“重构”中所描述的很多特定的重构方法都会
生成新的类,包括把一个类转换为两个、隐藏委托、去掉中间人以及引入扩展类等。
为了能更好地实现本节所描述的任何一个目标,这些都是产生各种新类的动机。
Classes to Avoid
应该避免的类
尽管通常情况下类是有用的,但你也可能会遇到一些麻烦。下面就是一些应
该避免创建的类。
避免创建万能类(god class)要避免创建什么都知道、什么都能干的万能类。
如果一个类把工夫都花在用Get()方法和set(方法向其他类索要数据(也就是
说,深入到其他类的工作中并告诉它们该如何去做的话,请考虑是否应该把这
些功能组织到其他那些类中去,而不要放到万能类里(Riel1996)
交叉参考这种消除无关紧要的类如果一个类只包含数据但不包含行为的话,应该问问自
类通常也叫结构己,它真的是一个类吗?同时应该考虑把这个类降级,让它的数据成员成为一个
体(structure关
于结构体的更多或多个其他类的属性。
内容,请参见第
13.1节“结构体”
避免用动词命名的类只有行为而没有数据的类往往不是一个真正的类。请
考虑把类似 Databaselnitialization(数据库初始化)或StringBuilder(字符串构造器
这样的类变成其他类的一个子程序。
Summary of Reasons to Create a Class
总结:创建类的理由
下面总结一下创建类的合理原因:
■对现实世界中的对象建模
对抽象对象建模
降低复杂度
隔离复杂度
隐藏实现细节
限制变化所影响的范围
■隐藏全局数据
代大全(第2版)

<==========================192end ==============================>
<==========================193start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo.com!^.com!仅供试看
156
第6章可以工作的类
■让参数传递更顺畅
创建中心控制点
让代码更易于重用
为程序族做计划
把相关操作放到一起
■实现特定的重构
Language-Specific Issues
与具体编程语言相关的问题
不同编程语言在实现类的方法上有着很有意思的差别。请考虑一下如何在一
个派生类中通过覆盖成员函数来实现多态。在Jva中,所有的方法默认都是可以
覆盖的,方法必须被定义成 final才能阻止派生类对它进行覆盖。在C++中,默认
是不可以覆盖方法的,基类中的方法必须被定义成 virtual才能被覆盖。而在 Visual
Basic中,基类中的子程序必须被定义为 overridable,而派生类中的子程序也必须
要用 overrides关键字
下面列出跟类相关的,不同语言之间有着显著差异的一些地方:
在继承层次中被覆盖的构造函数和析构函数的行为
在异常处理时构造函数和析构函数的行为
默认构造函数(即无参数的构造函数)的重要性
析构函数或终结器(finalizer)的调用时机
和覆盖语言内置的运算符(包括赋值和等号)相关的知识
当对象被创建和销毁时,或当其被声明时,或者它所在的作用域退出时,处
理内存的方式
关于这些事项的详细论述超出了本书的范围不过在“更多资源”…节提
供了一些与特定语言相关的很好资源。
6.6
Beyond Classes: Packages
超越类:包
交关于
类和包的区别,请
类是当前程序员们实现模块化(modularity)的最佳方式。不过模块化是个很
参见第5.2节中的庞大的话题,其影响范围要远远超出类在过去几十年间,软件开发的进展在很
“设计的层次”
代码大全(第2版)

<==========================193end ==============================>
<==========================194start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
6.6超越类:包
157
大程度上要归功于我们在编程时进行工作的粒度的增长。首先是语句,这在当时
算得上是自从机器指令以来迈进的一大步。接下来就是子程序,再后来则是类。
很显然,如果我们能有更好的1.具来把对象聚合起来,我们就可能更好地朝
着抽象和封装的目标迈进。Ada语言早在十多年前就已经支持包(package)的概
念了,现今Java语言也支持包了。如果你所用的编程语言不能直接支持包的概念,
你也可以自行创建自己的包(的“可怜程序员版or--programmer's version),并
通过遵循下列编程标准来强制实施你的包:
用于区分“公用的类”和“某个包私用的类”的命名规则
为了区分每个类所属的包而制定的命名规则和/或代码组织规则(即项目结构)
■规定什么包可以用其他什么包的规则,包括是否可以用继承和/或包含等
这些变通之法也是展示“在一种语言上编程”和深入一种语言去编程”之
间区别的好例子。关于这一节的更多信息,请参见第34.4节“以所用语言编程,
但思路不受其约束”。
CHECKLIST: Class Quality
cc067核对表:类的质量
交叉这是抽象数据类型
关于类的质量的
考虑事项的核对口你是否把程序中的类都看做是抽象数据类型了?是否从这个角度评估
表。关于创建类
的步
它们的接口了?
的步骤列表,请
参见第9章233抽象
页中的“伪代码
编程过程”
口类是否有一个中心的?
口类的命名是否恰当?其名字是否表达了其中心目的?
口类的接口是否展现了一致的抽象?
口类的接口是否能让人清楚明白地知道该如何用它?
口类的接口是否足够抽象,使你能不必顾虑它是如何实现其服务的?你能
把类看做黑盒子吗?
口类提供的服务是否足够完整,能让其他类无须动用其内部数据?
口是否已从类中除去无关信息?
口是否考虑过把类进一步分解为组件类?是否已尽可能将其分解?
口在修改类时是否维持了其接口的完整性?
代大全(第2版)

<==========================194end ==============================>
<==========================195start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.cor.com!仅供试看^
158
第6章可以工作的类
封装
口是否把类的成员的可访问性降到最小?
口是否避免暴露类中的数据成员?
口在编程语言所许可的范围内,类是否已尽可能地对其他的类隐藏了自己
的实现细节?
口类是否避免对其使用者,包括其派生类会如何使用它做了假设?
口类是否不依赖于其他类?它是松散耦合的吗?
继承
口继承是否只用来建立“是一个/isa”的关系?也就是说,派生类是否遵
循了LsP(Liskov替换原则)?
口类的文档中是否记述了其继承策略?
口派生类是否避免了“覆盖”不可覆盖的方法?
是否把公用的接口、数据和行为都放到尽可能高的继承层次中了?
口继承层次是否很浅?
口基类中所有的数据成员是否都被定义为 private而非 protected的了?
跟实现相关的其他问题
口类中是否只有大约七个或更少的数据成员?
口是否把类直接或间接调用其他类的子程序的数量减到最少了?
口类是否只在绝对必要时才与其他的类相互协作?
口是否在构造函数中初始化了所有的数据成员?
口除非拥有经过测量的、创建浅层复本的理由,类是否都被设计为当作深
层复本使用?
与语言相关的问题
口你是否研究过所用编程语言里和类相关的各种特有问题?
代码大全(第2版)

<==========================195end ==============================>
<==========================196start==============================>

该书下载自书部落-分享计算机经典巨著!--www. ! --www.shu.com!仅供试看^
更多资源
159
Additional Resources
更多资源
Classes in General
,一般问题
cc2e.com/0679 ec2e.com/0679  meyer, bertrand. object-oriented Software Construction ),bertrand.《object-orintedSoftwareConsructin》(《面向对象软件构
造》),2ded. New York,ny: Prentice Hall PTR,197.这本书详细地讲解了抽象数据
类型,并解释了它是如何构成类的基础的。第14至16章深入地讲解了继承。在
第15章中, Meyer提出了支持多重继承的正面论据。
Ricl, Arthur J. Object-Oriented Design Heuristics ) Reading, MA:
Addison-Wesley-,1996.这本书就如何改善程序的设计给出了大量的建议,这些建
议大多是从类的角度出发的。有几年时间我一直回避这本书,因为它看上去实在
太庞大了。不过,这本书的主体部分只有约200页厚。Rie的写作风格通俗易懂,
令人赏心悦目。这本书内容集中,很有实用性。
C++
C++
cc2e.com/0686  meyers, scott. keffective c++: 50 Specific Ways to Improve Your Programs and
Designs》(Designs)《5ftctiv+dedJReading,MAtAdionwWeley198+,第二版》),2ded.readi,maadision-wsley,1998
Meyers, Scott, 1996, KMore Effective C++: 35 New Ways to Improve Your
Programs and Designs(More Effective+中文版》) Reading,MA:
Addison-Wesley-,1996. Meyers的这两本书都可以称得上是C++程序员的圣典了。
他的书在诙谐之中向我们传达了一位语言大师对于C++细微之处的品味。
Java
Java
cc2e.com/0693
Bloch, Joshua. Effective Java Programming Language Guide). Boston, MA:
Addison-Wesley-,2001. Bloch在该书中给出了很多关于ava语言的实用建议,同时
也介绍了一些更为常用的、合理的面向对象实践。
Visual Basic
Visual Basic
ccco00下面这几本书都是与 cc2e.com/0600 visual basic:中类相关的不错的参考资料:
Foxall, James. Practical Standards for Microsoft Visual Basic .NET)
Redmond, WA: Microsoft Press, 2003
Cornell, Gary, and Jonathan Morrison KProgramming VB. NET: A Guide for
Experienced Programmers). Berkeley, CA: Apress, 2002
Barwell,fred,etal. Professional VB.net》,2ded.wrox,2002.
代码大全(第2版)

<==========================196end ==============================>
<==========================197start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo. com! ^ ^.com!仅供试看
160
第6章可以工作的类
Key Points
要点
类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。
类的接口应隐藏一些信息如某个系统接口、某项设计决策、或一些实现
细节。
包含往往比继承更为可取除非你要对是一个isa”的关系建模。
继承是一种有用的工具,但它却会增加复杂度,这有违于软件的首要技术使
命管理复杂度。
类是管理复杂度的首选工具。要在设计类时给予足够的关注,才能实现这一
目标。
代码大全(第2版)

<==========================197end ==============================>
<==========================198start==============================>

该书下载自-书部落-分享计算机经典巨著-www. !--www.shubulo. com!^^.co!仅供试看个
High-Quality Routines
第7章
高质量的子程序
cce.co/077内容
7.1创建子程序的正当理由:第164页
7.2在子程序层上设计:第168页
7.3好的子程序名字:第171页
7.4子程序可以写多长:第173页
7.5如何使用子程序参数:第174页
7.6使用函数时要特别考虑的问题:第181页
7.7宏子程序和内联子程序:第182页
相关章节
构造子程序的步骤:第9.3节
可以工作的类:第6章
一般设计技术:第5章
软件架构:第3.5节
第6章描述了创建类的个中细节,而本章则将转向子程序(routines),关注
那些关乎子程序质量好坏的特征。如果你希望在进入细节之前阅读有关能够影响
子程序设计的事项,那么请先阅读第5章“软件构建中的设计”,然后再回到本章。
第8章“防御式编程”也阐述了高质量的子程序的一些重要属性。如果你对创建
子程序和类的步骤更感兴趣,那么从第9章“伪代码编程过程”开始可能会更好。
在讨论高质量的子程序的细节之前,明确下面这两个基本术语会很有帮助。
首先,什么是“子程序(routine)”?子程序是为实现一个特定的目的而编写的一
个可被调用的方法( method)或过程(procedure)。例如C++中的函数(function),
Java中的方法( method),或 Microsoft Visual Basic中的函数过程(function
procedure)或子过程( sub procedure)。对于某些使用方式,C和C++中的宏( macro
也可认为是子程序。你可以把创建高质量子程序的很多技术应用到所有这些情况
中。
那什么又是高质量的子程序呢?这个问题更难回答。也许回答这个问题的最
代码大全(第2版)

<==========================198end ==============================>
<==========================199start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo..com!仅供试看
162
第7章高质量的子程序
简单的办法,是来看看什么东西不是高质量的子程序。这里举一个低质量的子程
序的例子:
C++示例:低质量的子程序
void Handlestuff( CORP_DATA inputRec int crntotr, EMP_DATA em
pRec,
double estimRevenue, double ytaRevenue, int screenx, int screenY,
CODING
COLORtype& newColor, COLORTYPE& prevColor, StatusType& status
int expenseType
int i:
for(i=0;i<100;++)(
inputRec. revenue [i] =0
inputRec. expense corpExpense crntotr]
UpdateCorpDatabase( empRec
estimRevenue= ytdRevenue4.0/(double) crntQtr;
newColor =prevColor;
status SUCCESSi
if expenseTypei
for(i=0;i<12;i++)
profit[i] revenue[i] expense. typel[i];
else if expenseType = 2 )
profit[il revenue[il expense. type2[i]:
else if( expenseType==3
profit [i] revenue [i] expense. type3 [i]
这个子程序里有哪些不妥呢?给你一个提示:你应该能够从中发现至少10个
不同的问题。请你先列出自己发现的问题,然后再来看下面这份清单:
这个子程序有个很差劲的名字。 Handlestuff()一点也没有告诉你这个子程
序究竟是做什么的。
■这个子程序没有文档(有关文档的话题已经超出了子程序的范畴,因此将在
第32章“自说明代码”中讨论)。
这个子程序的布局不好。代码的物理组织形式几乎没有给出任何关于其逻辑
组织的提示。布局的使用过于随意,程序内的不同部分使用了不同的布局风
各。请比较一下 expenseType==2和 expenseType==3这两处的代码风格。
(在第31章“布局与风格”中会讨论布局问题。)
这个子程序的输入变量 inputRec的值被改变了。如果它是一个输入变量,
它的值就不应该被修改(而且在C++中它应该定义为 const)。如果变量的
值就是要被修改的,那就不要把它命名为input Rec
这个子程序读写了全局变量它从 corpExpense中读取数值并将其写入
profit它应该更直接地与其他子程序通信,而不是去读写全局变量。
代码大全(第2版)

<==========================199end ==============================>