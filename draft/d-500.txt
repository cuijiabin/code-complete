<==========================400start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看^
15.2case语句
363
把 default子句只用于检查真正的默认情况也许有时候你只剩下了一种情况
需要处理,于是就决定把这种情况编写为default子句(默认子句)。尽管这么做
有时候很诱人,但却是很不明智的。你将失去ase语句的标号(label)所提供的
自动说明功能,而且也丧失了使用default子句检测错误的能力。
这种case语句一经修改很容易损坏。如果你用的是真正的默认情况,那么增
加一种新情况就很容易——你只需增加这种情况和相应的代码即可。但如果你所
用的是伪造的默认情况,那么修改起来就会非常困难。你不得不增加新的情况,
很可能还要把它变为新的默认情况,然后把原来用的默认情况改为普通情况。还
是一开始就使用真正的默认情况吧。
利用 default子句来检测错误如果一条cae语句中的默认子句既没有用来做
其他的处理,按照正常执行顺序也不太可能会发生,那么就向里面加入一条诊断
消息:
Java示例:使用 default子句来检测错误——良好的实践
switch commandshortcutLetter
case'a':
PrintAnnualReport
break:
case 'p':
e was consi
/ no action required, but case was considered
break;
case 'q':
PrintQuarterlyReport
breaki
PrintSummaryReport()
breaki
Display InternalError(
"Internal Error 905: Call customer support. ")
像这样的消息在开发版代码和产品版代码里都很有用。与其让系统崩溃,或
者产生看似正确、直到客户老板检查才发现有问题的结果,不如让用户们看到“内
部错误:请致电客户支持”的消息。
如果把默认子句用于错误检测之外的其他目的,那就意味着每一种情况的选
择都是正确的。请仔细检查以确认每一个可能进入case语句的值都是合法的。如
果你发现了一些不合法的值,那么就重写这些语句,让默认子句去执行错误检测。
在C++和Java里,避免代码执行越过一条ase子句的末尾类似于C的语言
(C、C++和Java)不会自动地跳出每一种情况的执行。相反,你必须明确地为每
case子句写结束语句(break语句)。如果你不这么做,程序就会越过其末尾并
代码大全(第2版)

<==========================400end ==============================>
<==========================401start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看^
364
第15章使用条件语句
继续执行下一case子句的代码。这导致了一些特别奇怪的编程习惯,包括下面这
个糟糕的例子:
c++示例:滥用case语句
switch InputVar)
CODING
case'A': if test (1
//statem
HORROR
交叉参考这段
ase. statement
case
://st
statement 3
代码的格式有效
/ statement 4
地粉饰了这段代
码。如果想知道
代码格式如何才
break;
能真实反映出代
码质量,请参考
第31.3节中的
“行尾布局”以
这种习惯很不好,因为它把不同的控制结构搅在一起了。嵌套的控制结构已
及第31章“布局经够难理解的了,重叠的结构简直就不可能弄清楚。修改case'a或者case'b
与风格”的其余
部分。
比做脑部外科手术还困难,而且很有可能需要先清理一下这些情况后才能做任何
修改。这样倒不如一开始就做对的好。总之避免代码执行路径越过case子句的
末尾是个好主意。
在C++里,在case末尾明确无误地标明需要穿越执行的程序流程如果要你
故意让代码越过某case子句的末尾,那么就在相应的位置给出明确的注释,解
释为什么要这样编写代码。
C++示例:对穿越case子句末尾的情况加以注释
switch( errorDocumentationLevel)
case DocumentationLevel_Full:
/ FALLTHROUGH --Full documentation also prints summary comments
case DocumentationLevel_Summary:
DisplayErrorSummary( errorNumber
FALLTHROUGH-- Summary documentation also prints error number
case DocumentationLevel_Numberonly:
Display ErrorNumber( errorNumber )
break;
default:
DisplayInternalError(.a11
"Internal Error 905: Call
customer support.")
代码大全(第2版)

<==========================401end ==============================>
<==========================402start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
15.2case语句
365
这种方法发挥作用的几率,就和你发现某个人宁愿拥有一艘旧的渡船也不愿
拥有一艘新的巡洋舰的几率是一样的。一般而言,那些执行完一个case之后又执
行到另case的代码,在修改时都容易引发错误,这种代码就应该避免。
CHECKLIST: Using Conditionals
cc2e.com/1545
核对表:使用条件语句
if-then语句
口代码的正常路径清晰吗?
口if-then测试对等量分支的处理方式正确吗?
口使用了else子句并加以说明吗?
口else子句用得对吗?
用对了if和else子句,即没把它们用反吗?
口需要执行的正常情况是位于if而不是else子句里吗?
if- then else-if语句串
口把复杂的判断封装到布尔函数调用里了吗?
口先判断最常见的情况了吗?
口判断包含所有的情况吗?
itn-else-if是最佳的实现吗?比case语句还要好吗?
case语句
case子句排序得有意义吗?
口每种情况的操作简单吗?必要的时候调用了其他子程序吗?
口case语句检测的是一个真实的变量,而不是一个只为了滥用case语句
而刻意制造变量吗?
口默认子句用得合法吗?
口用默认子句来检测和报告意料之外的情况了吗?
口在C、C++或者Java里,每一个case的末尾都有个吗?
大全(第2版)

<==========================402end ==============================>
<==========================403start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看
366
第15章使用条件语句
Key Points
要点
对于简单的if-else语句,请注意if子句和else子句的顺序,特别是用它来
处理大量错误的时候。要确认正常的情况是清晰的。
对于 if-then--else语句串和case语句,选择一种最有利于阅读的排序。
为了捕捉错误,可以使用case语句中的 default子句(默认子句),或者使
用 if-then--else语句串中的最后那个else子句
各种控制结构并不是生来平等的。请为代码的每个部分选用最合适的控制结
构。
代码大全(第2版)

<==========================403end ==============================>
<==========================404start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!^.com!仅供试看^
Controlling Loops
第16章
控制循环
ccecm/1609内容
16.1选择循环的种类:第367页
16.2循环控制:第373页
16.3轻松创建循环由内而外:第385页
16.4循环和数组的关系:第387页
相关章节
驯服深层嵌套:第19.4节
一般控制问题:第19章
条件代码:第15章
■直线型代码:第14章
■数据类型和控制结构之间的关系:第10.7节
“循环”是一个非正式的术语,用来指代任意一种迭代控制结构(iterative
control structure)——任一能够导致应用程序反复执行一段代码的结构。常见的循
环种类有C++和Java中的for、 while和do -while-,以及 Microsoft Visual Basic中的
For-next、 While-W-end和Do-loop- While.使用循环是编程中最复杂的方面之一
知道如何以及何时使用每一种循环是创建高质量软件的一个决定性因素。
16
Selecting the Kind of Loop
选择循环的种类
在大多数语言中,你只能用到少数几种循环。
计数循环(《counted1oop《)执行的次数是一定的,可能是针对每位雇员执行
一次。
连续求值的循环( continuously evaluated loop)预先并不知道将要执行多少
次,它会在每次迭代时检查是否应该结束。例如,它会在还有剩余资金的时
候继续运行,直到用户选择了退出,或者遇到了一个错误。
无限循环( endless loop)一旦启动就会一直执行下去。你会在心脏起搏器
微波炉以及导航控制仪等嵌入式系统里找到它。
迭代器循环(iterator loop)对容器类里面的每个元素执行一次操作。
代码大全(第2版)

<==========================404end ==============================>
<==========================405start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
368
第16章控制循环
这些类型的循环首先是在灵活度上有差异——要么循环执行的次数是一定
的,要么就在每次迭代的时候检查循环有没有完成。
这些循环还在检查循环是否执行完毕的位置上有所不同。你可以把检查放在
循环的开始、中间或者结尾处。这一特征能够告诉你该循环会不会至少执行一次。
如果是在循环头进行检查,那么它的循环体就不一定会执行到。如果把检查放在
循环尾,它的循环体就会至少执行一次。如果是在循环的中间检查,那么位于检
查前面的那一部分循环就会至少执行一次,但是位于检查后面的那部分循环就不
一定会执行到了。
灵活度和检查位置决定了如何对用作控制结构的循环种类进行选择。表16-1
显示了多种语言中的循环种类,并且描述了其灵活度和检查位置。
表16-1循环的种类
语言
循环的种类
灵活度
检查位置
Visual Basic
For-Next
严格
开始
While-Wend
灵活
开始
Do-Loop-While
灵活
开始或结尾
For-Each
严格
开始
C, C++,C#, Java For
灵活
开始
While
灵活
开始
do-while
灵活
结尾
foreach*
严格
开始
*目前只在C#中可用。其他一些语言,包括jva,在本书写作的时候也有计划要
采纳这种循环。
When to Use a while Loop
什么时候使用 while循环
编程新手有时认为 while循环会不断地求 while条件的值,并且会在条件变成
假的时候执行结束,而不论循环里面正在执行的是哪一条语句(Curtis等人,1986)
尽管没有这些新手所想象的那么灵活,whil循环的确是一种灵活的循环选择。如
果你预先并不知道循环要迭代多少次,那么就使用 while循环。与一些编程新手
所想的正相反,执行每通过这种循环一次, while只做一次循环终止的检测,而且
有关 while循环的最主要事项就是决定在循环开始处还是结尾处做检测。
代码大全(第2版)

<==========================405end ==============================>
<==========================406start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
16.1选择循环的种类
369
Loop with Test at the Beginning
检测位于循环的开始
对于在开始处进行检测的循环,在C++C#、java、 Visual Basic以及大多数
其他的语言里,你可以使用 while循环。在其他语言里,你也可以模拟 while循环
Loop with Test at the End
检测位于循环的结尾
你也许偶尔会遇到这种情况:需要一个灵活的循环,但是该循环至少需要执
行一次。在这种情况下,你可以用一个在结尾处做条件检测的 while循环。在C++、
c#以及Java里,你可以用do- -while,在 Visual BasicWhile里用Do-loop-,或者在
其他语言里模拟在末尾进行条件检测的循环。
When to Use a Loop-With-Exit Loop
什么时候用带退出的循环
带退出的循环(Loop-ith-exit)就是终止条件出现在循环中间而不是开始或
者末尾的循环。 Visual Basic明确支持loop-ith-exit循环,你可以在C++、C和Java
中用结构化的 while和 break来模拟它,或者在其他语言中用goto来模拟它
Normal Loop-With-Exit Loops
正常的带退出循环
一个带退出循环通常由循环头、循环体(包括终止条件)和循环尾组成,如
下面的 Visual Basic例子所示:
Visual Basic示例:带退出循环的一般结构
Do
语句。
If some exit condition Then Exit Do
更多语句。
Loop
带退出循环通常是在这样的场合下使用:如果把循环条件检测放在循环开始
或结束处,那就需要写出一个半循环(loop-nd-a-half)的代码。下面是一个应该
使用带退出循环但却没有用的C++例子:
C++示例:有重复的代码,这在维护时会出现问题
score
/ Compute scores and ratings.
score
这两行在这里 GetNextRat ing(&rating Increment)
出现了
Lrating= rating+ ratingIncrement;
while(( score target Score)&&( ratingIncrement=0))
tne
GetNextScore &scoreIncrement
然后在这
_score score scoreIncrement;
里再次出现。
GetNextRating(&ratingIncrement);
rating= rating+ ratingIncrement
代码大全(第2版)

<==========================406end ==============================>
<==========================407start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.cor.com!仅供试看^
370
第16章控制循环
例子中的前两行代码又在 while循环中的后两行中重复出现了。在修改的时
候,你很容易忘记让这两组代码保持一致。如果别的程序员来修改这段代码,很
可能不会注意到这两组代码应该同步地修改不管怎样,其结果都是由于没有完
全地修改而导致出错。你可以按照下面的样子来重写这些代码,以使之更加清晰:
C++示例:带退出循环,更容易维护
Compute scores and ratings. The code uses an infinite loop
11 and a break statement to emulate a loop-with-exit loop.
score=0
while(trueiar
这就是循环退出
GetNextRating(&ratingInc
条件(现在你可以
rating= rating+ ratingIncrement;
用第19.1节介绍
的狄摩根定理对
if(!(( score targe
re)&( ratingIncrement=0)))
其进行简化)
break;
GetNextScore( &scoreIncrement
me
score= score+ scoreIncrement;
下面是用 Visual Basic写的代码:
Visual Basic示例:带退出循环
Compute scores and ratings
score =0
rating rating ratingIncrement
coretarasrd
f(not(score< targetScore and ratingIncrem>0)) Then Exit Do
c,。
GetNextScore ScoreIncrement
score score scoreIncrement
Loop
在你使用这种循环的时候,请把下面这些细节考虑进去。
交叉参考循环
退出条件在本章
把所有的退出条件放在一处。把它们写得到处都是,实际上就会使得某些终
后面有详细的介止条件在调试、修改或者测试的时候被忽略。
绍。如果想知道
如何在循环中合
理使用注释,请
用注释来阐明操作意图。如果你在一个不直接支持带退出循环的语言里使用
查阅第32.5节中直接退出法,那么就应该用注释把你做的事情解释清楚。
的“注释控制结
构”
代码大全(第2版)

<==========================407end ==============================>
<==========================408start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c! ^.com!仅供试看^
16.1选择循环的种类
371
带退出的循环也是单入单出的结构化控制结构,也是一种首选的循环控制
(Software Productivity Consortium,1989)。事实证明,它比其他种类的循环都
HARD DATA要容易理解。一份针对程序员学员的研究把它和那些在开始或者结尾位置终止的
循环做了对比(Soloway, Bonar and Ehrlich983)在使用了带退出循环以后,学
员们在一份理解力测试中的得分提高了25%,研究人员得出结论称,带退出循环
结构要比其他循环结构更接近于人类思考迭代型控制的方式。
在日常的编程实践中,带退出循环的应用仍然不够广泛,人们还在烟雾缭绕
的房间里争论这是不是开发产品代码的好的方法。尽管人们还在讨论,但只要你
小心谨慎地使用,带退出循环就是一种值得放在你的程序员工具箱中的好工具。
Abnormal Loop-With-Exit Loops
非正常的带退出循环
这里说明了用另外一种利用带退出循环避免一个半循环(loop-and-a-half)的
情况。
C++示例:用got闯入循环中间糟糕的实践
goto starti
while( expression)(
CODING
// do something
HORROR
Start:
/ do something else
乍一看,这个例子和前面一个带退出循环的例子很像。它用在第一次循环的
时候无须执行/ do something而是执行/ do something else的场合。这也
是一个单入单出的控制结构:进入该循环的唯一方法是通过顶上的got入口,而
终止该循环的唯一方法是经过 while判断。这种方法有两个问题:它使用了goto,
而且它的写法太少见,易使人感到困惑。
在C++里,你可以不用goto而达到同样的目的,如下例所示。如果你所用的
语言不支持 break命令,那么你可以用goto来模拟 break.
C++示例:重写后的不用goto的代码更好的实践
本例中, break while(true)
前后的语句块已 do something else
经进行了交换。
代码大全(第2版)

<==========================408end ==============================>
<==========================409start==============================>

该书下载自书部落-分享计算机经典巨著!-www. ! --www.shubulo.com!^^.com!仅供试看^
372
第16章控制循环
if(!( expression))(
break;
do something
When to Use a for Loop
何时使用for循环
深入阅读想知如果你需要一个执行次数固定的循环,那么for循环就是一个很好的选择。
道更多关于使用在C++、C、Java、 Visual Basic以及大多数其他语言里,你都可以使用它。
for循环的好建
议么?请阅读
可以用for循环来执行那些不需要循环内部控制的简单操作。当循环控制就是
Writing Solid简单的递增或递减,如对某一容器的元素进行迭代的时候,就可以使用for循环。
odeMaguire for循环的关键之处在于,你在循环头处把它写好后就可以忘掉它了,无须在循环
1993)。
的内部做任何事情去控制它。如果存在一个必须使执行从循环中跳出的条件,那
么就应该改用 while循环。
类似地,不要在for循环里通过直接修改下标值的方式迫使它终止,在这种情
况下应该改用 while循环。for循环就是为了简单的用途,更复杂的循环最好用
while循环去处理
When to Use a foreach Loop
何时使用 foreach循环
foreach循环或其等价物(c#中的 foreach, Visual Basic中的For-each,以及
Python中的for-in)很适用于对数组或者其他容器的各项元素执行操作。它的优势
在于消除了循环内务处理算术,从而也就消除了任何由循环控制算术导致出错的
可能性。下面举一个这种循环的例子:
c#示例: foreach循环
int fibonacci Sequence new int0,11,2,3,5,8,13,21,34;
int evenFibonacciNumbers =0
count the number of odd and even numbers in a fibonacci sequence
cis in a Fibonacci sequence
foreach int fibonacciNumber in fibonaccisequence
if( fibonacciNumber2)==0)
evenFibonacciNumbers++
else
oddFibonacciNumbers++
Console. WriteLine "Found {0}
numbers and (1) even numbers.
oddFibonacciNumbers, evenFibonacciNumbers
代码大全(第2版)

<==========================409end ==============================>
<==========================410start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看^
16.2循环控制
373
6.2
Controlling the Loop
循环控制
循环会出什么样的错误呢?任何一种答案都可以归结到下面所说的问题之
一:忽略或错误地对循环执行初始化、忽略了对累加变量或其他与循环有关的变
量执行初始化、不正确的嵌套、不正确的循环终止、忽略或者错误地增加了循环
变量的值、以及用不正确的循环下标访问数组元素等。
你可以采取两种方法来阻止这些错误的发生。首先,减少能影响该循环各种因
素的数量。简化、简化、再简化!其次,把循环内部当做一个子程序看待把
KEY POINT控制尽可能地放到循环体外。把循环体执行的条件表述清楚。不要让读者看了循
环体以后才明白循环的控制。应该把循环看做是一个黑盒子:外围程序只知道它
交叉参考如果你的控制条件,却不知道它的内容。
使用的是前面提到C++示例:将循环视为黑盒子
的 while(true
whileinputFile. EndofFile(&& moreDataAvailable)
break方法,那么
退出条件是放在黑
盒中。这样一来,
即便是仅仅用到了
一个退出条件,
也会无法将这个循这个循环终止的条件是什么?很明显要么inputFile. EndofFile()为真,
环视为黑盒。要么 MoreDataAvailable为假这就是你所需要知道的全部。
Entering the Loop
进入循环
在代码进入循环的时候使用下述指导原则。
只从一个位置进入循环各种不同的循环控制结构允许你在循环头、循环体
或者循环尾处执行测试。这些结构丰富到足以让你每次都从循环头部进入该循环。
你无须从多个位置进入。
把初始化代码紧放在循环前面就近原则主张把相关的语句放在一起。如果
相关的语句分散在一个子程序里的各处,那么在修改子程序的时候就很容易忽略
掉它们,导致不正确的修改。如果把相关的语句都放在一起,那么在修改的时候
交叉参考在本就容易避免出错。
章靠后部分的
“将循环下标的
把循环初始化语句和与它相关的循环放在一起。如果你不这样做,一旦把该循
作用域限制于循环放到一个更大的循环中,并且忘记修改相应的初始化代码,就会导致错误。在你
环内部”中,你把循环代码移动或复制到另一个子程序中,却没有移动或复制它的初始化代码的时
可以读到关于限
制循环变量作用候,也会发生同样的问题。让初始化远离循环把它放在包含循环的子程序上方
域的详细内容。的数据声明部分或者内务处理部分里都可能引发上述的初始化问题。
代码大全(第2版)

<==========================410end ==============================>
<==========================411start==============================>

该书下载自-书部落-分享计算机经典巨著!--www !--www.shubulo.c!^^.com!仅供试看^
374
第16章控制循环
用 while(true)表示无限循环你也许有一个不需要终止的循环例如,用在
心脏起搏器或者微波炉等固件( firmware)中的循环。或者有一个只在某一事件发
生时才终止的循环一个“事件循环(event loop)”你可以用很多种方式来实
现无限循环。但用fori=1to99999样的语句假造一个无限循环是很不好
的,因为具体的循环上限模糊了循环的用意99999可能是一个合乎情理的值。
这种假的无限循环降低了代码的可维护性。
普遍认为 while(true)是C++、Java、 Visual Basic和其他支持比较结构语言中
无限循环的标准写法。有些程序员倾向于使用for(;),这种写法也是可以接
受的。
在适当的情况下多使用for循环for循环把循环的控制代码集中在一处,从
而有助于写成可读性强的循环。程序员们在修改软件的时候常会犯一个错误,那
就是修改了位于 while循环顶部的循环初始化代码,但却忘记了修改循环底部的
相关代码。在for循环中,所有相关的代码全都写在循环的顶部,因此修改起来更
加容易。如果能够很恰当地用for循环来替换其他类型的循环,那就这么做。
在 while循环更适用的时候,不要使用for循环对C++、C#、Java中for循
环结构的一种很常见的陋习是,很随便地用 while循环的内容来填充for循环的循
环头。下面例子显示了这样一种用while循环来填充for循环头的用法:
C++示例:胡乱把while循环体填充到for循环头
read all the records from file
for( inputFile. MoveTostart(), recordcourinputFile. EndofFile(
SODINO
recordCount++){
HORROR
inputFile. Get Record();
与其他语言里的同样结构相比,C++中的for循环的优势在于,它能够更加灵
活地表现所能使用的初始化信息和终止信息的种类。这种灵活性所固有的不足之
处在于,你也可以把与控制循环无关的语句放在循环头里面。
应该把for循环头的位置保留给循环控制语句那些用于初始化循环和终
止循环,或者用于使循环趋向于终止的语句。在上面的例子中,位于循环体内的
inputFile. Get Record()语句将循环推向终止但是有关 recordcount的语句却
没有这种作用;它们属于内务语句,并不控制循环的进度。把 recordCount语句
放在循环头内,但却把inputFile. Get Record(语句置于其外会产生误导:让人
错误地认为是 recordCount在控制这个循环。
如果你希望在这种情况下使用for循环而不是 while循环,那么就应该只把循
环控制语句放在循环头里面,把其他的都放在外面。下面是使用这里的循环头部
的正确方法:
代码大全(第2版)

<==========================411end ==============================>
<==========================412start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看^
16.2循环控制
375
C+示例:合乎逻辑但非常规的for循环头部
recordCount0
for( inputFile. MoveTostart();
!inputFile. EndofFile (
inputFile. GetRecord())
recordcount++
在这个例子里,循环头部的内容全都与控制循环有关其中 inputFile.move
Tostart()语句对循环执行初始化, inputFile. EndofFile()语句检测循环是否已
经终止, inputFile. Get Record()语句把循环推向终止。对 recordCount有影响
的那些语句并不直接把循环推向终止,因此很适宜放在循环头部之外。用 while
循环做这件工作可能更合适些,但是至少这段代码对循环头的使用是符合逻辑的。
作为比较,下面是使用 while循环时的代码:
++示例: while循环的适当用法
/1 read all the records from file
inputFile. MoveToStart();
recordCount =0;
while !inputFile. EndofFile() )
inputFile. GetRecord()
reco
recordcount++
Processing the Middle of the Loop
处理好循环体
下面讲解如何处理循环体。
用“{”和“}”把循环中的语句括起来任何时候都要在代码中使用括号。
它们不会增加任何运行时所需的时间或存储空间,只会增加可读性,并且防止修
改代码时出错。它们是一种很好的预防性编程实践。
避免空循环在C++和Java里可以写空循环,即把循环所处理的代码和检测
循环是否终止的代码写在同一行里。下面举一个例子:
+示例:空循环
while(( inputChar= dataFile. GetChar())= CharType_eof
代码大全(第2版)

<==========================412end ==============================>
<==========================413start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.con.com!仅供试看^
376
第16章控制循环
在这个例子中,产生空循环的原因在于whil表达式包含了两样操作:循环
所做的工作 inputChar= dataFile. GetChar()和对循环是否应该终止
的检测 inputChar!= CharType_eof。如果重写这段循环,以让读者更清楚
地了解它所做的工作,这段循环就会变得更有条理:
C++示例:将空循环改为有循环体的循环
do
inputChar dataFile. GetChar()
while( inputChar= CharType_eof)
新代码占用了三条完整的代码行,而不是一行代码再加一个分号,这是很合
适的,因为它完成的正是三行代码而非一行代码加一个分号的工作。
把循环内务操作要么放在循环的开始,要么放在循环的末尾循环内务操作
(《houskeggi+1j4《)是指像i=i+1或者j++这样的表达式,它们的主要目的不是完
成循环工作,而是控制循环。下面例子中的内务操作是在循环的最后完成的:
C++示例:在循环末尾完成内务操作
nameCount =0;
totalLength 0;
while (!inputFile. EndofFile ())
do the work of the loop
innustin.
inputFile>> inputstring;
names nameCount inputstring;
1/ prepare for next pass through the loop--housekeeping
这是内务操作语 nameCount++
向。
totalLength= totalLength+ inputstring. length();
一般来说,在循环之前初始化的那些变量,也就是需要在循环内务部分里处
理的变量。
交叉参考第
25章代码调整
一个循环只做一件事仅靠循环可同时做两件事的这一事实,是无法充分证
策略”和第26明这两件事是应该放在一起做的。循环应该和子程序一样,每个循环只做一件事
章“代码调整技并且把它做好。如果用两个循环会导致效率低下,而使用一个循环很合适,那么
术”详细讨论了就把代码写成两个循环,并注明可以把它们合并起来以提高效率,然后等测量数
如何对代码进
行优化。
据显示程序的这一部分性能低下的时候再去合并它们。
代码大全(第2版)

<==========================413end ==============================>
<==========================414start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!^.com!仅供试看^
16.2循环控制
377
Exiting the Loop
退出循环
下面几小节讲解如何处理循环尾。
设法确认循环能够终止这是基本要求。在脑海里模拟执行这个循环,直到
你可以确认无论在何种情况下循环都能终止。要考虑到正常的情况、端点,以及
每一种异常情况。
使循环终止条件看起来很明显如果你使用for循环,而且没有随便修改循环
下标,也没有使用goto或者 break来跳出循环那么这个循环的终止条件会是很
明显的。与之类似,如果你在使用 while者 repeat-until-循环的时候把所有的控
制语句都放在 while子句或者 repeat-until-子句中,那么终止条件也会十分明显。
关键就在于要把控制都放在一个地方。
不要为了终止循环而胡乱改动for循环的下标有些程序员会随便改动for循
环下标的取值,以达到提前终止循环的目的。下面就是一例:
java例:胡乱改动循环下标
//some code
CODING
HORROR
这里随便改动了循
if(...
i=.100;
环下标。
/ more code
这个例子里的用意是,通过在某些条件下把赋值为100来终止循环因
为这个值已经超过该for循环从0到99的取值范围事实上,所有好的程序员
都会避免这么做;这是业余爱好者的标志一旦你写好了for循环,那么它的循
环记数器就不受你的控制了。你可以改用 while循环来获得对退出条件更多的控
制权。
避免出现依赖于循环下标最终取值的代码在循环终止后使用循环下标值是
很不好的。循环下标的最终取值根据语言以及实现的不同而不同。循环终止正常
与否也会影响到这一数值。即使你恰好能不假思索地知道这一取值是多少,那么
下一个阅读代码的人也会在上面花费时间。更好并且更具自我描述性的做法是,
在循环体内某个适当的地方把这一最终取值赋给某个变量。
代码大全(第2版)

<==========================414end ==============================>
<==========================415start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! www.shubulo.c.com!仅供试看^
378
第16章控制循环
下面的代码滥用了下标的最终取值:
C++示例:滥用循环下标的最终取值的代码
for recordcount 0; recordCount MAX_RECORDS; recordCount++
if( entry[ recordcount= testvalue)
1
break;
// lots of code
这里滥用了循环
索引的终止值。if(IrecozdCounL《MAXLRECORDS<max_records
return true )
else
return( false)
在这段代码里,第二个 recordCount< MaxRecords检测让人觉得该循环将
会处理完 entry[]中的所有值,如果发现与 testValue相同的取值就返回true,
否则就返回 false。然而很难记住下标值是不是一直递增到超出循环的末尾,因
此很容易犯off-by-one错误。你最好还是不要写出依赖于下标最终取值的代码。
下例显示了应该怎样重写这段代码:
C++示例:没有滥用循环下标的代码
found =false;
0; recordcount MAX_ RECORDS; recordcount++
+
if( entry recordcount= testvalue)
found=true;
break;
// lots of code
return( found)
第二段代码里多用了一个变量,并使对 recordCount的引用变得更局部化了。
正如常理,多用一个布尔变量使最终代码变得更加清晰。
考虑使用安全计数器安全计数器是一个变量,你在每次循环之后都递增它,
以便判断该循环的执行次数是不是过多。如果你有一个程序,程序中发生的错误
将带来灾难性的后果,那么就可以用安全计数器来确保所有的循环都终止了。下
面的C++循环将会因为使用安全计数器而受益:
代码大全(第2版)

<==========================415end ==============================>
<==========================416start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.c.com!仅供试看^
16.2循环控制
379
C++示例:本应使用安全计数器的代码
doNex
node =node->Next;
whilenode-Next NULL
下面是加上了安全计数器的同一代码段:
C++示例:使用了安全计数器的代码
safetyCounter =0;
do
node node->Nexti
这是安全计数器代 safetyCounter++in
码
Assert( false,"Internal Error: Safety-Counte- violation.")
} while(node-next=null)
安全计数器并不能包治百病。每次都在代码里使用一个安全计数器,也会增
加复杂度,并且可能引发其他的错误。由于不是每个循环都要用它的,因此当你
在使用了安全计数器的那部分程序中修改循环的时候,就可能会忘记维护安全计
数器的相关代码。然而,如果把安全计数器作为整个项目的一种标准应用于关键
的循环,那么含有安全计数器的代码不会比其他的代码更容易出错。
Exiting Loops Early
提前退出循环
很多语言都提供“除了满足for或者 while的结束条件之外”的终止循环的方
法。在接下来的讨论里,术语break用于指代C++、和Java中的 break、 Visual Basic
中的Exit-do和xit-for以及类似的结构,也包括在那些不直接支持 break的语言
中使用goto来模拟的结构。 break语句(或者它的等价物)使循环通过正常的退
出渠道退出;程序会从循环后面的第一条语句开始执行下去。
作为一种循环控制的辅助语句, continue语句和 break非常相似然而,continue
不会让程序从循环退出,而是让程序跳过循环体的余下部分,从该循环的下一次
迭代的开始位置继续执行。 continue语句相当于ifthen子句的一种缩写,它将阻
止循环的剩余部分的执行。
考虑在 while循环中使用 break语句而不用布尔标记在有些情况下,通过往
while循环中加入布尔标记来实现退出循环体,可能使循环变得很难理解。用 break
来取代一系列的if检测,有时候使你可以从循环中移除一些缩进层次,从而简化
循环控制。把多个 break条件放到一些独立的语句里,并且让它们靠近产生break
代码大全(第2版)

<==========================416end ==============================>
<==========================417start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.con.com!仅供试看^
380
第16章控制循环
的代码,就能减少嵌套,并且让循环更容易阅读。
小心那些有很多 break散布其中的循环一个循环包含很多的 break,有可能
意味着程序员对该循环的结构或对循环在围绕它的代码中的角色缺乏清晰的认
识。在大量使用 break的场合中,用一系列的循环而非一个含有多个出口的循环
可能会使表达更为清晰。
根据《 Software Engineering Notes》中一篇文章所言,1990年1月15日导致
纽约市电话系统停机9个小时的软件故障就是由于一个多余的 break语句造成的
(sen1990)
++示例:在do- -switchbreak-if句块中错误地使用了语句
do
switch
这一break原本打
算是用来退出if的,
但它实际连 switch
break;
也退出了。
while()
使用多个 break不一定就是错的,但是如果它们出现在循环中,那么就是一
个警告的标记。它就像煤矿中的金丝雀,非但没有响亮地歌唱,反而消耗了那里
的氧气。
在循环开始处用 continue进行判断一种使用 continue的好方法是,在循环
开始处做完条件判断后让代码越过剩下的循环体继续执行。例如,如果在循环中
要阅读记录、忽略掉一种记录而处理另一种,那么就可以在循环开始处加入下
面这种判断:
伪代码示例:相对安全地使用 continue
while not eof file do
read( record, file
if( record.type> targetType)then
continue
process record of targetType
end while
这样使用 continue,可以避免用一个能让整个循环体都缩进的if判断。反之,
如果 continue出现在循环中部或者末尾,那么就应该改用if
代码大全(第2版)

<==========================417end ==============================>
<==========================418start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
16.2循环控制
381
如果语言支持,请使用带标号break结构Java支持使用带标号的 break语句
(《labeledbrcak,《),以防止产生纽约市电话中断所遇到的那种问题。可以用带标号
break语句退出for循环、if语句或者任何括在大括号里的代码段(Arnold, Gosling
and Holmes 2000).
下面是对纽约市电话程序问题的一种可能解决方案,其编程语言从C++转换
成了Java,以演示带标号 break的用法:
Java示例:更好的方法,在do- -switch-break-if语句块中使用带标号的
do
switch
CALL_CENTER_DOWN:
if ()
这里的标号使得
reak语句的退出
break CALL_CENTER_DOWN;
目标一目了然。
while ...
使用 break和 continue时要小心谨慎使用beak消除了把循环看做黑盒子的
可能性。把控制循环退出的条件只写在一条语句里是简化循环的有力手段。使用
break就使阅读代码的人必须去读循环体,才能理解循环是如何控制的。这使循环
变得更难理解。
除非你已经考虑过各种替换方案,否则不要使用reak.我们无法确定 continue
和 break是好还是坏。有些计算机科学家认为它们是结构化编程中的合法技巧;
有些人却不这么认为。既然你不能对 continue和 break究竟是对是错做出普遍意义
下的判断,那么就用吧,但是前提是对由此可能产生的错误保持警惕。其实这里
的建议很简单:如果你不能证明使用 break或者 continue的正当性,那么就不要用
它们。
Checking Endpoints
检查端点
对一个简单循环,通常需要注意三种情况:开始的情况,任意选择的中间情
况,以及最终的情况。在你创建循环的时候,应在脑海里运行这三种循环情况,
以确认该循环不会出现任何off-by-one错误。如果有一些特殊情况是与第一次或
者最后一次的情况都不同,那么也要检查它们如果循环中包含了复杂的计算,
那么就拿出计算器来手动地检查这些计算是否正确。
代码大全(第2版)

<==========================418end ==============================>
<==========================419start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.cor.com!仅供试看^
382
第16章控制循环
是否愿意执行这种检查,是高效程序员和低效程序员之间的一项关键差别。
高效的程序员既会在脑海里进行模拟,也会手动地执行运算,因为他们知道这些
手段将会有助于找出错误来。
KEY POINT
低效的程序员会随意地做一些试验,直到他们找到了一种看上去能工作的组
合。如果某个循环没有按照想象的那样去工作,低效的程序员可能会把<改成<=。
如果还不行,他们就会把循环下标加1或者减1。这样做最终可能会碰出正确的
组合来,也可能把原有的错误改成了另一个更微妙的错误。即使这样随意的开发
过程能够产生出一个正确的程序,这些程序员也不明白为什么这个程序是正确的。
你可以通过在头脑中模拟和手工运算而获益多多。这种智力训练带来的好处
是:在最初的编码阶段少犯错误,在调试阶段更快地找出错误,以及从整体上更
好地理解应用程序。它意味着:你能够真正理解你的代码是如何工作的,而不是
瞎猜。
Using Loop Variables
使用循环变量
下面是使用循环变量的一些指导原则。
交叉参考在第用整数或者枚举类型表示数组和循环的边界通常来说,循环计数器应该是
11.2节中的“为循
环下标命名”有整数。浮点数递增时会有问题。例如,你把1.0和26742897.0加起来的结果可能
变量命为循环会是26742897.0而不是26742898.0如果这个递增值是一个循环计数器,那么
关于如何
变量命名的详细你就可能有了一个死循环。
在嵌套循环中使用有意义的变量名来提高其可读性数组的下标和循环的下
标常用同一个变量。如果你有一个一维数组,那么用ij或者k做下标可能还说
KEY POINT
得过去。但是如果你用的是二维甚至多维的数组,那么就应该用有意义的下标名
来明确你的用意。有意义的数组下标名字既能表明循环的用途,也能表明所访问
的那部分数组的用途。
下面是没有遵循这项原则的代码;它使用的是没有意义的ij和k:
Java示例:差劲的循环变量名
for(inti=0; numPayCodes;i++)
for int=0;<12:++)ns:
CODING
for(intk=0;k< numDivisions;k++){
HORROR
sumsum+ transactionik
代码大全(第2版)

<==========================419end ==============================>
<==========================420start==============================>

该书下载自-书部落-分享计算机经典巨著--www !--www.shubulo.cor!.com!仅供试看^
16.2循环控制
383
你认为 transaction数组下标的含义是什么?透过ij和k能看出
transaction的内容吗?如果你有 transaction的声明,你能很容易地判断出这
些下标的使用顺序是不是正确吗?下面用可读性更好的循环变量名重写了这个循
环:
Java示例:好的循环变量名
for( int payCodeIdx=0 payCodeIdx numPayCodes; payCodeIdx++)
for (int month =0; month 12; month++
for int divisionIdx;.
divisionIdx numDivisions;
divisionIdx++
sum sum transaction[ month ] payCodeIdx ] divisionIdx
现在你认为 transaction数组的下标代表的都是什么含义呢?在这种情况
下,这个问题就很容易回答了,因为变量名 payCodeIdx、 month和 divisionIdx
告诉你的信息比i、j和k多得多。计算机能同样轻松地阅读这两种循环。然而对
于人来说,阅读第二种循环要比第一种容易得多。第二种也要好于第一种,因为
你的主要受众是人,而不是计算机。
用有意义的名字来避免循环下标串话习惯性地使用ij和k有可能会导致
下标串话(cross-t-tak)—用同一下标名表示不同的用途。请看下面的例子:
C++示例:下标串话
i在这里首次用到for(i=0;i< numPayCodes++)
/ lots of code
for(=0;j<12;j++)
/ lots of code
在这里又出现了
+for= 0;< numDivisions; i++
sum sum transaction[ ] i ] k ]
由于用惯了i,所以竟在同一个嵌套结构中使用了两次。i所控制的第二个for
循环与前一个发生了冲突,这就是下标串话如果使用比ij和k更有意义的名
字,那么这个问题是可以避免的。一般说,如果某个循环体内有着多于两三行的
代码,或者它有可能会增长,或者它位于一组嵌套的循环里面,那么就应该避免
使用ij和k。
把循环下标变量的作用域限制在本循环内循环下标串话以及其他在循环外
部使用循环下标的做法所带来的问题非常严重,使得Ada的设计者决定让for
代码大全(第2版)

<==========================420end ==============================>
<==========================421start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
384
第16章控制循环
循环的下标在超出循环作用域后就失效;如果试图在for循环的外部使用这些变量
就会引发编译错误。
C++和Java也在某种程度上实现了相同的观点允许在循环内部声明循环
下标,但是并不要求这么做。在第378页的例子中, recordCount变量是可以在
for语句内部声明,从而使其作用域限制在该for循环内部,如下所示:
C+示例:在tor循环内部声明循环下标变量
for int recordcount 0; recordCount MAX_RECORDS; recordcount++)(
/1 looping code that uses recordCount
从原则上说,这种技术允许在多个循环里重复声明 recordCount,而不会带
来误用了两个不同 recordCount的危险。采用这种用法所生成的代码会是下面这
样的:
C++示例:在for循环内部声明循环下标变量并安全地重用这个变量也许是安全的
for( int recordcount=o; recordcount MAXRECORDS recordCount++
looping code that uses recordcount
1/ intervening code
for( int recordCount=; recordcount MAXRECORDS recordCount++)(
additional looping code that uses a different recordcount
这种技术有助于说明 recordCount变量的用途;不过,请不要依赖于你的
编译器对 recordCount作用域所做的检查。《Tec++ Programming Language》
(Stroustrup1997)第6.3.3.1节说, recordcount作用域限于它所在的循环。然
而,当我用三种不同的C++编译器来验证这项功能的时候,却得到了三种不同
的结果:
第一种编译器标出了位于第二个for循环里的 recordCount,提示出现了多
重变量声明并报错;
第二种编译器允许在第二个for循环里使用 recordcount,但却也允许在第
一个for循环的外部使用它;
第三种编译器允许在两个for循环中使用 recordcount,同时不允许在超出
所声明的作用域后再度使用它。
这也是很常见的情况。对那些比较深奥的语言特性,不同的编译器实现常常
不同。
代码大全(第2版)

<==========================421end ==============================>
<==========================422start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看
16.3轻松创建循环由内而外
385
How Long Should a Loop Be
循环应该有多长
循环的长度可以用代码行数或者嵌套层次来衡量。下面给出一些指导原则。
循环要尽可能地短,以便能够一目了然如果你常常在显示器上看循环,而
你的显示器能够显示50行代码,那么就应该把循环的长度限制在50行以内。专
家们曾建议把循环的长度限制在一页纸以内。不过,如果你开始接受编写简单代
码这一原则,那就很少会写出超过15或者20行的循环。
交叉参考第19.4把嵌套限制在3层以内研究表明,当嵌套超出3层以后,程序员对循环的
节“驯服危险的深理解能力会极大地降低( Yourdon1986a)。如果你写的嵌套层次超出了这一数字,
嵌套”有关干简
化嵌套循环的说那么应该通过把某一部分提取为子程序或者简化控制结构的方式来缩短它(在概
明。
念上)。
把长循环的内容移到子程序里如果循环设计得好,那么通常可以把循环体
内的代码移到一个或几个子程序里面,并在循环体内加以调用。
要让长循环格外清晰长度会增加复杂度。如果你写的是短循环,那么就可
以使用 break continue、多个出口、复杂的终止条件等有风险的控制结构。如果
你写的循环比较长,并且担心会给阅读者带来不便,那么就要给它写一个单出
口,并且要保持退出条件清晰无误。
16.3
Creating Loops Easily-From the Inside Out
轻松创建循环由内而外
如果你在编写复杂循环的时候遇上麻烦——大多数程序员都会的可以使
用一种简单的技巧来让它从一开始就是正确的。下面就是一般的处理过程。从
种情况开始,用字面量( literal)来编写代码然后缩进它,在外面加上一个循环
然后用循环下标或计算表达式替换那些字面量。如果需要,在它的外面再套上
个循环,然后再替换掉一些字面量。根据你的需要持续这一过程。等你做完以后,
再加上所有需要的初始化。由于你是从简单的情况开始并且由内向外生成代码的,
因此你可以把这一过程看做是由内而外的编码。
交叉参考从内
到过
假设你正在为,家保险公司开发程序。其中的寿险费率要根据人员年龄和性
外编写循环的别的不同而变化。你的职责是开发一个能够计算一组人员的人寿保险费用总额的
过程类似于第9
章“伪代码编程过子程序。需要写一个能够从列表中取得每个人的费率并能进行累加的循环。你应
程”讲述的过程。该像下面这样做。
代大全(第2版)

<==========================422end ==============================>
<==========================423start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co.com!仅供试看^
386
第16章控制循环
首先,在注释里写下循环体需要执行的操作步骤。在你还没开始考虑语法、
循环下标、数组下标等细节之前,把需要做的事情先写下来,会比在进入细节之
后写更容易一些。
第1步:由内而外创建循环(伪代码示例)
-get rate from table(从表中取得费率)
--add rate to total
(将费率加到总和上)
然后,在还没有编写整个循环之前,尽可能多地把循环体内的注释转化成代
码。在本例中就是为每个人提取费率,并且把它们累加起来。使用的数据要明确、
具体,而不要抽象。
现在 table还没
第2步:由内而外创建循环(伪代码示例)
有任何下标。rate table
p
totalRate totalRate rate
例子中假定 table是保存了费率数据的数组。开始的时候你无须关心数组的
下标。Rate变量用于存储从费率表中取出的个人费率数据。与之相似, totalRate
变量用于存储总费用。
接下来,往 table数组里加入下标:
第3步:由内而外创建循环(伪代码示例)
rate= table census. Age census. Gender
totalRate totalRate rate
该数组是通过年龄和性别来访问的,因此用 census.ge和 census. Gender
来做它的下标。在这个例子中假定 census是一个结构体,其中存储着各个人的
信息。
接下来的一步是给现有语句外面加上一层循环。因为该循环的目的是要计算
一个组中每个人的费率,所以它的下标应该是人。
第4步:由内而外创建循环(伪代码示例)
rson
For person firstPerson to lastPerson
sus. G
rate= table census.age, census. Gender
atetopat
totalRate totalRate rate
End For
你在这里要做的就是在现有代码的外面加一个for循环,然后缩进现有的代
码,并把它们放在一个 begin--end对里面。最后,检查并确认依赖于 person循环
下标的那些变量都已经被推广(generalized)了。在本例中, census变量随 person
变化而变化,所以要适当地推广它。
代码大全(第2版)

<==========================423end ==============================>
<==========================424start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! --www.shubulo.co!.com!仅供试看^
16.4循环和数组的关系
387
第5步:由内而外创建循环(伪代码示例)
For person firstPerson to lastperson
rate= tablel census person.ae, census person.Gender
totalRate totalRate rate
End For
最后,写出必要的初始化代码。在本例中, totalRate变量是需要初始化
的。
最后一步:由内而外创建循环(伪代码示例)
For personfirst person to lastPerson
totalRate totalRate rate
End For
如果你必须在 person循环之外再加上一层循环,那么方法还是一样的。你不
必严格地遵循上述步骤。这里的要点在于从具体事件入手,在同一时间只考虑一
件事,以及从简单的部分开始创建循环。在开发更通用、更复杂循环的过程中,
你迈的步子要小,并且每一步的目的要容易理解。这样一来,你就可以减少在同
一时间需要关注的代码量,从而减少出错的可能。
16.4
Correspondence Between Loops and Arrays
循环和数组的关系
交叉参考在第循环和数组之间有着密切的联系。在许多情况中,循环就是用来操纵数组的,
107节数据类型而且循环计数器和数组下标一一对应。如说,下面用Java写的for循环的下标
关系”中有对循环就是和数组下标相对应的:
和数组之间关系的java示例:数组乘法
进一步讨论。
for( int row=0; row maxRowsrow++)
for int column =0; column maxCols: column++){
product[ row column= row column* row] column
在Java中,用循环来执行这样的数组操作是必然的。不过值得一提的是,循
环结构和数组并不是天生就相互关联的。有些语言,特别是APL和 Fortran90以
及其后续版本,提供了强大的数组操作功能,从而无须使用上述循环。下面是用
APL来执行相同的操作:
APL示例:数组乘法
product <-a x b
代码大全(第2版)

<==========================424end ==============================>
<==========================425start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul ^.com!仅供试看^
388
第16章控制循环
APL代码更加简单,并且更不容易出错。它只用了3个操作符,而相应的Java
代码却用了17个之多。APL代码里面也不包含容易出错的循环变量、数组下标或
者控制结构。
这个例子说明了一点,那就是你通过编程来解决问题,而有的时候这种解决
方案是特定于语言的。你所用的语言将在相当人的程度上影响到你的解决方案。
CHECKLIST: Loops
ccc16核对表:循环
循环的选择和创建
口在合适的情况下用 while循环取代for循环了吗?
口循环是由内到外创建的吗?
进入循环
口是从循环头部进入的循环吗?
口初始化代码是直接位于循环前面吗?
口循环是无限循环或者事件循环吗?它的结构是否清晰?
口避免使用像fori=1to9999这样的代码吗?
口如果这是一个C++、C或Java中的for环,那么把循环头留给循环控制
代码了吗?
循环的内部
口循环是否用了“(}”或其等价物来括上循环体,以防止因修改不当而出错
吗?
口循环体内有内容吗?它是非空的吗?
口把内务处理集中地放在循环开始或者循环结束处了吗?
口循环像定义良好的子程序那样只执行了一件操作吗?
口循环短得足以一目了然吗?
口循环的嵌套层次不多于3层吗?
口把长循环的内容提取成单独的子程序吗?
口如果循环很长,那么它非常清晰吗?
代码大全(第2版)

<==========================425end ==============================>
<==========================426start==============================>

该书下载自书部落分享计算机经典巨著--ww. ! --www.shubule.com!仅供试看
要点
389
循环下标
口如果这是一个for循环,那么其中的代码有没有随意修改循环下标值?
口是否把重要的循环下标值保存在另外的变量里,而不是在循环体外使用该循
环下标?
口循环下标是序数类型(整数)或者枚举类型一而不是浮点类型吗?
口循环下标的名字有意义吗?
口循环避免了下标串话问题吗?
退出循环
口循环在所有可能的条件下都能终止吗?
口如果你建立了某种安全计数器标准,循环使用安全计数器了吗?
循环的退出条件清晰吗?
口如果使用了 break或者 continue那么它们用对了吗?
Key Points
要点
循环很复杂。保持循环简单将有助于别人阅读你的代码。
保持循环简单的技巧包括:避免使用怪异的循环、减少嵌套层次、让入口和
出口一目了然、把内务操作代码放在一处。
■循环下标很容易被滥用。因此命名要准确,并且要把它们各自仅用于一个用
途。
仔细地考虑循环,确认它在每一种情况下都运行正常,并且在所有可能的条
件下都能退出。
代丹大全(第2版)

<==========================426end ==============================>
<==========================427start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo..com!仅供试看^

<==========================427end ==============================>
<==========================428start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo. cor.com!仅供试看^
Unusual Control Structures
第17章
不常见的控制结构
cccom/177内容
17.1子程序中的多处返回:第391页
17.2递归:第393页
17.3goto:第398页
17.4针对不常见控制结构的观点:第408页
相关章节
一般控制问题:第19章
■直线型代码:第14章
条件代码:第15章
循环代码:第16章
异常处理:第8.4节
有些控制结构处在这样的尴尬境地中:有时被人当做最前沿的编程要素,有时
却又会被批判得声名狼藉这些情况甚至常常同时发生!这些结构不是所有语言
都有的,但如果在提供这些结构的语言中谨慎地使用它们,你将会获得很多帮助
Multiple Returns from a Routine
子程序中的多处返回
多数语言都提供了某种半途退出子程序的方法。程序可以通过return和exit
这类控制结构,在任何需要的时候退出子程序。它导致子程序按照正常的退出途
径终止,并把控制权转交给调用方子程序。在这里,我们用return这一词语泛指
C++和Java中的 return, Microsoft Visual Basic中的 Exit Sub和 Exit Function,以
及与之相似的其他结构。下面给出一些使用return语句的指导原则。
如果能增强可读性,那么就使用 return在某些子程序里,一旦知道了答案,
你会希望马上返回到调用方子程序。如果子程序被定义为检测出错误以后不再做
KEY POINT
任何更多的清理操作,那么不马上返回就意味着你还得写更多的代码。
代码大全(第2版)

<==========================428end ==============================>
<==========================429start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo ^.com!仅供试看^
392
第17章不常见的控制结构
下面就是一个好例子,它演示了一种需要从子程序里的多个位置返回的合理
情况:
C++示例:子程序中的多处返回好做法
该函数返回
HComparison Compare int valuel, int value2. )
Comparison枚举
if valuel value2 )
类型。
return Comparison_LessThan;
else if valuel value2 )
return Comparison _GreaterThan:
return Comparison_Equal;
另外一些例子就不够鲜明,下面将会提到一些。
用防卫子句(guard clause)(早返回或早退出来简化复杂的错误处理如果
代码中必须要在执行正常操作之前做大量的错误条件检测,就很可能导致代码的
缩进层次过深,并且遮蔽正常情况的执行路径,如下所示:
Visual Basic示例:遮盖了正常的执行路径
If file. validName ()Then
If file. Open() Then
If encrypt ionKey. valid() Then
这是处理正常情况
If file. Decrypt encryptionKey)hen
→ lots of code
的代码。
End If
End If
End If
从审美的角度来说,把子程序的主体缩在4条if语句里面很难看,尤其是当
最里层if语句的代码非常多的时候。在这种情况下,如果先检查错误情况,用这
些代码来为正常的执行路径清路,那么代码的布局有时可能变得更清楚。下面给
出一个这种方法的示例:
Visual Basic示例:用防卫子句澄清正常路径
set up, bailing out if errors are found
If Not file. validName() Then Exit Sub
If Not file.open() Then Exit Sub
f1
Not encryptionkey.vali() Then Exit Sub
If Not file. Decrypt( encryptionKey Then Exit Sub
t
lots of code
代码大全(第2版)

<==========================429end ==============================>
<==========================430start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
17.2递归
393
上述代码很简单,看来采用这种技术实现的解决方案很整洁。但是产品代码
通常要求在发现错误的时候做大量的内务或者清理操作。下面是一个更符合实际
的例子:
Visual Basic示例:更实际地利用防卫子句澄清正常路径的代码
set up, bailing out if errors are found
If Not file. validName()then
errorstatus FileError_InvalidFileName
Exit Sub
End If
If Not file. Open ()Then
errorStatus FileError_CantOpenFile
Exit Sub
End If
Tf Not encruntionKey valid Then
If Not encryptionKey. valid()Then
errorStatus FileError_InvalidEncryptionKey
Exit Sub
End If
t(e
nceryr
If Not file. Decryp encryptionKey ptFil
Then
errorStatus= FileErrorCantDecryptFile
Exit Sub
End If
这是处理正常→ lots of code
情况的代码。
对于产品规模代码,这种 Exit Sub方法将在处理正常情况之前加入相当数量的
代码。不过,这种 Exit Sub方法的确避免了第一个例子里的那种深层嵌套。如果把
第一个例子中的代码也扩展开来,展示其中对 errorStatus变量的赋值,那么相对
而言 Exit Sub在集中相关语句方面做得更好。最后, Exit Sub方法的可读性和可
维护性也会更好,而这是一片非常大的空白区域所做不到的。
减少每个子程序中 return的数量如果在读子程序的后部时,你没有意识到
它从前面某个地方返回的可能性,想理解这个子程序就很困难。由此可见,使用
return要十分审慎——只当它们能增强可读性的时候才去使用。
7.2
Recursion
递归
在递归( recursion)里面,一个子程序自己负责解决某个问题的一小部分,
它还把问题分解成很多的小块,然后调用自己来分别解决每一小块。当问题的小
KEY POINT
部分很容易解决,而问题的大部分也很容易分解成众多的小部分时,常常会用到
递归。
递归并不常用,但如果使用得谨慎,还是可以得到非常优雅的解。比如下例,
其中的排序算法就很好地使用了递归:
代码大全(第2版)

<==========================430end ==============================>
<==========================431start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
394
第17章不常见的控制结构
Java示例使用递归的排序算法
void Quicksort( int firstIndex, int lastIndex, String [ names
int midpoint =Partition( firstInde, last Index, names
这里用到了递归
QuickSort( first Index, midpoint--i, names)
QuickSort midPoint+1, lastIndex, names
调用。
在本例中,该排序算法把数组分成两部分,然后再调用自身来分别为数组的
每一部分排序。当它调用自身的时候所使用的数组太小而无须排序时比如
(last Index= firstIndex)就会停止对自身的调用。
对于某一小范围内的问题,使用递归会带来简单、优雅的解。在稍大一些范
围里,使用递归会带来简单、优雅但是难懂的解对于大多数问题,它所带来的
解将会是极其复杂的——在那些情况下,使用简单的迭代通常会比较容易理解。
因此要有选择地使用递归。
Example of Recursion
递归的例子
假设你有一个表示迷宫的数据类型。从本质上来说,迷宫就是一个网格,在
网格的每一个点,你都有可能向上下左右四个方向移动。你通常可以往不止一个
方向移动。
那么,你如何才能写出一个能够走出如图17-1所示的迷宫的程序呢?如果用
了递归,答案就会显而易见。你从入口处开始然后尝试所有可能的路径,直到
找到走出去的路来。当你第一次走到某一个点上的时候,你试着向左走。如果不
能向左走,那么就试着向上走或者向下走,如果这样还不行,那么就试着向右走。
你不用担心走迷了路,因为你经过某个点的时候,都会在那里留下一些面包屑,
所以同一个点是不会走两次的。
Up
Right
Go up because left
is unavailable
Left
Down
图17-1递归式是对付复杂事物的很有价值的工具在用于对付适当问题的时候
代码大全(第2版)

<==========================431end ==============================>
<==========================432start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. !--www.shubuld.com!仅供试看^
17.2递归
395
相应的递归代码如下:
C++示例:用递归穿越迷宫
bool FindPathThroughMaze( Maze maze, Point position)(
if the position has already been tried, don't try it again
if( AlreadyTried(maze, position))
return false;
.he exit, declare success
if( ThisIsTheExitmaze, position))
return true;
/ remember that this position has been tried
RememberPosition( maze, position )
/1 check the paths to the left, up, down, and to the right; if
/ any path is successfu
if MoveLeft( maze, position, Enewposition ))1
if( FindPathThroughMaze(maz, newPosition))(
return true;
if( MoveUp maze, position,&newposition))
if( FindPathThroughMazemaze, newPosition))
return true;
if( MoveDown maze, position, Gnewposition))
return true;
if( MoveRight(maze, position&newPosition))
if( FindPathThroughMaze(maze, newPosition))
return true;
n
return false;
第一行代码负责检查这个点有没有尝试过。编写递归子程序的关键目标之一
就是要防止产生无穷递归。在本例中,如果你不对某一点是否尝试过进行检查,
那么就可能无限地尝试下去。
第二条语句负责检查该点是不是迷宫的出口。如果 ThisisTheExit()返回
true,那么子程序本身就会返回true
代码大全(第2版)

<==========================432end ==============================>
<==========================433start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor ^.com!仅供试看
396
第17章不常见的控制结构
第三条语句记得这一点已经尝试过了。这将消除因为产生了回环路径而出现
无穷递归的可能。
子程序中其余的代码负责尝试向左、上、下、右方向移动,以找到一条路径。
一旦子程序返回了true即当子程序找到了一条走出迷宫路径的时候代码
就会终止递归的运行。
这个子程序的逻辑是简单易懂的。大多数人在刚开始使用递归的时候会感到
不适应,就是因为递归里的自我引用。不过,对于这个例子,使用其他的替换方
案会更加复杂,而递归却能工作得非常好。
Tips for Using Recursion
使用递归的技巧
在使用递归的时候,需要记住以下技巧:
确认递归能够停止检查子程序以确认其中含有一条非递归的路径。通常这
意味着该子程序中含有一项判断,无须进一步递归就能停下来。在那个迷宫的例
子里, AlreadyTried()和 ThisIsTheExit(两项判断保证递归能够停止。
使用安全计数器防止出现无穷递归如果你在一种不允许使用上述简单测试
的环境中使用递归,那么就用安全计数器来防止产生无穷递归。该安全计数器必
须是一个不随每次子程序调用而重新创建的变量。可以用一个类成员变量,或者
把该安全计数器作为参数加以传递。如下所示:
在递归函数中, Visual Basic示例:用安全计数器避免无穷递归
safetyCounter If safetyCounter >SAPETY LIMIT Then
值,因此在
End If
VisualBasicsafetyCounter safetyCounter 1
是一个 ByRef参f
数。
RecursiveProc( safetyCounter)
End Sub
在这个例子中,如果对子程序的调用次数超出了安全上限,递归就会停止。
如果你不希望把安全计数器作为明确的参数传递,那么你可以使用C++、Java
或者 Visual Basic中的成员变量,或者其他语言中的等价物。
把递归限制在一个子程序内循环递归(A调用B,B调用C,C调用A)非
常危险,因为它很难检查。依靠脑力来管理位于一个子程序内的递归已经够困难
了;理解跨越多个子程序的递归实在是勉为其难如果你有循环递归,那么通常
你可以重新设计这些子程序,以便把递归限制在一个单一的子程序内。如果你
代码大全(第2版)

<==========================433end ==============================>
<==========================434start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubulo.c.com!仅供试看^
17.2递归
397
做不到这一点,并且仍然认为原来的递归是最好的解决方案,那么作为一种保险
的递归策略,就请使用安全计数器吧。
留心栈空间用了递归以后,你将无法保证你的程序会使用多少栈空间,也
很难预测程序在运行期间会表现得怎样。不过你还是可以按照下述步骤来控制
程序在运行期间的表现。
首先,如果你使用了安全计数器,那么在给它设置上限时需要考虑的事项之
一就是,你愿意给该递归子程序分配多少(stck)空间。要把它的上限设置得
足够低,以防止栈溢出。
其次,应注意观察递归函数中局部变量的分配情况,特别要留意那些内存消
耗大的对象。换句话说,要用new在堆(heap)上创建对象,而不要让编译器在
栈上面自动创建对象。
不要用递归去计算阶乘或者斐波纳契数列在计算机科学教科书中存在着这
样的缺陷,那就是用愚蠢的例子来讲解递归。典型的例子就是计算阶乘或者斐波
纳契数列。递归是一种强有力的工具,但是把它用在这两者中的任何一种都是愚
蠢之极的。如果为我工作的程序员用递归去计算阶乘,那么我宁愿换人。下面是
用递归去计算阶乘的子程序:
ava示例:用递归计算阶乘,这种方案并不合适
int Factorial( int number )
if( number==1)
return 1:
CODING
ese number Factorial( number-1)
除了速度缓慢,并且无法预测运行期间的内存使用状况以外,用递归写出的
子程序要比用循环写出的子程序更难理解下面就是用循环写出的子程序:
Java示例:用循环去计算阶乘,这很合适
int Factorial( int number)
int intermediateResult
for int factor 2; factor < number; factor++){
intermediateResult intermediateResult* factor;
return intermediateResult;
代码大全(第2版)

<==========================434end ==============================>
<==========================435start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^.com!仅供试看
398
第17章不常见的控制结构
从这个例子中可以总结出三点经验。首先,计算机科学教程中给出的递归示
例没有给这个世界带来任何的好处。其次,也是更为重要的,递归是一种非常强
大的工具,其功能之强大要远远超出使用它们来稀里糊涂地计算阶乘或者斐波纳
契数列。再次,也是最重要的,在用递归之前你应该考虑它的替换方案。你用递
归能做到的,同样也可以用栈和循环来做到有时候用这种方法好;有时用另一
种方法好。在你定下来使用哪种方法之前,请把两者都考虑一下。
17.3
goto
goto
你可能认为关于goto的争论都已经销声匿迹了然而迅速地浏览遍现代的源
码库,比如说SourceForge.net,你就会发现goto仍然活得很不错,并且深深地扎根
于你公司的服务器上进一步说,goto争论的现代版本仍在以各种各样的形式出现,
如争论多处返回、多个循环出口、具名循环出口错误处理以及异常处理。
The Argument Against gotos
反对goto的论点
人们反对使用goto的普遍理由是:没有使用got的代码就是高质量的代码。
最初燃起战火的那篇著名的文章就是 Edsger Dijkstra发表于1968年3月号的
《 KCommunications of the ACM》杂志上的《 Go To Statement Considered Harmful
(《GoTo语句是有害的》)一文 Dijkstra认为,代码质量是与程序员所使用的goto
数量成反比的。在其后的著作里, Dijkstra论述说,没有使用goto的代码更容易
证明其正确性。
含有goto的代码很难安排好格式。缩进应该用来显示逻辑结构,而goto却影
响逻辑结构。用缩进来显示goto及其目标的逻辑结构非常难,甚至是不可能的。
使用goto也会破坏编译器的优化特性。有些优化要求程序的控制流程位于不
多的几个语句之间。而无条件的goto却使得流程变得很难分析,从而削弱了编译
器优化代码的能力。这样一来,即便使用gto提高了源代码语言一级的效率,整
体效率也可能因编译器优化功能受到限制而有所降低
goto的支持者们有时争辩说,goto会使得代码更小,运行更快。然而含有goto
的代码却极少是最快或者最小的。DonaldKnuth《Srucurd在其经典文章《Structured
Programming with go to Statements》(《带goto句的结构化编程》)中给出了多种应
用示例,在这些示例中,使用goto会使运行速度更慢,而且代码也更大( Knuth1974)
在实践中,使用goto会违背代码应该严格自上而下运行的原则。如果谨慎使
用,goto或许不会让人感到迷惑,然而一旦引入gto语句,它们就会遍布于代码
之间,就像房子里有了白蚁。一允许使用got,那么坏的goto就会与好的混在
一起,所以最好还是禁止使用它们。
代码大全(第2版)

<==========================435end ==============================>
<==========================436start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubuld.com!仅供试看
17.3 goto
399
整体而言,在 Dijkstra的文章发表后的20年里,经验表明使用了goto的代码
是笨拙且无益的。 Ben Shneiderman在一份调查中得出的结论也支持了 Dijkstra的
观点,即我们最好不要使用goto( Shneiderman980),而很多现代语言,包括Java,
甚至不支持goto
The Argument for gotos
支持goto的观点
goto的支持者们通常都会强调要在特定的场合下谨慎地使用goto,而不要不
分青红皂白地用。大部分论断都反对随意使用goo.对goto的拥护始于 Fortran
最为盛行的年代 Fortran没有提供什么像样的循环结构,在缺少关于如何使用goto
编写循环的好指导的前提下,程序员们编写了大量的“意大利面条”式的代码。
这些代码毫无疑问是与低质量程序的产生联系在一起的,但是它们却与小心谨慎使用
goto来弥补现代语言中的不足没什么关系
如果使用位置恰当,goto可以减少重复的代码。如果不能一致地修改,重复
的代码就会带来问题。重复代码还增加了源代码和可执行文件的体积。与代码重
复所带来的问题相比,goto所具有的一些负面影响在这种情况下就显得不那么重
要了。
交叉参考在本goto在分配资源、使用资源后再释放资源的子程序里非常有用。通过使用
节的“错误处理和goto,你可以在一段代码里执行清理操作。这将减少你在某个检测错误的位置发
goto中详细介绍
了如何在分配资现问题后忘记释放资源的可能。
源的代码中使用在某些情况下,使用goto会让代码的运行速度更快,体积更小 Knuth在1974
goto另外,关于
异常处理的讨论,年的那篇文章里也提到一些使用goto会带来实际好处的例子
见第8.4节“异
常”。
编程水平高并不等于不使用goto。在大多数情况下,有系统地分解、精化以
及适当选择控制结构都会自动地生成没有goto的程序。让代码不包含goto并不是
目的,而只是结果,把目标集中在消除goto上面是于事无益的
这些结论仅仅证
在对goto做了几十年的研究之后,人们还是无法证明它们是有害的。在一份
明采用杂乱不堪调查中,B.A. Sheil得出结论说,不合实际的测试条件、糟糕的数据分析以及不确
的控制结构会
响程序员的表现,定的结果都无法支持 Shneiderman和其他人的观点一代码中的bug数量是与goto
但并不能证明任数量成正比的(1981)。 Sheil也没能继续证明下去说goto是一种好的想法相
何特定改善控制
流结构的方法能反,他所说的那些实验性证据也不是结论性的。
带来多大实际的
好处。
最后,很多现代语言已经包含了goto,包括 Visual Basic、++和有史以来设
.a.Sheil计得最仔细的Ada语言Ada是在有关goto的争论出现了很久以后才设计出来的
在对争论双方的观点做了全面考虑之后,Ada的工程师们还是决定支持goto
代码大全(第2版)

<==========================436end ==============================>
<==========================437start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo...com!仅供试看^
400
第17章不常见的控制结构
The Phony goto Debate
关于goto的虚假辩论
大多数有关goto的争论的一项主要特征是:它们都是很肤浅地在面对问题。
认为“goto是罪过”的人会给出一小段使用了goto意义不大的代码,然后再显
示不用goto重写这段代码是多么地容易。其实,这么做主要证明的是,不用goto
写那种意义不大的( trivial)代码是很容易的。
认为“我离不开goto”的人会举出这样的例子来去掉一个goto就会多一次
比较或多一行重复代码。这个例子主要证明的是,用了goto就会少写个比较这
对于现在的计算机来说不是什么大不了的负担。
大多数的教科书也帮不上什么忙。它会举一些不用goto而重写一些代码的琐
碎例子,以为这样就能涵盖上面的主题。下面就假拟一个此类教科书中的小例子:
C++示例:看上去很容易就能重写为不使用goto的代码
do (
GetData inputFile,data)
if(eof( inputFile))(
goto LOOP_EXIT:
DoSomething(data)
while data !=-1
LOOP_EXIT:
书中很快就把它转换成为不用goto的代码,如下:
C++示例:去掉了goto的所谓等价代码
GetData inputFile,data)
while(leof inputFile&& data=-1)))
Dosomething data )iat
GetData( inputFile, data
这个所谓的“琐碎”例子里面包含了一个错误当data等于-1并且正在进
入该循环的时候,翻译之后的代码检测到这个1,然后就会退出该循环而不执行
DoSomething()而原来的代码会在检测到-1之前执行 DoSomething()那本书
试图演示不用goto编程是多么容易,结果却把自己给出的例子给转换错了。不过
书的作者也大可不必为此而烦恼,因为其他的书也会犯相似的错误。即使是支持
goto的人们也很难把使用了goto的代码翻译过来。
下面这段不用goto的代码转换得比较准确:
代码大全(第2版)

<==========================437end ==============================>
<==========================438start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo..com!仅供试看^
17.3 goto
401
C++示例:去掉了goto的真正等价代码
do
GetData( inputFile,data);
if Ieof( inputFile ))
DoSomething data )
while(( data=-1)&&(eof inputFile
即使这段代码翻译对了,这个例子还是不足以服人,因为它所显示的只是goto
的一种微不足道的应用。细心的程序员是不会因为这个小例子而选择goto作为他
们所青睐的控制形式的。
已经讨论了这么多,现在想再给goto的理论之争加上任何有价值的内容都已
经很困难了。然而,有一点常识被忽略了,在某些情况下,一个完全知道goto不
是好选择的程序员,也会为了增强可读性和可维护性而选用goto
下面举几个有经验的程序员赞成使用goto的例子。讨论时既会给出使用goto
的代码,也会给出不用goto而重写的代码,并且将评价这两个版本之间的利弊。
Error Processing and gotos
错误处理和goto
编写高度交互式的代码要求程序员十分关注错误处理,并在发生错误的时候
清理资源。下面例子中的代码会清除一组文件该子程序首先获得一个需要清除
的文件列表,然后查找其中的每一个文件,打开它,覆盖其内容,然后删掉它。
该子程序将在每一步骤中检查错误状态。
Visual Basic示例:处理错误以及释放资源的带goto的代码
This rout
Sub PurgeFiles( ByRef errorState As Error_code)
Dim fileIndex As Integer
Dim fileToPurge As Data_File
Dim numFilesToPurge As Integer
c1 lespurge
MakePurgeFileList( fileList, numFilesToPurge)
errorstate= Filestatus_Success
fileIndex
While fileIndex numPilesToPurge
fileIndex fileIndex 1
If Not FindPile fileList( fileIndex), fileToPurge))hen
这里出现了
errorstate = Filestatus_FileFindError
GoTo.
End END-_PROC
代码大全(第2版)

<==========================438end ==============================>
<==========================439start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^^.com!仅供试看^
402
第17章不常见的控制结构
If Not OpenFile fileToPurge)hen
errorState =FileStatus_PileopenError
这里也出现了
GoTo END_PROC
GoTO.
End If
If Not OverwriteFile( fileToPurge Then
errorstate Filestatus_FileoverwriteError
这里也出现了
GoTo END_PROC
GoTo.
End If
errorstate Filestatus_FileeraseError
这里也出现了
GoTo.
End If
End While
i是oto的nd_prOC:1
labelo
End suletepurge iletist filelist, nunilestoPurge
这是一个典型的有经验的程序员决定采用goto的应用场景。当子程序需要为
数据库连接、内存或者临时文件等资源执行分配和清理操作的时候,也会发生相
似的情景。在这些例子中,如果不用goto,通常就需要重复写出清理资源的代码。
这样一来,程序员就会比较使用goto的弊端和维护重复代码所带来的麻烦,最后
或许会决定还是用goto更好。
你可以用好几种方法来重写上述代码,以避免使用goto,每种方法都是有利
有弊的。可能的重写策略包括以下几种:
用嵌套的if语句重写为了用嵌套的if语句重写这段代码,你需要这样嵌套,
使得仅当一条if语句检测成功时才执行下一条f语句。这是标准的、教科书式的
消除goto的编程方法。下面就用这种标准方法来重写该子程序:
交叉参考该函 Visual Basic示例:利用嵌套的if语句消除goto的代码
数也可以用 break This routine purges group of files.
重写以消除 goto Sub PurgeFiles( ByRef errorstate As Error_code)
第16.2节中的“提Dim fileToPurge As Data_file
前退出循环”详细Dim fileList As Filelist
介绍了该方法。
Dim numFilesToPurge As Integer
M
MakePurgeFileList fileList numPilesToPurge
errorstate= Filestatus_Success
fileIndex =0
suce
在 While的判断条 While( fileIndex< numFilesToPur And errorstate FilestatusSuccess
件中已经添加了对
errorState的判断。
fileIndex fileIndex 1
代码大全(第2版)

<==========================439end ==============================>
<==========================440start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^ .com!仅供试看^
17.3 goto
403
If Findrile filelist( fileIndex), fileToPurge)Then
If OpenFile( fileToPurge)then
If OverwriteFile( fileToPurge )Then
If Not Erase( fileToPurge Then
errorState Filestatus_FileeraseError
End If
Else couldn't overwrite file
errorstateFilestatus Fileoverw
Elsend coulan't open file
errorstate= Filestatus_FileOpenError
End If
这里距设置该变量
Else couldn't find file
的if语句已经有13
errorstate Filestatus_Filerinderror
行代码之远了。
End If
End while
DeletePurgerileList( fileList, numFilesToPurge)
End Sub
对习惯于不用goto而编程的人来说,上面代码可能要比goto版本的代码好读
一些。如果你用了这种方法,可能就没脸去面对goto支持者的质询了
交叉参考在第31这种嵌套if方法的最大缺点在于,它的嵌套层次实在是太深了。为了理解这
章“布局与风格”段代码,你必须要把整个嵌套组装入脑海。而且,错误处理代码和引发错误代码
中有关于缩进和其
他代码排版问题的之间的距离实在是太远了:例如,把 errorState设置为
描述。在第19.4节
令 Filestatus_FileFindError的代码和引发它的if语句竟然相隔了13行。
面有行。同时,你也无须在同一时间把整个结构都放在脑中。你完全可以忽略掉前面
危险的深
嵌套”
嵌套层次的
在前面用的goto的版本里,没有任何一条语句与引发它的条件的间隔多于4
述。
已经成功的条件,只去关注于接下来的操作。在这种情况下,用goto的版本要比
嵌套if的版本更具有可读性,并更容易维护。
用一个状态变量重写代码为了用状态变量重写代码,你需要创建一个表明
该子程序是否处于出错状态的变量。在本例中,子程序已经使用了一个
errorState状态变量,直接用它就可以了。
Visual Basic示例:利用状态变量消除goto的代码
This routine purges a group of files.
Sub PurgeFiles( ByRef errorstate As Errorcode
Dim fileIndex As Integer
Dim fileToPurge As Data_File
Dim fileList As File List
Dim numFilesToPurge As Integer
MakePurgeFileList fileList, numFilesToPurge)
errorState= Filestatus_Success
fileIndex =0
代码大全(第2版)

<==========================440end ==============================>
<==========================441start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubu.com!仅供试看^
404
第17章不常见的控制结构
While判断增加
→ While( fileIndex numFilesToPu And errorstate FilestatusSuccess
了对 errorState
的判断。
fileIndex fileIndex +1
If Not FindFile( fileList( fileIndex), fileToPurge )Then
errorState= Filestatus_FileFinderror
这里判断了状态
End If
>If errorstate Filestatus_Success )Then
变量。
If Not OpenFile fileToPurge)hen
eerrorState Filestatus_Fileopenerror
End If
这里也判断了状
End If
if( errorstateri success Then
态变量。
If Not OverwriteFile fileToPurge)then
errorstate Filestatus
End If
这里也判断了状
End If
态变量。
If Not Srase( fileToPurge )Then
errorState FileStatus_FileEraseError
aEnd If
End If
End While
Encg DeletePurgeFileList fileList, numFilesToPurge
Sub
这种使用状态变量方法的优点在于,它没有像第一次重写那样使用深层的
if-then-else嵌套,所以读起来会比较容易。同时,与嵌套if方法相比, if-then--else
检测后面的操作与该检测之间的距离要更近,并且完全避免了使用else子句
想理解嵌套if的版本是需要一些智力训练的。状态变量版本则要更容易理解,
因为它更接近于人们考虑问题的方式。你先找到文件。如果一切正常,那么就打
开文件。如果仍然一切正常,就覆盖文件。如果还是一切正常的话
这种方法的缺点在于,使用状态变量的方法应用还不够普遍。应该对它们的
用法加以充分说明,否则有的程序员就会不懂你的意图。在这个例子里面,使用
命名良好的枚举类型就能起到很重要的辅助作用。
用try y-finally-重写有些语言,包括 Visual Basic和Java,提供了一套try- -finally
语句,可以用于在发生异常的情况下清理资源。
如果想用ty- -finally重写,就要把原本负责检测错误的代码括在try里面,然
后把清理代码括在 finally里。其中try代码块确定异常处理的作用域, finally代码
块负责执行所有的资源清理操作。不论有没有异常抛出,或者抛出的异常有没有
被 PurgeFiles()子程序捕捉到, finally代码块都会执行。
代码大全(第2版)

<==========================441end ==============================>
<==========================442start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubr.com!仅供试看^
17.3 goto
405
Visual Basic示例:利用try- -finally消除goto的代码
ions
'This routine purges a group of files. Exceptions arepassed to the caller.
Sub PurgeFiles
Dim fileIndex As Integer
Dim fileToPurge As Data_File
Dim filetist As File List
Dim numFiles ToPurge As Integer
MakePurgeFileList( fileList, numFilesToPurge)
Try
fileIndex =0
While fileIndex numilesToPurge
fileIndex =fileIndex
FindFile( fileList fileIndex), fileToPurge
OpenFile fileToPurge)
OverwriteFile( fileToPurge)
Erase( fileToPurge
End While
Finally
DeletePurgeFileList( filetist, numFilesToPurge)
End Try
End Sub
这种方法假定所有的函数调用在出错的时候都会抛出异常,而不是返回错误
代码。
这种ty- -finally方法的优点在于,它要比使用gto的方法简单,而且没有用
到goto,也没有使用深层的ifthen-else嵌套结构。
这种try- -finally方法的局限性在于,必须在所有代码中持续一致地使用这种方
法。如果早期代码既使用了错误码,又使用了异常,那么负责异常处理的代码就
要为每一种可能的错误设置一个错误码,而这样一来,产生的代码就会和各种采
用前面方法写出的代码一样复杂了。
Comparison of the Approaches
各方法之间的比较
交叉参考有多
种方法适用于类
这四种方法中的每一种都值得说一说。使用goto的方法避免了深层的嵌套和
似情况,这些方
不必要的检测,但是它确确实实地包含了goto。嵌套if的方法避免了使用goto,
法的详细列表请但它的嵌套层次太深了,并且增加了子程序的逻辑复杂度。使用状态变量的方法
阅度第194节
“对减少嵌套层避免了使用goto和深层次嵌套,但却引了额外的检测。使用try- y-finally没有
次的技术的总用到goto,也没有用到深层次嵌套,但却不是所有的语言都支持。
结”。
对于支持try y-finally-的语言和还没有选定某种方法作为标准的代码而言,
try -finally-方法是最简单的。如果try y-finally-方法不可用,那么使用状态变量要略
好于使用goto和嵌套if,因为它的可读性更好并且能够更好地反映问题的本质。
但这并不是说该方法在所有的情况下都是最好的。
如果能把上述任何一种技术持续地应用于个项目中的所有代码,那么都是
很不错的。请权衡利弊,然后再在项目范围内做出选择某种方法的决定。
代码大全(第2版)

<==========================442end ==============================>
<==========================443start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
406
第17章不常见的控制结构
gotos and Sharing Code in an else Clause
goto和在ese子句中的共享代码
有一种颇具挑战性的情况,这时一些程序员就会使用goto:程序有两个条件
检测语句和一个else子句,而你希望执行其中一个条件检测语句以及该else子句
中的代码。下面举一个会让某些人选择goto的例子:
C++示例:借助goto共享else子句中的一段代码
if statusok
if dataAvailable)(
CODING
goto MID_LOOP;
else
importantVariable= GetValue()
MID_LOOP:
/1 lots of code
这是个好例子,因为它的逻辑非常曲折—照这个样子,想读懂它是几乎不
可能的,想不用goto而正确地重写也非常难。如果你认为自己能轻松地不用goto
而重写它,那么请让别人检查看看!很多专家级的程序员都曾经重写错了。
你可以用好几种方法来重写它。你可以重复代码,把公用代码提取到一个子
程序里面,然后在两处调用它,或者重新检测该条件。在大多数语言里,重写以
后的代码都会比原来的略多一些,运行速度也会相对较慢,但是这种差异会非常
小。除非这段代码位于一个调用特别频繁的循环里,否则在重写的时候不用考虑
效率问题。
最佳的重写方法是,把// lots of code部分移到一个单独的子程序里面去。
然后你就可以在原goto语句出现或跳转到的地方调用该子程序,同时保留原有的
条件结构。代码如下:
C++示例:将公共代码放到子程序中,由此共享else子句中的代码
if statusok
if dataAvailable )
importantvariable xi
DoLotsOfCode importantVariable
else fortana
importantvariable =Getvalue()
DoLotsOfCode importantVariable
代码大全(第2版)

<==========================443end ==============================>
<==========================444start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看^
17.3 goto
407
通常,写一个新的子程序是最好的办法。但有时候把重复的代码提取成单独
的子程序是不现实的。在这种情况下,你可以通过重新组织条件判断语句的结构
来解决该问题,从而使代码都留在一个子程序里而不是产生另一个新的子程序。
C++示例:不使用goto,共享else子句中的代码
if(( statusok& dataAvailable) HIstatusok
if( statusok&& dataAvailable)
importantvariable =x;
else
11 lots of code
交叉参考解决该这种对goto版本代码的转换比较可靠,也很机械。它多检测了两次 statusOK,
问题的另一种方法多检测了一次 dataavailable,不过代码实现的功能是一样的。如果重复判断条
就是使用决策表,
这种方法在第18件让你觉得很烦,那么请注意,在第一个if检测中是不需要判断两次 statusOK
章“表驱动法”里值的。你还可以去掉第二个if检测中对 dataAvailable的检测
有详细讨论。
Summary of Guidelines for Using gotos
goto使用原则总结
用不用goto是一个信仰问题。我的信条是,在现代语言里,你可以很容易地把
九成的goto替换成与之等价的顺序结构。对于这些简单的情况,你应该把goto替换
掉并把这当成习惯。对于复杂的情况,你仍有九成不用goto的可能:你可以把代码
KEY POINT
拆分成小的子程序,使用try- -finally,使用嵌套if,检测并重新检测某个状态变量,或
者重新设置条件结构。对于这些情况,想消除goto相对来说比较难,但这是一种很
好的智力训练,本节所给出的一些技巧也能在这里派上用场。
对于剩下的那1%的情况,即当使用goto是解决问题的合理办法的时候,请
在使用的同时予以详细的说明。如果你穿着雨鞋,那么就没有必要绕开泥潭走路
了。不过也要虚心参考别的程序员提出的不用oto的方法。也许他们发现了一些
被你忽视的东西。
下面对使用goto的指导原则做一个总结。
在那些不直接支持结构化控制语句的语言里,用goto去模拟那些控制结构。
在做这些的时候,应该准确地模拟。不要滥用goto所带来的灵活性。
交叉参考第25如果语言内置了等价的控制结构,那么就不要用goto
章“代码调整策如果是为提高代码效率而使用goto,请衡量此举实际带来的性能提升。在大
略”以及第26章多数情况下,你都可以不用goto重新编写代码,这样既可以改善可读性,
“代码调整技术”
介绍了如何提高同时也不会损失效率。如果你的情况比较特殊,那么就对效率的提升做出说
代码效率。
明,这样,goto的反对者们在看见goto以后就不会删除它。
代码大全(第2版)

<==========================444end ==============================>
<==========================445start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com!仅供试看
408
第17章不常见的控制结构
除非你要模拟结构化语句,否则尽量在每个子程序内只使用一个goto标号
除非你要模拟结构化语句,否则尽量让goto向前跳转而不要向后跳转
。。
确认所有的goto标号都被用到了。没用到的goto标号表明缺少了代码,即
缺少了跳向该标号的代码。如果某些标号没有用,那么就删掉它们。
确认goto不会产生某些执行不到的代码。
如果你是一位经理,那么就应该持这样的观点:对某一个goto用法所展开
的争论并不是事关全局的。如果程序员知道存在替换方案,并且也愿意为使
用goto辩解,那么用goto也无妨。
17.4
Perspective on Unusual Control Structures
针对不常见控制结构的观点
曾几何时,有些人认为下面列出的每一种控制结构都是很不错的想法:
不加限制地使用goto
能动态计算出goto的跳转目标并且执行跳转
用goto从一个子程序的中部跳转到另一个子程序的中部的能力
■根据行数或者标号调用子程序,从而允许代码从子程序中间的某个位置开始
执行
具备让应用程序动态生成代码并且执行这些代码的能力
尽管现在看起来上述这些想法都是很离奇、过时或者危险的,但它们都曾经
被认为是可以接受的,甚至是人们所期望的。在很大程度上,软件开发这一领域
是在限制程序员对代码的使用中得到发展的。因此,我对非传统的控制结构持有
很强的怀疑态度。我猜想,本章所讲述的人部分控制结构最后都只能和计算得到
的goto标号(computed goto labels)、可变的子程序入口点(variable routine entry
points)、自修改代码(self- modifying code),以及其他与此类似的注重灵活方便而
忽视结构和复杂度管理能力的结构一起,存在于程序员的垃圾堆里。
Additional Resources
更多资源
cc2e.com/1792
下列资源也涉及到了不常见的控制结构。
Returns
返回
Fowler, Martin. (Refactoring: Improving the Design of Existing Code) Reading,
MA: Addison-Wesley-,1999.这本书在讲述名为“用防卫子句替换嵌套条件
(Replace Nested Conditional with Guard Clauses)”的重构技巧时, Fowler建议
使用多个 return语句来从同一个子程序中返回,从而减少一组if语句中的嵌套层
代码大全(第2版)

<==========================445end ==============================>
<==========================446start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
更多资源
409
次。Fowler认为多个 return是一种获得更好清晰度的手段,而让一个子程序具有
多个 return并不会带来危害
gotos
gotos
下面这些文章中包含了有关goto的全部辩论这一辩论还时不时地出现于大
多数工作场所、教科书以及杂志中,但是你不会听到任何超出20年之前就仔细探
究过的范围之外的内容。
cce.co99 cc2e.com/1799 dijkstra, edsger. "go to. Statement Considered Harmful"(Go To,edsger.gotoStatementConsideredHarmful(o语句是有
害的)《Communications of the ACM》11,o.3(March1968):147148,可以从
www.cs. www.cs. utexas. edu/users/ewd/.edu/users/Ew/获得。这就是那篇点燃了软件开发史上持续时
间最长的论战之一的文章。
wulf,w.a. Case Against the GOTO”(一个反对GOTO的例子),
《 Proceedings of the2 25th5 National ACM Conference》, August1972:791797这是
另一份反对不加选择地使用goto的论文。Wul认为,如果编程语言已经提供了足
够的控制结构,那么大多数情况下是不需要使用goto的。从1972年即写作这篇
文章的那一年开始,C+、Java、 Visual Basic等语言都证明了Wulf所说的是对的。
Knuth, Donald.“Structured Programming with go to Statements(带goto的结
构化编程)1974.发表于1974.dwardYourd《ClascswSgjwqreEngineeig主编的《Classcsisfwarengineen
(《软件工程的经典文献》), Englewood Cliffs NJ: Yourdon Press,1979这篇长
文并不是全部关于goto的,但是其中包括了很多消除goto能够提高效率的代码示
例,也包括了很多增加goto能够提高效率的代码示例。
Rubin, Frank. "'GOTO Considered Harmful' Considered Harmful"("GOTO
有害的”是有害的)《 Communications of the ACM》(《ACM通讯》)30,no.3(March
1987):195-196.在这篇草率地写给编辑的信中 Rubin断言说,不用goto编程已
经给商业带来了“上亿元的”损失。他随后给出了一小段使用了got的代码,并
且称这段代码要比不用goto的好。
Rubin的这封信所收到的反馈要比信本身还有意思。在5个月内
《 KCommunications of the ACM》(CACM)公开了大量的信件,这些信件就Rubi
原有的7行应用程序给出了不同的版本。从数量上看,这些信件平均来自goto的
支持者和反对者。读者提出的重写建议大约有17种之多,而这些重写的代码也充
分涵盖了避免使用goto的各种方法。CACM的编辑称,截止到当时,这封信所收
到的反馈数量要远远超出CACM上讨论过的任何一个主题。
要想阅读这些后续信件,请参见:
Communications of the ACM30,no.5(may1987):351-355.
Communications of the ACM 30, no.(June 1987): 475-478.
Communications of the ACM30,no.7july1987):632--634.
代码大全(第2版)

<==========================446end ==============================>
<==========================447start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo.com!^.com!仅供试看^
410
第17章不常见的控制结构
Communications of the ACM 30, no. (August 1987): 659 662.
■ Communications of the ACM30,no.12(December1987):997,1085
cc2e.com/1706 clark, r. lawrence, "a Linguistic Contribution of GOTO-less Programming"(-
个来自语言学的针对无GOTO的编程的观点), Datamation, December1973.这篇
经典的文章幽默地表示要用“come from(来自)”来代替“goto(转到)”。此文
再版于1974年4月期的《 Communications of the ACM》
CHECKLIST: Unusual Control Structures
cc71核对表:不常见的控制结构
return
口每一个子程序都仅在有必要的时候才使用 return吗?
口使用 return有助于增强可读性吗?
递归
口递归子程序中包含了停止递归的代码吗?
口子程序用安全计数器来确保该子程序能停下来吗?
口递归只位于一个子程序里面吗?
口子程序的递归深度处于程序栈容量可以满足的限度内吗?
口递归是实现子程序的最佳方法吗?它要好于简单的迭代吗?
goto
口是否只有在万不得已的时候才使用goto?如果用了goto,是否仅仅是出于
增强可读性和可维护性呢?
口如果是出于效率因素而使用的goto,那么对这种效率上的提升做出衡量并
且加以说明了吗?
口一个子程序里最多只用了一个goto标号吗?
口所有的goto都向前跳转,而不是向后跳转吗?
口所有的goto标号都用到了吗?
Key Points
要点
多个 return可以增强子程序的可读性和可维护性,同时可以避免产生很深的
嵌套逻辑。但是使用它的时候要多加小心。
递归能够很优雅地解决一小部分问题。对它的使用也要倍加小心。
在少数情况下,goto是编写可读性和可维护代码的最佳方法。但这种情况非
常罕见。除非万不得已,不要使用goto
代码大全(第2版)

<==========================447end ==============================>
<==========================448start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
Table-Driven Methods
第18章
表驱动法
cc2c/1865内容
18.1表驱动法使用总则:第411页
18.2直接访问表:第413页
18.3索引访问表:第425页
18.4阶梯访问表:第426页
18.5表查询的其他示例:第429页
相关章节
隐藏信息:“隐藏秘密(信息隐藏)”第5.3节
■类的设计:第6章
用决策表代替复杂的逻辑:第19.1节
用查询表替代复杂表达式:第26.1节
表驱动法是一种编程模式(scheme)——从表里面查找信息而不使用逻辑语
句(if和case)。事实上,凡是能通过逻辑语句来选择的事物,都可以通过查表来
选择。对简单的情况而言,使用逻辑语句更为容易和直白。但随着逻辑链的越来
越复杂,查表法也就愈发显得更具吸引力。
如果你已经熟悉了表驱动法,那么本章也许只是你的一个回顾。你可以参阅
第18.2节中的“例子:灵活的消息格式”,该示论述了面向对象设计并不仅仅
因为它是“面向对象”,就一定会好于其他的设计接下来你可以参阅第19章中
关于一般控制问题的讨论。
18.
General Considerations in Using Table-Driven Methods
表驱动法使用总则
在适当的环境下,采用表驱动法,所生成的代码会比复杂的逻辑代码更简单、
更容易修改,而且效率更高。假设你希望把字符划分成字母、标点符号和数字三
KEY POINT类,那么你也许会用到下面这种复杂的逻辑链:
代码大全(第2版)

<==========================448end ==============================>
<==========================449start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
412
第18章表驱动法
Java示例:使用复杂的逻辑对字符分类
if (( 'a' < inputchar & inputChar < 'z') )II
(('A'<= inputChar & inputChar <='Z')) )
charType CharacterType. Letteri )II
else if(( inputchar inputchar
(inputChar= input Char == inputChar ==
( inputChar=))( inputChar=)( inputChar=)
( inputChar==)l( inputChar=))(
charType =CharacterType. Punctuation;
else if(0'= inputchar)&&inputChar=9))(
charType CharacterType. Digit;
另一方面,如果用一个查询表(lookup table,就可以把每一个字符的类型保
存在一个用字符编码访问的数组里。那么上述的复杂代码片段就可以替换为:
ava示例:使用查询表对字符分类
charType= charTypeTable[ inputChar
这段代码假设 charTypeTable数组已经提前创建好了。这时你把程序中的信
息存放在数据里而不是逻辑里也就是说,放在表中而不是检测中
Two Issues in Using Table-Driven Methods
使用表驱动法的两个问题
在使用表驱动法的时候,必须要解决两个问题。首先,你必须要回答怎样从
表中查询条目的问题。你可以用一些数据来直接访问表。比如说,如果你希望把
KEY POINT
数据按月进行分类,那么创建一个月份表是非常直截了当的。你可以用一个下标
从1到12的数组实现它。
另一些数据可能很难直接用于查表。例如,假设你希望按照社会安全号码做
数据分类,那么除非你可以承受在表里面存放99999条记录,否则就不能用
社会安全号码直接查表。你会被迫采用一种更为复杂的方法。下面是从表里面查
询记录的方法列表
直接访问(Direct access)
索引访问(Indexed access)
阶梯访问(Stair-step- access
本章后面部分将就这其中的每一种访问方法展开详细讨论。
代码大全(第2版)

<==========================449end ==============================>
<==========================450start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
18.2直接访问表
413
在使用表驱动法的时候,需要解决的第二个问题是,你应该在表里面存些什么。
有的时候,表查询出来的结果是数据。如果你遇到的是这种情况,那么就可以把这
KEY POINT些数据保存到表里面。在另外一些情况下,表查询出来的结果是动作action)在
这种情况下,你可以保存一个描述该动作的代码或者,在有些语言里,你可以保
存对实现该动作的子程序的引用。无论是哪一种情况,表都会变得更为复杂。
18.2
Direct Access Tables
直接访问表
和所有的查询表一样,直接访问表代替了更为复杂的逻辑控制结构。之所以
说它们是“直接访问”的,是因为你无须绕很多复杂的圈子就能够在表里面找到
你想要的信息。如图18-1所示,就可以直接找出你想要的条目来。
(age, year)
查询表
图18-1如图名所示,直接访问表允许你访问感兴趣的表元素
Days-in-Month Example
示例:一个月中的天数
假设你需要计算每个月中的天数(为了说明起见,此处不考虑闰年)笨做法
就是写一个大的if语句:
Visual Basic示例:确定各月天数的笨拙做法
If month 1 Then
days 31
ElseIf month 2 )Then
days=28
ElseIf( month=3)then
days 31
ElseIf month =4 )Then
days 30
ElseIf month =5 )Then
days 31
ElseIf month =6 )Then
days=30
ElseIf month =7 )Then
days 31
译注:例如函数指针。
代码大全(第2版)

<==========================450end ==============================>
<==========================451start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo. com!^.com!仅供试看^
414
第18章表驱动法
ElseIf month 8 Then
days =3
ElseIf month =9 )Then
days =30
ElseIf month 10 )Then
days 31
ElseIf month 11 )Then
days =30
ElseIf month 12 Then
days =31
End If
实现同样功能的一种更简单、更容易修改的方法是把这些数据存到一张表里
面。在Microsoft Visual Basic里面,你需要首先创建出这张表:
Visual Basic示例:确定各月天数的优雅做法
Initialize Table of "Days Per Month"Data
Dim days PerMonth() As Integer
31,28,31,30,31,30,31,31,303130,31
现在,你无须再写那条长的if语句,只需要一条简单的数组访问语句就可以
得出每个月中的天数了:
Visual Basic示例:确定各月天数的优雅做法(续)
days =daysPerMonth( month-1
如果你想在查表的版本中把闰年考虑进去那么代码仍然会很简单,假设
LeapYearIndex()的取值要么为0,要么为1:
Visual Basic示例:确定各月天数的优雅做法(续)
days= daysPerMonth( month--1, LeapYearIndex())
如果把闰年也考虑进来,那么那条长长的if语句将会变得更为复杂了
计算每月的天数是一个很适合用直接访问表描述的例子,因为你可以用
month变量去表里面查询记录。一般来说,你可以用原本控制着很多if语句的数
据去直接访问表。
代码大全(第2版)

<==========================451end ==============================>
<==========================452start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看^
18.2直接访问表
415
Insurance Rates Example
示例:保险费率
假设你在写一个计算医疗保险费率的程序,这些费率是随着年龄、性别、婚
姻状况以及吸烟与否的不同情况而变化的如果你不得不用逻辑控制结构来表示
不同费率的话,那么可能会写出下面的代码:
java示例:确定保险费率的笨拙做法
if( gender= Gender. Female)
if maritalstatus = Maritalstatus. Single (
if s
= SmokingStatus.
CODING
HORROR
if age<18)
rate=200.00;
else if(age==18)
rate=250.00
else if age = 19
rate=300.00
else if 65< age
rate=450.00;
else
if age 18
rate=250.00;
a(age=18)(
ate=300.00;
。;
else if age =19)
rate=350.00;
else if 65 age
rate=575.00;
else if( maritalstatus= Maritalstatus Married)
这是简化的逻辑结构,它应该已经能让你对事情的复杂度有足够的了解了。
它还没有显示已婚的女士、所有的男士或者1至65岁之间的人士。你可以想象:
如果要把整个费率表编写出来该有多复杂。
你也许会说,“是的,可为什么你要为每一个年龄都做一次判断呢?为什么不
把这些费率放进用年龄作下标的数组里?”好问题,而一种显而易见的改进就是
把在每一年龄的费率存在一个独立数组里。
代码大全(第2版)

<==========================452end ==============================>
<==========================453start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubule.com!仅供试看
416
第18章表驱动法
然而,更好的做法是把这些费率存入所有因素索引的数组里,而不仅仅是按
年龄索引。你可以在 Visual Basic中这样声明数组:
Visual Basic示例:声明数据,用于建立保险费率表
Public Enum SmokingStatus
SmokingStatus_First =0
Smokingstatus_Smoking=
SmokingStatus_NonSmoking 1
Smokingstatus_Last 1
End Enum
Public Enum Gender
Gender_First
Gender_Male =0
Gender_ Female 1
Gender_Last =1
End Enum
Public Enum Maritalstatus
Maritalstatus_First =0
Maritalstatus_single =0
Maritalstatus_Married 1
Maritalstatus_ Last =1
End Enum
Const MAX_AGE As Integer =125
交叉参考表驱a
动法的优势之一Dimraterable(DaLeTab1eSmokingScausLast《GenderastMarita1StatusZLas_last,
就是你可以把表
MAX_AGE As Double
里面的数据存放
在声明了这个数组以后,你还需要找一种把数据存进去的方法。你可以使用
序运行时再读取赋值语句、从磁盘文件中读入数据计算出这些数据、或者执行任何合适的操作。
这些数据。这样一旦备好了这些数据,在需要计算费率时,你就可以直接获取结果了。前面那段
一来,就可以在
不改动程序本身复杂的逻辑就可以用类似于下面这样简单的语句取而代之:
的情况下调整保 Visual Basic示例:确定保险费率的优雅做法
险费率等参数。 rate rateTable( smokingstatus, gender, maritalstatus,age)
第10.6节“绑定
时间”有这方面这种方法具有用查表取代复杂逻辑的一般优点。这种查表操作的可读性更好,
的介绍。
也更容易修改。
Flexible-Message-Format Example
例子:灵活的消息格式
你可以用表来描述那种有太多变化,多得无法用代码表示的逻辑。了解了字
符分类、月中的天数和保险费这三个例子以后,你至少知道了如果需要,可以写
代码大全(第2版)

<==========================453end ==============================>
<==========================454start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo. com! ^.com!仅供试看^
18.2直接访问表
417
一个很长的if语句。但是,在某些情况下,数据会复杂得根本无法用硬编码的
if语句来描述
如果你认为自己已经掌握了直接访问表的要领那么你可能想跳过下面的例
子。不过,它要比前面的例子稍微复杂些,而且进一步展示了表驱动法的威力。
假设你编写一个子程序,打印存储在一份文件中的消息。通常该文件中会存
储大约500条消息,而每份文件中会存有大约20种不同的消息。这些消息源自于
一些浮标(Buoy),提供有关水温、浮标位置等信息
每一条消息都有若干字段,并且每条消息都有一个消息头,其中有一个
告诉你该消息属于这20多种消息中的哪一种。图18-2显示了这些消息是如何存
储的。
浮标D
湿度消息
消息内容
buovenperature
Temperature
BuoyHistory
浮标D
BuoySign
ovl oca
漂移消息
BuoyLocation
BuoyTemperature
Buoy Temperature
消息内容
ture
Buoy Temperat
ncation
Buoy Locan
it Check
Circuiton
ift
ture
Buoy Dr perana
wTempe
oyTemperature
浮标D
uoy
buoneor
位置消息
消息内容
图18-2信息并不是按照特定顺序存储的,每条消息用D标识
这些消息的格式并不是固定不变的,它们由你的客户来确定,而你也无法要
求你的客户去把格式稳定住。图18-3显示了其中一些消息的格式细节
代码大全(第2版)

<==========================454end ==============================>
<==========================455start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo. con.com!仅供试看
418
第18章表驱动法
浮标D
浮标
浮标D
温度消息
漂移消息
位置消息
平均温度
纬度改变
纬度
浮点数
浮点数
浮点数
温度范围
经度改变
经度
浮点数
浮点数
浮点数
采样点数
测量时间
深度
整数
时间
整数
位置
测量时间
字符串
时间
测量时间
时间
图18-3除了消息D之外,每种消息有其自己的格式
Logic-Based Approach
基于逻辑的方法
如果你采用基于逻辑的方法,那么你可能会读取每一条消息,检查其I,然
后调用一个用来阅读、解释以及打印一种消息的子程序。如果你有20种消息,那
么就要有20个子程序。你还要写出不知道多少底层子程序去支持它们例如,
你可能需要一个 Print Buoy TemperatureMessage()子程序来打印浮标温度消息。
用面向对象的方法也好不到哪里去:你通常会用一种抽象的消息对象,并为每种
消息类别派生出一个子类。
每次有任何一种消息的格式变了,你就不得不修改负责处理该消息的子程序或
者类的逻辑。在前面给出的消息细节中,如果把平均温度字段从浮点类型改成了其
他类型,你就要修改 Print Buoy TemperatureMessage()的逻辑(如果浮标自身也
从一个“飘浮的点”变成了其他物体,那么你将不得不再做出一种新的浮标来!)。
在基于逻辑的方法中,其消息阅读子程序包含一个循环,用来读入消息、解
释其ID,以及根据该ID调用20个子程序中的某一个。下面就是基于逻辑方法所
用的伪代码:
交叉参考这些 While more messages to read
低级伪代码的作 Read message header
用不同于代码设 ecode the message ID from the message header
计阶段所用到的 If the message header is type1then
Print a type 1 message
伪代码。第9章 Else if the message header is type2then
“伪代码编程过
Print a type 2 message
程”有关于后者的
详细介绍。
Else if the message header is type 19 then
erint a type 19 message ;
Else if the message header is type 20 then
Print a type 20 message
代码大全(第2版)

<==========================455end ==============================>
<==========================456start==============================>

该书下载自书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
18.2直接访问表
419
这段伪代码已经经过简化了,因为你无须看完所有的20种情况就能知道其中
的路数了。
Object-Oriented Approach
面向对象的方法
如果你采用某种面向对象的方法,那么问题的逻辑将被隐藏在对象继承结构
里,但是基本结构还是同样复杂:
While more messages to read
Read a message header
Decode the message ID from the message header
If the message header is type 1 then
Instantlate a type message object
Else if the message header is type 2 then
Instantiate a type 2 message object
Else if the message header is type 19 ther
Instantiate a type 19 message object
Else if the message header is type 20 then
Instantiate a type 20 message object
End while
无论是直接写逻辑,还是把它包含在特定的类里面,这20种消息中的每一种
都要有自己的消息打印子程序。子程序也可以用伪代码表示,下面就是读取和打
印浮标温度消息子程序的伪代码:
Print "Buoy Temperature Message
f
Read a floating-point value
Print "Average Temperature"
Print the floating-point value
alue
Read a floating-point value
Print "Temperature Range"
Print the floating-point value
Read an integer value es
Print "Number
Samples"
Print the integer value
Read a character string
Print "Location"
Print the character string
Bead a time of day
int theme of Measurement"
Print Tim
Print the time of day
这只是针对一种消息的代码。其他的19种消息也都需要有相似的代码。而且
如果增加了第21种消息,那要么增加第21个子程序,要么增加第21个类无
论如何,新增一种消息类型都要求修改代码。
大(第2版)

<==========================456end ==============================>
<==========================457start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看
420
第18章表驱动法
Table-Driven Approach
表驱动法
表驱动法要比前几种方法都经济。其中的消息阅读子程序由一个循环组成,
该循环负责读入每一个消息头,对其ID解码,在 Message数组中查询其消息描述,
然后每次都调用同一个子程序来解释该消息。用了表驱动法之后,你可以用一张
表来描述每种消息的格式,而不用再把它们硬编码进程序逻辑里。这样会降低初
期编码的难度,生成更少的代码,并且无须修改代码就可以很轻松地进行维护
为了使用该方法,你需要先列出消息种类和字段类型。在C++中,你可以按
照下面的方法来定义所有可能的字段类型:
C++示例:定义消息数据类型
enum FielaType
FieldType_Floating Point,
FieldType_Integer,
FieldType_string,
FieldType_TimeofDay,
FielaType_Boolean,
FielaType BitField.
FieldType_last= FieldType_ BitField
不用再为20种消息中的每一种硬编码打印子程序,你可以只创建少数几个子
程序,分别负责打印每一种基本数据类型浮点、整型、字符串等。你可以把
每种消息的内容描述放在一张表里(包含每个字段的名称),然后再根据该表中的
描述来分别解释每一消息。下面是用于描述一种消息的表记录的示例:
示例:定义消息表中的一项
NumFields 5
MessageName "Buoy Temperature Message"
Field 1, FloatingPoint, "Average Temperature"
Field 2, FloatingPoint, "Temperature Range"
eld 3. Integer, "Number of Samples"
Field 4, string, "Location"
Field 5, Timeofpay, "Time of Measurement"
Message End
这张表既可以硬编码在程序里(在这种情况下,所示的每个元素都将被赋给
一个变量),也可以在程序启动时或者随后从文件中读出。
一旦把消息定义读入程序,那么你就能把所有的信息嵌入在数据里面,而不
必嵌入在程序的逻辑里面了。数据要比逻辑更为灵活。当消息格式改变的时候,
代码大全(第2版)

<==========================457end ==============================>
<==========================458start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
18.2直接访问表
421
修改数据是很容易的。如果必须要新增一种消息类型,那么只须往数据表里再增
加一项元素即可。
下面就是表驱动法中最上层循环的伪代码:
While more messages t. read
前三行同基于 Read message header
逻辑方法的伪
代码一样。
Decode the message ID from the message header
the messgs description in the message-descri table.
Look up the messag
Read the message fields and print them based on the message description
End While
与基于逻辑方法的伪代码不同,这里的伪代码并没有做任何简化,因为它的
逻辑实在是太简单了。在这一层下面的逻辑里面,你会发现一个子程序就可以解
释消息描述表里面的消息描述、读入消息数据并且打印消息。这个子程序比任何
一个基于逻辑的消息打印子程序都要通用,它不算太复杂,而且它只是1个子程
序,而不是20个:
While more fields to print
Get the field type from the message description
case field type
of
tread atingatintoi
read afloating-point value
print the field label
print the floating-point value
of integer
read an integer value
print the integer value
of character string
read a character string
print the field label
print the character string
of time of day
read a time of day
print the field label
print the time of day
of boolean
read a single flag
print the field label
print the single flag
of bit field
read a bit field
print the field label
print the bit field
nd case
End while
代丹大全(第2版)

<==========================458end ==============================>
<==========================459start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
422
第18章表驱动法
诚然,这个有着6种情况的子程序要比只负责打印浮点温度消息的子程序长
一些。但它是你要使用的唯一的打印子程序。你不必为了其他那19种消息再写
19个子程序。这个子程序可以处理6种字段类型,负责处理所有的消息类型。
这个子程序也显示出了实现这类表查询操作的最复杂的一种方法,因为它用
到了一个case语句。另外一种方法是创建一个抽象的 AbstractField类,然后
为每一种字段类型派生一个子类。这样你就无须使用case语句,只须调用适当类
型对象的成员函数即可。
你可以按照如下方式用C++来创建这些对象类型:
+例:建立对象类型
class AbstractPield
public:
virtual void ReadAndPrint string, Filestatus )=0;
class FloatingPointField public AbstractField
public: voi
virtu
id Readane
ndprint strina ilestat
};
class IntegerField ..
class StringField .
这段代码片段为每个类声明了一个成员函数,它具有一个字符串参数和一个
Filestatus参数。
下一步是声明一个数组以存放这一组对象。该数组就是查询表,如下所示:
C++示例:创建一个用于持有各类型的对象的表
AbstractField* field[ Field_Last
建立对象表的最后一步是把具体对象的名称赋给这个 Field数组:
C++示例:建立对象清单
field Field_ FloatingPoint= new FloatingPointField()
field Field Integernew IntegerField()
fielaI Field string = new stringField()
fiela Field_Boolean ]=new BooleanField(\
field[ Field_rimeofDay =new TimeofDayField(
field Field_ BitField= new BitFieldField)
代码大全(第2版)

<==========================459end ==============================>
<==========================460start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
18.2直接访问表
423
这段代码片段假定,位于赋值语句右边的 Floating等标识符是
类型为 AbstractField的对象的名称。把这些对象赋给数组中的数组元素意味
着,为了调用正确的ReadAndPrint()子程序你只需要引用一个数组元素而不
用直接使用某个具体类型的对象。
一旦建立了这个子程序表,要处理消息里的一个字段,你只需要访问对象表
并且调用表中的一个成员函数就可以了。代码如下:
这些是针对消息C++示例:在表中查询对象及其成员函数
中每个字段的维 fielardx=1
护代码。
while(( fieldidx= numFields InMessage)&&( filestatus=ok))
fielaType fieldDescription[ field
ielaTax.:
fieldName fieldDescription fieldrdr .FieldNamea
这就是表查找,它 field[ fieldType. ReadAndPrint( fieldName, filestatus)
通过查找对象表
调用一个由字段
类型所决定的函
还记得那34行含有case语句的表查询伪代码吗?如果你把case语句替换
数。
成一个对象表,那么这就是提供相同功能所需的全部代码了。难以置信的是,这
也是代替基于逻辑方法中的那20个单独的子程序的全部代码。进一步说,如果消
息描述信息是从文件中读入的,那么除非新增加了字段类型,否则根本无须为了
新增加消息类型而修改代码。
你可以在任何一种面向对象语言中使用这种方法。与写长篇的if语句、case
语句或者大量的子类相比,这种方法更不容易出错、更容易维护并且效率更高。
使用继承和多态的设计并不一定就是好的设计。在前面“面向对象的方法”
一节里用的那种生搬硬套的面向对象设计,所需的代码量和一个生硬的功能设计
一样多甚至会更多。那种方法使解决方案变得更复杂,而不是变得更简单
在这个例子里面,核心的设计理念既不是面向对象也不是面向功能而是使用
一个经过深思熟虑的查询表。
Fudging Lookup Keys
构造查询键值
在上述三个示例中,你可以将数据作为键值直接访问表。也就是说,你可以
直接把 messageID用作键值而无须修改,就像你在月中的天数示例中使用 month,
以及在保险费率示例中使用 gender、 marialstatus和 smokingstatus-一样
你当然希望总是能直接得到访问表的键值,因为这样既简单又快速。不过,
有时候数据不是那么合作。在保险费率一例中,age(年龄)的表现就有些异常
原本的逻辑中为不满18岁者设置了一个费率,为18至65岁之间的人士设置了不
代码大全(第2版)

<==========================460end ==============================>
<==========================461start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看
424
第18章表驱动法
同的费率,为超过65岁者设置了一个费率。这就意味着,对于17岁以下或者66
岁以上的人,你不能直接把年龄用做表的键值,这张表只为一些年龄保存了一组
费率。
从这就引出了构造查询表键值的问题。你可以用几种不同的方法来构造这些
键值。
复制信息从而能够直接使用键值使age能像键值一样用于费率表的一种简
便方法是,为0至17岁之间的每个年龄都复制一份18岁以下的费率,然后自接
用该age键值来访问表。你也可以用同样的方法来处理超过66岁的情况。这种方
法的优点在于表自身的结构非常简单,访问表的操作也很简单。如果你需要为17
岁以及17岁以下的年龄段增加些年龄相关的费率,那么只需要修改这个表就可
以了。这样做的缺点在于,复制生成的几余信息会浪费空间,并且表中存在错误
的可能性也增加了真希望缺点仅仅是表中的冗余信息占用了空间。
转换键值以使其能够直接使用让age能像一个键值那样直接使用的第二种
方法是用一个函数将age转换为另一个数值从而使其能像键值那样使用。在这
个例子里,该函数必须把所有介于0至17岁之间的年龄转换成一个键值,比如说
17,同时把所有超过66的年龄都转换成另一个键值,比如说66这个特殊的区
间很容易处理,你可以用min()和max()函数来做这一转换。例如,你可以用下
述表达式:
来生成一个位于17到66之间的表键值。
创建这样的转换函数,要求你能够从打算用作为键值的数据中识别出某种模
式来,而这不一定总是像使用min()和max(子程序一样简单。假设在另一个例
子里面,保险费率是以5年为一个区段,而不是1年一个区段,那么除非你想把
所有的数据都复制5次,否则你就要另写一个函数,把age正确地除以5,然后
再使用min()和max(子程序。
把键值转换提取成独立的子程序如果你必须要构造一些数据来让它们像表
键值一样使用,那么就把数据到键值的转换操作提取成独立的子程序。这样做可
以避免在不同位置执行了不同的转换,也使得转换操作修改起来更加容易。给子
程序起一个好的名称,比如说 Key FromAge(),同样也会明确该数学运算的用意。
如果你的开发环境中已经提供了现成可用的键值转换功能,那么就用它。例
如,Java中提供的关联型容器 HashMap,可以用作根据键值(key)查出实值( value)
代码大全(第2版)

<==========================461end ==============================>
<==========================462start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
18.3索引访问表
425
18.3
Indexed Access Tables
索引访问表
有的时候,只用一个简单的数学运算还无法把age这样的数据转换成为表键
值。这类情况中的一部分可以通过使用索引访问的方法加以解决。
当你使用索引的时候,先用一个基本类型的数据从一张索引表中查出一个键
值,然后再用这一键值查出你感兴趣的主数据。
假设你经营着一家商店,有大约100种商品。再假设每种商品都有一个4位
数字的物品编号,其范围是0000到999在这种情况下,如果你想用这个编号
作为键值直接查询一张描述商品信息的表,那么就要生成一个具有10000条记录
的索引数组(从0到9999)。该数组中除了与你商店中的货物的标志相对应的100
条记录以外,其余记录都是空的。如图1-4所示,这些记录指向了一个物品描述
表,而该表所含的记录数量要远远小于10000
查询表的索引
数组(基本为空)
查询表本身
(基本为满)
图18-4索引表不是直接访问,而是经过居间的索引去访问
索引访问技术有两个主要优点:首先,如果主查询表中的每一条记录都很大,
那么创建一个浪费了很多空间的索引数组所用的空间,就要比创建一个浪费了很
多空间的主查询表所用的空间小得多。举例来说,如果主表中的每条记录需要占
用100字节,而索引表中的每条记录需要占用2字节。假设主表中有100条记录,
代码大全(第2版)

<==========================462end ==============================>
<==========================463start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo.c.com!仅供试看^
426
第18章表驱动法
而用来访问它的数据有10000种可能取值。这样一来,你面临的就是在10000条
索引记录和10000条主数据成员记录之间做出选择。如果你用的是一套索引,那
么用掉的总内存量是30000字节。如果你放弃了索引结构,而把空间耗费在主表
里面,那么用掉的总内存量就会是100000字节。
第二项优点是,即使你用了索引以后没有节省内存空间,操作位于索引中的记录
有时也要比操作位于主表中的记录更方便更廉价比如说,如果有一张含有员工姓名、
雇用日期和薪水的表,你可以生成一个索引来按照员工姓名访问该表,生成另一个索
引表按照雇用时间来访问该表,以及生成第三个索引按照薪水来访问该表。
索引访问技术的最后一个优点就是表查询技术在可维护性上所具有的普遍优
点。编写到表里面的数据比嵌入代码中的数据更容易维护。为了使这种灵活性最
大化,可以把借助索引访问数据的代码提取成单独的子程序,然后在希望通过物
品编号获得表键值的时候调用该子程序。当需要修改表的时候,你可以考虑更换
这种索引访问技术,或者换用另一种表查询的技术。如果你不把索引访问代码随
便写到应用程序中各个地方,那么这种访问技术更改起来是非常容易的。
18.4
Stair-Step Access Tables
阶梯访问表
还有另外一种访问表的方法,那就是阶梯访问。这种访问方法不像索引结构
那样直接,但是它要比索引访问方法节省空间。
如图18-5所示,阶梯结构的基本想法是,表中的记录对于不同的数据范围有
效,而不是对不同的数据点有效。
图18-5阶梯方法通过确定每项命中的阶梯层次确定其归类,它命中的“台阶”确定
其类属
举例来说,如果你正在开发一个等级评定的应用程序,其中“B”记录所对应
的范围是75%到90%。下面是你某一天可能会编写到的等级区间:
≥90.0%
<90.0%
<75.0%
<65.0%
ABCDF
<50.0%1
代码大全(第2版)

<==========================463end ==============================>
<==========================464start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shubulo..com!仅供试看^
18.4阶梯访问表
427
这种划分范围用在表查询中是很糟糕的,因为你不能用简单的数据转换函数
来把表键值转换为A至F字母所代表的等级用索引也不合适,因为这里用的是
浮点数。你可能想到把浮点数转换成整数,从而使应用索引技术变成可能。但是
为了演示起见,这个例子还会继续使用浮点数。
为了使用阶梯方法,你要把每一区间的上限写入一张表里,然后写一个循环,
按照各区间的上限来检查分数。当分数第一次超过某个区间的上限时,你就知道
相应的等级了。在使用阶梯方法的时候,你必须要谨慎地处理范围的端点。下面
就是根据这个例子写的、用 Visual Basic来一组学生成绩评判等级的代码:
Visual Basic示例:阶梯表查询
set up data for grading table
Dim rangeLimit) As Double(50.0,65.0,75.0,90.0,100.0
Dim grade() As String="f","d","c","Bn,"a"
maxGradeLevel grade. Length -1
onrad
studon
assign a grade to student based on the student's score
gradetevel=
studentGrade ="A"
While(( studentGrade="a")and( gradeLevel maxGradeLevel))
if( studentScore rangeLimit( gradeLevel))Then
studentGrade grade( gradeLevel)
End
gradetevel gradeLevel +1
Wend
尽管这个例子很简单,但却可以很容易把它推广到处理多个学生、多种等级
(例如,不同的任务对应的绩点(point level)不同,其等级也会不同),以及等
级发生变化的情况。
与其他表驱动法相比,这种方法的优点在于它很适合处理那些无规则的数据。
等级评定的例子很简单,因为尽管等级的划分区间是无规则的,但用的数字却都
是“四舍五入过的(round)”,即都是以5或者0结束的阶梯方法处理起未经舍
入的数据也同样不错。你可以把阶梯方法用于数据呈如下概率分布的统计任务
概率
保险索赔金额
0.458747
$0.00
0.547651
$254.32
0.627764
$514.77
0.776883
$747.82
0.893211
$1,042.65
代码大全(第2版)

<==========================464end ==============================>
<==========================465start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
428
第18章表驱动法
续表
概率
保险索赔金额
0.957665
$5,887.55
0.976544
$12,836.98
0.987889
$27,234.12
像这样无规则分布的数据,是不可能用一个函数把它们整齐地转换成表键值
的。而阶梯方法就是问题的正确解法。
使用这种方法同样也可以享受到表驱动法所具有的一般性点:它非常灵活并
容易修改。如果等级评定例子中的等级区间有变化,那么只需要修改 RangeLimit
数组中的记录,应用程序就可以很容易适应该变化。你可以很轻松地把应用程序
中赋予等级的那部分进一步推广,使其能够接受一张等级表和相应的分数线。赋
予等级的那各部分也不一定必须使用百分比来表示分数;它可以使用原始的数据
点而不是百分比,而应用程序也无须为此做太多改动。
下面是你在使用阶梯技术的时候需要注意的一些细节。
留心端点确认你已经考虑到每一个阶梯区间的上界。进行阶梯查询以找出
那些位于上界之外的项目来,然后把剩下的那些项目归入最上一级范围之内。这
样做有时要求为最高一级区间的最高点假拟出一个值。
注意不要把<误用为<=。确认循环能够在找出最高一级的区间之后恰当地终
止,同时确保正确地处理了区间的边界。
考虑用二分查找取代顺序查找在等级评定的示例中,负责赋予等级的那个
循环是在等级界限的列表中顺序查找。如果这个列表很大,那么这种顺序型查找
的成本就会成为效率的一种制约。如果事实的确如此,你可以把它替换成一个准
二分查找法。说它是“准”( quasi)二分查找法的原因是,大多数二分查找的主要
目的都是要找到一个数值。而在这个例子里面,你要做的不是找出一个数值,而
是要为某一个数值找出正确的分类来。因此二分查找的算法必须能够正确地判断
出该数值的归属。同样,你要记得把端点作为一种特殊的情况看待。
考虑用索引访问来取代阶梯技术像第1.3节中描述的那些索引访问方法可
能会成为阶梯技术的很好替代品。阶梯方法中的查找操作可能会比较耗时,如果
执行速度很重要,你也许会愿意用索引访问法来取代阶梯法,即以牺牲存储空间
来换取速度。
很显然,这种替代方案并不是在任何时候都适用的。在等级评定示例中,你
也许可以采用它;如果你只有100个非连续的百分比值,那么用于创建一个索引
数组的内存成本是完全可以接受的。另一方面,如果你有的是前面给出的那样的
代码大全(第2版)

<==========================465end ==============================>
<==========================466start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看
18.5表查询的其他示例
429
概率数据,那么你是无法得出一种索引方案的因为无法把0.458747和0.547651
这样的数据用做记录的键值。
交叉参考第5章在某些情况下,上述的任何一种方法都是可行的。此时设计的关键之处就在
“软件构建中的于从一系列好的可以相互替代的方案中根据你所面临的情况选出一种来。不要
设计方案的好方太担心选不出最佳的方案。正如 Butler Lampson, Microsoft公司一位杰出的工程
法。
所说,最好是去找一种好的方案而且同时避免引发灾难,而不要试图去寻找最
佳的方案( Lampson1984)。
把阶梯表查询操作提取成单独的子程序在你创建了一个转换函数,能把像
StudentGrade这样的数值转换成表的键值时请把它提取成单独的子程序。
18.5
Other Examples of Table Lookups
表查询的其他示例
本书的其他章节中还有一些关于表查询的例子。它们出现在对其他技术的讨
论过程中,其上下文也没有强调表查询问题你可以在下列章节找到这些示例:
■在保险表中查找费率:第16.3节,“轻松创建循环由内而外”
用决策表代替复杂的逻辑:第19.1节中的“用决策表代替复杂的条件”
表查询过程中内存分页的成本:第25.3节,“蜜糖和哥斯拉”
布尔值的组合( or or):第26.1节中的“用查询表替代复杂表达式”
预先计算贷款表中的数值:第26.4节,“表达式”
CHECKLIST: Table-Driven Methods
cc核对表:表驱动法
口你考虑过把表驱动法作为复杂逻辑的替换方案吗?
口你考虑过把表驱动法作为复杂继承结构的替换方案吗?
口你考虑过把表数据存储在外部并在运行期间读入,以便在不修改代码的
情况下就可以改变这些数据吗?
口如果无法用一种简单的数组索引(像age示例中那样)去访问表,那么
你把计算访问键值的功能提取成单独的了程序,而不是在代码中重复地
计算键值吗?
代码大全(第2版)

<==========================466end ==============================>
<==========================467start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
430
第18章表驱动法
Key Points
要点
表提供了一种复杂的逻辑和继承结构的替换方案如果你发现自己对某个应
用程序的逻辑或者继承树关系感到困惑,那么问问自己它是否可以通过一个
查询表来加以简化。
使用表的项关键决策是决定如何去访问表你可以采取直接访问、索引访
问或者阶梯访问。
使用表的另一项关键决策是决定应该把什么内容放入表中。
代码大全(第2版)

<==========================467end ==============================>
<==========================468start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com!.com!l仅供试看^个
General Control Issues
第19章
般控制问题
cc2e.com/1978197内容
19.1布尔表达式:第431页
19.2复合语句(语句块):第443页
19.3空语句:第444页
19.4驯服危险的深层嵌套:第445页
19.5编程基础:结构化编程:第454页
19.6控制结构与复杂度:第456页
相关章节
直线型代码:第14章
条件代码:第15章
■循环代码:第16章
不常见的控制结构:第17章
软件开发的复杂度:第5.2节中的“软件的首要技术使命:管理复杂度”
如果不讨论有关控制结构的一些一般性问题,那么任何关于控制的讨论都是
不完整的。本章所讲述的大部分内容都十分详细,并且实用性很强。如果你更关
心的不是应用细节,而是控制结构的理论,那么请阅读第19.5节,该节从历史的
角度出发对结构化编程做了分析。还有第19.6节,该节关注控制结构之间的关系。
Boolean Expressions
布尔表达式
除了最简单的、要求语句按顺序执行的控制结构之外,所有的控制结构都依
赖于布尔表达式的求值(evaluation)
Using true and false for Boolean Tests
用true和 false做布尔判断
在布尔表达式中应该用标识符true和 false,而不要用0和1等数值。大多
数现代编程语言都提供了布尔数据类型,并且为真和假提供了预定义的标识符。
代码大全(第2版)

<==========================468end ==============================>
<==========================469start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
432
第19章一般控制问题
这样就简化了问题——有的语言甚至不允许你为布尔变量赋true或 false以外
的值。你需要在那些不提供布尔数据类型的语言中制订一些规则,以使得布尔表
达式更可读。下面是此类问题的一个例子:
Visual Basic示例:使用含混的标记作为布尔值
Dim printerError As Integer
Dim reportselected As Integer
Dim summarySelected As Integer
HORROR
If printererror =0 Then InitializePrinter()
If printerError=1 Then Noti()
If reportSelected 1 Then PrintReport
If summnarySelected =1 Then PrintSummary (
orint erfrroro Then
If printerError =0 Then CleanupPrinter (
如果使用像0和1这样的标识在代码中很普遍的话,那么这里会有什么不对
吗?阅读代码时很难看出,究竟在判断结果为真还是为假时执行这些函数调用。
代码根本没有反映出究竟1代表的是真,代表的是假,还是正好相反。甚至连1
和0是不是代表真和假也不清楚。例如,在 If reportSelected=1这一行代
码中,1很可能代表的是第一份报告,如果是2就代表第二份报告,3代表第三份
报告;代码里根本没有反映出1代表真或假在想写0时也很容易写成1,或者
正好相反。
请在布尔表达式的判断里采用true和 false来代表真和假。如果你的语言
并不直接支持这些写法,那么就用预处理宏或者全局变量来创建它们。下面就是
采用 Microsoft Visual Basic中内置的True和 False重写的上面示例:
Visual Basic示例:使用True和 False代替数值来作判断很好,但不是最好
交叉参考下 Dim printerError As Boolean
一个代码示例 Dim reportSelected As ReportType
给出了一种更 Dim summaryselected As Boolean
好的完成相同 DrinterError= False) Then InitializePrinter()
判断的方法。f( printerError=rue) Then NotifyUserofError()
enortselected _po
Tf reportSelected ReportType_First Then PrintReport (
f( summarySelected= True Then PrintSummary()
.rror=
if( printerError= False) Then CleanupPrinter()
使用True常量和 False常量,这些语句的用意就非常清晰了。你不再需要
强记1和0代表的是什么含义,也不会不小心把它们用颠倒。此外,现在也可以
很清楚地看出,前面Visual Basic示例中的某些1和0代表的并不是布尔标识。
代码大全(第2版)

<==========================469end ==============================>
<==========================470start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
19.1布尔表达式
433
其中 If reportSelected=1这一行根本就不是在做布尔判断;它判断所选取
的是不是第一份报告。
这种方法可以告诉读者你正在执行一个布尔判断。另外,与把0误写为1相
比,你很难会把 false误写为true,你也可以避免在代码中到处使用0和1这样
的神秘数值。下面是一些如何定义布尔判断中的true和 false的技巧
隐式地比较布尔值与true和 false把表达式当做布尔表达式,可以写出更清
晰的判断语句。例如,写成
while not done )..
while a b ).
而不要写成
while done false ..
while ((a b) true )..
通过使用隐式比较,能减少阅读你的代码的人必须要记住的项(term)数,
这样写出的表达式读起来也更像英语中的对话。前面的那个例子还可以用更好的
风格改写:
Visual Basic示例:隐式地判断True和 False更佳
Dim printererror As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
.1
f( Not printerError Then InitializePrinter()
if( printerError Then NotifyUser()
Lected ReportType first yThen print renort
f( summarySelected) Then PrintSummary()
If Not printerError Then CleanupPrinter
交叉参考详细如果你的语言不支持布尔变量,并且你不得不模拟它们,那就可能无法使用
内容请阅第12.
节“布尔变量”。本例这种技术,因为模拟的true和fase未必能用 while(not done)这样的语句进
行检测。
Making Complicated Expressions Simple
简化复杂的表达式
你可以采取多种办法来简化复杂的表达式。
拆分复杂的判断并引入新的布尔变量与其写一个庞大的、具有很多项的复
杂判断,还不如把中间结果赋给变量,让你可以执行一个更简单的判断。
代码大全(第2版)

<==========================470end ==============================>
<==========================471start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
434
第19章一般控制问题
把复杂的表达式做成布尔函数如果某项判断需要重复做,或者会搅乱对程
序主要流程的理解,那么可以把该判断的代码提取成一个函数,然后判断该函数
的返回值。例如,下面是一个复杂的判断:
Visual Basic示例:复杂的判断
f(( document. At Endofstream)nd Not inputError))and
((min_LINES< lineCount)and( lineCount= MAXLINES))and
Not ErrorProcessing())Then
End If
这是一个读起来很糟糕的判断,特别是当你对判断本身不感兴趣的时候。把
这个判断放入一个布尔函数,就可以把它隔离起来除非它非常重要,否则读者
完全可以忘掉它。你可以按下面方式把这个f判断放到一个函数里面:
交叉参考你可以 Visual Basic示例:将复杂的判断移入布尔函数,用新的中间值使判断更清晰
借助中间变量对布 Function DocumentIsValid(
尔判断进行说明
yRet documentTocheck As Document,
详细方法在12.5 1ineCount As Integer
节的“用布尔变量) As Boolean
对程序加以文档说
明”。
Dim allDataRead As Boolean
Dim legalLineCount As Boolean
这里引入了中间变11ataread=(37《noutErro《.atendofstream)andnotinputerror)
量,由此对最后一行,€nCoUn《N1neCounAndneCountwxLTNEsy€=(minlies<linecount)and(linecountmaxlines
代码的判断目的进 Documentisvalid= aliDataRead And legallinecount
行说明。
End Function
本例假设 Error Processing()是一个可以表明当前处理状态的布尔函数。现
在,当你顺着代码的主流程阅读时,就无须再去读那个复杂的判断了:
Visual Basic示例:去掉复杂判断后的代码的主流程
If Document Isvalid( document, lineCount, inputError )Then
do something or other
End If
如果这个判断只用一次,你可能会认为没有必要把它放入一个子程序中。不
过,把这个判断放到一个命名良好的函数里能改善可读性,并且能让你清楚地了
KEY POINT解代码在做什么,因而这样做很有必要。
代码大全(第2版)

<==========================471end ==============================>
<==========================472start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com.com!仅供试看^
19.1布尔表达式
435
新函数名为程序引入了一个抽象,可以清晰地在代码中说明该逻辑判断的目
的。这样做比用注释好,因为人们更关心程序代码,可能不去读注释。而且这种
描述更不容易过时。
交叉参考第18用决策表代替复杂的条件有时候有一个很复杂的判断,其中涉及到多个变
章“表驱动法”
有关于用表代替量。这时用一个决策表(decision-table-)代替if或者case语句来执行判断可能非
复杂逻辑的详细常有帮助。决策表查询操作写起来很容易,只有几行代码,也不会用到复杂难懂
介绍。
的控制结构。降低了复杂度,也就降低了出错的可能性。如果你用的数据变了,
那么只需要修改决策表即可,而无须改动代码;你只需要更新数据结构的内容就
可以了。
Forming Boolean Expressions Positively
编写肯定形式的布尔表达式
Iann't not no
Not few people dont' have not any trouble nonshort string of
undummy.(我并
非不是一个不傻 nonpositives(并不是只有不多的人在理解不太短的非肯定句子的时候不会遇到任
的人。)何不方便)这句话的意思是大多数人在理解一长串否定用语的时候都会觉得
Homer Simpson困难。你可以采取一系列措施来避免把复杂否定形式的逻辑表达式引入到程序之
中:
在if语句中,把判断条件从否定形式转换为肯定形式,并且互换if和else子
句中的代码下面是一个否定形式的判断:
Java示例:令人困惑的布尔判断
这是表示否定的逻if(!statusOK)
辑取反运算。
/ do something
else(
/ do something else
这里的判断已经你可以把它改成下面这种肯定形式的判断语句:
逆转了。
java示例:更清晰的肯定形式的布尔判断
if statusoK
这段代码已经和下
/do something else
面一段代码交换了
位置。
和上面代码交换se
位置。
1/ do something
代码大全(第2版)

<==========================472end ==============================>
<==========================473start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
436
第19章一般控制问题
第二段代码片段在逻辑上和前一段相同,但更容易阅读,因为否定的表达式
交达式肯定已经转换成肯定的了。
参考使用
形式的这条建议
有时会和“在if作为另外一种方案,你还可以给变量换一个名字,以表达判断真值的反义。
子句中处理正常
情况的建议相抵在本例中,你可以把 statusoK替换成 ErrorDetected,这样当 statusoK为假
触(请阅第15.1的时候, ErrorDetected就会为真了
这时你就需要考用狄摩根定理简化否定的布尔判断狄摩根定理(DeMorgan's' Theorems)揭
虑两种方法的利示了一个表达式和另一个含义相同但却以双重否定形式表达的表达式之间的逻辑
弊,从而选择最适
合的方法。
关系。例如,你可能会写包含下面判断的代码片段:
ava示例:否定型判断
if !displayOK !printeroK
该判断在逻辑上等同于:
ava例:应用狄摩根定理之后的判断
if( displayok&& printerOK
这样就无须互换if和else子句中的代码了;上面两段表达式是逻辑等价的。
为了把狄摩根定理应用于逻辑与运算符ad或者逻辑或运算符or以及一对运算对
象,你需要对每一个运算对象取反,把and和or互换,同时对整个表达式取反。
表19-1总结出了狄摩根定理下可能的表达式转换形式。
表19-1狄摩根定理的逻辑表达式的转换法则
原表达式
等价表达式
not and not B
not(A or B)
not A and B
not( or not B)
A and not B
not(not A or B)
A and B
not(not or not B)
not A or not B*
not (A and B)
not or B
not (A and not B)
A or not B
not (not A and B)
or B
not(not and not B)
*这就是本例中所用的表达式。
代码大全(第2版)

<==========================473end ==============================>
<==========================474start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
19.1布尔表达式
437
Using Parentheses to Clarify Boolean Expressions
用括号使布尔表达式更清晰
交叉参考第如果你有一个复杂的布尔表达式,那么与其依赖于所用语言的求值顺序,不
31.2节中的“括如用括号更清楚地表达你的意图。使用括号降低了对代码阅读者的要求,这些阅
号”详细介绍了如
何借助括号对其读者可能并不理解你的语言求布尔表达式值的微妙细节。如果你很聪明,那么就
他类型的表达式不会使代码可读性依赖于你自己或者代码阅读者对求值优先级的深度理解特
别是当你必须要使用两种或两种以上语言的时候。使用括号和发电报不一样:你
不会为每一个字符付费多写的那些字符都是免费的。
下面是一个括号用得太少的例子:
Java示例:括号过少的表达式
if< b == =) ..
这首先是一个含义很不清楚的表达式,而且它还会把人弄糊涂,因为你看不
出写代码的人想表达的是(a<b)==(c==d)还是((a<b)=c)=d下
面这种表达式写法仍然有些含混,但是其中的括号已经起了不小的作用:
java示例:加了括号的表达式
if ( a = c d ))
在这个例子里,加了括号后,程序的可读性和正确性都提高了编译器原
交叉参考很多本是不会这样来解释第一个代码片段的。如果拿不准,就使用括号。
用于编写程序的
用一种简单的计数技巧来使括号对称如果你不知道所用的括号用得是不是
文本编辑器都提
供了圆括号、方括配对,那么下面的简单计数技巧会很有用。开始的时候说“0”,然后从左到右扫
号和花括号的配描该表达式。当遇到一个左括号的时候说“1”,并且每次遇到一个左括号的时候
对功能。第30.2
节中的“编辑”有就把这一数字加1。每次遇到一个右括号的时候把这个数字减1。如果到表达式最
关于程序编辑器后的时候所得结果为0,那么你用的括号就是配对的。
的介绍。
java示例:配对的括号
看这里。
if(((ab)=c=d&& done)
111
嘴里念。0123
23
代码大全(第2版)

<==========================474end ==============================>
<==========================475start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
438
第19章一般控制问题
在这个例子里,你最后得到的结果是0,因此括号是配对的。下面的例子中
出现了括号不配对的情况:
看这里
ava示例:不配对的括号
Hif ( a <b) = c = d & !done
嘴里念
012
2
10
位于最后一个右括号之前的那个0表明,在这一点以前少用了一个括号。你
应该在算到表达式的末尾才能得出0
把布尔表达式全括在括号里面括号用起来很方便,而且能够改善可读性。
在实践中,把布尔表达式整个括在括号里是一种很好的习惯。
Knowing How Boolean Expressions Are Evaluated
理解布尔表达式是如何求值的
在求布尔表达式的值的时候,很多语言都会使用一些隐含的控制方式。一些
语言的编译器会先计算布尔表达式中的每个项的值,然后再把这些项组合起来求
出整个表达式的值。一些语言的编译器采用“短路(《shortciruiu《)”或者“惰性
(lazy)”求值,只求出那些必须的部分。当你希望用第一个判断的结果来控制第
二个判断是否执行的时候,这一点就显得尤为重要了。例如,设想你正在检查一
个数组的元素,并写出下面的判断语句:
伪代码示例:易错的判断
while MAX_ELEMENTS and item[ i ]<>0 ..
如果整个表达式都被求值,你就会在循环的最后一次迭代中遇到一个错误。
那时变量i等 maxElements于,所以表达式item[i]就等于item[maxElements],
而这是一个数组下标越界错误。你可能会辩解说这并不碍事,因为你只是在查看
数值而没有修改它。但这是一种很差的编程实践,它会让阅读你代码的人感到不
解。在很多环境中,这样做要么会带来一个运行时错误,要么会引发一次内存保
护违例( protection violation)
在伪代码中,你可以重新组织这个判断的结构使上述错误不再发生:
伪代码示例:重新安排结构后的正确判断
whileimax_ELEMENTS
if item[ i <>0 then
这样写是对的,因为只有当i小 maxElements于的时候才去计算item[i]的
值。
代码大全(第2版)

<==========================475end ==============================>
<==========================476start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!.com!仅供试看
19.1布尔表达式
439
很多语言都提供了相应的功能,在第一时间阻止此类错误的发生。例如,C++
采用短路求值:如果and的第一个操作数( operand)为假,那么就跳过第二个操
作数,因为整个与表达式的取值反正一定为假了换句话说,在C++中,表达式
if SomethingFalse & SomeCondition )..
中唯一被求值的部分是 SomethingFalse一旦确定了 SomethingFalse的取值
为假,求值过程就马上结束。
对于or运算符来说,求值也有相似的短路行为。在C++和va中,表达式
if somethingTrue someCondition )..
中唯一被求值的部分是 somethingTrue一旦确定了 somethingTrue的取值为
真,求值过程就马上结束,因为只要某一部分为真,整个或表达式就为真。作为
采用这种求值方法的结果,下面的语句很好而且合法。
java示例:利用短路求值的判断
if(( denominator=0)&&((itm/ denominator)>min_VALUE))
如果在 denominator等于0的时候求整个表达式的值,那么位于第二个操作
数处的除法就会产生一个除零错误。但是由于仅当第一部分为真的时候才去求第
二个部分的值,因此当denominator等于0的时候第二部分就不会参与计算,因
此就不会产生除零错误。
另一方面,由于与运算&&(and)是从左向右结合的,因此下面在逻辑上等
价的语句却不能正常工作:
java示例:短路求值不起作用的判断
if(((item denominator)>min_alue)&& denominator=0)
在这个例子中,item/denominator将在 denominator=0之前求值,从
而会引发除零错误。
Java提供的“逻辑”运算符又把这一问题复杂化了。Java中的&和逻辑运算
符会保证,无论整个表达式的结果能否通过部分项的真假判定而无需完全求值,
所有的项都要经过完整的求值。换句话说,下面的代码在java中是安全的:
Java示例:利用短路求值的正确判断
if(( denominator=0)&&(( item denominator)>min_VALUE)
代码大全(第2版)

<==========================476end ==============================>
<==========================477start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
440
第19章一般控制问题
但是下面这样写就不安全了:
ava示例:错误的判断因为不能保证采用短路求值
if(( denominator!=0)&((ite/ denominator)min_VALUE
不同语言所用的求值方法是不同的,而语言的实现者们也倾向于随意地对待
表达式的求值,所以请查阅你所用语言特定版本的用户手册,以了解你的语言是
KEY POINT如何求值的。由于你代码的读者可能不会像你这么敏锐,因此更好的做法是使用
嵌套的判断语句来明确你的用意,而不要依赖于求值顺序和短路求值。
Writing Numeric Expressions in Number-Line Order
按照数轴的顺序编写数值表达式
应该很好地组织数值判断,使其顺序与数轴上的点排列顺序相符。一般来说,
应该把数值判断组织好,使你能有像下面这样的比较方式:
min_ELEMENTS<= and<=maxELEMENTS
i<min_ELEMENTS or MAX_ELEMENTS<i
这里的关键点在于要从左到右、从小到大地排列元素。在第一行中,
MINELEMENTS和 MAXELEMENTS是两个端点,所以把它们放在两边。变量i应该
位于这两点之间,所以把它写在中间。在第二个示例中,你是想判断i是否位于
范围之外,因此把i写在判断外围两端的位置,而把 MINELEMENTS和
MAX_ELEMENTS写在里面。这种方法可以很容易地用图19-1中的生动图形说明:
MIN_ELEMENTS <=i and<=MAX_ELEMENTS
MIN_ELEMENTS\ Valid values for i MAX_ELEMENTS
<MIN_ELEMENTS or MAX_ELEMENTS<i
MIN_ELEMENTS.
MAX_ELEMENTS
Valid values for i
图19-1一个用数轴顺序做布尔判断的例子
如果你只拿i来 MIN和ELEMENTS比较,那么i的位置应取决于判断成功以
后i的位置在哪里。如果i应该小于MINELEMENTS,那么你应该这样写判断语句:
while< MIN_ELEMENTS ..
但如果i应该 MIN大于ELEMENTS,那么就要这样写判断语句了:
while MIN_ELEMENTS) ..
代码大全(第2版)

<==========================477end ==============================>
<==========================478start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubul.com!仅供试看
19.1布尔表达式
441
这种方法要比下面这种判断语句清楚多了:
(i MIN ELEMENTS and【imax_ELEMENTS
后面这种判断无法从直观上就“判断的是什么”给读者以提示。
Guidelines for Comparisons to
与比较的指导原则
编程语言把0用做很多的。它是一个数值,是字符串中的零终止符,是空
指针的取值,是举的第一个元素的取值,是逻辑表达式中的 false既然它有
如此多的用途,因此你写的代码中就应该彰显0的特定用法。
隐式地比较逻辑变量如前所述,编写下面这样的逻辑表达式是很合适的:
while done )..
在这里隐式地与0做比较是很好的,因为它位于一个逻辑表达式中。
把数和0相比较尽管与逻辑表达式比较适合采用隐式写法,在与数值表达
式比较时却应该采用显式写法。对数值而言,应该写成
while balance ! 0)
而不要写成
while Balance )..
在C中显式地比较字符和零终止符(10)字符和数字一样,都不是逻辑
表达式。所以对于字符,就应该写成
while *charPtr!='10')
而不是写成
while *charptr ..
这一建议并不符合C语言里常用的字符数据处理习惯(如此处的第二个例子
所示),但是它进一步强调了该表达式是在处理字符数据,而不是逻辑数据。有
些C传统并不是基于最大化的可读性或者可维护性的,这里就是一例。所幸的是,
随着越来越多的代码是用C++和 STL string成的,这一问题也随之渐渐地消逝。
把指针与NULL相比较对于指针,就应该写成
while bufferltr ! NULE, .
代大全(第2版)

<==========================478end ==============================>
<==========================479start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor.com!仅供试看
442
第19章一般控制问题
而不要写成
while bufferPtr ..
与使用字符的建议相似,这一项建议也有违既成的C传统,但由之带来的可
读性的改善却说明它是值得的。
Common Problems with Boolean Expressions
布尔表达式的常见问题
布尔表达式中还含有少量与特定语言相关的缺陷:
在C家族语言中,应该把常量放在比较的左端家族语言在布尔表达式上
存在一些特殊的问题。如果你因为误把==写成了=而遇到麻烦,那么可以考虑采
用把常量和字面量置于表达式左侧的编程方法,就像下面这样:
C++示例:将常量放在等号左侧编译器会捕获这个错误
if MIN_ELEMENTS = )..
对于这个表达式,编译器会提示=出了错,因为给常量赋任何值都是非法的。
与之相反,在下面的表达式中,编译器只会给出一个警告,而且仅当你把编译器
的警告完全打开时才会有:
C++示例:将常量放在等号右侧编译器可能不会捕获这个错误
if MIN_ELEMENTS ..
这项建议与按照数轴顺序排列的建议相冲突。我个人偏向于使用数轴排序法,
让编译器来告诉我有没有无意写出的赋值语句。
在C++中,可以考虑创建预处理宏来替换&&,和=(不得已才这么做)如
果你遇见过这类问题,就可以为布尔与运算和或运算创建出一些define宏,然后
用AND和OR来取代&&和。与之相似,把=错用成=也是一个常犯的错误。
如果你常为这个问题所困扰,就可以创建一个类似于 EQUALS的宏来表示逻辑等
于(==)
很多有经验的程序员认为,这种方法可以帮助那些无法彻底掌握编程语言细
节的程序员提高其代码的可读性,但对于那些已经很熟练掌握编程语言的程序员
来说,代码的可读性却降低了。另外,大多数编译器会对看起来用错了的赋值和
代码大全(第2版)

<==========================479end ==============================>
<==========================480start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看
19.2复合语句(语句块)
443
按位运算符给出警告。把编译器警告的全部都打开通常要比创建非标准的宏更好。
在Java中,应理解a==b和a.equals(b)之间的差异在Java中,a==b判断的
是a和b是否引用了同一个对象,而equals(b)判断的是这两个对象是否具有相同
的值。一般来说,Java应用程序里应该使用像 equals(b)这样的表达式,而不要用
a==bo
9.2
Compound Statements(Blocks)
复合语句(语句块)
“复合语句”或“语句块”指的是一组语句,该组语句被视为一条单一的语
句,用于控制程序流。在C++、C#、C和Jav中,可以通过在一组语句的外面括
上“”和“)”来创建复合语句。有时它们也可以用某条命令的关键字来表示,
如 Visual Basic中的For和Next下面就如何有效地使用复合语句给出一些指导原
则。
交叉参考很多
用于编写程序的
把括号对一起写出先写块的开始和结束部分然后再填充中间部分。人们
文本编辑器都提常常会抱怨说匹配括号对或者 begin和end对难,而这个问题是完全可以避免的。
供了圆括号、方如果你遵循了这项指导原则,那么就再也不会为这些匹配工作而犯难了。
括号和花括号的
配对功能。第先这么写:
30.2节中的“编for(i=0;i< maxlines;i++)
编辑器的介绍。再这么写:
for= 0: i maxzines; i++){}
最后这么写:
for(i=0;i maxLinesi++)
whatever goes in here
这种方法适用于所有的块结构,包含C++和Java中的if、for和 while,以及
Visual Basic If-Then-sefor-nxt While--Wend组合
用括号来把条件表达清楚要想读懂条件语句,就要先弄清楚哪条语句是跟
在if判断后面的。在i判断后面只写一条语句可能看上去很美观,但是一经修改,
这样的语句就会演变成复杂的块,而在这时用单一的语句就很容易引发错误
请用块来清楚地表达你的用意,无论块内的代码行数是1还是20
代码大全(第2版)

<==========================480end ==============================>
<==========================481start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
444
第19章一般控制问题
19.3
Null Statements
空语句
在C++中可以写空语句,即一条仅含有分号的语句,如下所示:
C+示例:传统的空语句
Rea
while recordArray. Read index+)= recordArray. EmptyRecord))
C++中的 while循环后面必须跟一条语句,但也可以是空语句。只含有一个分
号的语句就是空语句。下面就是如何在C++中处理空语句的指导原则。
交叉参考处理空
语句的最好方式就
小心使用空语句空语句并不多见,因此应该突出这种用法。方法之一就是
是拒绝使用他们。让空语句中的分号自占一行,并且加以缩进,就像对待其他的语句一样。这就是
第162节中的“避前面例子中用到的方式。另外,你也可以用一组空的括号来强调该空语句。下面
免空循环”有详细
的介绍。
是两个例子:
标识空语句的一种C++示例:加以强调的空语句
方式。
while( recordArray.read index+)= recordArray. EmptyRecord())
while( recordArray.read( index++)l= recordArray. EmptyRecord())
另一种方式。
为空语句创建一个 DoNothingO()预处理宏或者内联函数这条语句什么也不
做,但却能毫无争议地表明“这里不希望做任何事情”的用意。这和在空白的文
档页面上标明“本页为空白页”异曲同工。这一页其实并非完全空白,但这句话
却让你知道这一页本来就不准备写东西。
下面就是在C++中如何使用#define来自定义空语句(你也可以用内联函数
来创建它,其效果是相同的)。
C++示例:用 DoNothing()来强调空语句
#define DONothing (
while( recordArray.read( index++)= recordArray. EmptyRecord())(
DoNothing();
除了在空的 while和for循环中使用 DONothing(),你也可以在 switch语句中
的无意义选项中使用它;加入 DoNothing()表明你已经考虑了这种case,并且的
确不需要对该case做什么操作。
代码大全(第2版)

<==========================481end ==============================>
<==========================482start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看^
19.4驯服危险的深层嵌套
445
如果你的语言不支持预处理宏或者内联函数,那么你也可以写一个
DONothing()子程序,让它简单地把控制权立即交还调用方子程序。
考虑如果换用一个非空的循环体,是否会让代码更清晰空循环体代码的产
生多数都是为了利用循环控制代码的副作用(《sideffcstc《)在大多数情况下,如
果把这种副作用明显表示出来,那么代码也将会变得更加易懂,如下所示:
C++示例:更加清晰的重写后的代码,采用非空循环体
RecordType record= recordArray. Read index)i
index++i
while record ! recordArray. EmptyRecord()){
record= recordArray.read index)
index++;
这种方法引入了一个额外的循环控制变量,并要写更多的代码,但是它强调
了直截了当的编程方法,而不是自作聪明地利用控制循环代码的副作用。这样强
调对于产品代码是很可取的。
9.4
Taming Dangerously Deep Nesting
驯服危险的深层嵌套
过分深层的缩进,或者“嵌套”,已经困扰了计算机界达25年之久,并且至
今仍然是产生混乱代码的罪魁祸首之一。 Noam Chomsky和 Gerald Weinberg做过
HARD DATA
的一份研究表明,很少有人能够理解超过层的if嵌套( Yourdon1986a),很多
研究人员建议避免使用超过3到4层的嵌套(Myers1986、 Marca1981、 Ledgard、
Tauer1987a)。深层嵌套与第5章“软件构建中的设计”中所讲的软件首要技术使
命管理复杂度是相违背的。而这已经足够成为避免使用深层嵌套的理由
了。
避免深层嵌套并不太难。如果你写出了深层的嵌套,那么可以重新设计if和
else子句中执行的判断,或者把代码重构为更简单的子程序。下面给出一些用于
KEY POINT
避免深层嵌套的方法。
通过重复检测条件中的某一部分来简化嵌套的if语句如果嵌套层次变得太
深,你可以通过重复检测其中的一些条件来减少嵌套的层次。下面这个例子中的
嵌套层次已经深到应该重新安排结构了:
++示例:糟糕的深层嵌套代码
if( inputStatus= InputStatus_Success)
/ lots of code
if( printerRoutine=null)
代码大全(第2版)

<==========================482end ==============================>
<==========================483start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shul.com!仅供试看^
446
第19章一般控制问题
交叉参考重新 ots of code
判断部分条件以
简化语句的方法
if( SetupPage())
类似于重新判断
/ lots of code
状态变量。第
17.3节中的“错
if( AllocMem(& printData))(
1/ lots of code
误处理和goto”
有关于该方法的
介绍。
设计这个例子是用来说明嵌套的层次的。其中/ lots of code部分意指这
个子程序里面含有足够多的代码,足以占满好几屏,或者超出打印纸的边界。下
面是用重复检测取代嵌套后重写的代码:
C+示例:利用重复测试的非嵌套代码
if( inputstatus= Inputstatus_Success)
/1 lots of code
if printerRoutine ! NULL )
// lots of code
if ( inputStatus = Inputstatus_Success &&
( printerRoutine=null)&& SetupPage()
lots of code
if( AllocMem(&printData))
/ lots of code
这个例子很贴近实际,因为它表明你不能无偿地减少嵌套层次;作为减少嵌
套层次的代价,你必须要容忍使用一个更复杂的判断。不过,把嵌套层次从4层
缩减到了2层是很大的改进,所以值得考虑
用 break块来简化嵌套if上面描述的方法的一种替代方案,是定义一段可以
作为语句块来执行的代码。如果在语句块的中间某些条件没有满足,那么就让执
行直接跳到块的末尾。
C++示例:使用break块
do
begin break block
if( inputstatus= InputStatus_Success)(
break; / break out of block
代码大全(第2版)

<==========================483end ==============================>
<==========================484start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! -www.shub.com!仅供试看^
19.4驯服危险的深层嵌套
447
lots of code
if printerRoutine = NULL
break; / break out of block
lots of code
if (!SetupPage()){
break;/ break out of block
lots of code
if(AllocMem(&printData))
break; / break out of block
1/lots of code
} while(FALSE)l end break block
这种技巧很不常见,所以只有在你的整个团队都很熟悉这种技巧,并且已经
把它纳入了团队可接受的编码实践以后,才能使用。
把嵌套if转换成一组if-then-else语句如果持批评的眼光来看待if语句嵌套,
那么也许会发现可以重新组织它的结构,即用ifthen-else语句串来取代嵌套的if
语句。假设你有这样一棵茂盛的决策树:
ava示例:茂盛的决策树
if 10 quantity )
if(100 quantity)(
if(1000 quantity)
discount =0 .10:
else
, discount=0.05:
else
discount =0.025;
else
discount=0.0;
其中的判断逻辑组织得很差。首先,这些判断中有许多冗余。当判断了 quantity
是否大于1000的时候,就不需要再去判断它是否大于100并且大于10。因此,
可以重新组织这段代码:
代码大全(第2版)

<==========================484end ==============================>
<==========================485start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo ^.com!仅供试看^
448
第19章一般控制问题
java示例:将嵌套的if语句转换为一组if-then-else语句
if(1000< quantity)
discount =0 10:
else if 100 quantity
discount=0.05;
else if 10 quantity
discount =0.025;
)
else (
discount =:
这种方案比其他一些要好,因为数值是很整齐地排列的。如果有关的数值不
太规整,那么你可以按下面方式重写嵌套的if语句:
Java示例:当数值“杂乱”时,将嵌套的if语句转if换为一组-else语句
if(1000< quantity)
discount 0.10;
else if((100 quantity)&( quantity=1000)
discount =0.05;
)
auan
else if 10 quantity & quantity < 100 )
discount =0.025;
else if quantity < 10
discount =0;
这段代码与上面一段的主要区别是,else-if子句中的表达式并不依赖于前面
的判断结果。这段代码不需要else子句就能工作,而且这些判断之间的顺序也是
无关的。代码里可以包含4个if而不包含 else else版本之所以是可取的,唯一
原因是那样做能避免不必要的重复判断。
把嵌套if转换成case语句你可以用case语句重写一些判断,特别是那些含
有整数的判断,而不是去用一长串if和else。在有些语言里你无法使用这种方法,
但是对那些可以使用case的语言来说,这是一种功能强大的技术下面是用 Visual
Basic重写后的代码:
Visual Basic示例:将嵌套if语句转换为case语句
Select Case quantity
case 0 To 10
discount =0.0
case 11 To 100
discount =0.025
代码大全(第2版)

<==========================485end ==============================>
<==========================486start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubule.com!仅供试看
19.4驯服危险的深层嵌套
449
Case 101 To 1000
discount =0.05
Case Els
e
discount =0 .10
End Select
读这个例子就像读一本书一样。如果你拿它与前几页上的那两个有着大量缩
进的例子比较,就会觉得这种方案非常整洁。
把深层嵌套的代码抽取出来放进单独的子程序如果深层嵌套出现在循环
里,你通常都可以通过把循环体提取成子程序来加以改善。当嵌套是由于条件和
迭代二者共同产生的时候,这么做将特别有效。把if-then-else分支保留在主循环
中,以便显示决策的分支,然后把分支中的语句提取成单独的子程序。下面这段
代码需要用这种修改方式来改善:
C+示例:需要分入子程序的嵌套代码
read transaction record
transaction=ReadTransaction()
1/ process transaction depending on type of transaction
if transaction. Type ==TransactionType_Deposit
/ process a deposit
if transaction. AccountTYpe AccountType_Checking
MakeBusinessCheckDep(transaction. Account
else if transaction. AccountSubType
MakePersonalCheckDep(transaction.A
else if transaction. Account
MakeSchoolCheckD
else if transact
MakesavingsDep
else if trans
MakeDebitcar
else if trans
MakeMoneyMa
else if
MakeCDDe
else if transa
/7 process a
if transa
MakeCheck
else if
Makesaving
else if
MakeDe
代码大全(第2版)

<==========================486end ==============================>
<==========================487start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
450
第19章一般控制问题
里是
TransactionType_else if transaction Type = TransactionType_Transfer
Transfer交易类型。
MakeFundsTransfer(
transaction. SourceAccountType,
transaction. TargetAccount Type,
transaction. AccountNum,
transaction. Amount
)
else
process unknown kind of transaction
LogTransactionError"Unknown Transaction Type", transaction);
尽管这段代码很复杂,但它并不是你所见过的最糟糕的代码。代码里只用了
4层嵌套,加了注释,使用了合理的缩进,并且其功能分解也很到位,特别是其
中的 TransactionType_Transfer交易类型然而,尽管存在这些优点,你还是
可以通过把内部if判断的内容拆分成单独的子程序来改善它。
交叉参考只要C++示例:将嵌套代码分解到子程序后的好代码
按照第9章中“伪while(Transactionscomplete())
的
步骤编写子程序, transaction ReadTransaction();
这样的功能分解
简直易如反掌。第
if preransactionarypen dereadsactiontype deposinsaction
5.4节中的“分而p
ProcessDeposit
治之”给出了功能
分解的指导原则。
transaction. AccountType.
transaction. AccountSubType,
transaction. AccountNum,
transaction.Amount
);
)
else if transaction. Type =TransactionType_Withdrawal )
ProcessWithdrawal(
transaction. AccountType,
transaction.AccountNum
transaction. Am
);
else if( transaction.type
actiontyne mransfer
TransactionType_Transfer )
MakeFundsTransfer(
transaction. SourceAccount Type,
transaction. TargetAccountType,
transaction. AccountNum
transaction. Am
);
)
else
/ process unknown transaction type ra
LogTransactionError("Unknown Transaction Type", transaction
代码大全(第2版)

<==========================487end ==============================>
<==========================488start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo..com!仅供试看^
19.4驯服危险的深层嵌套
451
新子程序中的代码只是简单地从原来的子程序中提取出来,并形成新的子程
,、
序(这里没有给出新的子程序)。新的代码具有以下优点。首先,两层嵌套使得代
码结构更简单并更容易理解。其次,你可以在一个屏幕里阅读、修改和调试这个
缩短了的 while循环—它不再跨越好几屏或者超出打印纸的边界。第三,把
ProcessDeposit()和 ProcessWithdrawal1()的功能提取成子程序,能带来模块
化的其他基本好处。第四,现在很容易看出,可以把这段代码拆分成一个case语
句,使它更容易读,如下所示:
C++示例:分解后的嵌套代码,使用case语句
while( TransactionsComplete())
4/ read transaction recor
d
transaction =ReadTransaction();
process transaction depend
Drocess transaction depending on type of transaction
switch transaction.type)
case( TransactionType_Deposit):
ProcessDeposit(
nsactin
transaction. AccountType,
transaction, AccountSubType,
transaction. AccountNum,
transaction.Amount
break;
case( TransactionType_Withdrawal):
ProcessWithdrawal
transaction. AccountType,
transaction
break;
sse ranesc
ase
ctionTypeTransfer):
MakeFundsTransfer
transaction. SourceAccountType,
ansact ion. TargetAccount Type,
ans
nsaction
transaction.Amount
break;
default:
process unknown transaction type
LogTransactionError("Unknown Transaction Type", transaction)
break;
代码大全(第2版)

<==========================488end ==============================>
<==========================489start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看
452
第19章一般控制问题
使用一种更面向对象的方法在面向对象的环境中,简化这段代码的一种简
单方法是创建一个抽象的 Transaction基类,然后从它派生出Deposit、
Withdrawal和 Transfer子类来。
C++示例:使用多态机制的好代码
TransactionData transactionData;
Transaction *transaction;
while ITransactionsComplete()
/ read transaction record
transactionData ReadTransaction();
create transaction object depending on type of transaction
switch transactionData. Type )
case TransactionType_Deposit )
transaction new Deposit transactionData
break;
case( rransactionTypeWithdrawal):ionn
transaction new Withdrawal( transactionData
break;
case TransactionTypeTransfer) ctionData
transaction= new Transfer( transac
break;
default:
process unknown transaction type
LogTransactionError ("Unknown Transaction Type", transactionData);
return;
transaction->Complete();
delete transaction;
对于各种规模的系统,都可以用 Factory Method模式来替换其中的 switch语
句,该模式可以重用于系统中任何需要创建 Transaction类型对象的场合。如果
在这个系统里使用下面的代码,那么这一部分还会变得更加简单:
交叉参考第24C++示例:使用多态机制和 Object Factory的好代码
章“重构”有更 TransactionData transactionData;
多类似的改善代 Transaction*transaction
码的方法。
while( TransactionsComplete())
read transaction record and complete transaction
transactionData= ReadTransaction();
transaction= TransactionFactory. Create( transactionData)
transaction->Complete()
delete transaction;
对记录而言, TransactionFactory. Create(子程序中的代码可以看作识对
前一个例子中 switch语句的简单改写:
代码大全(第2版)

<==========================489end ==============================>
<==========================490start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
19.4驯服危险的深层嵌套
453
C++示例: Object Factory的好代码
Transaction *TransactionFactory: Create(
TransactionData transactionData
)
n type
create transaction object, depending on type of transaction
switch transactionData.type)
case TransactionType_Deposit
return new Deposit( transactionData )
break;
case( TransactionTypewithdrawal)
return new Withdrawal( transactionData )
break;
case TransactionType_Transfer )
return new Transfer( transactionData)
break:
default:
1/ process unknown transaction type
LogTransactionError("Unknown Transaction Type", transactionData);
return NULL;
重新设计深层嵌套的代码一些专家认为在面向对象的程序设计里出现
case语句,就说明代码没有做好分解,因此实际上极少有必要使用case语句(Meyer
1997)。前面把调用子程序的case语句转变成一个使用多态方法调用的 object
factory(对象工厂),就是这方面的一个例证。
更一般的说法是,复杂的代码表明你还没有充分地理解你的程序,所以无法
简化它。深层嵌套是一个警告,它说明你要么应该拆分出一个子程序,要么应该
重新设计那部分复杂代码。当然,这并不意味着你一定要修改这个子程序,但如
果不修改的话,你应该能提出一个好的理由来。
Summary of Techniques for Reducing Deep Nesting
对减少嵌套层次的技术的总结
下面是一份你可以使用去减少嵌套层次的技术列表,其中还标明在本书的哪
个位置讨论了相应的技术:
重复判断一部分条件(本节)
转换成if-then-else(本节)
转换成case语句(本节)
把深层嵌套的代码提取成单独的子程序(本节)
使用对象和多态派分(polymorphic dispatch)(本节)
代码大全(第2版)

<==========================490end ==============================>
<==========================491start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^ ^.com!l仅供试看
454
第19章一般控制问题
用状态变量重写代码(第17.3节)
用防卫子句来退出子程序,从而使代码的主要路径更为清晰(第17.1节)
使用异常(第8.4节)
完全重新设计深层嵌套的代码(本节)
19.5
A Programming Foundation: Structured Programming
编程基础:结构化编程
“结构化编程”这一名词始现于一篇题为Structured Programming》的具有
里程碑意义的文章,该文由 Edsger Dijkstra在1969年NATO软件工程会议上发表
(Dijkstra1969)。自从结构化编程这一概念提出以后,“结构化”这一术语就被大
量地应用于所有的软件开发活动中,包括结构化分析( structured analysis)、结构
化设计(structured design)以及结构化混日( structured goofing off)除了都创
建于“结构化”被广泛推崇的时代之外,这些状态各异的结构化方法学之间并没
有多少相互联系。
结构化编程的核心思想很简单,那就是一个应用程序应该只采用一些单入单
出的控制结构(也称为单一入口、单一出口的控制结构)单入单出的控制结构指
的就是一个代码块,它只能从一个位置开始执行,并且只能结束于一个位置。除
此之外再无其他入口或出口。结构化编程和结构化的、自上而下的设计不完全一
样。前者只适用于具体编码层。
一个结构化的程序将按照一种有序的且有规则的方式执行,不会做不可预知的
随便跳转。你可以按自上而下的方式阅读它,而它执行起来也大体是遵循这个顺序
的。使用规则性不强的方法所生成的源代码很难有意义且形象地反映出程序是如
何在机器上执行的。可读性差意味着不容易理解,最终导致应用程序的低质量。
时至今日,结构化编程的核心概念仍然很有用,在使用 break、 continue、 throw、
catch、 return,考虑其他问题时都需要这些概念。
The Three Components of Structured Programming
结构化编程的三个组成部分
下面几节将会描述结构化编程的三个组成部分。
Sequence
交叉参考想了顺序
解关于顺序结构
的更多内容,请
“顺序”指一组按照先后顺序执行的语句。典型的顺序型语句包括赋值和调
阅第14章“组织用子程序。下面是两个例子:
直线型代码”。
代码大全(第2版)

<==========================491end ==============================>
<==========================492start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看^
19.5编程基础:结构化编程
455
Java示例:顺序
1/ sequence of assignment statements
a="1"
b="2"
C"3"
11
a sequence of calls to routines
System.out. printIn);
System.out. println(b);
System.out. printIn( c
Selection
选择
交叉参考想了选择是一种有选择的执行语句的控制结构。 if-then--else语句就是一个常见的
解关于选择结构
的更多内容,请阅
例子。要么执行if-then子句,要么执行else子句,两者不会同时执行。即“选择”
第15章“使用条其中的某一条子句加以执行。
件语句”。
选择控制的另一个例子是case语句。C++和Java中的 switch语句以及 Visual
Basic中的 select语句都是case的实例。在每一实例中,都只有一种情况(case)
的语句选定执行。从概念上说,if语句和cae语句是类似的。如果你的语言不支
持case语句,那么你可以用if语句来模拟下面举两个选择的例子:
Java示例:选择
/1 selection in an if statement
if totalAmount 0.0
1/ do something
else
do something else
1
n。。 tstemont
/ selection in a case statement
switch commandshortcutLetter
case 'a':
PrintAnnualReport()
breaki
case'q':
PrintQuarterlyReport ()
break;
case 's':
PrintSummaryReport()
break;
default:
DisplayInternalError( "Internal Error 905: Call customer
support.")
代码大全(第2版)

<==========================492end ==============================>
<==========================493start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看^个
456
第19章一般控制问题
Iteration
迭代
交叉参考关于迭代是一种使一组语句多次执行的控制结构。迭代常常称为“循环”迭代的
使用迭代的详情,种类包括 Visual Basic中的or-next,以及C++和Java中的 while和for下面是
请阅第16章“
制循环”。
个用 Visual Basic写的迭代的例子:
Visual Basic示例:迭代
example of iteration using a For loop
For index first To last
DoSomething index
Next
1。
example of iteration using a while loop
index =first
While( index=last
ndex
DoSomething index
index index 1
Wend
example of iteration using a loop-with-exit loop
index first
Do
If index last Then Exit Do
DoSomething index
index index +1
Loop
结构化编程的中心论点是,任何一种控制流都可以由顺序、选择和迭代这三
种结构生成(Bohm Jacopini1966)。程序员有时候会倾向于使用那些更方便的语
言结构,但是编程这一领域却似乎更多地是在对我们能用编程语言做些什么加以
限制的过程中取得发展的。在结构化编程出现之前,使用goto能够最方便地控制
应用程序流,但是那样写出的代码已被证明是难以理解并且不好维护的。我的观
点是,对于三种标准的结构化编程结构之外的任何控制结构的使用也就是说,
使用 break、 continue、 return、 throw-catch-—都要持一种批判的态度。
19.6
Control Structures and Complexity
控制结构与复杂度
控制结构之所以受到了如此多的关注,就是因为它们对程序整体复杂度的影
响非常大。控制结构用得不好就会增加复杂度;反之则能降低复杂度。
代码大全(第2版)

<==========================493end ==============================>
<==========================494start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看
19.6控制结构与复杂度
457
交叉参考让事
“程序复杂度”的一个衡量标准是,为了理解应用程序,你必须在同一时间记
情尽量简单但住的智力实体的数量。这种智力游戏可以说是编程中最难的方面之一,这使编程
不能过于简单。
Albert Einstein需要比其他任何活动都要专心。它也是程序员对“不时被打断”特别反感的原因一
这种打断就相当于让一位杂耍艺人一边抛接三个球,一边帮你照看商店。
就直觉而言,程序的复杂度看来在很大程度上决定了理解程序所需要花费的
精力。 Tom McCabe发表过一篇很有影响力的论文,称应用程序的复杂度是由它的
KEY PONT控制流来定义的(McCabe1976)。其他一些学者找出了一些McCabe提出的秩复
杂度量度( cyclomatic complexity metric)之外的因素(例如子程序使用的变量个
数),但是他们均认同这一观点,即如果控制流不是影响复杂度的最大因素,那么
至少也是最大的因素之一。
How Important Is Complexity
复杂度的重要性
交叉参考第5.2计算机科学界的研究人员对复杂度重要性的关注至少已经有20年时间了很
节中的“软件的首多年以前, Edsger Dijkstra已经就复杂度的危险提出警告:“有能力的程序员会充
复杂度”对复杂度分地认识到自己的大脑容量是多么地有限;所以,他会非常谦卑地处理编程任务”
做了详细介绍。( Dijkstra1972)。这并不是说你必须得增加自己的脑容量才能应对巨大的复杂度,
而是在说,你永远也不可能有能力应对如此巨大的复杂度,因此只有尽可能地采
取措施来降低复杂度。
与控制流有关的复杂度非常重要,因为它与不可靠的代码和频繁出现的错误
息息相关( McCabe1976, Shen et al.1985) William.ward的报告说,采用 McCabe
HARD DATA
的复杂度量度标准以后, Hewlett-Packard-的软件可靠性有了大幅增长(1989b)
他们把 McCabe的度量标准用于一个有7700行代码的程序,去设法标明有问题
的区域。该程序的发布后,错误率是每千行代码有0.31个错误另一个具有125000
行代码的程序的发布后(post-release)错误率是每千行代码有0.02个错误。Ward
的报告称,由于这两个程序的复杂度比较低,它们中包含的缺陷要比
Hewlett-Packard的其他程序都低。我自己的公司 Construx软件公司也从
2000年开始采用复杂度量标准来定位那些存在问题的子程序,收到了同样的效果。
General Guidelines for Reducing Complexity
降低复杂度的一般原则
你可以采用以下两种方法之一来更好地处理复杂度问题。首先,你可以通过
做一些脑力练习来提高你自身的脑力游戏水平不过编程本身的训练就已经足
够多了,而且人们看上去也很难处理好超过5到9个的智力实体(Miller 11956)
提高的可能性不大。其次,你可以降低你的应用程序的复杂度,以及为了理解它
所需要的专心程度。
代大全(第2版)

<==========================494end ==============================>
<==========================495start==============================>

该书下载自-书部落-分享计算机经典巨著--www.sulo.coml仅供试看
458
第19章一般控制问题
How to Measure Complexity
如何度量复杂度
深入阅读这里你也许对到底是什么使得程序变得更复杂或者更简单有直观的感觉。研究人
提到的方法源于员已经试着把他们的直觉归纳出来,总结出了一些衡量复杂度的方法。在这些数
Tom McCabe的
论文“A值技术中,最著名的可能就是 Tom McCabe的方法了。该方法通过计算子程序中
Complexity“决策点(decision points)”的数量来衡量复杂度表19-2给出了一种用于计算
Measure"
复
杂度度量法决策点的方法。
1976)。
表19-2计算子程序中决策点数量的技术
1.从1开始,一直往下通过程序
2.旦遇到以下关键字,或者其同类的词,就加1:
if、 while、 repeatfor、and、o
3.给case语句中的每一种情况都加1
下面举一个例子
if(((status Success) and done or
( not done and numlines> maxLincs))then
在这段代码中,从1算起,遇到if得2,and得,or得4,and得5.加起来,
这段代码里总共包含了5个决策点。
What to Do with Your Complexity Measurement
如果处理复杂度的度量结果
计算出决策点的数量以后,你就可以用得到的数值分析你写的子程序的复杂
度了:
0—5
子程序可能还不错
610得想办法简化子程序了
10+
把子程序的某一部分拆分成另一个子程序并调用它
把子程序的一部分提取成另一个子程序,不会降低整个程序的复杂度,只是
把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水
平。由于重点是要降低你需要在头脑中同时考虑的项目的数量,所以降低一个给
定子程序的复杂度是有价值的。
10个决策点的上限并不是绝对的。应该把决策点的数量当作一个警示,该警
示说明某个子程序可能需要重新设计了。不要死守这个规则。一条情况很多的case
语句可能会包含超过10个的元素。如果硬拆开它可能就是很愚蠢的,这取决该
case语句的用途。
代码大全(第2版)

<==========================495end ==============================>
<==========================496start==============================>

该书下载自-书部落-分享计算机经典巨著!www. !--www.shubul.com!仅供试看
19.6控制结构与复杂度
459
Other Kinds of Complexity
其他类型的复杂度
课入阅读
McCabc的测量方法并不是唯一合理的方法但它却是计算机文献中讨论最
(Software Engi-
neering Metrics多的方法,并且非常有助于你去考虑控制流的问题。其他度量方法包括:所用的
andModels》数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码
(Conte. Dunsmore,
and Shen1986)行数(跨度)、变量生存的代码行数(生存期),以及输入和输出的量。有些研究
对复杂度度量有
精论述。
人员基于这些相对简单数据的组合,归纳出了一些复合量度。
CHECKLIST: ControlStructure Issues
cc29.com/1985
核对表:控制结构相关事宜
口表达式中用的是true和 false,而不是1和0吗?
口布尔值和tue以及 false做比较是隐式进行的吗?
对数值做比较是显式进行的吗?
口有没有通过增加新的布尔变量、使用布尔函数和决策表来简化表达式?
口布尔表达式是用肯定形式表达的吗?
口括号配对吗?
口在需要用括号来明确的地方都使用了括号吗?
口把逻辑表达式全括起来了吗?
口判断是按照数轴顺序编写的吗?
口如果适当的话,Java中的判断用的是a equals(b)方式,而没有用ab方
式吗?
口空语句表述得明显吗?
口用重新判断部分条件、转换成 if-then--else或者case语句、把嵌套代码提
取成单独的子程序、换用一种更面向对象的设计或者其他的改进方法来简
化嵌套语句了吗?
口如果一个子程序的决策点超过10个,那么能提出不重新设计的理由吗?
代大全(第2版)

<==========================496end ==============================>
<==========================497start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! -www.shubul.com!仅供试看
460
第19章一般控制问题
Key Points
要点
使布尔表达式简单可读,将非常有助于提高你的代码的质量
深层次的嵌套使得子程序变得难以理解。所幸的是,你可以相对容易地避免
这么做。
结构化编程是一种简单并且仍然适用的思想:你可以通过把顺序、选择和循
环三者组合起来而开发出任何程序。
■将复杂度降低到最低水平是编写高质量代码的关键。
代码大全(第2版)

<==========================497end ==============================>
<==========================498start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
第5部分
Code Improvement
代码改善
本部分内容
■第20章软件质量概述
.463
第21章协同构建
479
第22章开发者测试
.499
■第23章调试
535
第24章重构
.563
■第25章代码调整策略
587
■第26章代码调整技术
609
代码大全(第2版)

<==========================498end ==============================>
<==========================499start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww ! -www.shubulo..!.com!仅供试看^

<==========================499end ==============================>