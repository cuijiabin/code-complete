<==========================700start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c!.com!仅供试看
28.1鼓励良好的编码实践
663
交叉参考有逐行复查代码代码复查通常包括程序员本人和至少两名评审员。这表明至
关复(review)少有3个人会逐行阅读全部代码。同事复查(peer review)的另一种称法是“同是压
的更多细节,请
参阅第21.3节力”。除了能为“原程序员离开项目”这情况提供一层安全保障外,复查还能
“正式检查”和改善代码的质量,因为程序员知道会有其他人阅读他的代码。即使你的小组还没
他类型的协同有明确地制定出编码标准,复查也会以种微妙的方式促成小组的编码标准
开发实践”。
°小组成员会在复查过程中做出一些决定,而随着时间的推移,小组会得出自己的
编码标准。
要求代码签名在其他领域里,技术图纸是要由管理工程师来认可和签字的。
一经签字就表明,该工程师所知这些图纸在技术上是可行的并且没有错误。些
公司也用相同的方法来管理代码。在认定代码完成code complete)之前,高级技术
人员必须在代码清单上签字。
安排一些好的代码示例供人参考优良管理中的一个重要方面就是清楚地表
达你的目标。传达你的这种目标的一条途径是给程序员传阅一些好的代码,或者
公开张贴出来。这样一来,你就用一份清楚的样例说明了自己的质量目标。类似
地,编码标准手册里也可以主要包含一份“最佳代码清单”。将一些代码列表选
定为“最佳的”,为别人树立起效仿的榜样这种手册更新起来要比用英语书写
的标准手册容易得多,而且它能很容易地将编码风格中的细微之处表达清楚,而
交叉考编程
这些用文字描述起来却是无比困难的。
很大程度上是
强调代码是公有财产程序员有时候会认为他写的代码是他“自己的代码”,
将你的工作与别就像私有财产一样。尽管这的确是他们的工作成果,但是代码属于项目的一部分,
沟通。如果想
做深入的了解,应该对项目组的其他人公开。即使其他时间都不公开,至少在代码复查和维护时
请参考第33.5节也要让别人看到
和第34.3节。
曾经报道过的最成功的一个项目是用11个工作年开发了8300行代码在投
入运行后的前13个月里只找出了一个导致系统失灵的错误。如果你得知这个项目
HARD DATA是在20世纪60年代后期完成的一当时还没有联机编译(online compilation)或者
交互式调试设施就更会觉得它所取得的成就很了不起了该项目所具有的生
产力在20世纪60年代末期每工作年编写7500行代码即使按照今天的
标准来看也仍然令人印象深刻。该项目的首席程序员在报告中说,项目成功的关
键因素之一就是把所有计算机的运行记录(无论有没有出错)都视为公有资产而
非私有财产(Backer and Mills 191973)这一观点延伸到了当今的很多环境(contexts)
中,如开源软件( Raymond2000)和极限编程所倡导的集体所有权(Beck2000
等。
代构大全(第2版)

<==========================700end ==============================>
<==========================701start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !--www.shubu.com!仅供试看
664
第28章管理构建
奖励好代码运用你所在机构的奖励机制来激励良好的编码实践。在开发你
的激励体制的时候,请把以下这些方面纳入考量:
所给予的奖励应该是程序员想要的。(很多程序员讨厌那种夸一句“好样的!”
式的奖励,特别是当它来自于非技术的管理人员的时候。)
只有非常出色的代码才应得到奖励如果你奖励个大家都知道他工作干
得不好的程序员,那么你看起来就像是正试图操作核反应堆的霍默·辛普
森。至于这位程序员是否有良好的合作态度或者上班是否准时都不重要。
如果你的奖励不符合技术标准,你将失去信誉。如果你的技术水平还没有
高到足以判断代码的优劣,那么就不要判断这时候千万不要奖励,或者
让你的团队来选择该奖励谁。
一份简单的标准如果你正在管理一个编程项目,并且你具有编程的背景,
那么有一种方法可以简单有效地获得好的工作成果,你宣称“我必须能阅读并理
解这个项目里的所有代码。”管理者不是技术尖这一事实反而有助于阻止产生
“聪明的”或者难理解的代码。
The Role of This Book
本书的角色
本书的大部分篇幅是在讨论良好的编程实践。其目的并不是想为呆板的标准
做辩护,更不想被用做一份呆板的标准。请用本书作为讨论的基础,把它看做良
好的编程实践的资料集,同时用它来找出那些可能对你的环境有益的实践。
28.2
Configuration Management
配置管理
软件项目是不断变化的。代码在变、设计在变、需求也在变。而且需求的变
化会引起设计上的更多变化,设计上的变化又会引起代码和测试用例的更多得多
的变化。
What Is Configuration Management
什么是配置管理
配置管理是“系统化地定义项目工件(project artifacts)和处理变化,以使项目
一直保持其完整性”的实践活动。它的另一种说法是“变更控制”。其中的技术
包括评估所提交的更改、追踪更改、保留系统在不同时间点的各历史版本。
如果你不对需求变更加以控制,那么就会为系统中某些最终会被去除的部件
1译注:霍默·辛普森是美国卡通连续剧“辛普森一家”中的父亲,担任春田核电厂安全检查员,他
非常喜欢开玩笑,经常有一些令人啼笑皆非的举动
代码大全(第2版)

<==========================701end ==============================>
<==========================702start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看^
28.2配管理
665
编写代码,也会去写出一些可能与系统中新的部件不兼容的代码。可能直到集成
时你才会发现这些不兼容的问题,这会导致一种手忙脚乱的局面,没人能知道将
会发生些什么。
如果不对代码的变更加以控制,你就可能会修改某个别人也正在修改的子程
序;想把两个人的改动成功地合并到一起将成为问题。不加控制的代码变更会让
代码看上去得到了更充分的测试。测试的可能是旧的、没修改过的版本;而改过
的版本也许还没有测试。如果没有良好的变更控制,你可能会修改某个子程序,
发现新的错误,但却再也无法恢复当初可以工作的老版本了。
这些问题产生的时间是不确定的。如果没有系统地对变更加以控制,你就相
当于在迷雾中随意游走,而不是直接向着一个清晰的目标迈进。如果没有好的变
更控制,与其说你是在开发代码,不如说是在浪费时间。配置管理会帮助你有效
地利用时间。
尽管配置管理的必要性是如此明显,几十年来还是有很多程序员不做这种管
理20多年前的一份调查表明,超过三分之一的程序员甚至还不熟悉这一概念
HARD DATABeck and Perkins1 1983),而且也几乎没有迹象表明这一情况有所改变。CU
软件工程研究所(Software Engineering Institute)最做的一份研究表明,在那些采
用非正规的软件开发实践的组织之中,不足20%的组织里有适当的配置管理(seI
2003)。
配置管理不是由程序员发明的,但由于编程项目是相当不稳定的,配置管理
对程序员特别有用。将其应用于软件项目,配置管理也通常称做“软件配置管理”
(CSM)。SCM关注于程序的需求、源代码、文档和测试数据。
SCM自身也有“过度控制”的问题。诚然,避免发生交通事故的最稳当办法
就是不让人们驾驶车辆,而一个肯定能防止产生软件开发问题的办法是停止所有
的软件开发活动。然而尽管这也是一种控制变更的方法,它却是开发软件的极端
糟糕的方法。因此你必须仔细地对SCM做出计划,发挥它的优势,避免给你带来
负担。
交叉参考如果
在小型的单人项目中,除了为非正式的周期性备份做出计划以外,你不用
想深入了解项目SCM或许还能做得不错。然而,配置管理仍然是很有用的(而且事实上,我在撰
规模对“构筑”
的影响,请参阅写本书手稿的时候就用到了配置管理在一个大型的50人的项目里,你多半需
第27章“程序规要使用全套的SCM方案,包括相当正规的备份过程、控制需求变更和设计变更,
模对‘构建’的
影响”。
以及对文档、源代码、内容、测试用例和其他项目工件全面进行控制。如果你的
项目不大不小,你就需要在以上两个极端情况之间某种正规(formality)的程度。下
面描述SCM实施中的一些可选项。
代超大全(第2版

<==========================702end ==============================>
<==========================703start==============================>

该书下载自书部落-分享计算机经典巨著!-ww. !--www.shubulo..com!仅供试看^
666
第28章管理构建
Requirements and Design Changes
需求变更和设计变更
交叉参考某些在开发过程中,你一定会有很多关于如何改善系统的想法。如果每产生一个
开发方法能更好想法就实施相应的变更,你会发现自己走上了软件开发的 treadmill(一系列似乎
地支持变更。如
果想对此做深入永不完结的工作)——虽然系统在发生变化,但却没有向着“完成”的方向迈进。
了解,请参考第以下是一些用于控制设计变更的指导原则。
3.2节“辨明你
所从事的软件的遵循某种系统化的变更控制手续如第3.4节所述,当你面临很多变更请求的
类型”
时候,系统化的变更控制手续宛如天赐之物。通过建立一套系统化的手续,你就
能将变更放在“在对系统整体最为有利”的环境下进行考虑。
成组地处理变更请求人们倾向于一有想法就去实现那些较容易的变更。这
种处理变的方法的问题在于,那些好的变更可能反而被丢掉了。如果你在项目
进行到25%的时候想起一项简单的变更,当时一切都正按计划进行,你就会去实
现该变更。如果你在项目进行到50%并且进度已经滞后的时候又想到了另外项
简单的变更,你多半不会去实现它。等到项目进行到最后,时间差不多用完了,
这时不管后一项变更是不是比前一项好上10倍,你都没有机会去做任何非本质性
的变更。有一些最好的变更就这样“逃过处理”其原因仅仅是因为你想到它的
时候为时已晚。
解决该问题的一种方法是,记下所有的想法和建议,不管它实现起来有多容
易。把它记录下来,直到你有时间去处理它们。到那时,把它当做整体(group)来
看待,从中选中最有益的一些变更来加以实施。
评估每项变更的成本每当你的客户、你的老板或者你自己想要修改系统的
时候,请评估做这些修改所需要花费的时间,包括对修改的代码做复查以及重新
测试整个系统的时间。在评估耗时的时候还要把这一变更导致的连锁反映(需求、
设计、编码、测试以及修改用户文档)的耗时考虑进去。让所有相关的人员知道
软件是杂乱地交织在一起的,让他们知道评估变更的耗时是必要的,哪怕要做的
变更看上去微不足道。
交叉考如果
想从另外一个角
无论第一次建议实施变更的时候你的感觉有多乐观,都不要草率地做出评估。
度了解如何处理这种评估的误差通常会有2倍甚至更高。
变更,请参阅第
3.4节中的“在提防大量的变更请求尽管变更在一定程度上是不可避免的,变更请求的数
构建期间处理需
求变更”。如果量太大仍然是一个很关键的警报信号,它表明需求、架构或者上层设计做得不够
想了解如何安全好,从而无法有效地支持构建活动对需求或者架构进行返工也许看上去代价昂
地处理代码变
更,请参阅第24贵,但是与“多次构建软件”或者“扔掉不需要的功能的代码”的高昂代价相比
章“置构。还是值得考虑的。
代码大全(第2版)

<==========================703end ==============================>
<==========================704start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.com!仅供试看^
28.2配置管理
667
成立变更控制委员会或者类似机构变更控制委员会的职责是在收到变更请
求的时候去芜存精。任何想提出更改的人都要把变更请求提交给变更控制委员会。
这里的“变更请求”是指任何可能改变软件的请求:有关一个新功能的想法,对现
有功能的更改,一份“错误报告”(可能报告了真正的错误,也可能没有)等等。
委员会成员定期开会复查提交的请求。它可能同意或不同意,也可能推迟有关请求。
人们认为变更控制委员会是一项“设定需求变更的优先级”以及“控制需求变更”
的最佳实践;然而,它们在商业环境中仍然应用得不够广泛(Jones1998, Jones2000)
警惕官僚主义,但也不要因为害怕官僚主义而排斥有效的变更控制缺乏规
范的变更控制是当今软件业面临的主要管理难题之一有相当大一部分进度落后
的项目本来是可以按时完成的,如果他们原来就考虑了那些“未做跟踪但却同意
执行的变更”的话。糟糕的变更控制会导致变更堆积如山,从而破坏了项目状态
的能见度、长期的可预见性、项目计划,尤其破坏风险管理,破坏了一般意义上
的项目管理。
变更控制倾向于滋生官僚主义,所以重要的是要找到一些简化变更控制过程的
方法。如果你不愿意采用传统的变更请求,那么就简单地设置一个名为“变更委员
会Change Board”电子邮件账号,然后让大家把他们的更改请求发送到这个地址。
或者是让人们在变更委员会的会议上互动地提出他们的变更建议。有种特别有效
的方法是把所有的变更请求都作为缺陷记录在你的缺陷跟踪系统里。有些纯化论者
会把这些变更归入“需求缺陷”一类,你也可以把它们归为“变更”而不是缺陷。
你既可以正式地实施变更控制委员会制度,也可以设立一个产品计划组或者
作战委员会,由它们来执行变更控制委员会的传统职责。再者,你也可以指派某
一个人来当“变更独裁者”。无论怎么称呼,都要去做!
偶尔我也会遇到因为变更控制做得笨手笨脚而饱受折磨的项目不过我见过的由
于没做有意义的变更控制因而饱受折磨的项目是前者的10倍。变更控制的实质就是
KEY POINT确定什么最重要,所以不要因为害怕官僚主义就不去享受变更控制的诸多益处
Software Code Changes
软件代码变更
配置管理的另一项内容是源代码控制。如果在你修改代码以后新产生了一个
错误,并且看上去与你所做的更改无关,那么在你寻找问题的根源的时候,很可
能希望拿代码的新版本与老版本做对比。如果从比较中看不出什么线索,你可能
还想看更早的版本。如果你使用了能够记录源代码的各个版本的版本控制工具
(version-control- tools),那么这种版本历史回溯的操作就会是小菜一碟。
代大全(第2版)

<==========================704end ==============================>
<==========================705start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubu.com!仅供试看^
668
第28章管理构建
版本控制软件优良的版本控制软件的用起来很轻松,你几乎察觉不到自己
在使用它。此类软件尤其适用于团队项目。有一种风格的版本控制会锁住源文件,
KEY POINT以确保同一时间只能有一个人修改该文件。通常,当你希望编辑某一个文件中的
源代码的时候,你要把这个文件从版本控制系统中 check out(签出)。如果已经
有人将它 check out,你会得到提示说你无法 check out旦你能 check out该文件,
对其进行修改和“没有使用版本控制软件时”没什么两样一直到你准备把它
check in(签入)。另一种风格的系统允许多人同时编辑文件,然后在 check in代
码的时候处理“合并改动”的问题。对于任何一种情况,当你签入文件的时候,
版本控制软件都会询问你更改的原因,你得回答一个理由。
从这样一种适度的投入中,你可以获得如下一些重大益处。
别人正在修改某一文件的同时,你修改这个文件不会和他发生冲突(如果冲
突了,至少你能知道这一点)。
你能方便地将你机器上的全部项目文件的复本更新到当前版本,通常这只需
要执行一条简单的命令。
你可以回溯到任何文件的任意版本,只要它曾经被 check in到版本控制系统
中。
你可以获得一份对任何文件的任意版本所做的更改的清单。
你无须担心个人文件备份,因为版本控制提供了安全保障。
版本控制对于团队项目来说是必不可少的。当把版本控制、缺陷跟踪和变更
管理整合到一起的时候,其威力会更大。 Microsoft公司的应用程序部门甚至认为
其专有的版本控制工具是一项“主要竞争优势”(Moore1992)。
Tool Versions
工具版本
对于某些种类的项目而言,可能需要有“重新构造出‘创建软件的各个特定
版本’的原样环境”的能力,包括编译器、链接器、代码库等。在这种情况下,
你也要把所有这些工具也都纳入版本控制之中。
Machine Configurations
机器配置
很多公司(包括我的公司)都因创建了标准的开发机器配置而受益。这些公
司会为标准的开发工作站生成一份磁盘映像其中包括全部常用的开发工具和办
公软件等软件。然后将这一映像文件加载到每位开发者的机器上采取标准化配
代码大全(第2版)

<==========================705end ==============================>
<==========================706start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
28.2配置管理
669
置有助于避免因为“配置略有不同”或者“使用工具的版本不同”等等原因造成
的许多麻烦。与单独安装每一种软件相比,使用标准化的磁盘映像还极大地简化
了机器的安装过程。
Backup Plan
备份计划
备份计划(baskup plan)并不是个全新的概念;它指的是定期备份你的工作。
如果你正在手写一本书,那么是不会把书稿堆在走廊里的。不然的话,书稿可能
被雨淋湿,被风吹走,或者被你邻居家的小狗借回去垫窝。你把它放在某个安全
的地方。软件不像纸张一样真实有形,所以你可能容易忘记了自己把一些非常重
要的东西只放在了一台机器上。
对计算机里的数据而言,各种情况都有可能发生:磁盘可能会损坏;你或别
人可能会意外地删掉了某个关键的文件;一位愤怒的员工可能会破坏你的机器
你也可能会遭遇盗窃、洪水或者火灾等事件而失去一台机器。请采取一些措施米
保护你的工作成果。你的备份计划应该包括定期进行备份,并且定期地将备份介
质转移到脱机存储设施里。除了源代码以外,还应该备份你项目中的所有重要资
料——文档、图表、笔记等。
在制定备份计划的时候,人们常常忽略的一点是:要测试你的备份过程。应
该找个机会试着进行一次数据恢复,以确认备份数据中包含了你所需要的全部数
据,并且可以成功地恢复。
在你做完一个项目后,要对该项目进行归档。把所有的东西都保存下来:源
代码、编译器、工具、需求、设计、文档重新创建该产品所需的一切事物。
要把它都放在一个安全的地方。
CHECKLIST: Configuration Management
ccc0核对表:配置管理
概要
口你的软件配置管理计划是否用于帮助程序员,并能将额外负担降至最低?
口你的软件配置管理方法是否避免了对项目的过度控制?
口你是否将一些变更请求聚成一组?无论采用非正式的方法(如创建一份末
决更改的列表)还是更加系统的方法(如设立变更控制委员会)
口你系统地评估了每一项提交的更改对成本、计划和质量的影响吗?
口你是否把重大的变更看做是需求分析还不够完备的警报信号?
代大全(第2版)

<==========================706end ==============================>
<==========================707start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看
670
第28章管理构建
工具
口你用版本控制软件来促进配置管理吗?
口你用版本控制软件来减少团队工作中的协调问题吗?
备份
口你定期地备份项目中的所有资料吗?
口你定期地把项目备份数据转移到off- -site storage果了吗?
口所有的资料,包括源代码、文档、图表和重要的笔记都得到备份了吗?
口你测试过备份与恢复的过程吗?
Additional Resources on Configuration Management
有关配置管理的更多资源
cc2e.com/2850
因为本书是关于软件构建的,所以这一节是从构建的眼光看待变更控制。但是
变更会从各个层次上对项目造成影响,因此一个全面的变史控制策略也要考虑各个
层次的问题。
Hass, Anne Mette Jonassen. Configuration Management Principles and Practices )
Boston MA Addison-Wesley-2003这本书描述了软件配置管理的全景,也讲述了如何
把软件配置管理融入你的软件开发过程之中的实践细节。其着眼点在于配置项
(configuration itcms)的管理和控制。2
Berczuk, Stephen P. and Brad Appleton. Software Configuration Management
Patterns: Effective Teamwork, Practical Integration). Boston, MA: Addison-Wesley,
2003与Hass的那本书相似,这本书就软件配置管理的全景做出了描述,颇具实用
中开发者分隔并且协调他们的工作。子
性。作为对Hass书内容的补充,书中提出了一些实用的指导原则,用于指导团队
cc2e.com/2857
SPMN. Little Book of Configuration Management). Arlington VA Software
Program Managers Network,1998这是一本介绍配置管理活动的小册子,其中详细
说明了评判成功的各个因素你可以在SPM网站
www.s.com/ www.spmn.com/products_guidebooks . html.guidebooks.html免费下载该手册。
Bays, Michael. Software Release Methodology) Englewood Cliffs, NJ: Prentice
Hall,1999.本书侧重于从“将软件作为产品来发布”的角度讲解软件配置管理。
Bersoff, Edward H., and Alan M. Davis. "Impacts of Life Cycle Models on Software
Configuration Management. Communications of the ACM 34, no. 8 (August 1991): 1()4
118.这篇文章描述了软件开发的一些新方法特别是原型(prototyping)法是如
何影响软件配置管理的。本文尤其适用于那些采取敏捷开发实践的环境。
2译注:影印版《配置管理原理与实践(影印版)》,清华大学出版社;中译本《配置管理原理与实
践》,清华大学出版社。
3译注:中译本《软件配置管理模式》,中国电力出版社。
代码大全(第2版)

<==========================707end ==============================>
<==========================708start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
28.3评估构建进度表
671
28.3
Estimating a Construction Schedule
评估构建进度表
软件项目管理是人类在21世纪面临的一项重大挑战评估项目的规模和完成
项目所需的工作量是软件项目管理中最具挑战性的方面之一平均水平的大型软
HARD DATA
件项目都要超时一年,并且超过预算经费100%才能完成( Standish Group1994
Jones 19997, Johnson1999)。在个人层面上对预估进度表和实际进度表的调查
显示,开发人员的估计值比实际值要乐观20%~3%(van Genuchten1991)这
既与“对项目规模和工作量的评估”不准确有关,也与开发不力有关本节将讨
论评估软件项目所涉及的一些问题,并指出到何处去获取更多的信息
Estimation Approaches
评估的方法
你可以采取以下几种方法来评估项目的规模和完成它所需要的工作量。
深入阅读若想使用评估软件
了解更多的进度
评估技巧,请参见使用算法方法,如 Cocomo II,这是 Barry Boehm提出的评估模型(Boehm et
Rapid Develop-
al.2000)。
ment)( MoConnell
1996】第8章和聘请外界的评估专家来评估有关项目。
Software Cost为评估举行排练(wak-through)会议。
Estmation with Co
como( Boehm评估项目的每一部分,然后把它们加起来。
ea.00
注:中译本分别为让成员评估各自的任务,然后再把各任务的评估值加起来。
发》,电子工业出参考以往项目的经验。
版社;《软件成本保留以往项目的评估,查看其准确度。用它来调整新的评估。
1模型方法》,机
你可以在本节最后“有关软件评估的额外资源部分获取有关这些方法的更
械工业出版社。】多信息。下面是一套评估项目的好方法。
深入阅读这种建立目标你为什么需要评估?你在评估什么?你只评估构建活动还是评估所
方法取自 Softw
are Engineering有的开发活动?你只评估项目需要的工作量,还是把休假、节假日、培训和其他非项
Economicsnonproject)的活动也都算进去?需要什么样的评估准确度才能达到你的目标?评
Boehm1981估需要达到什么样的确定度?乐观评估与悲观评估会产生截然不同的结果吗?
【
注:中译本
软件工程经济
学,机械工业出
为评估留出时间,并且做出计划匆匆忙忙的评估是不准确的。如果你在评
版社。】
估一个大型项目,那么就要把评估当作一个“迷你项目/mini project”来做,并且
要花时间为评估制定“迷你计划/miniplan”,以使你能做得好。
代大全(第2版

<==========================708end ==============================>
<==========================709start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
672
第28章管理构建
交叉参考关于清楚地说明软件需求就像建筑师无法估算一座“相当大”的房子要花费几
软件需求的更多
信息,请参阅第何一样,你也无法可靠地评估一个“相当大”的软件项目。当要做的事情还没确
3.4节“需求的先
决条件”。
定下来的时候,无论是谁想让你对完成这些事情所需要的工作量做出评估的都是
不切实际的。在评估之前要先定义需求,或者计划出一个预估过程。
在底层细节层面进行评估依据你瞄准的目标的不同,评估要建立在对项目
各项活动做出详细考查的基础之上。一般而言,你考查得越详细,你的评估结果
就会越准确。人数定律说的是,如果估计有10%的误差,而你只对整体做一次估
计的话,结果可能高出10%也可能低出10%如果分成50个小块再估计,某些块
的估计会偏高,某些块的估计会偏低,而这些误差趋向于相互抵消。
交叉参考在软
件开发中,很难
使用若干不同的评估方法,并且比较其结果本节一开始列出了许多评估方
找出一个不适合法。它们的评估结果并不完全一样,所以请试着多用种方法,并研究不同方法
采用迭代法的领
域。迭代对于评所产生的不同结果。小孩们很早就知道,如果分别向父母两个人索要一碗冰淇淋,
估非们也会聪明起来,给出一致的回答:但有时却不会。看看你能从不同的评估方法
有用。第
34.8节
比仅仅向父亲或母亲索要的成功率要高些(而且可能要到两碗)。有些时候家长
迭代技术作了总中获得哪些不同的回答吧。
结
没有哪种方法在所有情况下都是最佳的,研究这些方法之间的不同之处会得
出很多启示。例如,在写本书第一版时,我最初粗略估计书的厚度会是250至300
页。当我最终做了一次深入的评估之后,评估结果变成了873页。“这不可能。”
我当时想,于是我又用另外一种截然不同的方法去评估。这第二次评估的结果是
828页。考虑到这些评估之间的差距大约在5%以内,我得出结论,认为书的厚度
会更接近于850页(而不是250页),于是我又对我的写作计划做了相应的调整。
定期做重新评估软件项目的一些因素会在最初评估后有所变化,因此要计
划好定期进行重新评估。如图28-2所示,项目越接近完成,评估的准确度应该越
高。要不时地将评估结果和实际结果进行比较衡量,用这一衡量结果来改善你对
项目剩余部分的评估
代码大全(第2版)

<==========================709end ==============================>
<==========================710start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! -www.shubulo.com!仅供试看^
28.3评估构建进度表
673
cc2e.com/286项目评估的变化范围
工作量,成本或特征)
4x
2x
1.5x
1.25x
1.0x
0.8x
0.67x
0.25x
Time
图28-2项目早期的评估结果注定不会很准确。随着项目推进,评估的准确度会越来
越高。在项目进行过程中要定期地重新评估,用你在每一项活动中学到的知
识去改进你对下一项活动的评估
Estimating the Amount of Construction
评估构建的工作量
交叉参考如果构建能给项目进度造成多大范围的影响,部分地取决于“构建”在项目中所
想详细了解不同
规模的项目的编占的比例。“构建”可以理解为详细设计、编码与调试、单元测试等。请再看一
码工作量,请参下第654页上的图27-3。图中显示“构建”所占的比例随着项目规模的不同而
阅第27.5节中
的“活动比例和变化。除非你的公司保存有以往项目的历史数据,否则图中显示的“各种活动所
项目规模”。
占时间的比例”是进行新项目评估的不错的出发点。
关于“项目中‘构建’活动占多大比例”这一问题,最佳的答案是:这个比
例会随着项目以及组织机构的不同而不同。请把你的组织的项目经验记录下来,
然后用它来评估未来项目需要花费多少时间。
代码大全(第2版)

<==========================710end ==============================>
<==========================711start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看^
674
第28章管理构建
Influences on Schedule
对进度的影响
交叉参考程序对软件项目进度影响最大的是所开发的程序的规模。但是很多其他因素也会
的规模对生产力
和质量的影响并对软件开发的进度造成影响。一些针对商业应用程序做的研究已将部分因素的影
不总是很直观的。响效果做了量化,如表28-1所示。
请参阅第27
“程序规模对构
表28-1影响软件项目工作量的因素
建的影响”以了因素
潜在的有益的影响潜在的有害的影响
集中开发vs.分散开发
-14%
22%
数据库大小
10%
28%
满足项目需要的文档
19%
23%
在解释需求方面的灵活度
9%
10%
处理风险的积极程度
-12%
14%
语言经验和工具经验
16%
20%
人员连贯性(流动性)
19%
29%
平台稳定性
-13%
30%
过程成熟度
-13%
15%
产品复杂度
-27%
74%
程序员个人能力
24
34%
所需的可靠度
-18%
26%
需求分析师的个人能力
-29%
42%
对重用的要求
-5%
24%
最新技术水准的应用程序
11%
12%
存储限制(要使用多少可用的存储资源)0%
46%
团队凝聚力
-10%
11%
团队在该应用领域的经验
19%
22%
团队在该技术平台上的经验
15%
19%
应用程序自身的)时间限制
0%
63%
对软件工具的使用
22%
17%
来源:《 KSoftware Cost Estimation with Cocomo》(Boehm et al.2000)
以下是一些能影响软件开发进度,但不易被量化的因素。这些因素选自于
Barry Boehm Software Cost Estimation with Cocomo II) (2000) Capers Jones
的《Estimating Software Costs》(1998)
需求开发者(Requirements developer)的经验和能力
■程序员的经验和能力
代码大全(第2版)

<==========================711end ==============================>
<==========================712start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo. com!^ .com!仅供试看
28.3评估构建进度表
675
团队的动力
管理的质量
重用的代码数量
人员流动性
需求变更
客户关系的质量
用户对需求的参与度
客户对此类应用软件的经验
程序员对需求开发(requirements development)的参与程度
计算机、程序和数据的分级安全环境
■文档量
项目目标(进度、质量、可用性以及其他可能的目标)
这里列出的每一项因素都可能很重要,因此请与表28-1中列出的因素(其中
也包括了这里的某些因素)一同考虑。
Estimation vs. Control
评估与控制
重要问题是你
为了按时完成软件项目而做的“计划”中,评估是很重要的组成部分一旦
是想预测,还是你确定了交付日期和产品规格书剩下的主要问题就是如何控制人员和技术资源
想控制?
Tom Gilb
的开销,以便能按时交付产品。从这个角度上来说,最初评估的准确度的重要性
远远比不上你“随后为了完成进度而成功地控制资源”的重要性。
What to Do If You're Behind
如果你落后了该怎么办
本章前面曾提到,项目平均会超出原定完成时间的100%。当你落后的时候,
增加时间通常并不可行。如果可行的话,就那么做。否则你可以采取以下的一种
或者几种解决方案。
希望自己能赶上当项目落后于进度安排时,人们通常的反应是对此抱有乐
观态度。通常人们的理由是:“‘需求’所用的时间比我们预期的要长,但是现
HARD DATA在需求已经固定下来了,所以我们一定会在后面省下时间。我们将会在编码和测
试阶段把时间补回来。”这种情况几乎不会发生。一项对300个软件项目展开的
调查显示,越接近项目后期,延误和超支的现象就越严重( van Genuchten1991)
项目并不能在后期把时间补回来;而是会越来越落后。
代码大全(第2版)

<==========================712end ==============================>
<==========================713start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubu.com!仅供试看^
676
第28章管理构建
扩充团队根据 Fred Brooks定律,往一个已经落后的软件项目里加人手只会
使得它更加落后(Brooks1995)。这无异于火上浇油。 Brooks的解释是很有说服
力的:新手需要先花时间熟悉项目,然后才能发挥出生产率。培训他们就要占用
已受训人员的时间。而且,仅仅增加人员数量,会导致项目交流的复杂度和数量
也增加。 Brooks指出,一位女可以怀胎十月诞下一子,并不意味着10位妇女能
只用一个月时间生下一个孩子。
毫无疑问, Brooks定律中的警告应该更多地引起关注。人们往往乐意往一个
项目中增派人手,希望他们能让项目按时完成管理者们需要了解,开发软件和
铆接金属板是不一样的:更多的工人在工作并不一定意味着能做更多的工作
然而,简单地说,“往一个延期的项目里增加人手会让它延期更久”却掩盖
了这样一个事实,那就是在某些场合下,往延期的项目里增加人手是能够让它提
速的。正如 Brooks在分析这一定律时所说的,如果个项中的任务不可分割、
不能个个击破,那么增加人手是无济于事的。但如果项目中的任务可以分割,那
么你就可以把它进一步分细,然后分配给不同的人来做,甚至可以分配给项目后
期才加入进来的人。其他一些研究人员已经正式地定义出了“在哪些场合下你可
以往一个延期的项日中增加人手,而不会导致该项目更加落后”(Abdel-Hamid-
1989, McConnell1999)。
课入阅读如果
缩减项目范围缩减项目范围这一强大的技术常会为人们所忽略。如果你去
想了解“只构建
最需要的特性”掉了一项特性,你就除去了相应的设计、编码、调试、测试和编写文档工作。你
的话题,请参考也删除了该特性和其他特性之间的接口。
(Rapid
Development当你最初做产品计划的时候,要把产品的功能划分成“必须有”、“有了更
McConnell好”和“可选择”三类。如果进度落后了,那么就调整“可选择”和“有了更好”
1996的第14
“Feature-S-st的优先级,并仍掉那些最不重要的功能。
Control".
如果做不到完整地去掉某项特征,那么还可以提供一个该功能的简化版本
你可以按时地交付一个尚未进行性能调校的版本。你也可以提供一个版木,其中
最不重要的功能的实现相当粗略。你可以放松对速度的要求,因为提供一个速度
较慢的版本会容易得多。你也可以放松对空间的要求,因为提供一个占用更多内
存的版本会容易得多。
重新评估实现那些非重要特性的开发时间。在两小时、两天或者两星期之内
你能提供什么功能?“花两星期打造的版本”比“花两天打造的版本”好在哪里?
“花两天打造的版本”比“花两小时打造的版本”好在哪里?
代码大全(第2版

<==========================713end ==============================>
<==========================714start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^ ^.com!仅供试看
28.4度量
677
Additional Resources on Software Estimation
有关软件评估的更多资源
cce.om/2871下面是一些关于软件评估的额外资源:
Boebm, Barry, et al. Software Cost Estimation with Cocomo>. Boston, MA:
Addison-Wesley-,2000.这本书全面讲述了当今最流行的 Cocomo评估模型的来
龙去脉。
Boehm, Barry W. KSoftware Engineering Economics. Englewood Cliffs, NJ:
Prentice Hall,1981.这本较早的书对软件项目评估做出了详细的描述,其内容要比
Boehm的新书的内容更为通用。
Humphrey, Watts S. KA Discipline for Software Engineering). Reading, MA:
Addison-Wesley-,1995.书中的第5章讲述了 Humphrey的探查( Probe)方法,该
方法可在开发者个人层面上评估工作量。
Conte, S. D., H. E. Dunsmore, and V. Y. Shen. KSoftware Engineering Metrics
and Models》. Menlo Park,ca: Benjamin/Cummings,1986.第6章包含一份有关各
种评估方法的很不错的综述,其中包括评估的历史、统计模型、基于理论的模型
以及复合模型。本书还展示了各种评估方法的应用,针对一个项目的数据库,并
且相对于项目的实际长度比较了有关评估结果
Gilb, Tom. (Principles of Software Engineering Management). Wokingham,
England: Addison-Wesley-,1988.第16章的标题“评估软件特性的10项原则”有
点半开玩笑。Gilb反对进行项目评估,赞成进行项目控制。他指出,人们并不是
真正希望进行准确的预测,而是希望能控制最终的结果。Gilb给出了10条原则,
用来控制项目以使其满足最后期限、成本目标或者其他项目目标。
28.4
Measurement
度量
度量软件项目有很多种方法。以下是对项目进行度量的两项根本原因
任何一种项目特征(attribute)都是可以用某种方法来度量的,而且总会比根本
不度量好得多度量结果也许不会完全精确度量也许很难做,而且也许需要持
KEY POANT续地改善结果,但是它能使你对软件开发过程进行控制,而如果不度量就根本不
可能控制(Gilb2004)。
如果有些数据要用于科学实验,那么就必须进行量化。你能想象一位科学家
建议禁止某种新食品,仅仅因为一组小白鼠比另一组“看上去更病态”吗?这太
荒谬了。你会要求一个量化的理由,比如“吃了新食品的小鼠每月的生病时间要
比对照组的小鼠多3.7天”。为了评价软件开发方法,你就必须对它进行度量
类似“这种新方法看上去生产率更高”的说法是欠妥的。
代大全(第2版)

<==========================714end ==============================>
<==========================715start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww !--www.shubulo.c.com!仅供试看^
678
第28章管理构建
量得到才能做得留心度量的副作用度量会对动机产生影响。人们会对那些被度量的事物更
出。
-Tom Peters
加用心,他们认为度量的目标是在评价他们。要谨慎地选择哪些环节需要被度量。
人们会倾向于集中做那些被度量的工作,而忽视未被度量的工作。
反对度量就是认为最好不要去了解项目中到底在发生什么在你度量项目的
某个环节时,你会获得一些前所未有的认识你能看出这一环节是变大了、变小
了还是没有变。透过度量,你至少打开了一扇能看到项目的这一环节的窗户。如
果你不对度量做出精化的话,那么这扇窗户可能会很小很朦胧,但是总比没有
窗户好得多。由于某些因素不确定就反对进行一切度量,就像因为某些窗户碰巧
很朦胧就反对所有窗户一样。
事实上,你可以对软件开发过程中的任何环节进行度量。表28-2列出了一些
其他从业者认为有用的量度。
表28-2有用的软件开发的度量环节
规模
整体质量
编写的代码总行数
缺陷总数
注释总行数
每个类或子程序的缺陷数
类或者子程序的总数
每千行代码的平均缺陷量
数据声明的总数
两次系统“失灵”之间的平均时间
空行总数
编译器检测到的错误数量
缺陷跟踪
可维护性
每个缺陷的严重级别
每个类的 public子程序数量
每个缺陷的位置(类或子程序)
传给每个子程序的参数数量
每个缺陷的根源(需求、设计、构造、每个类的 privateprivate子程序和/或变
测试)
量的数量
更正每个缺陷的方法
每个子程序使用的局部变量的数量
每个缺陷的责任人
每个类或子程序调用的子程序的数量
每更正一个缺陷所涉及的代码行数
每个子程序中决策点的数量
更正每一个缺陷所花费的工作小时数每个子程序中控制流的复杂度
找出每一个缺陷所需的平均时间
每个类或子程序中包含的代码行数
更正每一个缺陷的平均用时
每个类或子程序中的注释行数
更正每个缺陷的尝试次数
每个类或子程序中数据声明的数量
因更正缺陷而引发的新错误数量
每个类或子程序中的空行数量
每个类或子程序中使用goto的数量
每个类或子程序中输入语句或输出语
句的数量
生产率
项目花费的工作小时数
每个类或子程序花费的工作小时数
每个类或子程序的修改次数
项目花费的钱数
每行代码花费的钱数
每个缺陷花费的钱数
代码大全(第2版)

<==========================715end ==============================>
<==========================716start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看
28.4度量
679
你可以使用当前已有的软件工具来获得这其中的大多数度量数据。贯穿本书
的讨论指出了“每一种度量都很有用”的理由。目前,这其中的大多数度量都还
不能区分程序、类、子程序的细致差别(Shepperd and Ince1989)。它最主要的作
用是识别出那些看起来像“局外人”的子程序;如果某个子程序的度量数据很离
奇,这就是一个警告信号,说明你应该重新审视该子程序,查明导致其质量显著
偏低的原因。
不要一开始就收集全部可能得到的度量数据——你将会置身于复杂数据的汪
洋大海中,而无法领悟哪怕其中任何一项数据的含义。应当从一组简单的度量数
据开始,比如缺陷数量、工作月数、总费用以及代码总行数。在你的项目范围内
为这些度量进行标准化,然后加以精化,随着你对‘希望度量什么的理解的进
展加入一些新的度量内容( Pietrasanta1 1990)
确认你收集的数据是有理由的。制定目标,确定为了实现这一目标需要问哪
些问题,然后再做度量,以此回答这些问题(Basili and Weiss1984)你问的信
息必须是可以获得的,还要记住,项目的最后期限永远比收集数据更重要(Basili
etal.2002)。
Additional Resources on Software Measurement
有关软件度量的额外资源
cc2com/2878下面是一些额外资源。
Oman, Paul and Shari Lawrence Pfleeger, eds. KApplying Software Metrics). Los
Alamitos,ca: IEEE Computer Society Press,196.本集收录了超过25篇有关软件
度量的关键论文。
Jones, Capers. Applied Software Measurement: Assuring Productivity and
Quality,2ded. New York,ny: McGraw-hil,1997. Jones是软件度量界的领袖,
他的书籍中汇集了这一领域的知识。书中讲述了当今度量方法的权威理论和实践,
并描述了传统度量手段的缺陷。书中给出了一个完整的用于收集“功能点数据”
的程序。 Jones曾收集分析大量有关质量和生产力的数据,并将分析结果提炼到本
书中一其中有一章非常精彩地描述了美国软件开发的平均水平。
代码大全(第2版)

<==========================716end ==============================>
<==========================717start==============================>

该书下载自-书部落分享计算机经典巨著!-ww. ! --www.shubuld.com!仅供试看
680
第28章管理构建
Grady, Robert B. Practical Software Metrics for Project Management and
Process Improvement》. Englewood Cliffs,nj Prentice Hall PTR,1992. Grady讲述了
惠普公司在建立软件度量程序时获得的经验和教训,并且告诉你该如何在你的组
织。
Conte,. D., H. E. Dunsmore, and V. Y. Shen Software Engineering Metrics
and Models》. Menlo Park,ca: Benjamin/Cummings,1986.本书编录了截止到1986
年的软件度量方面的知识,包括常用的度量方法、实验技术以及实验结果的评判
标准。
Basili, Victor R., et al. 2002. "Lessons learned from 25 years of process
improvement: The Rise and Fall of the NASA Software Engineering Laboratory,
Proceedings of the 24th International Conference on Software Engineering.
Orlando,fl,2002.这篇文章收录了世界上最尖端的软件开发组织之(指naSA
软件工程实验室)的经验和教训,集中反映在度量这个话题上。
ce2e.com/2892 nasa software engineering laboratory. KSoftware Measurement Guidebook),
june1995,nasa-gb-001-94.这本大约100的手册可能是有关“建立和运作度
量程序”的实用信息的最佳来源。该手册可以从NASA的网站上下载。
cc2e.com2899
Gilb,tom.《 Competitive Engineering》. Boston, MA Addison-Wesley-,2004.本
书讲述了一种以度量为中心的方法,可以用该方法来定义需求、评估设计、度量
质量,以及一般意义上的项目管理。本书可以从Gilb的网站上下载
28.5
Treating Programmers as People
把程序员当人看
由于编程活动的抽象性,人们提倡更自然的办公环境以及合作者之间的充分
交流。高科技公司常会向其员工提供公园般的公司园区、有机的组织结构、舒服
PONT的办公室以及其他“high-touch-”的环境,借此平衡这种有时显得枯燥的智力密集
型工作。最成功的科技公司能将高科技(high-teh)和high- -touch的元素糅合到一起
(Naisbitt 191982)。本节将会从多个视角出发,说明程序员并非只是与硅芯片打交
道的有机物。
代码大全(第2版)

<==========================717end ==============================>
<==========================718start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
28.5把程序员当人看
681
How Do Programmers Spend Their Time
程序员们怎样花费时间
程序员不仅在编程上花时间,也要花时间去开会培训、阅读邮件以及纯粹
思考。Bell实验室在1964年做的一份研究显示程序员在各方面所花的时间如表
28-3所列。
表28-3有关程序员如何分配时间的一种观点
活动
邮件各技术
工作程序
源代码业务个人会议培训种文件手册方法等测试总计
说或者听
4%17%7%3%
1%
32%
和管理人员谈话
1%
1%
打电话
2%1%
3%
阅读
14%
2%2%
18%
写/记录
13%
1%
14%
离开或外出
4%1%4%6%
15%
步行
2%2%
1%
1%
6%
杂项
2%3%3%
1%
1%1%11%
总计
35%29%13%7%6%5%2%2%
1%100%
来源:《Research Studies of Programmers and Programming》( Bairdain 19196,载于 Boehm1981)
以上数据基于一项针对70位程序员的时间和活动所进行的研究。这些数据已
经很旧,而且不同的程序员花费在各项活动上的时间比例也不尽相同,但是其结
果还是发人深省的。一个程序员大约有30%的时间花费在“对项目没有直接好处”
的非技术活动之上:步行、个人事务等。这份调查中,程序员有6%的时间花费在
走路上;这相当于一星期有2.5个小时、一年有25个小时会花费在走路上。这
看上去似乎不算什么,但是一旦你认识到程序员每年花费在走路上的时间和花费
在培训上的时间相等,并且三倍于他们阅读技术手册的时间,六倍于他们和管理
人员谈话的时间之后,你就会有所感悟了。我个人至今也没有看到这一模式有多
大改变。
Variation in Performance and Quality
性能差异与质量差异
不同程序员在天分和努力程度方面的差别十分巨大,这一点与其他所有领域
都一样。一项对不同职业——写作、橄榄球、发明、治安和飞行器导航做的
HARD DATA
调查研究表明,最顶尖的20%人员的产出占全部的50%( Augustine1979)。这一
研究结果基于对生产率数据的分析,如触地得分、专利数量、侦破的案件数量等。
由于有些人因为没有做出切实的贡献而未被包括在调查当中(如没有得分的橄榄
球运动员、没有专利的发明家、没有破案子的侦探等),因此,这份数据可能还
低估了生产率的实际差异。
代码大全(第2版)

<==========================718end ==============================>
<==========================719start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubul.com!仅供试看^
682
第28章管理构建
具体到编程领域,很多研究都已表明,在编写的程序的质量、编写的程序的
大小以及程序员的生产率等方面,(最好的与最坏的)都有着一个数量级的差异。
Individual Variation
个体差异
有关程序员编程生产力的个体差异的最早一项研究是由 Sackman、 Erikson和
Grant在20世纪60年代末期做出的(Sackman, Erikson, and Grant1 1968)他们对
HARD DATA平均工作经验为7年的专业程序员进行了调查,发现最好和最差程序员的初始编
码用时比例为20:1,调试用时比例为25:1,程序规模比例为5:1,程序执行速度比
例为10:1。他们并未发现程序员的经验与代码质量或生产率之间有什么关联。
尽管像25:1这样具体的比例并不是特别有意义但是像“程序员之间有着数
量级的差异”这样更一般的陈述的意义却是很明确的,并且已经被其他许多针对
HARD PATA专业程序员的研究所证实(Curtis198, Mills 11983, DeMarco and Lister1985, Curtis
et al. 1986, Card 1987, Boehm and Papaccio 1988, Valett and McGarry 1989, Boehm
etal.2000)
Team Variation
团队差异
不同的编程团队在软件质量和生产率上也存在着相当大的差异。好的程序员
倾向于聚集在一起,差的程序员也是一样,这一观察由一项针对18个组织中的
166名专业程序员所做的研究所证实(Demarco and Lister1 1999)。
一项针对7个相同的项目做的研究表明,其花费的工作量的变化范围大到
3.4:1,程序规模之比为3:1(Boehm, Gray and Seewaldt1 1984)尽管存在这样的
HARD DATA生产率差异述研究中的程序员的差别却并不大。他们都是有多年经验的专业
程序员,并且都是计算机科学专业的研究生毕业。由此可以合理地推断出,如果
被研究的团队并不是特别地相像,那么存在的差异将会更加巨大。
更早的一份对多个编程团队做的研究发现,不同团队完成相同的项目,其程
序规模之比为51,花费的时间之比为2.6:1( and Schulman1974)
在为了创建 Cocomo评估模型而对超过20年的数据进行了研究之后, Barry
Bochm和其他的研究人员得出结论,认为一个由“程序员能力等级在第15个百分
HARD DATA点”的人员组成的团队,其开发应用程序需要花费的工作月数是“程序员能力等
级在第90个百分点”的人员组成的团队的3.5(Boehm et al.2000) Boehm和
其他研究人员发现,80%的贡献来源于20%的贡献者(Boehm1987b)
代码大全(第2版)

<==========================719end ==============================>
<==========================720start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com!.com!仅供试看
28.5把程序员当人看
683
这其中的含义对于招聘和录用来说是非常清晰的如果你为了聘请到前10%
最优秀的程序员而需要(比雇佣后10%最差劲的程序员〕多支付报酬,那么就请
欣然接受这一现实。你会因为所聘用的程序员的高品质和高生产力而迅速得到回
报,而且这么做还有一个剩余效应,那就是你的组织中其他程序员的品质和生产
力不会下降,因为好的程序员倾向于聚到一起。
Religious Issues
信仰问题
不是所有编程项目的管理者们都会认识到,有一些编程问题与信仰有关。如
果你是一名管理者,并且试图要求统一某些编程实践,那么就可能会激怒你的程
序员。下面就是事关信仰的一些问题:
■编程语言
■缩进风格
大括号的摆放位置
所用的集成开发环境
■注释风格
效率与可读性的取舍
对方法的选择例如,Scrum、极限编程、渐进交付
编程工具
■命名习惯
对goto的使用
■对全局变量的使用
量度,特别是有关生产力的量度,如每天编写的代码行数
以上问题的共同特征是,每一项都是程序员个人风格的反映。如果你认为有
必要控制程序员的某些信仰,请考虑这些要点。
要清楚地知道你是在处理一个敏感的问题在全心全意投入之前要先试探程
序员们对有关敏感问题的看法。
对这些领域要使用“建议”或者“指导原则”避免制定僵硬的“规则”或
者“标准”。
避免流露明显的意图为了规整缩进风格或者大括号的摆放位置,可以要求
在源代码宣告完成之前先通过一个格式美化工具来处理让格式美化工具来处理
格式。为了规整注释风格,可以要求对所有的代码进行复查,修改那些不清晰的
代码,直到代码变得清晰为止。
代码大全(第2版)

<==========================720end ==============================>
<==========================721start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看^
684
第28章管理构建
让程序员们制定他们自己的标准正如在其他地方所提到的,“特定标准的
细节”往往没有“存在某个标准”重要。不要给你的程序员们设立标准,但一定
要坚持让他们在“那些对你来说非常重要的领域里”标准化。
有哪些信仰的话题值得引发一场激战呢?要求在任何领域里的所有微小细节
上都步调一致,其收效恐怕无法弥补由此而对士气造成的影响。如果你发现有人
“不分青红皂白地使用goto或全局变量”、程序风格的可读性差、或者有其他影
响整个项目的实践行为,那么就得为了提高代码质量而不怕一些摩擦了。如果你
的程序员是负责任的,那么这很少会成为问题。最大的斗争往往只在编码风格的
一些细微差异上,你完全可以置身事外只要这对项目没有损失。
Physical Environment
物理环境
以下是一个实验:到乡间去,找到一个农场,见到农场主,问他为每个工人
在装备上花费了多少钱。农场主会去看他的谷仓,看看里面的几台拖拉机、一些
小货车、一台联合收割机、一台豌豆收割机等,然后他会告诉你,算到每个工人
头上的花费超过100000美元。
接着再到城里,找到一家软件公司,见到一位程序开发经理,然后问他为每
个工作者在设备上投入了多少钱。这位程序经理会扫视一下办公室,,一张桌子、
一把椅子、几本书和一台电脑,然后告诉你,每个工作者身上花费不足25000美
元。
物理环境对生产率有着巨大的影响。 DeMarco和Lier向来自35个组织的166
名程序员询问了其所处的物理环境的质量。大多数雇员都对其工作环境感到不满。
在此后举行的一次编程竞赛中,排名在前25%的程序员都具有宽敞、安静、更为
私密的办公室,并且较少受到其他人员和电话的干扰。下面对最好和最差的参赛
者所处的办公环境的差异做出总结:
环境因素
最好的25%
最差的25%
专属的办公空间
78平方英尺(合7.2平方米)46平方英尺(合4.3平方米)
可接受的安静的工作场所
57% yes
29%yes
可接受的私人工作场所
62% yes
19% yes
电话可以静音
52% yes
10% yes
电话可以呼叫转移
76% yes
19% yes
经常会被不必要地打断
38% yes
76%yes
工作场所得到程序员赞许57%yes
29% yes
来源:《Peopleware》(DeMarco and Lister1999)。
代码大全(第2版)

<==========================721end ==============================>
<==========================722start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
28.5把程序员当人看
685
以上数据显示,在生产力与工作场所质量之间有着很强的相关性。前25%最优
秀的程序员的生产力是后25%最差劲的程序员的2.6倍。 DeMarco和 Lister以为由
HARD OATA于好的程序员获得了晋升,因此,他们自然会拥有更好的办公室。然而进一步的调
查却显示事实并非如此。来自同一组织的程序员不论表现好坏,他们所拥有的办
公设施均相差无儿。
大型软件密集型组织均有类似的经历。 Xerox TRW、ibm和Bcll实验室都
出,他们认识到,给每个人10000到30000元的基础建设投资能显著地提高生
产力,投入比强征暴敛更有助于提高生产率(Boehm1987a)“生产力办公室
(productivity offices)”自己估计生产力提高了39%47%(Boehm et al.1984)
总而言之,如果你的工作环境属于最差的那25%,那么你有机会给生产率带来
100%的提升,办法是把环境改善为最佳的那25%。如果你的工作环境处于平均水
平,你还是可以通过把环境改善为最佳的那2%,从而把生产率提升40%甚至更多。
Additional Resources on Programmers as Human Beings
有关“把程序员当人看”的额外资源
cc2e.com/2806下面是一些额外资源。
Weinberg, Gerald M. The Psychology of Computer Programming), 2d ed. New
ork,ny: Van Nostrand Reinhold,1998.这是第一本明确提出把程序员当做人来看
的书籍,而且到目前为止仍然是论述“编程活动作为人的活动”的最佳书籍。书中
饱含对“程序员的人性”的敏锐观察,并且解释了其隐含含义。4 DeMarco, Tom and
Timothy Lister. Peopleware: Productive Projects and Teams 2d ed. New York, NY:
Dorset House,1999正如书名所示,这本书所关注的同样是编程活动中的人员因素。
其中包括很多奇闻逸事,内容涉及人员管理、办公环境、雇用和培养正确的人员、
团队成长以及享受工作。作者依靠一些奇闻事来支撑自己的一些不寻常的观点,
不过有些地方的逻辑显得比较牵强。但是书中以人为中心的思想却是最为重要的,
作者毫不犹豫地把这一思想阐述出来。
cc2e.com/2820
McCue, Gerald.tbm's' Santa Teresa Laboratory- Design for
Program Development IBM Systems Journal17,no.1(1978):4-25. McCue讲述了
IBM创建其 Santa Teresa办公室(office complex的过程BM研究了程序员的需求,
以此创建出了建筑指导方案,并且为程序员设身处地着想,设计了办公设施。程序
员们自始至终地参与了整个过程。其结果是,在每年的意见调查中,员工对Santa
Teresa的物理设施的满意度是全公司最高的。
4译注:中译本《程序开发心理学》,清华大学出版社。
5译注:中译本《人件》,清华大学出版社。
代码大全(第2版)

<==========================722end ==============================>
<==========================723start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
686
第28章管理构建
McConnell, Steve.《 Professional Software Development》. Boston,ma:
Addison-Wesley-,2004.第7章“Orphans Preferred(首选孤儿)”总结了一些针对程序
员的人口统计学研究的结果,内容包括个性种类、教育背景和工作期望。
Carnegie, Dale. How to Win Friends and Influence People), Revised Edition. New
York,ny: Pocket Books,1981.当 Dale Carnegie在1936年写下本书第一版的书名的时
候,他无法想象该书的内容在今天会具有什么样的含义。看上去这应该是一本被
Machiavelli放在他的书架上的书。然而,本书的思想与 Machiavellian的控制手段是
针锋相对的, Carnegie的其中一个核心观点是:诚地去了解他人(developing genuine
interest in other people)是十分重要的。 Carnegie对如何处理日常关系具有敏锐的洞察
力,他讲述了怎样通过更好地了解他人,从而与之共事。书中提供了大量令人难忘的
奇闻逸事,有时一页上甚至有两三个之多。每一个需要和他人一起工作的人都应该在
适当的时候读一读这本书,而每一位管理人员更应该现在就去读它。7
Man
28.6管理你的管理者
在软件开发中,非技术出身的管理者随处可见,具有技术经验但却落后于这个时
代10年(以上)的管理者也比比皆是。技术出色并且其技术与时俱进的管理者实属
凤毛麟角。如果你正在为一位这样的管理者工作,那么就尽可能地保住你的工作吧。
这可是非常难得的待遇。
在等级制度中
如果你的管理者是很典型的那种,那么你将不得不肩负一项不值得羡慕的责
每位员工都倾任管理你的管理者。“管理你的管理者”意味着,你需要告诉他应该这样做
向于被提升到而不应该那样做。其要诀在于,你要表现得使你的管理者认为他仍然在管理你。
他不能胜任的
角色上去下面就是一些应对管理者的方法:
Pater原则
■把你希望做什么的念头先藏起来,等着你的管理者组织一场有关你希望什么的
头脑风暴/集体讨论(你的想法)。
■把做事情的正确方法传授给你的管理者。这是一项需要持之以恒的工作,因为
管理人员经常会被提升、调迁或者解聘。
关注你的管理者的兴趣,按照他的真正意图去做,而不要用一些不必要的实现
细节来分散其注意力。(请把它设想成是对你工作的一种“封装”。)
拒绝按照你的管理者所说的去做,坚持用正确的方法做自己的事。
换工作
最佳的长远的解决方案是教育你的管理者。这样做通常很难,但是你可以通过阅
读卡内基的《人性的弱点》一书来做好必要的准备。
6译注:马基雅维利(1469—1527),意大利政治家和历史学家,他的著作《君主论》(1513年)阐述了
一个意志坚定的统治者不顾道德观念的约束如何获得并保持其权力
1译注:这本书是戴尔卡内基的《怎样广结善缘并影响他人》,国内译本名为《人性的弱点》,机
械工业出版社。
代码大全(第2版)

<==========================723end ==============================>
<==========================724start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. --www.shubulo.com!^.com!仅供试看^
有关管理构造的额外资源
687
Additional Resources on Managing Construction
有关管理构造的额外资源
cc2e.com/2813下面介绍几本涵盖了软件项目管理中的通常的利害关系的书籍。
gilb,tom.《 Principles of Software Engineering Management. Wokingham,
England: Addison-Wesley-,1988.gilb用图表的方式展现了自己30年的经历,并且
在大多数时间里他的见解都要领先于其他人(无论其他人是否认识到这一点)。
本书就是一个很好的例子。本书是最先讨论进化的/渐进式的开发实践、风险管合
理并使用形式化检查的书籍之Gilb熟知那些尖端的方法;而且事实上,这本
在15年前出版的书籍中已经包含了当今敏捷开发阵营中的大多数好的实践。Gib
非常注重实效(pragmatic),而本书目前也仍然是最佳的软件管理书籍之一
McConnell, Steve.《 Rapid Development》 Redmond,wa: Microsoft Press,1996
本书讲述了项目领导(poct-leadership)和项目管理的相关问题。其着眼点在于
那些正在承受巨人进度压力的项目。据我观察,这符合绝大多数项目的情况。
Brooks, Frederick P., Jr. The Mythical Man-Month: Essays on Software
Engineering, Anniversary Edition) (2d ed). Reading, MA: Addison-Wcsley, 1995.
书汇集了有关编程项目管理的隐喻及民间传说。书的内容趣味横生,并且对你认
知自己的项目也颇有启示作用。本书是基于 Brooks开发OS360操作系统这一挑
战性任务而写成,虽然我对这一点还持有一些保留意见。书中充满了诸如“我们
这样做但是失败了”和“我们本该这样做,因为它应该能行”这样的建议。Brooks
对那些不成功的技术所做的评论很让人信服,但是他宣称其他的技术能够行得通
的时候却太带有猜测性了。阅读本书的时候一定要持批判的眼光,才能把他的观
察和猜测区分开。但这一警告并不会缩减本书的基本价值。它仍然是计算机书籍
中引用次数最多的书籍,而且即便本书最初出版于1975年,其内容至今仍未过时。
在阅读的时候,每隔几页不说一句“对极了!”是很难受的。
Relevant Standards
相关标准
IEEE Std 1058-1998, Sturdurd for Sofiware Project Management Plans
IEEE Std 12207 1997, Information Technology-Software Life Cycle Processes
IEEE Std 1045-1992, Standard for Software Productivity Metrics
IEEE Std 10621998, Recommended Practice for Software Acquisition
IEEE Std 1540 2001, Standard for Software Life Cycle Processes-Risk Management
IEEE Std 828-1998, Standard for Software Configuration Management Plans
IEEE Std 1490-1998, Guide-Adoption of PMI Standard-A Guide to the Project
Management Body of Knowledge
代大全(第2版)

<==========================724end ==============================>
<==========================725start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com!仅供试看
688
第28章管理构建
Key Points
要点
■好的编码实践可以通过“贯彻标准”或者“使用更为灵活的方法”来达到。
配置管理,如果应用得当,会使程序员的工作变得更加轻松。特别包括变更
控制。
好的软件评估是一项重大挑战。成功的关键包括采用多种方法、随着项目的
开展而修缮评估结果,以及很好地利用数据来创建评估等。
度量是构建管理成功的关键。你可以采取措施度量项目的任何方面,而这要
比根本不度量好得多。准确的度量是制定准确的进度表、质量控制和改进开
发过程的关键。
程序员和管理人员都是人,在把他们当人看的时候工作得最好。
代码大全(第2版)

<==========================725end ==============================>
<==========================726start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看^
Integration
第29章
集成
cc2com/2985内容
29.1集成方式的重要性:第689页
29.2集成频率阶段式集成还是增量集成:第691页
29.3增量集成的策略:第694页
29.4 Daily Build与冒烟测试:第702页
相关章节
开发者测试:第22章
■调试:第23章
■管理构建:第28章
术语“集成”指的是一种软件开发行为:将一些独立的软件组件组合为一个
完整系统。对小项目,集成也许意味着花一上午的时间就可以把一些类编织到一
起。对大项目,集成也许要花数周或数月时间,把一组程序编织为一个整体。任
务无论大小,适用共同的原则。
“集成”这个主题与“构建的先后次序”这个主题相互纠缠。你构建类或组
件的顺序肯定会影响你将它们集成到一起的顺序你总不能集成还没有构建
来的东西吧。集成和构建次序都是重要的主题。本章从集成的观点讨论这两个主
题
29.集成方式的重要性
Importance of the Integration Approach
在软件以外的工程领域,正确集成的重要性已广为人知。在我生活的地方,
一起事故戏剧性地展示了糟糕的集成的危险:华盛顿大学的露天足球场在建设时
中途坍塌,参见图29-1
代码大全(第2版)

<==========================726end ==============================>
<==========================727start==============================>

该书下载自-书部落-分享计算机经典巨著-- --www.shubu.com!仅供试看^
690
第29章集成
图29-1华盛顿大学的露天足球场坍塌了,因为它在建造时不能支撑自己的重量。很
可能在完工后它会足够牢固,但是它的建造顺序是错的这是一个“集成”
错误
就算这个足球场在建造完成之后会足够牢固,它也必须在每一步都要足够牢
固才行。如果你按错误的顺序构建并集成软件那么会难于编码、难于测试、难
。,
。二
于调试。如果只有全部造好才能工作,那么这个软件看起来永远也做不完。在构
建期间,它可能由于自身的重量而坍塌bug的数目看起来不可克服、看不到
进步、或者无法抗拒复杂度——即便完成后的产品是能运转的。
因为集成是在开发人员完成开发者测试之后才进行的,而且集成过程是与系
统测试一道进行的,所以集成有时也被认为是一种测试行为然而,集成本身就
足够复杂了,因此应该被看做一项独立的行动。
从周到的集成中,你能预期获得某些下列的益处:
更容易诊断缺陷
缺陷更少
KEY POINT
脚手架更少
花费更少的时间获得第一个能工作的产品
更短的整体开发(overall development)进度表
更好的顾客关系
增强士气
增加项目完成的机会
更可靠地估计进度表
更准确的现状报告
■改善代码质量
较少的文档
代码大全(第2版)

<==========================727end ==============================>
<==========================728start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!仅供试看^
29.2集成频率——阶段式集成还是增量集成
691
这些看起来像系统测试被遗忘的“兄弟”要求得到的东西,但是,正因为它
很重要而又常常被忽视,所以集成在本书中占据独立的一章。
29.2
Integration Frequency-Phased or Incremental
集成频率—阶段式集成还是增量集成
程序集成有两种方式:阶段式集成和增量集成。
Phased Integration
阶段式集成
阶段式集成以前一直是规范,直到几年前情况才有所改变。它遵循下列明确
的步骤,又称“阶段”。
1.设计、编码、测试、调试各个类。这一步称为“单元开发”。
2.将这些类组合为一个庞大的系统(“系统集成/system integration”)
3.测试并调试整个系统。这称为“系统瓦解/system dis-integration。(感谢
Meilir Page-Jones-的诙谐观察。)
阶段式集成的一个问题是,当第一次把系统中的类放到一起时,新的问题会
不可避免地大量浮现,而问题的成因可能是方方面面的。既然这一大堆类以前从
来没有在一起工作过,造成问题的“罪犯”就可能是某个未经严格测试的类、两
个类之间的接口中的错误、或者两个类交互作用导致的错误等。总之,所有的类
都是疑犯。
“出现问题的位置的不确定性”加上“所有问题都是一下子出现”这一事实,
让你不仅要处理由于各个类之间的交互导致的问题还要处理那些难于诊断的,
由于“问题”之间相互影响而导致的问题。因此,段式集成的另一个名称是“大
爆炸集成”,如图29-2所示。
全局变量
不同的错误
处理假定
大爆炸集成
具有糟糕
文档的接口
弱封装
图29-2阶段式集成也称为大爆炸集成,其理由很充分
代码大全(第2版)

<==========================728end ==============================>
<==========================729start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com.com!仅供试看^
692
第29章集成
必须到项目的后期,所有的类都经过开发者测试之后,才能开始阶段式集成。
当最终把这些类组装到一起、错误大量涌现时,程序员立即转入惊惶失措的“调
试状态”而不能有条理地检测并纠正错误。
对小程序不,对微型程序一而言,阶段式集成或许是最佳方法。如果
程序只有两三个类,阶段式集成或许能节约你的时间如果你走运的话。但是
对绝大多数情况,另一种方法更好。
Incremental Integration
增量集成
交叉参第2.3在增量集成中,你一小块一小块地编写并测试你的程序,然后一次一块地将
的的它拼接起来。在这种“一次一块”的集成方式中,遵循以下步骤。
长“和“软件构建:
建造软件小节描
1.开发一个小的系统功能部件。它可能是最小的功能部件、最难的部件、关
述了供增量集成键部件、或者以上的某种组合对它彻底地测试并调试。将它作为骨架,稍后附
使用的“隐喻”。着肌肉、神经、皮肤等系统的其余部件。
2.设计、编码、测试、调试某个类。
3.将这个新的类集成到系统骨架上。测试并调试“骨架和新类的结合体”。
在进一步添加任何新类之前,确保该结合体能工作如果做完了剩余的所有工作,
就回到步骤2开始重复这一过程。
偶尔,你也可能想要集成某些“大于单个类的单元”比如,如果某个组件
经过彻底测试,其中每个类经过了迷你(ini)集成,那么你可以集成这整个组
件,并仍然使用增量集成的方式。随着你不断地添加部件,系统增大,动量增加
就像雪球从山上滚下来时体积和动量不断增大一样,如图29-3所示。
增量集成
滚雪球式集成
图29-3增量集成有助于项目增长,就像雪球从山上滚下来时那样
代码大全(第2版)

<==========================729end ==============================>
<==========================730start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com! .com!仅供试看个
29.2集成频率—阶段式集成还是增量集成
693
Benefits of Incremental Integration
增量集成的益处
无论你使用何种增量策略,增量集成都比传统的阶段式集成有更多优势。
易于定位错误如果在增量集成中新的问题浮出水面,那个新的类明显脱不
了干系。要么在“它面向程序其余部分的接口”中包含有错误,要么是它与某个
已经集成的类的交互产生了错误。无论哪种情况,如图29-4所示,你都知道到哪
去查错。此外,因为每次只需面对少量问题,那么“多个问题之间相互影响”或
“一个问题将另一个问题掩盖”的风险也就降低了。出现的接口错误越多,那么
增量集成对项目的优势越明显。有统计表明,某个项目中有39%的错误是模块间
的接口错误( Basili and Perricone1984)。因为很多项目中,开发人员花费多至50%
的时间用于调试,使定位错误变容易,就能将调试的效率最大化,从而提高项目
的质量与生产率。
阶段式集成
增量集成
图29-4在阶段式集成中,你一次集成许多组件,很难知道错误在哪。错误既可能位
于其中任何一个组件,也可能位于组件之间的连接处。在增量集成中,错误
通常要么是在新的组件中,要么是位于新组件和系统之间的连接中
及早在项目里取得系统级的成果一旦代码被集成并运转起来,即便整个系
统还不可用,那么它看起来就像是很快就可用了使用增量集成,程序员能更早
地看到工作的成果,比原来怀疑项目永远也不能吸入第一口气的时期,士气也会
更高。
改善对进度的监控在频繁地进行集成时,“哪些功能是有的,哪些功能还
没实现”都是很明显的。管理层对进度会有更好的判断,“看到系统50%的功能
已经能工作”总比“听到编码‘已经完成了99%””更有说服力。
代码大全(第2版)

<==========================730end ==============================>
<==========================731start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看
694
第29章集成
改善客户关系如果频繁地集成对提高开发人员的士气有作用,那么它也能
提高客户的十气。客户喜欢看到进度增加的迹象,而增量式的 build能频繁地产生
这种迹象。
更加充分地测试系统中的各个单元项目及早开始集成。每开发一个类就集
成一个类,而不是等到最后那个喧闹的“集成”狂欢节。在这两种开发模式下,
类都经过了开发者测试,但是在增量集成中(比起阶段式集成而言,每个类作
为整个系统的一部分的演练次数更多。
能在更短的开发进度计划内建造出整个系统如果仔细地安排集成过程,那
么你可以在设计某个部件的同时,对另一个部件进行编码。这样并不能减少开发
出完整的设计和代码的总工作时数,但它能让一部分工作并行进行,当“日历时
间”非常珍贵时,这点就非常宝贵了。
增量集成支持并鼓励使用其他增量策略。“渐进主义”施于“集成”的益处
还只是初见端倪。
29.3
Incremental Integration Strategies
增量集成的策略
使用阶段式集成时,你无须安排项目中各组件的构建顺序。所有组件都是同
时集成的,所以你可以按任意顺序构建它们只要在发起总攻的那一天准备好就
行。
使用增量集成时,就得仔细计划了。大多数系统要求先集成某些组件,再集
成其他组件。因此,为集成做计划也会影响为构建做计划构建组件的顺序要合
乎集成这些组件的顺序。
集成顺序的策略有多种多样的形状和规模,没有哪一种对所有情况而言都是
最佳的。最佳集成步骤随项目不同而变化,最佳解决方案总是为了满足特定项目
的特定需求而制定的。了解了方法论数轴上的这一点,会让你洞察各种可能的解
决方案。
Top-Down Integration
自顶向下集成
在自顶向ド的集成中,首先编写并集成位于继承体系顶部的类。顶层类可能
是主窗口、程序的控制循环、Java中包含mai()的对象、 Microsoft Windows应
用程序的 WinMain(),或类似的东西。为了能演练该顶层类,需要编写一些存根
(stub)。然后,随着从上而下地集成各个类,这些“存根类逐渐替换为实际的类。
图29-5说明了这种集成过程。
代码大全(第2版)

<==========================731end ==============================>
<==========================732start==============================>

该书下载自书部落分享计算机经典巨著!--www. ! --www.shubulo.com!^.com仅供试看
29.3增量集成的策略
695
Stan
口口
Finish+
图29-5在自顶向下的集成中,首先加入顶部的类,最后加入底部的类
自顶向下集成的一个重要方面是,类之间的接口必须仔细定义。调试起来最
棘手的错误不是那种影响单个类的错误,而是那种由于类之间微妙的交互作用而
出现的错误。仔细地进行接口规格说明(specification)能减少这一问题。接ㄇ规格
说明不是一项集成行为,但要确保明确地说明了接口的规格。
除了具有增量集成的一般优点,自顶向下集成的一个额外优点是,能相对较
早地测试系统的控制逻辑。继承体系顶部的所有类都进行了大量演练,因此较大
的、概念上的设计问题就能及早暴露出来。
自顶向下集成的另个优点是,如果你认真地进行了计划,你能在项日早期
就完成一个能部分工作的系统。如果用户界面位顶层,那么你能很快获得一个
基本的操作界面,然后再填充细节。“让某些看得见的东西早点工作起来”能提
高用户和程序员双方的士气。
自顶向下的增量集成也能让你在完成底层的设计细节之前就开始编码。一旦
各个部分都开始进行相当底层的细节设计,那么就可以开始实现并集成那些位于
更高层的类,不必等到万事俱备(每个“i”都打上点,每个“t”都画上短横线)。
尽管有以上优点,但是纯粹的自顶向下集成通常也具有一些令人难以容忍的
缺点。纯粹的自顶向下集成将棘手的系统接口的演练留到最后才进行。如果系统
接口有很多bug,或者性能有问题,那么你通常希望很早就能开始处理它们,而
不要等到项目结束。“底层的问题冒上影响顶层系统”的情况并不罕见,这一
情况会导致高层的变动,从而减少进行早期集成的收益。为使冒出这种问题的机
会减到最少,须对那些“演练系统接口的类”及早(并仔细地)开展开发者测试
和性能分析。
代大全(第2版)

<==========================732end ==============================>
<==========================733start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubuld.com!仅供试看
696
第29章集成
纯粹的自顶向下集成的另一个问题是,你需要满满一卡车的“存根/stub”,
用于从上而下的集成工作。很多底层的类尚未被集成,这意味着集成的中间步骤
需要用很多的 stub stub本身也是问题,因为它是测试代码,比起精心设计的产
品代码来,它更有可能包含着错误。为了支持(集成)新的类,就要编写一些新
的stub,而这些新的stub又可能包含错误,这就破坏了增量集成“将错误的来源
限制在单个新的类中”这一目的。
交叉参考“自实现纯粹的自顶向下集成也是近乎不可能的。按常规的自顶向下集成方法,
上而下集成和你从顶层开始称为第1层——然后集成位于下一层(第2层)的所有类。当
“自上而下设
计”的关系是有集成完第2层的全都类之后,才能开始集成第3层的类。纯粹的自顶向下集成的
“名”无实的。这种僵化形式完全没有道理。很难想象有人会不怕麻烦特意使用纯粹的自顶向下
关于自上而下设
计的细节,请参集成。大多数人使用一种混合的(hybrid)方法,例如自上而下地分部件集成。
见第5.4节“自
上而下和自下而最后,如果系统没有顶层类,那么就不能使用自顶向下集成。在许多交互式
上的设计法”。系统中,“顶层”的位置带有主观性。在许多系统中,用户界面是顶层。在另外
的系统中,main()是顶层。
相对于纯粹的自顶向下集成,图29-6所示的“竖直分块/vertical-slice”集成
是一种很好的替代品。按这种集成步骤,系统是分部件自上而下实现的,多半先
充实(完成)一块功能,再转而进行下一块功能。
Start
Finish
Finish
Finish
图29-6除了严格的自顶向下进行集成,你也可以在各个竖直划分的功能块中自上而
下地进行集成
尽管纯粹的自顶向下集成行不通,但是思考它也有助于你决定使用哪种通用
的方式。某些适用于纯粹的自顶向下集成的益处和风险同样适用于(虽然不太明
显)较为宽松的自顶向下集成方法(例如竖直分块集成),所以请紧记这些益处
和风险。
代码大全(第2版)

<==========================733end ==============================>
<==========================734start==============================>

该书下载自书部落-分享计算机经典巨著--ww. ! --www.shubule.com!仅供试看
29.3增量集成的策略
697
Bottom-Up Integration
自底向上集成
在自底向上的集成中,首先编写并集成位于 hierarchy底部的类自底向上集
成采用一次一个地添加底层类的方式(而不是次添加全部底层类),因此它是
一种增量集成策略。最初你需要编写test driver(动测试的类)来演练这些底层
类,随着开发的进行,将开发出的类添加到 test driver脚手架中随着高层类的加
入, driver类被替换为“真家伙”。图29-7展示了自底向上集成过程中类被集成
的顺序。
+Finish
000000000
Stan
图29-7在自底向上集成中,先集成底部的类,后集成顶部的类
自底向上集成只具有增量集成的一部分优点。它能将错误的可能来源限制到
“正在被集成的那一个类”上,因此容易定位错误。可以在项目的早期使开始集
成。自底向上集成也能及早演练“可能存在问题的系统接口”。既然系统的局限
通常能决定你是否能达到系统的设计目标,那么让系统先完成全套热身运动也是
值得去做的。
自底向上集成的主要问题在于,它将重要的高层系统接口的集成工作留到最
后才进行。如果系统在高层存在概念上的设计问题,那么要把所有的细节工作都
做完,构建才能发现这些问题。如果必需对设计做重大修改,那么底层的些1
作多半就得扔掉了。
自底向上集成要求你在开始集成之前,已经完成整个系统的设计工作。如果
你不这么做,那么那些不应该支配设计的假设(assumptions)最终会深深地嵌在底层
代码中,引起一种很尴尬的局面:在设计高层的类时,需要想办法绕过(work around)
底层类中的问题。“让底层细节驱动高层类的设计”违反了信息隐藏原则和面向
对象设计的原则。如果你在开始底层编码之时尚未完成高层类的设计,那么一定
会出现大量的问题,与之相比,集成高层类时遇到的问题不过是沧海一粟罢了
代码大全(第2版)

<==========================734end ==============================>
<==========================735start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看^
698
第29章集成
与自顶向下集成的情况一样,纯粹的自底向上集成也非常罕见,你可以代之
以某种混合式的方法,包括图29-8所示的分块集成法。
Finish
Start
Start
图29-8除了按纯粹的自底向上的步骤进行集成,你也可以分块进行这种集成。这样
做模糊了自底向上集成和功能导向的集成(本章稍后将描述)之间的界线
Sandwich Integration
三明治集成
鉴于纯粹的自顶向下集成和纯粹的自底向上集成(本身)所具有的问题,某
些专家推荐三明治集成法(Myers1976)。首先集成继承体系顶部的高层业务对
象(business-object-)类。然后集成底部的与设备接口的类和广泛使用的工具类。这
些高层类和底层类是三明治的那两片面包。
稍后开始集成中间层的类。这些类组成了三明治中的猪肉、奶酪和番茄。如
果你是一名素食主义者,那么这些类组成了三明治中的豆腐和豆芽,不过三明治
集成的作者对此不置一语—或许他的嘴里已经塞满了。图29-9解释了三明治集
成法。
Stan
Finish+
图29-9在三明治集成中,首先集成顶层类和广泛使用的底层类,然后集成中间层类
代码大全(第2版)

<==========================735end ==============================>
<==========================736start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!仅供试看^
29.3增量集成的策略
699
这种集成方法避免了纯粹的自底向上或自顶向下成的僵化做法。它先集成
通常比较棘手的类,而且具有“能让项目所需的脚手架数目最少”这一潜在优势。
这是现实的、实用的方法。下一种方法与之类似,但另有侧重。
Risk-Oriented Integration
风险导向的集成
风险导向的集成也称为“困难部件优先集成法”。与三明治集成类似,它也
试图避免“纯粹的自顶向下集成”或“纯粹的自底向上集成”的固有问题。巧合
的是,它也趋向于先集成顶层类和底层类,将中间层类留后处理然而,其动机
不同。
在风险导向的集成中,需要先鉴别各个类对应的风险级别。确定哪些部件实
现起来是最有挑战的,然后先实现这些部件。经验表明顶层的接口是有风险的,
,,
因此它通常位于风险清单的顶部。系统接口,通常位于继承体系的底层,也是有
风险的,因此它也在风险清单的顶部。另外你或许知道中间层有一些具有挑战
的类。可能是某个实现了未被透彻理解的算法的类,或者某个具有雄心勃勃的性
能目标的类。这样的类也可标为“高风险”,应及早集成。
余下的代码就是那些比较轻松的东西,可以等到以后再下手。其中的某些最
终可能比你想象的要困难,但这是不可避免的。图29-10展示了一个风险导向集
成的例子。
↓
Most risk:
000
Least risk:
do first.
do last.
图29-10在风险导向集成中,首先集成你认为最棘手的类,然后实现较容易的类
代码大全(第2版)

<==========================736end ==============================>
<==========================737start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.coI!.com!仅供试看
700
第29章集成
Feature-Oriented Integration
功能导向的集成
另一种方法是一次集成一项功能。术语“功能( feature,特征)”不代表任
何奇异的事物,它就是系统中一项可确认的功能( function)。如果你正在编写一
个字处理软件,一项功能可能是在屏幕上显示下划线,或者自动对文档进行格式
重排诸如此类的事情。
如果待集成的功能不止一个类,那么“增量集成”中的“增量”就大于一个
类。这稍微减少了“渐进主义”的益处,因为它降低了新错误的来源的确定程度。
但是在集成之前,你彻底测试了实现新功能的那些类,那么这只是一个小小的缺
点。你可以递归地使用增量集成策略,将一些小的代码块集成为“功能”,然后
增量地将一些“功能”集成为系统。
通常你需要先搭好一个骨架,选择“骨架”的标准是它能支撑其他功能。在
交互式系统中,首要的功能多半是交互式的菜单系统。你可以把其他功能挂在这
个首先集成的功能上。图29-11是这种做法的图示。
功能1:骨架
(可能是菜单)
功能2功能3功能4
功能5功能6
图29-11在功能导向的集成中,以一组“构成一项‘可确认的功能’”的类为单位
进行集成通常(但不总是)一次集成多个类
组件被添加到“功能树”中,功能树是一组组类(每组类实现一个功能)的
层次化结构。如果各个功能是相对独立的,那么集成就会比较容易,不同功能可
以调用相同的底层程序库代码,但是绝不与其他功能调用同样的中间层代码。(图
29-11中没有绘出共享的底层程序库类。)
代码大全(第2版)

<==========================737end ==============================>
<==========================738start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
29.3增量集成的策略
701
功能导向的集成具有三个主要优点。首先,它基本上不用脚手架(底层的程
序库类除外)。搭“骨架”时可能要用一点脚手架,否则在添加特定的功能之前,
骨架中的某些部件可能根本无法使用。
无论如何,把各个功能挂在骨架上之后,就无需脚手架了。既然每个功能都
是自成一体的,那么它会包含自己所需的支持代码。
第二个主要的优点是,每个新集成的功能都增加了系统的功能性(functionality)
这证明了“项目正在坚定不移地前进”。这样也就做出了你可以提供给用户评估的功
能性软件,或者你可以较早发布一个功能比原计划少一些的软件。
第三个优点是,功能导向的集成与面向对象设计能很好地协同工作。“对象”通
常能很好地映射为“功能”,这使得功能导向的集成成为面向对象系统的自然选择。
纯粹的功能导向的集成和纯粹的自顶向下或自底向上集成一样困难通常需
要先集成某些底层的代码,之后才能集成某些重要的功能。
T-Shaped Integration
T型集成
最后一种集成方法叫“T-型集成”,它希望解决自顶向下集成和自底向上集
成的问题。在这种集成方法中,选中某个特定的竖直块vertical slice”,对它及
早开发并集成。这个功能块应该能从头到尾地演练系统,而且这个演练过程应该
能找出系统设计所做的假设中的全部主要问题一旦实现了这个“竖直块”
并纠正了所有相关问题—那么就可以开发系统的挑大梁部件(overall breadth)了
(例如桌面应用程序中的菜单系统)。这种方法,如图29-12所示,常常与“风
险导向的集成”或“功能导向的集成”结合使用。
Start
□□
图29-12在T型集成中,你建造并集成系统的一个直插到底层的块,以验证架构的假
设,然后建造并集成系统的挑大梁部件,为开发余下的功能提供一个框架
代码大全(第2版)

<==========================738end ==============================>
<==========================739start==============================>

该书下载自-书部落-分享计算机经典巨著-www. !--www.shubulo.co!^.com!仅供试看
702
第29章集成
Summary of Integration Approaches
集成方法小结
自底向上、自顶向下、三明治、风险导向、功能导向、T型一你是否觉得
人们在他们没事干的时候杜撰出这些名字?确实是。这些方法中没有哪个是硬性
条例你按部就班地从步骤1进行到步骤4,然后宣称自己完成了就像软件
设计方法一样,更多的是启发而非算法。请不要像教条样遵循前面提到的任何
过程,而应该为特定项目剪裁一套独一无二的策略。
29
Daily Build and Smoke Test
Daily Build与冒烟测试
入阅读这里
无论你选用哪种集成策略, daily build和冒烟测试都是软件集成的好方法。每
的讨论大部分取天都将各个(源)文件编译、链接并组合为一个可执行程序,然后对这个程序进
Development)行冒烟测试,即执行一种相对简单的检查,看看产品在运行时是否“冒烟”。
(McConnell
1996)【译注中
这一简单的过程具有若重大的优点。它降低了低质量的风险,这是一种与
译本快速软件“不成功的集成”或“问题多多的集成”相关的风险。通过每天对所有代码进行
开发》,电子工冒烟测试,可以防止质量问题遍布(占领)整个项目。这就将系统带入了一种已
业出版社。】第
18章。如果你已知的良好状态,并一直保持这种状态这样你就能防止系统恶化到出现耗时的质
经阅读过,那么量问题的地步。
可以往前跳到
“持续集成”一
这一过程也便于诊断缺陷。当产品每都会 build出来并进行测试时,就很容
节。
易查明为什么它在某一天坏掉了。如果产品在1号能工作,到了18号就坏掉了,
那么一定是这两次 build之间的发生了什么破坏产品的事件。
它能提高士气。看到产品的工作成果能极大地提高十气。而且几乎与产品能
做什么无关开发者只要看到产品能显示一个矩形都会兴奋!使用 daily build
的话,每天产品能工作的部分都会多一点点,这能保持高昂的士气
频繁集成的另一个副作用是,它会使一些工作浮出水面,否则这些看不见的
作会累积起来,直到项目快结束时才出人意料地出现。这些累积的未曾浮出水面的
工作会转为项目末尾的焦油坑(tar pit),要花数周或数月实际才能挣扎解脱。那些不
曾用过这种方法的团队有时会觉得 daily build将他们的进展简慢到蜗牛爬行的速
度。而实际发生的情况是, daily build有规则地将工作均匀分担在项目的整个生命
周期中,项目的开发团队自始至终对工作的速度有了更准确的图景。
以下是使用 daily build的一些详情。
每日构建( daily build)每日构建最关键的部分是“ daily/每天” Jim McCarthy
说过,可以把 daily build视为项目的脉搏(McCarthy1 1995)。
代码大全(第2版)

<==========================739end ==============================>
<==========================740start==============================>

该书下载自-书部落分享计算机经典巨著!--www ! --www.shubu.com!仅供试看
29.4 Daily Build与冒烟测试
703
如果没有脉搏,项目就完蛋了。还有一个稍微差一点的比喻, Michael
Cusumano和 Richard. Selby将 daily build描述为项目的同步脉冲(Cusumano and
Selby1995)在相邻两个同步脉冲之间,不同开发者的代码允许有一点 out of sync
(脱离同步),不过在每遇到一个同步脉冲时,所有代码都必须回到校准(对齐)
状态。如果你坚持发送密集的同步脉冲,那么就能防止某些开发者完全失去同步。
某些组织不是每天 build而是每周进行 build。样做的问题在于,如果某次
build失败了,那么下一次成功的 build多半要等上数周时间。这种情况一旦发生,
那就实际上失去了频繁 build的全部益处。
检查失败的 build为了能让 daily build过程作起来,那么 build的软件要能
工作。如果软件不可用,那么 build应被视为失败了,而修复它就成了优先级最高
的事情。
每个项目应该对“什么算是破坏了build'’”建立自己的标准。这个标准需
要设立一套质量等级,这套等级要严格到“将使开发活动中断的缺陷’排除在
外”,同时宽松到“忽视细小的缺陷”。(不适当地过分关注这些细小的缺陷,
会使项目进展瘫痪。)
至少,“好”的 build应该:
成功地编译所有文件、库和其他组件;
■成功地链接所有文件、库和其他组件
不包含任何“使程序无法启动,或者操作起来全凭运气”的毁灭性bug,换
言之,好的 build应该能通过冒烟测试。
每天进行冒烟测试冒烟测试应该从头至尾地演练整个系统。它不必做到毫
无遗漏,但是应该能够暴露主要的问题。冒烟测试应该足够彻底:如果这一build
通过了测试,那么就能假定它已经足够稳定可以接受更加彻底的测试了。
如果没有冒烟测试,那么 daily build就没什么价值了。冒烟测试能预防产品
质量恶化和集成问题蔓延。如果没有冒烟测试,那么 daily build就变成了一项浪
费时间的演习:确定每天的编译都是干净的。
让冒烟测试与时俱进冒烟测试必须随着系统的发展而发展。在一开始,冒
烟测试可能只测试某些简单的事情,例如系统是否能印出“Hell,rd.”等。随
着系统的开发,冒烟测试变得更加彻底。最初的测试多半只花几秒钟运行时间
随着系统增大,冒烟测试可能花费10分钟、一小时、或者更多时间。如果冒烟测
试没有与时俱进,那么 daily build就会变成自欺欺人的演练,少量的测试用例造
成了“对产品质量的自信”这一虚假判断。
代码大全(第2版)

<==========================740end ==============================>
<==========================741start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo...com!仅供试看^
704
第29章集成
将 daily build和冒烟测试自动化照料并给 build喂食是耗时的事。让 daily
build和冒烟测试自动进行,才能确保代码能 build、冒烟测试能运行如果不能白
动化,那么每天进行build和冒烟测试是不切实际的。
成立 build小组在大多数项目中,“看护daily build并让冒烟测试保持更新”
的任务大到需要专门找个人米(兼职)做。在大型的项目中,需要多人全职为之
工作。例如,在 Microsoft Windows NT的首次发布中, build小组有4个全职的工
作人员(Zachary1994)。
仅当有意义时,才将修订(revisions)加入 build中通常独立工作的开发
人员们编写代码的速度不会快到使系统每天都有明显的进展。他们需要在一大块
代码上工作,然后才进行集成一当有一套具有一致性的状态的代码时,通常每
几天集成一次。
……但是别等太久才将修订加入进来对“check in代码次数较少”的情况
要当心。有可能出现这种情况:某个开发人员陷入一组纠缠不清的修订(revision)
中系统中的每个文件看起来都被牵扯到了这破坏了daily build的价值。不
过团队的其他人(除了这名开发人员)会继续享受增量集成的益处。如果某个开
发人员接连两三天都不 check in他做的改动,那么这名开发人员所做的工作就是
有风险的。 Kent Beck指出,频繁的集成有时迫使你将单一功能的构建分为若干阶
段进行。这一额外开销是可接受的,是为“减小集成的风险、改善项目状况的能
见度、改善可测试性,以及频繁集成的其他益处”而付出的代价(Beck2000)
要求开发人员在把他的代码添加到系统之前,进行冒烟测试开发人员在将
自己的代码添加到 build中之前,需要先测试。开发人员可以在自己的机器上建立
系统的一套私有 build,然后由开发人员独自进行测试。或者开发人员将这套私有
build发布给他的“测试伙伴”一名专门负责这位开发人员的测试人员这两
种做法的目的都是确保新的代码,在它影响其他的部件之前,能通过冒烟测试
为即将添加到 build的代码准备一块暂存区“daily build过程的成功”部分
取决于“知晓哪些build是好的,哪些是坏的”。在测试自己的代码时,开发人员
需要依赖“好的系统”。
大多数团队解决这个问题的办法是,为开发人员认为“已准备好添加到build
中”的代码准备一块暂存区。新的代码进入暂存区, build出新的 build,如果新的
build是可接受的,那么将新的代码合并到主源码中。
在小型和中型项目中,版本控制系统可提供这一功能。开发人员将新的代码
check in到版控制系统中。对于那些想要使用已知是好的 build的开发人员,他
们只需在 check out文件时设置一个日期选项让版本控制系统根据所设日期取回
上次的好的 build
代码大全(第2版)

<==========================741end ==============================>
<==========================742start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo.com!仅供试看
29.4 Daily Build与冒烟测试
705
在大型项目或者使用简易版本控制软件的项目中,暂存区功能是手工处理的。
新代码的作者给 build小组发电子邮件,告诉他们到哪去找即将被 check in的新文
件。或者buildch小组在某个文件服务器上建立一个“ in”区域,开发人员将
新版的源文件放在那里 build小组在验证了新代码不会破坏 build之后,负责将
它 check in到版本控制中
惩罚破坏 build的人大多数使用 daily build的团队对破坏 build的人加以惩
罚。从一开始就说清楚,保持 build的健康是本项目优先级最高的事情之一破坏
build应该是异常情况,而不是惯例。应强调:如果某些开发人员破坏了 build,就
要停止他们的其他工作一直到他们修复了uild如果破坏 build的情况经常发
生,人们就会很难认真对待“不要破坏 build”这项职责。
轻松的惩罚有助于强调这件应该优先注意的事。某些团队给每个破坏 build的
“菜鸟/sucker”分发棒棒糖。这位开发者须将这个棒棒糖系在他的办公室门上,
直到他修正问题后才能拿下来。其他团队则给有罪的开发者带山羊角,或者令其
捐5块钱给“风纪基金”。
某些项目采用更刺激的惩罚。 Microsoft的高价值项目(如Windows2000和
Microsoft Office)中,在项目的后期,开发者都要养成带上BP机的习惯。如果他
们破坏了 build,,,那么会被召回来修正缺陷,即便该缺陷是在凌晨3点发现的。
在早上发布 build某些团队发现自己喜欢整夜地做 build,在清晨做冒烟测
试,然后在早上发布新的build,不会拖到中午。在早上进行冒烟测试并发布 build
有若干优点。
首先,如果你在早上发布build,测试人员当天就能测试新鲜的 build而如果
通常在下午发布 build,那么测试人员会感到自己“被强迫在ド班之前启动自动测
试”。如果 build延迟了(这是常事),那么测试人员就必须等到很晚,以便启动
自动测试。由于自并没有过错而又必须待到很晚,这样的 build过程就会挫伤士
气
而如果在早上完成了 build,即使 build中有问题,那么找到开发人员来解决
问题的机会也更大。白天开发人员都在岗位上到了夜里,开发人员可能去任何
地方。即便给他BP机,也不是总能揪住他。
“在每天快结束时开始冒烟测试,如果发现问题,就在半夜把人召集起来”
的做法似乎更有男子气概,但这样做对团队过于刻薄,浪费了时间,得不偿失
代大全(第2版)

<==========================742end ==============================>
<==========================743start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubuld.com!仅供试看
706
第29章集成
即使有压力,也要进行 daily build和冒烟测试当进度压力变大时,维护 daily
build所需的工作看起来就像是奢侈的额外开销了。其实相反的观点才是对的。在
压力下,开发人员可能不遵守某些纪律。他感到压力,想走构建的捷径,在压力
较小的环境里他是不会这么做的。复审并测试自己代码也没有原来用心了。代码
趋向混乱(熵增加)的速度比平时(压力较小时)快得多。
在这一背景下, daily build强调了纪律,并让处于高压锅里的项目不出轨。代
码仍然会有变混乱的倾向,不过 build过程每天都在把这种倾向拉回来。
What Kinds of Projects Can Use the Daily Build Process
哪种项目能用 daily build过程
某些开发人员抗议说,每天进行 build是不切实际的,因为他们的项目太大了。
但是,某种可能是近代历史上最复杂的软件项目成功地应用了 daily build在发布
时, Microsoft Windows2000有5000万行代码,散布于好万个源文件中。完整
地 buildWindow次需要用若干台机器运行19小时,但是2000开发团队仍然设
法每天都 build daily build不是麻烦事,相反 Windows2000团队将这一超大型
项目的成功很大程度上归功于 daily build。项目越大,增量集成就越重。
一项对美国、印度、日本和欧洲总共104个项目的调查表明,仅有20%~25%
的项目在项目早期或项目中期使用 daily buildCusumano et a.2003),这就表示还
HARD DATA有很大的改进空间。
Continuous Integration
持续集成
某些软件作者以 daily build为出发点,推荐“持续”集成(Beck2000)大多
数已发表的有关持续集成的文献中,“持续”一词的含义都是“至少是每天一次”
(Beck2000),我认为这是合理的。不过我偶尔会遇到按字意思理解“持续”的
人。他打算将每个改 build动集成到最近的中每两三个小时就集成一次。对大多
数项目,我认为这种按字面意思的持续集成真是好得过分了。
在空余时间里,我开了一个讨论组,参与人员都是顶级的技术主管,来自像
Amazon.com,  boeing, expedia microsoft, Nordstrom.com、boeing、expedia、microsoft、nordstrom以及其他西雅图地区的公
HARD DATA司。在某一次投票中,这些顶级的技术主管没有哪一个认为持续集成优每天集
。。
成。在中型和大型项目中,让代码在短时间内处于“脱离同步”的状态是有价值
的。开发者在做大的修改时,常会脱离同步。在短时间之后,他们又会重新同步。
Daily build让项目组“汇合/rendezvous的频率已经足够高了。只要每天整个开发
组都能同步,那么他们就不需要持续地汇合。
代码大全(第2版)

<==========================743end ==============================>
<==========================744start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
更多资源
707
CHECKLIST: Integration
c2co22对表:集成
集成策略
口该策略是否指明了集成子系统、类、子程序时应该采用的最优顺序?
口集成的顺序是否与构建顺序协调,以便在适当的时候准备好供集成的类?
口该策略是否易于诊断缺陷?
口该策略是否使脚手架最少?
口所选的策略是否好于其他方式?
口组件之间的接口是否有明确定义?(定义接口不是集成的任务,但要验
证这些接口的定义是否明确。)
Daily build与冒烟测试
口项目是否经常 build理想情况下,天 build一次以支持增量集成?
口每次 build后是否都运行冒烟测试,让你知道这个 build能否工作?
你是否已使 build和冒烟测试自动进行?
口开发人员是否频繁地 check in他们的代码一一两次 chock in之间最多间隔
两天?
口冒烟测试是否与代码同步更新,随代码发展而发展?
口破坏 build是罕见事件吗?
口是否在有压力的情况下,也对软件进行 build和冒烟测试?
Additional Resources
更多资源
cc2e.com/2999/29以下是与本章主题相关的额外资源。
Integration
Integration
Lakos, John. <Large-Scale C++ Software Design). Boston, MA: Addison-Wesley,
1996. Lakos主张:系统的“物理设计”—其文件、目录、程序库等的层次结构
对开发团队建造软件的能力有着重大影响。如果你不注重物理设计,那么 build
所花的时间会长到破坏了频繁的集成。Laks的讨论主要针对C++,但是“物理
设计”的观点同样适用于使用其他语言的项目。
译注:中译本《大规模C++程序设计》,中国电力出版社。
代大全(第2版)

<==========================744end ==============================>
<==========================745start==============================>

该书下载自书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
708
第29章集成
Myers, Glenford J. The Art of Software Testing New York, NY: John Wiley
Sons,1979这本经典的讲测试的书把集成作为一项测试活动来讨论。
Incrementalism
渐进主义
McConnell, Steve. Rapid Development). Redmond WA: Microsoft Press,
1996。第7章“编制生命周期计划”详细讨论了在灵活的生命周期模型与不灵活
的生命周期模型之间的权衡。第20、21、35、36章讨论了“支持不同程度的‘渐
进主义’”的各种生命周期模型。第19章描述“为改变而做设计”,这是一项“支
持迭代与增量开发模型”的关键行动。
Boehm, Barry W. "A Spiral Model of Software Development and Enhancement."
《 KComputer》,may1988:61-72在这篇论文中,Bohm描述了软件开发的“螺旋
模型”。他提出的这一模型是“软件开发项目的风险管理”的一种方法,因此这
篇论文讲的是一般开发,而非只针对集成。 Boehm是世界上研究“软件开发的‘big
picture/全局’问题”的最重要的专家之一,他的清晰解释反映了他的深刻理解
Gilb, Tom. (Principles of Software Engineering Management). Wokingham.
England: Addison-Wesley-,1988.第7章和第15章透彻讨论了evolutionary delivery
逐步交付”,这是最早的增量开发方法之
Beck, Kent. Extreme Programming Explained: Embrace Change> Reading, MA:
Addison-Wesley-,2000.这本书包含对Gilb的书中很多观点的更现代、更简明、更
具有传道风格的表述。我个人更喜欢Gilb的书中的深入分析,不过某些读者可能
觉得Beck的表述更容易接受,或者能更直接地应用到他们正在开发的那种项目
中。2
Key Points
要点
构建的先后次序和集成的步骤会影响设计、编码、测试各类的顺序。
一个经过充分思考的集成顺序能减少测试的工作量,并使调试变容易。
增量集成有若干变型,而且除非项目是微不足道的任何一种形式的
增量集成都比阶段式集成好。
针对每个特定的项目,最佳的集成步骤通常是白顶向下、自底向上、风险导
向及其他集成方法的某种组合。T型集成和竖直分块集成通常都能工作得很
好
daily build能减少集成的问题,提升开发人员的士气,并提供非常有用的项
目管理信息。
2译注:中译本《解析极限编程拥抱变化》,人民邮电出版社。
代码大全(第2版)

<==========================745end ==============================>
<==========================746start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
Programming Tools
第30章
编程工具
ce.com/3084内容
30.1设计工具:第710页
30.2源代码工具:第710页
30.3可执行码工具:第716页
30.4工具导向的环境:第720页
30.5打造你自己的编程工具:第721页
30.6工具幻境:第722页
相关章节
■版本控制工具:第28.2节
调试工具:第23.5节
测试支持工具:第22.5节
现代化的编程工具减少了构建所需的时间。使用最前沿的工具集并熟悉
你所用的工具能使生产力增加50%还不止(Jones2000 Boehm et al.2000)
编程工具也能降低编程中必须的单调乏味的琐碎事务的劳动量。
犬类也许是人类最好的朋友,但鲜有好工具是程序员最好的朋友。正如 Barry
Boehm很早以前发现的那样,20%的工具往往据了80%的工具使用量(ary
HARD DATA Boehm1987b)如果你错过了某款更有用的工具,那么你就是错过了一种原本可
能大量使用的东西。
本章关注的焦点有两个特色。首先,本章只涵盖构建用的工具。而说明需求
规格的工具、管理工具、全程(end-to-en)开发工具等都超出了本书的范围。参
见章末的“更多资源”一节,了解为软件开发的这些方面而准备的工具更多的信
息。其次,本章谈论各类工具,而不涉及具体品牌。有少量工具非常常见,那么
我们就会提到它们的名称,但是特定的版本产品和公司等信息变化非常快,纸
上的墨迹还没干,这些信息多半就过时了。
一个程序员可能工作了很多年,但也没有发现并使用某些最有价值的工具。本章
的任务就是纵览目前可用的工具,看看你有没有忽视了某些可能非常有用的工具。
代码大全(第2版)

<==========================746end ==============================>
<==========================747start==============================>

该书下载自-书部落-分享计算机经典巨著!ww. ! --www.shubulo..com!仅供试看
710
第30章编程土具
如果你是一名工具专家,那么本章没有多少新的信息。你也许可以浏览本章
那些较容易的部分,然后阅读第30.6节“工具幻境”,然后继续前进到下一章。
30
Design Tools
设计工具
交叉参考有目前的设计工具主要就是那些“能创建设计图表”的图形化工具。设计工具
关设计的细节,时常内含于“计算机辅助软件工程”(CASE)工具中,而且功能更宽泛某些厂商
请参阅第5章把单独的设计工具当做CASE工具来宣传。图形化的设计工具通常能让你用标准
的图形符号来表述你的设计,包括:UML、架构方块图、继承体系图、实体关系
图、类图等。某些图形化的设计工具只能用一种表示法。另一些工具可以支持多
种不同的表示法。
从一个角度看,这些设计工具都只不过是华丽的绘图软件包使用简单的图
形软件包或者用纸和笔,你也能绘制该工具所能绘制的一切事物。但是这些工具
提供了那些简单的图形软件包所不具备的颇有价值的功能。如果你绘制了一幅泡
泡图(bubble chart),然后删除其中一个泡泡,那么图形化的设计工具就会自动地重
新安排其他泡泡,包括连接箭头和那些“原来连接到被删除的泡泡的低层泡泡”
当你添加泡泡时,1.具也能帮你照料各种琐事。设计工具能让你在高层抽象和低
层抽象之间来回移动。设计工具能检查你的设计的一致性,某些工具还能直接根
据你的设计产生源代码。
30.2源代码工具
ource Code Tools
针对源代码的工具比针对设计的工具更丰富,而且也更加成熟。
Editing
编辑
本组工具与编辑源代码有关。
Integrated Development Environments(IDEs)
集成开发环境(IDE)
据某些程序员的估计,他们有差不多40%的时间用来编辑源代码(Parikh1986,
Ratliff 191987)。如果情况真的如此,额外花点钱购买最好的IDE就是很好的投资。
HARD DATA
除了基本的文字处理功能,好的IDE还有下面这些特色:
在编辑器中进行编译和错误检测
与源代码控制工具、 build工具、测试工具、除错工具集成
代码大全(第2版)

<==========================747end ==============================>
<==========================748start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com!仅供试看^
30.2源代码工具
711
显示程序的扼要视图或大纲视图(只显示类名称或逻辑结构,不显示内容,
也称为“代码折叠”)
■跳转到类的定义、子程序定义、变量定义处
跳转到使用某个类、子程序、变量的全部位置
针对特定语言的格式编排
针对正在编辑的语言的交互式帮助
花括号( begin--end)匹配
常用语言的结构模板(例如,编辑器在程序员键入for之后,自动填完for
循环的结构)
智能缩进(包括在代码的逻辑发生变化时,能很方便地改变一整块语句的缩进)
■自动化的代码转换或重构
可以用熟悉的编程语言进行宏编程
列出查找的字符串,使常用的字符串无需重新键入
■在查找和替换时可用正则表达式
在一组文件中进行查找和替换
同时编辑多个文件
双列式的diff对比
■多级编辑动作撤销
鉴于还有人使用某些原始的编辑器,你也许会惊讶地发现:某些编辑器包含
以上所有功能。
Multiple-File String Searching and Replacing
针对多个文件的字符串查找和替换
如果你用的编辑器不支持对多个文件进行查找和替换,那么你仍然能找到替
补工具来做这件事。这些工具可以用来搜索某个类名或子程序名的所有出现位置。
当你在代码中发现了一个错误,你可以使用这种工具来检查其他文件中有无类似
错误。
你可以搜索:准确字符串、相似字符串(忽略大小写区别)或正则表达式
正则表达式非常强大,因为你能用它搜索复杂的字符串模式。如果你想找出代码
中数组下标里包含“神秘数值”(数字“0”到数字“9”)的所有地方,那么就可
以去搜索“字符,后跟零个或多个空格,后跟一个或多个数字,后跟零个或多
个空格,后跟字符”这一字符串模式。“grep”是一个广泛使用的搜索工具。用
grep查找神秘数值的命令大致如下:
grep"*10-9+]n*cpp
代码大全(第2版)

<==========================748end ==============================>
<==========================749start==============================>

该书下载自-书部落-分享计算机经典巨著--www. --www.shubulo.com!^.com!仅供试看
712
第30章编程工具
你还可以使用更精巧的搜索条件,对搜索进行细调。
在多个文件中替换字符串的能力也非常有用例如,假设你想给某个子程序、
常量、全局变量起个更好的名字,那么多半就需要在若干文件中更改这个名字。
能对多个文件进行字符串替换的工具让这项工作简单易行;这是很棒的,因为你
希望在创作出色的类名、子程序名、常量名时受到的阻碍越小越好。常用的能
处理多个文件的字符串替换工具包括Perl、AWK、sed等。
Diff Tools
diff工具
程序员时常需要比较两个文件。如果你为了纠正一个错误而对源代码进行了
若干修改,之后又想去掉其中不必要的改动,那么可以使用文件比较器,它能比
较原始文件和修改后的文件,并列出你改动了哪些行。如果你与其他人一起开发
一个程序,想知道自从上次你修改代码之后,别人又做了哪些改动,文件比较工
具(如diff)能比较当前版本的代码和你最后一次修改的代码,显示它们的区别。
如果你发现了一个新的缺陷,而你记得在较早版本的程序中没有遇到过它,那么
不用去看主治健忘症的神经科医生,用“比较器”比较当前版本的源代码和较早
版本的源代码,测定到底做了哪些修改,然后找到问题的根源。“比较器”这一功
能通常集成在版本控制工具中。
Merge Tools
Merge工具
有一种形式的版本控制系统会锁住源文件,这样文件每次只能由一个人修改。另
一种风格允许多人同时对文件进行修改,并在chec-in时将这些改动合并(merge到
起。在这种工作模式下,用来合并改动的T具至关重要。这些工具通常能自动执行简
单的合并,遇到合并时发生冲突的情况(或者更复杂的情况)则会向用户问讯。
Source Code Beautifiers
源代码美化器
交叉参考关
源代码美化器将你的源代码打扮整齐,让它们看起来整洁如这种工具能
于程序排布突出显示(highlight)类名和子程序名使缩进风格合乎标准,一致地安排注释的
layout)的细
节,参见第31格局,并执行其他类似的功能。某些美化器还能将各个子程序放入单独的Web页
童“布局与风面或者单独打印出来,或者执行更色彩鲜明的格式化操作许多美化器允许你定
格”
制美化代码的方式。
源代码美化器至少分两类。一类以源代码为输入,产生更美观的输出,而且
不改变原来的代码。另一类直接对源代码本身做修改使缩进合乎标准、调整
子程序参数列表的格式等。当面对大量的遗产代码时,这一功能就很有用了。这
种工具能做大量单调乏味的格式调整工作,使这些老代码符合你的编码风格约定。
代码大全(第2版)

<==========================749end ==============================>
<==========================750start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.com.com!仅供试看^
30.2源代码工具
713
Interface Documentation Tools
生成接口文档的工具
某些工具能从源代码文件中提取详细的接口文档。源文件中的代码先放入类似
“@tag”之类的标记,标明需要提取为文档的文字接下来就可以用生成接口文档的工
具从中提取被标记的文字,并以优良的格式展示出来。 Javadoc是此类工具的杰出代表。
Templates
模板
模板帮助你简化“经常从键盘输入的格式系统的内容”这类工作。假设你
想在每个子程序前放置一个标准的注释块。那么你可以先写一个框架(skclcton)
其中放上你需要的所有项目,留好空白。这样的框架就是“模板”,可以存放在文
件中,也可以保存为键盘宏命令。当编写个新的子程序时,可以很方便地在源
文件中插入该模板。使用模板技术也能设立更大的实体entity)例如类和文件
当然也适用于较小的实体,例如循环。
如果项目由一组人开发,那么“模板”是促进一致的编码与文档风格的简便
途径。在项目的一开始就让整个团队都能用上模板,那么团队的人就会使用这些
模板,因为这使得工作变简单而你能获得“致性”这个附加效益。
Cross-Reference Tools
交叉引用工具
交叉引用工具能列出所有的变量和子程序,以及使用这些变量和子程序的所
有位置通常放在Web页面上。
Class Hierarchy Generators
类的继承体系生成器
类的继承体系生成器能提供关于继承树(inheritance trees)的信息。调试中有时
会用到这种信息,不过更常用于分析程序的结构或者划分程序的模块,将系统
分解为软件包(package)或子系统。某些IDE也提供这一功能。
Analyzing Code Quality
分析代码质量
本类工具对源代码进行静态检查,评定其质量。
Picky Syntax and Semantlcs Checkers
吹毛求疵的语法/语义检查器
语法/语义检查器是编译器的补充,它能执行比通常的编译器更彻底的代码检
查。你所用的编译器多半只检查基本的语法错误。而“吹毛求疵”的语法检查器
能利用语言的细枝末节查出更微妙的错误从编译器的观点来看不算是错误,
代大全(第2版)

<==========================750end ==============================>
<==========================751start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.co.com!仅供试看
714
第30章编程工具
但多半不是你真正打算写的。例如,在C++中,下列语句是完全合法的,
while=0)..
但它想表达的常常是
while (i =0) ..
第一行代码在语法上是正确的,但是错写了=和是很常见的错误,这行代码
多半错了。Lint是一个“吹毛求疵”的语法/语义检查器,在许多CC++编程环境
中都能找到它。Lint会提醒你:未初始化的变量、完全没有用到的变量、赋了值
却没有用过的变量、没有对子程序的传出参数赋值、可疑的指针运算、可疑的逻
辑比较(比如刚才的例子)、不可达的代码、以及许多其他常见的问题。其他语言
也提供了类似的工具。
Metrics Reporters
尺度报告器
交叉参考关于
“尺度/metrics
某些工具能分析你的代码,并报告其质量。例如,可以用这类工具检查和报
的更多信息,参告各个子程序的复杂度,这样你能对最复杂的子程序(s)进行额外的复审、测试或
见第28.4节“度者重新设计。某些工具统计代码行、数据声明行、注释行、空行的行数,它既可
量”
以对整个程序进行统计,也能对各个子程序进行统计。它能跟踪程序的缺陷,并
能找出是谁制造了这些缺陷、改正缺陷需要哪些改动、谁进行的改正等。它能统
计对软件的修改,并找出改动最频繁的子程序据报道,复杂性分析工具在系统
维护的生产率方面有大约20%的正面效应(Jones2000)
Refactoring Source Code
重构源代码
有一些工具可以帮助你把源代码从一种格式转换为另一种格式。
Refactorers
重构器
交叉参考关于
重构软件能执行常见的代码重构任务,它既可以是单独的工具,也可能集成
重构,参见第24到IDE中重构浏览器(Refactoring browsers)让你能很方便地(在整个项目中)改
章“重构”
变某个类的名字。你如果希望把一段代码变成新的子程序(析出函数/extract
routine),只需在重构器中选中这段代码、输入新子程序的名称、调整参数列表中
的参数顺序就行了。重构器让更改代码更快捷而且不易出错。Java和 Smalltalk
已经有重构器,其他语言的重构器正陆续出现关于重构工具的更多信息,见
《《RgctoringX(owIer1999《14》(Fowle1999)书第14章“重构工具”
译注:中译本《重构》中国电力出版社出版。
代码大全(第2版)

<==========================751end ==============================>
<==========================752start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. --www.shubulo.con.com!仅供试看
30.2源代码工具
715
Restructurers
结构改组工具
结构改组工具能将一盘充斥着goto的意大利面条式的代码,转换为更有营养
的正餐结构更佳的代码(没有goto) Capers Jones报告说,在系统维护环境
中,改组代码结构的工具在系统维护的生产率方面能有25%~30%的正面效果
(Jones2000)在转换代码时,结构改组器需要做很多假设,如果代码原来的逻辑
就很糟糕,那么转换后的逻辑依然会很糟糕。然而,如果你正在手工进行转换,
,,
那么你可以用“改组器”来应对一般的情况,而用手动去调整那些困难的情况。
另一种做法是,用“改组器”处理一遍代码,以获得手工转换的灵感
Code Translators
代码翻译器
某些工具能将代码从一种语言翻译为另一种语言。当你有一个大的代码基础
(code base),现在需要转向另一个开发环境时代码翻译器就能发挥作用了使
用代码翻译器的风险在于,如果你的代码一开始就是烂的,那么翻详器只是简单
地将这堆烂代码翻译为一种你不熟悉的语言(的烂代码)
Version Control
Version Control
交叉参考第
为了应对软件版本的“增生扩散”状况,使用版本控制工具进行:
28.2节“软件代
码变更”描述了源代码控制
这些工具及其益依赖关系控制,类似UNIX下提供的make工具
处。
项目文档的版本管理
将项目的工件artifacts)(如需求、代码、测试用例等)关联到一起,这样当
发生需求变更时,你能找出受影响的 test代码和 cases
Data Dictionaries
数据字典
数据字典是描述项目中所有重要数据的数据库。在很多情况下,数据字典主
要关注数据库模式( schema)。在大项目中,数据字典也用来跟踪记录成百上千的
类的定义。在大型的团队项目中,它也能用来避免命名冲突命名冲突可能是语
法上的直接冲突,即两次使用了相同的名称;也可能是更加隐的冲突(或裂隙),
即用不同的名称来表示同事物,或者用相同名称表示一些有细微差别的事物。
对每个数据项(数据库表格或类),数据字典包含其名称和描述字典中也可能包
含关于如何使用该数据项的注意事项。
代丹大全(第2版)

<==========================752end ==============================>
<==========================753start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
716
第30章编程工具
30.3
Executable-Code Tools
可执行码工具
针对可执行码的工具与针对源代码的工具一样丰富。
Code Creation
产生目标码
本节描述产生目标码的工具。
Compilers and Linkers
编译器与链接器
编译器将源代码转化为可执行码。大多数程序都是编译执行的,当然也有一
些仍然是解释执行的。
标准的链接器将一个或多个目标文件(目标文件是编译器从源文件生成的)
与“生成可执行程序所需的”标准代码进行链接链接器常常可以链接多种语言
生成的目标文件,这样你就能为程序的各个部件选择最合适的语言,而不必自己
去处理代码集成的细节。
覆盖(overlay)链接器能让你用5磅的口袋装10磅物品即让程序在机器内存
比“它需要消耗的内存总量”少一些的情况下也能运行。覆盖型链接器创建一种
特殊的可执行文件,在任何时刻,该可执行文件只把自己的一部分加载到内存中,
其余部分放在磁盘上,需要时再调入。
Butld Tools
Build工具
build工具的目的是,让“使用当前版本的源文件来 build出程序”这一过程
花费的时间最少。对项目中的每个目标文件(target file),你需要指明它依赖哪些
源文件,以及如何生成之。 build工具也能消除出于“源文件状态不一致”导致的
错误 build具确保源文件处于一致的状态。常见的 build工具包括U附带
的make工具和用于Java程序的ant工具。
假设你有一个名为 userface.obj的目标文件。在相应的 Makefile里,你指明为
了生成 userface.obj,就需要编译 userface.cpp。还同时指明 userfacecpp依赖于
userface.h、 stdlib.h、 projecth。“依赖”这个概念就是说,如果 userface.h、 stdlib.h
project.h之一发生改变,那么 userface.cpp就需要重新编译
当 build你的程序时,make工具先检查你描述的所有依赖关系,并确定需要
重新编译哪些文件。如果250个源文件中有5个依 userface赖于.h中的数据定义,
而 userface发生了改变,那么make会自动重新编译这5个文件它不会重新编
代码大全(第2版)

<==========================753end ==============================>
<==========================754start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看
30.3可执行码工具
717
译另外245个文件(因为它们并不依赖于 userface.h)使用make或ant时就不必
重新编译全部250个文件,也避免了重新手工编译每个源文件,不小心遗漏了
个,由于没有同步而导致的怪异错误。总的来说,类似make或ant这样的 build
工具大大改进了平常的“编译链接运行”循环的耗时和可靠性
某些团队找到了一些代替make一类依赖性检查工具的有趣途径。例如,
Microsoft Word团队发现,直接重新 build所有源文件比使用make执行大量的依
赖性检查更快—只要这些源文件本身是优化过的(优化头文件的内容等等)。借
助这一方法,Word项目中普通开发人员的机器就能在13分钟内重新出整个
Word可执行文件它有数百万行代码。
Code Libraries
程序库
在短时间内编写高质量代码的一种好方法是不要全部自己编写,而去找一个
开源的版本(或者购买一个)。你至少能在以下领域找到高质量的程序库:
容器类
信用卡交易服务(电子商务服务)
跨平台的开发工具,你可以让编写的代码在 Microsoft Windows Apple
Macintosh Window System上都能运行一一只需为各个环境重新编译一次
源代码。
■数据压缩工具
■数据结构与算法
■数据库操作工具与数据文件操控工具
图解/图示/图表工具
■图像工具
■许可证管理器
■数学运算
网络与互联网通信工具
报表生成器与报表查询(report query)生成器
■安全与加密工具
■电子表格和数据网格T具
文本与拼写工具
语音、电话与传真工具
代大全(第2版)

<==========================754end ==============================>
<==========================755start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. ! --www.shubulo.com!^^.com!仅供试看
718
第30章编程工具
Code-Generation Wizards
代码生成向导
如果你不能找到想要的代码,那么让别人来写怎么样?你不必穿上一件黄色
的格子花呢坎肩,学着汽车推销员那样喋喋不休,哀求某人替你编写代码你可
以寻找为你编写代码的工具,而这样的工具通常集成在IDE中
代码生成工具往往把焦点瞄向数据库应用程序,但这已经包括了许许多多的
应用。常见的代码生成工具能生成数据库代码、用户界面代码和编译器代码。它
生成的代码通常不如程序员编写的代码好,但是许多应用场合并不需要手工雕琢
的代码。对某些用户来说,“10个能工作的应用程序”比“一个极为出色的应用
程序”更有价值。
代码生成器在制造“产品代码的原型”方面也很有用。利用代码生成器,你
或许能在数小时之内就拼凑(hack)出一个产品原形,它能示范用户界面的关键点,
或者你能用它试验多种设计方案。如果手工编码或许要花上数周时间才能实现
同样的功能。如果你只是想做试验,为何不使用最便宜的方式呢?
代码生成器的共有缺点是,它们生成的基本上都是几乎不可读的代码。如果
你曾经不得不维护这样的代码,或许你会非常后悔:为什么开始不手写这些代
码呢。
Setup and Installation
安装
许多厂商都提供创建安装程序的工具。这些工具通常能创建磁盘安装程序、
CD安装程序、DVD安装程序以及Web安装程序。它能检查目标机器上有无常用
的库文件,进行版本检查等。
Preprocessors
预处理器
交叉参关于在
预处理器和预处理器的“宏”功能对程序除错很有帮助,因为它使得“在廾
代码中添加或移除发版代码和产品版代码之间切换”变得更容易在开发过程中,如果你想在每个
调试助手,参见第
8.6节“计划移除子程序的起始处检查内存碎片,那么可以在每个子程序的开头放置一个宏。你多
调试辅助的代码”。半不希望将这些检查措施留在产品代码中那么就在产品代码中重新定义这个宏,
使它不产生任何代码。基于类似的理由,在编写能在多个环境下编译的代码(
如,同时在 Windows和 Linux下编译)时,预处理宏也能发挥很大作用。
代码大全(第2版)

<==========================755end ==============================>
<==========================756start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看
30.3可执行码工具
719
如果你使用的语言只有最基本的控制结构(例如汇编语言),那么可以编写一
个“控制流(control--flow)预处理器”,用该语言模拟结构化程序的构建,如
if-then-else和 while循环。
c2.com/309如果语言没有带预处理器,那么你可以在 cc2e.com/3091bui过程中使用独立的预处理器。
M4是一种很不错的选择,可以从wwwgnu.org/ M4, www.gnu.org/software/m4/./m4/获得。
Debugging
调试
下列工具有助于程序调试:
交叉参考第编译器的警告信息
23.5节“调试
工显测试用的脚手架
的和不那么明
显的描述了这Diff工具(用米比较不同版本的源代码文件)
些工具及其益
处。
执行剖测器
追踪监视器
交互式调试器软件版和硬件版
接下来讨论的测试工具也与除错工具相关。
Testing
测试
下列功能特性和工具有助于你进行有效的测试:
交叉参考第
22.5节测试支自动测试框架,如 JUnit、 NUnit、 CppUnit等
持工興”描述了
这些工具及其益
自动化的测试生成器
处。
测试用例的记录和回放工具
■覆盖率监视器(逻辑分析器和执行剖测器)
■符号调试器
系统扰动器(内存填充工具、内存“抖动”工具、选择性的内存失效的工具
内存访问检查器)
Diff工具(比较数据文件、截获的输出、屏幕图像等)
■脚手架
缺陷注入工具
缺陷跟踪软件
大全(第2版)

<==========================756end ==============================>
<==========================757start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shub.com!仅供试看^
720
第30章编程工具
Code Tuning
代码调整
下列工具能帮你调整自己的代码。
Execution Profilers
执行剖测器
执行情况剖测器观察运行中的代码,并报告每条语句执行了多少次,或者程
序在每条语句(或每条执行路径)上花费了多少时间。剖测(profiling)运行中的
代码就像医生用听诊器贴在你的胸口并让你咳嗽几声。它能帮助你深入了解程序
的运作,找出热点(hot spot)所在,告诉你应该针对哪些代码着力进行调整等
Assembler Listings and Disassemblers
汇编代码清单和反汇编
可能有一天你需要阅读高级语言生成的汇编代码某些高级语言编译器会生成汇
编代码清单。其他的编译器则不会这么做,那么你就得用反汇编器将编译器生成的机
器码反汇编成汇编代码。阅读编译器生成的汇编代码,你可以知道编译器将高级语言
代码翻译得到的机器码的效率如何。它还能告诉你有些什么高级代码看起来快却跑起
来慢。在第26章“代码调整技术”中,某些 benchmark(基准测试)的结果是违反直
。,
觉的。当需要对这些违反直觉的代码进行benchmarking时,我时常会去参阅汇编代码
清单,以求更好地理解结果,这些结果在高级语言里看简直就没道理。
如果你还不习惯汇编语言,又想入门的话,那么找不到比这更好的途径了:
将你编写的每条高级语言语句和编译器对应生成的汇编指令比对。第一次暴露在
汇编代码面前就往往会不知所措。当你看到编译器生成了多少代码时一包括它
生成了多少不必要的代码时你就再也不会像原来那样看待所用的编译器了。
相反地,在某些环境下,编译器必须生成极度复杂的代码。研究编详器的输
出,你会对它产生感激之情:要是用低级语言编程,那得要做多少工作啊。
30.4
Tool-Oriented Environments
工具导向的环境
业已证明,某些环境更适合于“工具导(tool-oriented)”的编程。
UNIX环境因此而著名:它有一堆名称古怪的小工具:grep、diffsot、make、
crypt、tar、ine、 ctags、sed、awk、vi,等等,而这些小工具彼此能很好地配合工
作。C/C++语言与UNX紧密耦合,体现了相同的哲学;C++标准库由许多小子程
序组成,这些子程序能很容易地组合成大子程序,因为它们能彼此很好地配合
代码大全(第2版)

<==========================757end ==============================>
<==========================758start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
30.5打造你自己的编程工具
721
cc2e.com/3026某些程序员在UNIX环境下有着非凡的生产力,因为他们善于使用工具。在
Windows或其他环境中,他们也使用功能与n类似的工具,以维持他们在u
下养成的习惯。UNX哲学成功的表现之一是,这些工具将UN习俗带到了别的
机器上。例如, cygwin提供了能在 Windows下使用的“UNX工具的等价物”
Eric Raymond写的《 The Art of Unix Programming》(2004)一书对UN编
程文化有见地深刻的讨论。
30.5
Building Your Own Programming Tools
打造你自己的编程工具
假设给你5小时完成一项任务,你有两种选择:
用5个小时的时间舒舒服服地完成任务;
兴奋地花4小时45分钟时间打造一个工具,然后利用该工具在剩下的15分
钟内完成任务。
绝大多数优秀的程序员在一百万次机会里只会有一次选择第一种方案,而其
他时候都使用第二种方案。建造工具是编程的基本活动的一部分。几乎所有的大
型组织(拥有超过1000名程序员)都有内部工具及支持团队。许多组织的私有
需求工具和设计工具比市场卖的还要优越(Jones2000)
你能编写本章中描述的许多工具。这么做不一定划算,不过编写这些工具并
没有高不可攀的技术壁垒。
Project-Specific Tools
项目特有的工具
大多数中型和大型项目需要独特的项目专用工具。比如,你可能需要有生成
特定种类的测试数据的工具,以此验证数据文件的质量,或者仿真尚未到位的硬
件。以下是支持特定项目的工具的一些例子。
某个航天工作团队负责开发一个飞行控制软件,用来控制红外传感器,并分
析其数据。为了验证该软件的性能,有一个飞行数据记录器记录飞行控制软
件的各项工作。工程师们编写了定制的数据分析工具来分析这一系统的性
能。在每次飞行之后,他们使用这个定制的工具对主要系统进行检查
Microsoft曾经计划在其 Windows图形环境的某个新版本中加入新的字体技
术。既然字体数据文件和用来显示字体的软件都是新做的,那么数据可能有
错,软件也可能有错。 Microsoft的开发人员编写了若干定制的工具,用来检
查数据文件是否有错:这样他们就能辨别到底是字体数据文件出错还是软件
出错。
译注:中译本《UNIX编程艺术》,电子工业出版社
代大全(第2版)

<==========================758end ==============================>
<==========================759start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubulo.co.com!仅供试看^
722
第30章编程工具
一家保险公司开发了一套雄心勃勃的系统,用来计算其保险费率的增长。因
为该系统很复杂,而准确性又是首要的,所以需要仔细检查数百个计算出的
保险费率,但是即便手工计算一个费率也要花费数分钟时间于是这家公司
编写了一个独立的软件工具,用来计算费率每次一个)。借助这一工具,
该公司能在数秒钟内计算一个费率,并用它核对主程序算出的费率,而花费
的时间比用手工核对少得多。
在为项目做计划时,就应该花部分时间来思考需要哪些工具,并为制造这
些工具分配时间。
Scripts
脚本
脚本是一种能自动执行重复性杂务的工具。在某些系统中,脚本也称为“批
处理文件”或“宏”。脚本既有简单的也有复杂的,而其中一些最有用的脚本写起
来却极为简单。例如,我写日记,为了保护隐私,每次写完我都会对它加密。为
了确保每次都正确地进行了加密与解密,我编写了一个脚本:先解密日记,然后
调用文字处理软件,再对它加密。脚本看起来像这个样子:
crypto c: \word\journal./d /Es /s
word c: wordjournal. doc
cryptc \word\journal.//s
其中的%1是密码占的位置,很明显密码不能出现在脚本中这个脚本节约了键
入这些命令和参数的工作量,还不会敲错,而且确保我总是执行了所有的操作,
执行的顺序也总是正确的。
如果你发现自己每天多次键入某个长度超过5个字母的命令,那么它就是脚
本或批处理文件不错的候选者。例子包括编译连接命令序列、备份命令、以及任
何带大堆参数的命令。
Tool Fantasyland
30.6工具幻境
交叉参考工具
过去数十年里,工具提供商和业界的权威人士都曾经许诺:用来消除编程的
的可用性部分地工具就在不远的地平线处。可能最具有讽刺意味的是,第一个获得这一绰号的工
依赖于技术环境
的成熟度关于这具就是 Fortran Fortran代表“Formula Translation Language公式翻译语言”,人们
点,请参见第4.3设想科学家和工程师只需简单地输入公式就能做计算,据此推测能消除对程序员
节你在技术浪潮
中的位置”。
的需求。
Fortran确实使科学家和工程师都能成功地写程序了,但是从我们今天的有利
位置看, Fortran看来是相对低级的编程语言。它根本不可能消除对程序员的需求,
业界在 Fortran方面的经历也是整个软件工业的发展过程的缩影。
代码大全(第2版)

<==========================759end ==============================>
<==========================760start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
30.6工具幻境
723
软件工业界不断地开发出新的工具,用于减少或消除编程过程中某些最单调
乏味的工作的数量,像是:源代码中语句的排布细节、编辑/编译/链接/运行程序
所需的一堆步骤、查找不匹配的括号、创建标准的消息框所需的若干步骤等等
每个新工具开始证明它对生产率有增益的时候,某些鼓吹者就会将这些增益外推
至无穷大,设想这些增益最终能“消除对编程的需求”。但是实际上发生情况是,
每一项新的编程改革都带有些许瑕疵。随着时间流逝,瑕疵被排除,该项改革的
全部潜力都弄清楚了。无论如何,一只了解了这种基本工具的概念,获得更大的
增益的办法就是去除一些偶然性的困难(accidental difficulties这样做的副作用就
是创建出一些新的工具。消除这些偶然性的困难并不能从本质上提高生产率:它
不过去掉了典型的“进两步、退一步”情况中的“退一步”而已。
在过去的数十年中,程序员已经看到到过无数的号称能“消除编程”的工具。
先是第三代语言,其次是第四代语言,然后是自动编程,再然后是CASE工具,
最后是可视化编程。以上各项进步都对计算机编程产生了价值可观的、增量式的
改进它们整体效应使得现在的“编程”对于那些在出现这些进步之前就学会
编程的人来说已是面目全非了。但是,没有哪项改革成功地消除了编程。
交叉参考第
5.2节偶然的难
出现这一对抗性态势的原因在于,就其木质而言编程从根本上说就是困难
题和本质的难的一即便有好的工具支援。无论能用到哪些工具,程序员都必须与凌乱的真实
题”描述了出现
编程的困难的原世界较力;我们须得严密地思考前后次序、依赖关系、异常情况;而且我们还要
因
与无法说清楚自己想法的最终用户交往。我们始终要应对连接到其他软件或硬件
的定义不清的接口,还要解决规章制度、业务规则以及其他复杂性之源,这些复
杂性来自计算机编程之外的世界。
始终需要人来填补真实世界里需要解决的问题和准备用来解决问题的计算机
之间的鸿沟。这些人将会被称做程序员,无论他是以汇编语言操控机器寄存器,
还是用 Microsoft Visual Basic操控对话框。只要有计算机,就需要能告诉计算机该
去做什么的人,这一活动将会被称做编程。
当你听到某个工具厂商宣称“这一新工具将会消除计算机程序设计”时,躲
开它!或者对这种厂商的幼稚的乐观主义一笑置之。
代码大全(第2版)

<==========================760end ==============================>
<==========================761start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看^
724
第30章编程工具
Additional Resources
更多资源
cc2e.com/3098看看这些额外的资源,更多地了解编程工具:
c.com/300www. cc2e.com/3005  www. sdmagazine. com/jolts. KSoftware Development Magazine Jolt.com/jolts.SofwareDevelopmentagazine》的年度Jolt
生产力大奖网站是了解目前最佳的编程工具的一个很好的消息源。
Hunt, Andrew and David Thomas.《 The Pragmatic ProgrammerBoston》,ma:
Addison-Wesley-,200.这本书第3章深入地讨论了程工具,包括:编辑器、代
码生成器、除错器、源代码控制、以及相关工具。
cc2e.com/3012 vaughn-nichols, steven. "Building Better Software with Better Tools," IEEE
Computer, September2003,pp.12—14.这篇文章综述了由BM、 Microsoft
Research、 Sun Research等机构的工具创新项目。
Glass, Robert L. Software Conflict: Essays on the Art and Science of Software
Engineering》. Englewood Cliffs,nj: Yourdon Press,1991.其巾一章名为
“Recommended: Minimum Standard Software Toolset,对“工具越多越好”这
一观点提出了自己深思熟虑的不同看法。Glas赞成“确定一套适合所有开发者的
最小工具集”,并将这套工具作为起始的工具箱(starting kit)
Jones, Capers. Estimating Software Costs). New York, NY: McGraw-Hill,
98
Boehm, Barry, et al. Software Cost Estimation with Cocomo Reading, MA:
Addison-Wesley-,2000. Jones的书和 Boehm的书都有专门讨论“工具对生产力的影
响”的章节。
CHECKLIST: Programming Tools
cco30核对表:编程工具
口你有一套有效的IDE吗?
口你的IDE集成了:源代码控制、 build/测试/除错工具,以及其他有用的功
能吗?
口你有能自动进行常用的重构操作的工具吗?
口你是否使用版本控制工具,对源代码、内容、需求、设计、项目计划及其他
的项目构件进行管理?
口如果你正面对超人型的项目,你是否使用了数据字典或者其他“包含系统
中使用的各个类的权威描述”的中央知识库。
口当可以用到代码库时,你是否考虑用它来代替“编写定制代码”?
3译注:中译本《程序员修炼之道》,电子工业出版社。
代码大全(第2版)

<==========================761end ==============================>
<==========================762start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^.com!仅供试看
要点
725
口你是否充分利用了交互式除错器?
口你是否使用make或其他“依赖关系控制软件,用来高效并可靠地 build
程序?
口你的测试环境包含有自动化的测试框架、自动测试生成器、覆盖率监视器、
系统扰动器、diff工具,以及缺陷跟踪软件吗?
口你有没有制造过定制工具能满足特定项目的需求的那种,特别是能自
动执行重复任务的工具?
口总而言之,你的工作环境有没有从“充足的工具支援”中获益?
Key Points
要点
程序员有时会在长达数年的时间里忽视某些最强大的工具,之后才发现并使
用之。
好的工具能让你的日子过得安逸得多。
下面这些工具已经可用了:编辑、分析代码质量、重构、版本控制、除错、
测试、代码调整。
你能打造许多自己用的专用工具。
好的工具能减少软件开发中最单调乏味的工作的量,但它不能消除对“编程”
的需要,虽然它会持续地重塑(reshape)“编程”的含义
代大全(第2版)

<==========================762end ==============================>
<==========================763start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看

<==========================763end ==============================>
<==========================764start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
第7部分
Software Craftsmanship
软件工艺
本部分内容
■第31章布局与风格
729
■第32章自说明代码
777
■第33章个人性格
819
■第34章软件工艺的话题
837
■第35章何处有更多信息
.855
代码大全(第2版)

<==========================764end ==============================>
<==========================765start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看

<==========================765end ==============================>
<==========================766start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
Layout and Style
第31章
布局与风格
c.c/3187内容
31.1基本原则:第730页
31.2布局技术:第736页
31.3布局风格:第738页
31.4控制结构的布局:第745页
31.5单条语句的布局:第753页
31.6注释的布局:第763页
31.7子程序的布局:第766页
31.8类的布局:第768页
相关章节
■自说明代码:第32章
代码格式化工具:第30.2节中的“编辑”
本章转向计算机编程的美学话题——程序源代码的布局。编排出色的代码会
带来视觉上和思维上的愉悦,这是非程序员的人不能感受到的。而精雕细琢代码、
使之达到美观的程序员们,却会从这一过程得到艺术上的满足。
本章介绍的技巧并不影响执行速度、内存使用量等方面的程序性能。但它却
会让你日后理解代码、检查代码以及修改代码变得更容易,也使其他人在你缺位
的时候更容易阅读、理解和修改你的代码。
本章充斥着各种需要讲究的细节,也就是人们说到“注意细微之处”时所指的
那些事项。贯穿项目的生命期,在意这些细节将使你写的代码在初始质量和最终维
护性能上都出类拔萃。这些细节是编码过程的有机组成部分,以至于晚了就很难做
好了。要想完全实现这些细节规定,在最初建构时就要着手去做。如果你干的是合
作项目,请让团队的人阅读本章内容,并在开始编码之前统一大家的风格。
你大概不会赞成此处给出的每个细节,但我的出发点是引起你对布局风格的
思考,而不是赢得你对与格式化风格有关的问题的认同。要是你有高血压,还是
转到下一章吧,那里的争议少一点。
代码大全(第2版)

<==========================766end ==============================>
<==========================767start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubulo.com!^.com!仅供试看^
730
第31章布局与风格
Layout Fundamentals
基本原则
本节阐述好的布局的原理,随后的各节讨论实例。
Layout Extremes
布局的极端情况
请思考清单31-1给出的子程序。
清单31-1Java程序布局示例1
* Use the insertion sort technique to sort the"data" array in ascending
order..
This routine assumes that dataf firstElement is not the first element
HORROR InsertionSort int data, int firstElement, int lastElement)(/* Replace
element at lower boundary with an element guaranteed to be first in a sorted
list. * int lowerBoundary data[ firstElement-1 data[ firstElement-11
=SORT_MIN; / The elements in positions firstElement through sortBoundary-1
are always sorted. In each pass through the loop, sort Boundary is increased,
and the element at the position of the new sortBoundary probably isn'
in its sorted place in the array, so it's inserted into the proper place
somewhere between firstElement and sortBoundary.*for(int sortBoundary
firstElement+ sortBoundary<= lastElement; sortBoundary++int
insertval= datal sortBoundary: int insertPos= sortBoundary; while(
insertVal< data insertPos--i)(data[ insertPos= data insertPos-1
insertPos insertPos--: datal insertPos= insertVal;}/* Replace
original lower-boundaryelement * data[ firstElement-1] =lowerBoundary;
该子程序在语法上是正确的。程序各处都有注释,变量名有意义,逻辑也很
清晰。不相信的话,你读一读,看能否找出一个错误来!然而它所缺乏的正是合
理的布局。这是一个极端的例子,在布局优劣程度的坐标轴上位于“负无穷大”。
清单31-2中的例子就不那么极端了。
清单31-2java程序布局示例2
* Use the insertion sort technique to sort the"data" array in ascending
order. This routine assumes that datal firstElement is not the first
public void InsertionSort( int data, int firstElement, int lastElement
CODINR / Replace listt at lower boundary with an element guaranteed to be first
HORROR
leme
in a, sorted list. *
int lowerBoundary data[ firstElement-1 ]
data firstElement-1- SORTMIN
/ The elements in positions firstElement through sortBoundary-1 are
always sorted. In each pass through the loop, sortboundary
is increased, and the element at the position of the.
new sort Boundary probably isn't in its sorted place in the
array, so it's inserted into the proper place somewhere
between firstElement and sortBoundary. *
for Boun
int sortBoundary firstElement+1;
sortBoundary < lastElement;
代码大全(第2版)

<==========================767end ==============================>
<==========================768start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!.com仅供试看^
31.1基本原则
731
sortBoundary++
)(1
int insertVal datal sortboundary i
int insertPos sort Boundaryi
while insertVal datal insertPoS-1
data[ insertPos datal insertPos-1 ]
insert Pos =insertPos-1:
data[ insertPos insertval;
/ Replace original lower-boundary element*/
data[ firstElement-1 =lowerBoundary;
这段代码和清单31-1中的一样。尽管人们多半会认为这段代码的布局比前一
个例子要好,但其可读性仍欠佳。布局还是显得拥挤,没有为子程序的逻辑组织
提供有益的提示。在布局优劣程度的坐标轴上,它位于原点附近的位置。前一个
例子是我们有意给出的,而第二个例子则不鲜见。我曾见过某些长达数千行的程
序,其布局的糟糕程度绝不亚于这个示例—没有文档说明,变量命名很糟糕,
整体可读性比这个例子还差。这段代码是为计算机做的布局,想必其作者并不指
望有人去看。清单31-3的代码又有所改进。
清单31-3java程序布局示例3
/ Use the insertion sort technique to sort the "data" array in ascending
order. This routine assumes that datal firstElement is not the
first element in data and that datal firstElement-1 can be accessed.
*1
public void InsertionSort int data, int firstElement, int lastElement )
1/ Replace element at lower boundary with an element guaranteed to be
/1 first in a sorted list.
int lowerBoundary data[ firstElement-1:
data[ firstElement-1 =SORT_MIN;
/* The elements in positions firstElement through sortBoundary-are
always sorted. In each pass through the loop, sortBoundary
is increased, and the element at the position of the
new sortBoundary probably isn't in its sorted place in the
array, so it's inserted into the proper place somewhere
between firstelement and sortBoundary.
*
oment1.
for( int sortBoundary= firstEleme+; sortBoundary<= lastElement
sort Boundary+).
int insertVal datal sortBoundary ]
int insertPos sortBoundary
while insertval datal insertPos 11
data[ insertPos data[ insertPos
insertPos insertPos -1;
代码大全(第2版)

<==========================768end ==============================>
<==========================769start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
732
第31章布局与风格
data[ insertPos insertVal;
1/ Replace original lower-boundary elem
Replace original lower-boundary element
data[ firstElement 1 lowerBoundary:
该子程序在布局优劣程度的坐标轴上处于很“正”的位置。它的布局比较符合
本章所讲述的原则,可读性比前两个好得多,明显可以看出对文档说明和变量名下
了功夫。先前例子中的变量名与这里同样有意义但程序拙劣的布局使其形同虚设。
这一示例与前两个例子的唯一不同之处,就在于运用了空白而代码和注
释完全一样。空白的使用仅仅是有助于人的阅读对计算机来说,解释这三个
片段都一样的容易做。你不必因为这方面不如电脑而难过!
The Fundamental Theorem of Formatting
格式化的基本原理
格式化的基本原理指出,好的布局凸现程序的逻辑结构。
使代码看起来有条理的最大意义莫过于展示出代码的结构。如果有某种方法
能够更好地给出代码结构,而另一种方法可以使代更悦目,那么还是选择前者
KEY POINT为好。本章将给出许多编程风格的示例,它们看上去也挺好,但却没有正确地表
现代码的逻辑关系。实际上,着重逻辑表现通常并不会做出难看的代码除非
代码的逻辑原本就很丑陋。能让好代码美观,而使差代码难看的技术,比那些能
让良莠不齐的代码看起来都很漂亮的技术更有用。
Human and Computer Interpretations of a Program
人和计算机对程序的解读
傻子都会写让计
算机理解的代
布局是关于程序结构的有用暗示。计算机可能只关心花括号或 begin/end,而
码;而优秀程序人看程序时却总倾向于从代码的视觉外观获取提示。请思考清单31-4中的代码段,
员写的是人能看其缩进格式给了人这三条语句在每轮循环里都执行的错觉
懂的代码
Martin Fowler清单31-4ava布局的例子,人和计算机对它的理解并非一回事
1/ swap left and right elements for whole array
for (=0< MAX_ELEMENTS; i++)
leftElement left[ i ]
left[ i ] right[ i 1;
right[i= leftElement;
代码大全(第2版)

<==========================769end ==============================>
<==========================770start==============================>

该书下载自-书部落-分享计算机经典巨著-- !--www.shubulo.cor.com!仅供试看
31.1基本原则
733
由于代码中没有包含一对的花括号,编译器会执行第一条语句mxELEMENTS
次,执行第二、三条语句各一次。缩进结构清晰地表明作者是希望这三条语句一
起执行,打算为它们围上一对花括号,但是编译器可不这么认为。清单31-5是另
一个例子。
清单31-5Java布局的又一示例,说明人和计算机对布局的理解截然不同
x=3+42+7
读代码的人通常倾向于认为该语句x的值等于(3+41*(2+7),即63;而计算
机则会忽略其中的空格,按照优先级规则将其解读为3+(4*2)+7,也就是18好
布局方案的关键是能使程序的外观与逻辑结构相符,换句话说,也就是要让人和
计算机对其有同样的理解。
How Much Is Good Layout Worth
好布局有什么用
我们的研究支持这么一个说法,即程序规划知识和编程论述规则对我们
理解程序有着深远影响。在《 The Elements of Programming Style》书中,
作者 Kernighan和 Plauger阐明了我们所称的“论述之规矩”。经验与规矩是
吻合的:以某种风格来写程序并不仅仅是出于美观考虑用习惯的方式写程
序有着心理因素—程序员有着强烈的意识,觉得其他程序员都会遵循这些
论述规矩。如果这些规矩未被遵守,程序员日渐积累起来的期望效用就会前
功尽弃。本论文所描述的对新手、高级学生程序员以及专业程序员的实验结
果,有力地支持了这些说法。
Elliot Soloway和 Kate Ehrlich
交叉参考好的
布局是可读性的
关于与计算机交流和与人交流的差异,布局问题大概比编程中的其他任何方
关键。关于可读性面都更明显。编程工作量的一小部分是写让机器读的程序,大部分工作是写能让
的重要意义,请参
34.3节“首先他人看懂的程序。
为人写程序,其次
才是为机器”。
1973年 Chase和 Simon在其经典论文《 Perception in Chess》(《对弈中的感
知》)中,提到有一项研究对国际象棋高手和新手记忆棋子位置的能力做了对比。
正在对弈时,棋子排列在棋盘上,高手的记性远远好于新手;而当棋子只是随意
摆在棋盘上时,两者的记性就没有多大差别。对此的传统解释是:高手的记性并
非天生优于新手,但高手具备某种知识结构,这些结构有助高手记住特定种类
代码大全(第2版)

<==========================770end ==============================>
<==========================771start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo..com!仅供试看^
734
第31章布局与风格
的信息。当新信息符合这些知识结构时—也即棋子的布置有意义时,高手可以
很容易地记住它们;若新的信息与不符合相关知识结构比如棋子被随意摆放,
则高手的记性一点也不比新手强。
儿年后, Ben Shneiderman将 Chase和 Simon的结论套用到计算机编程领域。
1976年他在 Exploratory论文《 Experiments in Programmer Behavior》(《程序员行
为的探索试验》)中报道了其研究结果。 Shneiderman发现,如果程序语句按照有
意义的方式布局,高手能比新手更好地记住语句而当语句乱七八糟时,高手的
优势就不明显了。 Shneiderman的结论也由其他研究证实(McKeithen et al.1981
Soloway and Ehrlich 11984)。1981年 McKeithen等人还在围棋、电子学、音乐以及
物理领域确认了这一基本思想。
本书发表第一版后,程序员Hank在阅读了手稿之后对我说:“你居然没有起
劲鼓吹下面这种使用括号的风格,真让人吃惊:
for.
}
“你的书里竟然还有这种括号使用风格:
for C...){
“我和Tony为第一种形式有过争论,我还以为你会觉得第一种好呢。”
我回答道:“看来你是赞成第…种风格,而Tony赞成第二种,对吧?”
Hank应道:“真有意思,我和Tony合作上个项目时,我偏爱风格2,Tony
却对风格情有独钟。我们一直都在争论哪种风格最好。我想我们都让对方喜欢
上了各自的风格!”
这件事情连同上面提到的研究,都表明结构能帮助高手去感知、理解和记住
程序的重要特性。编程高手通常会恪守自己的风格,即使和其他高手的风格迥然
N不同。底线是前后如一地组织程序,相比而言,关于程序细节特定的方法就次要
得多了。
代码大全(第2版)

<==========================771end ==============================>
<==========================772start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看
31.1基本原则
735
Layout as Religion
把布局作为一种信仰
强调对程序理解的重要性,并把程序结构化成熟知的形式,已使一些研究者
在考虑,如若一个程序的风格与某高手的风格不同时,是否会影响他对程序的理
解能力呢(Sheil1981; Soloway and Ehrlich 11984?这个问题说明布局不仅涉及
美学,同时也有了逻辑问题的味道,意即对编程格式的争论听起来更像是宗教斗
争,而非在讨论哲学。
ER
RELIGIOUS
WARSI
交叉参考如果
你将软件与信仰
混为一谈,可以在般说来,有些形式的布局显然好于另外一些本章前面一些例子里的布局
继续本章其他部较好,这就是明证。本书不打算明确指出哪一种更好,因为在这里存在争议。出
分之前,先阅读
34.9节“汝当分色的程序员在布局实践方面应当头脑开放,接受已证实为更好的方法,即使调适
离软件与信仰。”过程最初会感觉有些不舒服。
Objectives of Good Layout
良好布局的目标
这实际上指出了很多有关布局细节的结论都有主观美学的因素。人们达到月的常常可以通过
—高级程序员多种方法。如果明确了喜好的标准,对问题的争论就会客观一些。所以,好的布
对程序外观有着局方案应当是明确的,应当这样做。
强烈的期望,当这
些期望不能如愿准确表现代码的逻辑结构这重申了格式化的基本理论好的布局主要是为
时甚至是看
起来微不足道的了展现代码的逻辑结构。典型的例子就是,程序员利用缩进等空白来表达逻辑关系。
改变——都会让
他们的业绩急剧
始终如一地表现代码的逻辑结构有些布局风格的规则会遇到许多例外,以
下降。
-Eliot Soloway
至很难一直遵守。好的风格能够适应大多数情况
和 Kate Ehrlch
改善可读性如果有一种缩进策略合乎逻辑,但却令程序史难看懂,那么它
就无用处。只在编译器要求之处插入空白的布局方案的逻辑并不错,但却并不
易读。好的布局方案就该增强代码的可读性。
代码大全(第2版)

<==========================772end ==============================>
<==========================773start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
736
第31章布局与风格
经得起修改理想的布局方案应该能经得起代码修改的考验。修改某行时不
必连带修改其他行的代码。
除了这些原则,还应不时地考虑尽量减少实现简单语句或语句块的代码行数目
How to Put the Layout Objectives to Use
如何将布局目标付诸实施
你可以基于这些准则作为讨论布局的基础,这样喜欢某种布局而不是由另一
种的主观理由就能说得很清楚。
采用不同的方法来衡量这些准则,结论或许会有些不同例如,假设你很在
意将屏幕上用的行数达到最少或许因为你的计算机屏幕比较小,你就会批评
那种需要额外再用两行来放子程序参数列表的风格。
31.2
Layout Techniques
布局技术
通过不多的集中布局手段就能实现良好的布局本节就一一介绍它们。
White Space
空白
空白能够增强可读性。空白包括空格、制表符、换行、空行,是展现程序结
构的主要手段。
交叉参考研究
人员探讨了书的
你无法想象会有这样一本书:其中没有空格隔开单词,不分段落,也没有章节
结构与程序结构之分。这样的书或许从头至尾还是可以读的,但几乎不可能翻阅去找到某个关键句,
的相似性这方面
的信息请参看
或者定位某个重要的段落。更致命的大概是,书的这种布局不能对读者展示作者打
32.5节中的“程算如何组织信息,而作者的组织方法正是理解有关主题逻辑结构的最重要线索
序注释以书本为
范例”。
将书分成一些章节、段落以及句子,就向读者展现出了作者组织主题的思路。
如果这一组织不够明确,读者就必须自己去摸索这将极大地增加读者的负担,
或许他们自始至终都无法搞清有关主题的组织方式。
程序里包含的信息密度超过多数书籍里的信息密度。你也许一两分钟就能读
完并理解书的一页内容,大部分程序员却不能以类似的速度看懂未经修饰的程序
代码清单。程序应该比书提供更多的组织线索,而不是相反。
代码大全(第2版)

<==========================773end ==============================>
<==========================774start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com!^.com!仅供试看
31.2布局技术
737
分组从另一个角度看,空也是分组,也是确保相关的语句成组放在一起。
我们写作时,思路以段落分组。写得出色的段落只会包含与某些特定思想相
关的句子,而不是风马牛不相及的句子。同样一段代码只应由完成某任务的语
句组成,这些语句彼此相关。
空行正如将相关语句分组很重要一样,将不相关的语句分隔开也很有必要。
在英语中,段落的开始用缩进或者空行表示;代码中的一个段落的前面也应该加
入空行。
空行是指示一个程序如何组织的手段。可以用空行将相关语句各自划分成段
落、分开各子程序、突出注释部分。
尽管特定的统计可能很难实施,由 Gorla和 Benander于1990年完成的研究还
是发现,程序中空行的最佳比例约为8%~16%高于16%后调试时间将显著延长。
HARD DATA
缩进请用缩进形式显示程序的逻辑结构。作为一项守则,那些逻辑上隶属
某语句的语句都应缩进。
已经证实缩进确能提高程序员的理解能力。有篇名为 Program《 Indentation
and Comprehensibility》(《程序缩进和可理解性》)的文章报道说,多项研究发现
HARP DATA
缩进和理解力的提高有关(Miaria et al.1983)。当序有两到四个空格的缩进时,
受试者对程序的理解分数会比对毫无缩进的程序高出20%到30%。
同一个研究还发现,对程序的逻辑结构强调不足或过分都不合适。对根本没
有缩进的程序得到了理解程度的最低分;缩进了六个空格的程序则次之。该研究
的结论说缩进二到四个空格最得当。有趣的是许多受试者觉得缩进六个空格比
少些的空格更好用,即便它们的分数较低。这大概归因于六个空格的缩进看起来
更舒服。但不管怎样,如此缩进的可读性并不高。这个例子反映出美观和可读性
之间的矛盾。
代大全(第2版)

<==========================774end ==============================>
<==========================775start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
738
第31章布局与风格
Parentheses
括号
括号应该用得比你觉得需要的更多。对包含两个以上的项的表达式,应该用
括号去澄清之。或许有些括号并非必需,但它们使语义更加清晰且不会损失你什
么。打个比方,以下表达式如何求值?
C++:12+43*7/8
Microsoft Visual Basic: 12 +4 mod*/
关键问题是,你是否不得不去想想这些式子是怎样运算的?能不参考任何材
料就很自信地给出回答吗?即使经验丰富的程序员也无法做到。这正是应该为那
些求值顺序有疑问的表达式加括号的原因。
31.3
ayout Styles
布局风格
多数布局问题都涉及到块结构即跟在控制语句后面的那些语组。块结
构被花括号或关键字括起来(例如C++和Java中的“{"和“}”、 Visual Basic中
的“if-then-endi-”和其他语言的类似结构)为叙述方便,这里的讨论多数采
用“begin”和“end”,并假定你懂得如何将讨论运用于C++和ava中的花括号,
或者其他语言中的块结构。下面介绍四种常见的布局风格。
■纯块结构
■模仿纯块结构
使用“begin--end对(花括号)指定块边界
行尾布局
Pure Blocks
纯块结构
许多关于布局的争论源于许多常用语言的内在缺陷。一个设计精良的语言的
块结构非常清晰,适于一种自然而然的缩进风格。例如在 Visual Basic中,各个控
制结构都有自己的结束符,你用某种控制结构时不能没有结束符。代码分块是很
自然的事。 Visual Basic的例子在清单31-6、清单31-7、清单31-8中给出
代码大全(第2版)

<==========================775end ==============================>
<==========================776start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo..com!仅供试看^
31.3布局风格
739
清单31-6纯if块的 Visual Basic示例
If pixelcolor= ColorRed Then
statement1
statement2
End If
清单31-7纯 while块的 Visual Basic示例
While pixelColor= Color_red
statement1
statement2
Wend
清单31-8纯case块的 Visual Basic示例
Select Case pixelColor
Case Color_Red
statement1
statement2
casec
Case Color_Green
statement1
statement2
Case Else
statement1
statement2
End Select
Visual Basic的控制结构总有一个开始语句比如上面例子中的
“If-Then、“While、“Select--case”,而且有相应的结束语句。将控制结构
中的语句按缩进格式组织没有任何争议,对其他关键字的对齐方式的选择也产生
了一定的限制。
清单31-9是这类格式化方法的抽象表现形式。
清单31-9纯块布局风格的概例
A
B
代码大全(第2版)

<==========================776end ==============================>
<==========================777start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^ ^.com!仅供试看^
740
第31章布局与风格
在本例中,语句A和语句D分别是控制结构的开始和结束语句。对齐这两句
能给人以明确的前后照应的印象。
关于控制结构格式化的争议,部分源于有些语言并不要求块结构。你可以在
if-then后面只跟一条语句,而不必有正规的块。你必须为程序加上“begin--end”
对或者一对括号来构成代码块,而控制结构是不会自动产生代码块的。控制结构
中 begin和end不成对在C++和Java程序中就是“{”和“}”没有成对出现
一将会导致不知道 begin和end位于何处的问题故而,很多缩进问题之所以
存在,就是因为你得去弥补语言结构的不良设计后面几节描述了若干种补救的
方法。
Emulating Pure Blocks
模仿纯块结构
如果所用的语言不支持纯块结构,那么一个好的办法是:将关键字 begin和
end(或者“{”和“}”标记)看成是所在控制结构的扩展。因而在此类语言中应
该模仿 Visual Basic的格式化方式。清单31-1为欲模仿的结构的抽象视图。
清单31-10纯块布局风格的概例
ABC
在此风格中,控制结构以语句A开头,以语句D收尾。 begin意即应该放在
语句A的后面,end应为语句D。理论上要模仿纯块,应像清单31-11那样做
清单31-11模仿纯块风格的概例
C
代码大全(第2版)

<==========================777end ==============================>
<==========================778start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看^
31.3布局风格
741
这种风格用C++表示的例子参见清单31-12、清单31-13以及清单31-14
清单31-12模仿纯if块的C++示例
if( pixelcolor== Color_red)(
statement1:
ateme
statement2
清单31-13模 while仿纯块的C++示例
while( pixelcolor== Color_red
statement1;
statement2;
清单31-14模 switch仿纯/case块的C++示例
switch pixelColor
case Color Red:
statement1;
statement2;
break;
case Color_Green:
statement1;
statement2;
break;
default:
statement1;
atomon
statement2;
break;
这种对齐风格很好用,美观大方,可以一致地采用,可维护性也好。它符合
格式化的基本原理,有助于展现代码的逻辑结构,所以是恰当的风格选择。这种
风格在Java中是标准,在C++里用得也很普遍。
代码大全(第2版)

<==========================778end ==============================>
<==========================779start==============================>

该书下载自-书部落-分享计算机经典巨--www. !--www.shubulo. com!^.com!仅供试看^个
742
第31章布局与风格
Using begin-end Pairs (Braces)to Designate Block Boundaries
使用 begin-end对(花括号)指定块边界
纯块结构的替代方案是将 begin--end视为块边界(后面的讨论均用
“begin--end”来泛指 begin--end对、花括号,以及类似的语言结构)。采用这种
方法时,应该将 begin和end视为控制结构下的语句,而非控制语句的一部分。
就像前面在模仿纯块结构中所做的那样,理想的图形表示再次在清单31-15中给
出。
清单31-15纯块布局的风格概例
ABCD
而在这种风格中,要想把begin和end作为块结构的一部分而非控制语句,
必须将 begin置于块首(而不是控制语句的结尾),将end置于块尾(而不是结
束控制语句)。理论上,应该如清单31-16中那么做。
清单31-16以 begin和end为代码块边界的概例
BC
以 begin和end作为块边界的C++示例如清单3-17、清单31-18和清单31-19
所示。
清单31-17使用 begin和end作为if块边界的C++例子
if( pixelcolor== Color_red)
statement1;
statement2
清单31-18使用 begin和end作为 while块边界的C++例子
while pixelcolor ==Color_Red
statement1;
statement2;
代码大全(第2版)

<==========================779end ==============================>
<==========================780start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. !-www.shubuld com! ^.com!仅供试看
31.3布局风格
743
清单31-19使 begin用和end作为 switchcase代码块边界的C++例子
switch pixelcolor
case Color_Red:
statementl;
statement2;
break;
case Color_Green:
statementl;
statement2;
break;
statement1;
statement2;
break;
这种对齐风格挺好,符合格式化的基本原理同样也展示出代码的内在逻辑
结构)。唯一不足是无法精确适用于C++和Jaa中的 switch/case语句,如清单
31-19所示(关键字break代替右括号,而左括号没有等价表示)
Endline Layout
行尾布局
另一种布局策略是“行尾布局”,即一大组代码缩进至行中间或结尾的布局策
略。行尾缩进用来将代码块与作为该块开始的关键字对齐,使子程序的其余参数
与第一个参数对齐,或者在case语句中将各种情况对齐等类似目的。清单31-20
给出了抽象的例子。
清单31-20行尾布局风格的概例
A
B
C
D
这个例子中的语句A和D分别是控制结构的开始和结束语句,语句B、C和
D与语句A中的代码块开始关键字对齐。语句B、C、D的一致缩进表明它们为
一组。清单31-21为采用这种格式化策略的较为直观的例子。
代码大全(第2版)

<==========================780end ==============================>
<==========================781start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com! ^.com!仅供试看^
744
第31章布局与风格
清单31-31-21《VisuaIBasicwhile使用行尾布局的while代码块示例
While( pixelColor= Color_red
statement1;
statement2;
Wend
在这个例子中, bbegin位于行尾而非关键字的下面。有些人喜欢将置
于关键字的下面,但选择哪种方案只是一个细节问题。
在某些情况下行尾布局风格能很好的工作。清单31-22就是一个它适用的例
子。
清单31-22 Visual Basic中较少见但看上去相当好的行尾布局示例
If soldcount 1000 Then
markdown =0.10
ese关键字对
profit =0.05
齐于其上的
Else
then关键字
markdown =0 .05
End If
此例中的关键字Then、lse和 End If对齐,其后的代码也对齐。视觉上显
示出清晰的逻辑结构。
如果你挑剔地审视先前的case语句示例,可能会预见到这种风格的不完善。
当条件语句较复杂时,这种风格会提供无用或误导的逻辑结构信息。清单31-23
就是条件较复杂时该风格失效的示例。
清单31-23更典型的 Visual Basic示例,其行尾布局已失去应有的作用
If soldCount 10 And prevMonthsales 10 Then
If soldcount 100 And prevMonthsal 10 )Then
if( soldCount>1000)hen
CODING
markdown =0 .1
HORROR
profit =0.05
Else
markdown=0.05
End If
Else
markdown=0.025
End If
El
markdown =0.0
End If
代码大全(第2版)

<==========================781end ==============================>
<==========================782start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com!仅供试看
314控制结构的布局
745
示例末尾Ese从句的格式安排为何如此奇怪?因为它们总是与各自相应的关
键字缩进对齐。但是很难说缩进结构就清楚地显示了逻辑结构。如果代码有所修
改,以致于改变了第一行的长度,行尾风格就要求相关的多条语句也调整缩进,
从而产生维护性问题,而在纯代码块、模仿纯代码块以及使用 begin-end指定块
边界的布局风格中都不存在类似问题。
你可能觉得拼凑这些例子只是出于讨论需要尽管这种风格有不足之处,它
却一直沿用至今。大量课本和编程参考资料都推荐这种风格。我所见过的推荐这
种风格的书最早出版于20世纪70年代中期,最近则有2003年的。
总体来说,行尾布局不精确,很难持久地应用不易维护。你还会在本章的
余下部分看到行尾布局的其他问题。
Which Style Is Best
哪种风格最优
如果你用 Visual Basic语言,那就用纯块缩进结构( Visual Basic的集成开发
环境使你不用这一风格都很难)
对于Java,标准操作就是使用纯块缩进结构。
对于C+,你可能任由自己,或者采用团队中多数人喜欢的风格模仿纯块结构
和使用 begin--end指定块边界都能够工作得很好对其唯一的研究比较了这两种风
各,发现两者在可理解性方面并没有统计上的显著差别(Hansen and Yim1987)
所有风格都不绝对可靠,都偶尔需要进行“合理而明显”的折中。出于美观
原因你可能会更喜欢这种或那种。本书中的代码示例采用纯块风格,所以只要测
览这些例子,你就能领会很多有关该风格如何工作的说明。一旦你选择并持久地
应用某种风格,就能从良好的布局中受益匪浅。
31.4
Laying Out Control Structures
控制结构的布局
交叉参考有关
对控制结构做文
有些程序元素的布局主要牵涉美观问题。然而,控制结构的布局却会影响可
档说明的详细内读性和可理解性,故而实践中应优先考虑之。
容,请参见32.5
节中的“注释
控
制结构”:有关控
制结构的其他讨
论,请参阅第14
章到第19章
代大全(第2版)

<==========================782end ==============================>
<==========================783start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看
746
第31章布局与风格
Fine Points of Formatting Control-Structure Blocks
格式化控制结构块的要点
与控制结构块打交道时应该注意一些细节这里有若干基本原则。
不要用未缩进的 begin--end对在清单31-24所示的格式中, begin--end对和
控制结构对齐,其间的语句在 begin下缩进。
清单31-24ava中 begin--end对没有缩进结构的例子
begin与for对for(inti=0i< MAXLINES;1++
齐。
ReadLine i
语句在 begin下
ProcessLine i
缩进。
end与for对齐。
这种方法看起来不错,却违反了格式化的基本原理—没能显示出代码的逻
辑结构。这样的话, begin和end既不是控制结构的一部分,也不是其后语句的
一部分。
清单31-25是该方法的抽象表示。
清单31-25错误缩进结构的抽象例子
A
B
C
D
E
在这个例子中,语句B从属于语句A吗?它好像既非语句A的一部分,也不
从属于语句A。如果你用这种方法,就请改用先前介绍的那两种布局风格之一吧,
这样你的布局将会更加统一。
别让 begin和end两次缩进不要用无缩进的 begin--end,其一个推论就是
不要让 begin--end两次缩进。清单31-26所示的两次缩进, begin和end缩进,
而其间的语句又进一步缩进。
清单31-26 begin-end代码块不恰当地缩进两次的Java例子
for int i =0: i MAX_LINES; i++)
CODING
HORROR
begin下面的
「 ReadLine(i);
语句缩进了,
LProcessLine
似乎它们从属
于 Fbegin
代码大全(第2版)

<==========================783end ==============================>
<==========================784start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.c.com!仅供试看
31.4控制结构的布局
747
这个例子采用的风格虽好看,但却违反了格式化基本理论。一项研究表明
人们对于缩进一次的程序和缩进两次的程序的理解并无区别(Miaria et al.1983)
然而这种风格不能准确地给出程序的逻辑结构。 Readline()和 ProcessLine()
像是逻辑上从属于 begin--end对,但事实并非如此。
这一方法还扩大了程序逻辑结构的复杂度清单31-27和清单31-28所示的例
子看起来哪个更复杂呢?
清单31-27抽象结构1
清单31-28抽象结构2
两者都是for循环结构的抽象表示。尽管抽象结构1的代码与抽象结构2相
同,但其模样却更复杂。如果语句有两三层的嵌套,那么两次缩进会使代码有四
或六级缩进,导致布局看起来比实际代码复杂多了。通过使用模仿纯块结构,或
将 begin--end作为块边界,并将其间语句对齐,都可以避免这一问题。
Other Considerations
其他考虑
尽管块缩进是格式化控制结构的主要问题,你还是会遇到一些另类的难题,
这里再给一些指导原则。
段落之间要使用空行有些代码块没有用 begin--end对界定。逻辑代码块(即
属于一个整体的语句组)应该像英语中的段落那样对待用空行将它们各自分
开。清单31-29中的不同段落就应该分开。
代码大全(第2版)

<==========================784end ==============================>
<==========================785start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看^
748
第31章布局与风格
清单31-29应该分组并隔开的C++代码示例
cursor. start =startingScanLine;
cursor. end endingscanane:
window.title editwindow.title;
window. dimensionseditwindow. dimensionsi
cursor. blinkRate =editMode. blinkRate;
window.b
indow. backgroundcolor userPreferences. backgroundcolor:
Savecursor( cursor )
SetCursor cursor
交叉参考如果这段代码看起来不错,但加入空行可以在两个方面得到改进。其一,如果有
使用伪代码编程
过程,代码块会被一组语句并不需按某种特定的顺序执行,人们常常会像这里的样子把它们随便混
自动分隔。详情请在一起。你不必为计算机去改善语句的顺序,但是人却愿意看到更多线索,包括
参见第9章“伪代
码编程过程”。哪些语句需按特定顺序执行,哪些语句则不需要。在程序中加入空行,能促使你
更努力地去把哪些语句应属于一组的事情想清楚。清单31-30是修正之后的片段,
显示了这段代码究竟该如何组织。
清单31-30恰当分组和分隔的C++代码示例
window.dimensions editwindow.dimensions;
这些行产生indow.€wnQw1dWndowat1t1€.title
个文本窗。
window. backgroundcolor userPreferences. backgroundcolor;
window. foregroundColor userPreferend. foregroundcolor
cursor. start startingScanLine;
这些行产生光 cursor.end= endingScanLinei
标,应与前面 cursor. blinkRate= editMode. blinkRate;
那些行分隔 SaveCursor( cursor)
开。
SetCursor cursor)
这段重排后的代码表明它要做两件事。在上一个例子中,由于缺乏语句组织
和空行,加上过时的按等号对齐的技巧—使那些语句看起来比实际情况复杂得
多。
用空行改善代码的另一方面,是它自然而然地为注释提供了空间。在清单
31-30中,若在每个代码块上面添加注释,可以使布局锦上添花。
单语句代码块的格式要前后统一单语句代码块就是控制结构后面只有一条
语句,比如if测试语句后仅有的一条语句。这种情况下,正确编译并不需要 begin
和end,有三种风格可选,示于清单31-31
代码大全(第2版)

<==========================785end ==============================>
<==========================786start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo..com!仅供试看^
31.4控制结构的布局
749
清单31-31Java中单语句代码块风格选择示例
风格1if( expression
one-statement:
风格2a。if( expression)
one-statement;
风格2b。
if( expression)
o}
one-statement;
风格3if(3《expzesson《onetatement;)one-statement;
这些方法孰优孰劣还存在争议。风格1追随代码块所用的缩进方案,所以和
其他的方法一致。风格2(2a或者2b)也具有一致性,有 begin--end对就能减少
在if条件后添加语句却忘了加上 begin、end的可能性。这是特别细微的错误,
因为缩进结构会让你自以为代码正确,但是编译器可不这么想。相对于风格2而
言,风格3的主要优点就是键入比较方便。与风格1相比的优势是:如果需要拷
贝到程序里的其他地方,拷贝工作似乎更不容易出错。其缺点是:基于行的调试
器会把它当做一行,它将无法告知if条件后面的语句到底执行了没有。
我用过风格1,但多次错误的修改使我深受其害。而风格3会造成缩进策略
的例外,所以我也从不使用这种风格。在团队项目中,我喜欢风格2中的任一种,
因为它们有一致性和修改安全性。不管你选用哪种风格,都应该一贯使用它,在
if条件和所有循环中采用同一种风格。
对于复杂的表达式,将条件分隔放在几行上要将一个复杂表达式的各个部
分放在各自的一行里。清单31-32所示的例子表明,编程者格式化该语句时没有
考虑可读性。
清单31-32对复杂表达式毫无编排(也无可读性)的Java示例
if ( ('0' < inChar) & (inchar <='9' (('a' < inChar) &
(inChar<=z'))l(('a'<= inChar)&&(inChar<=2)))
这样的格式完全是供计算机用的,而不是让人看的。如果像清单31-33那样
将表达式分成几行,就能改善可读性。
代码大全(第2版)

<==========================786end ==============================>
<==========================787start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
750
第31章布局与风格
清单31-33容易看懂的表达式的Java示例
if(o inChar)&& inChar=9))
( ' < inchar & inchar <='z
(('a'<= inChar)&&( inchar<=z)))
交叉参考要将
复杂表达式组织第二个片段使用了几种格式化技巧缩进、空格、按行排序以及让不完整
得容易看懂,另行很显眼—从而得到易读的表达式。更重要的是,条件测试的意图也清晰可见。
一项技术是将其
到布尔函数如果表达式有错,例如Z误写成,用这种格式就很容易看出。若不操心格式化,
。有关内容以错误就不会那么明显了。
及其他可读性技
术,见第19.1节
“布尔表达式”
不用goto早先不用goto的理由是,goto会让程序的正确性验证变得很困
交叉参考关于难。这种说法被所有愿意程序正确的人所接受。对大部分程序员更具压力的问题
goto用法的细则是,goto使得格式代码布局很不好办。难道把goto语句和其转向标号之间的
节,请参看17.3代码统统缩进吗?如果有好几个转向同一标号的goto又怎么办呢?是不是让下
节“goto”。
个goto进一步缩进?下面是对格式化goto的几点建议。
goto标号应完全不用goto,也就一并消除了相关的格式化问题。
大写并左对齐于
行,应包含编程者转到的标号名全部使用大写字母表示,这样能使标号显眼
的名字、家庭电话
号码和信用卡号。包含goto的语句单独为一行,也为了使goto显眼
-Abdul Nizar
将goto语句转到的标号单独为一行,上下也为空行,从而使标号很显眼。
将含有标号的行突出,使其尽量显眼。
清单31-34给出了恰当的goto布局惯例。
交叉参考关清单31-34++中不良状况(即使用了goto)的最佳弥补方法
于解决该问题 void PurgeFiles( ErrorCode& errorCode
的其他方法,请FileList fileListi;
参见17.3节中int numFilesToPurge=0:
的“错误处理和MakePurgeFileList( fileList, numFilesToPurge)
goto”。
errorCode FileError_Success;
int fileindex=0
while( fileIndex numFilesToPurge)
DataFile fileToPurge:
if( IFindFileList fileIndex. fileToPurge))
errorCode FileError_NotFound;
这里有个goto
goto END_PROC;
代码大全(第2版)

<==========================787end ==============================>
<==========================788start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. --www.shubulo.com!^ ^.com!仅供试看^
31.4控制结构的布局
751
if(OpenFile( fileToPurge))(
errorCode FileError_ NotOpen:
这里有个goto
goto END_PROC
if(OverwriteFile fileToPurge))
errorCode FileError_CantOverwrite;
这里有个goto
→goto END_proc
if IErase( fileToPurge
errorCode =FileError CantErase;
这里有个goto
→goto END_proc
fileIndex++;
这里的大写
goto标号及其
布局的意图都NDPROC:
是为了让标号
不易被忽视。
DeletePurgeFileList fileList, numFilesToPurge )
交叉参考有关这一C++示例比较长,在这种情形下高手或许认为goto就是最好的选择。格
使用case语句的
内容,请参看第式化布局充其量也不过如此。
15.2节“case语
句”。
case语句不要有行尾布局的例外行尾布局的风险之一就是case语句的格
式化。case语句格式化的一种流行方法是将其都缩进于case说明的右边,如清
单31-35所示。维护太麻烦是这种风格的一大弊端
清单31-35case语句采用行尾布局难以维护的C++示例
switch ballColor
case BallColor_Blue:
rollout
break;
case BallColor_Orange:
SpinonFinger();
break;
case BallColor_FluorescentGreen: Spike();
break:
case Ballcolor_White:
KnockCoveroff():
cas
Ballcol
r_WhiteAndBlue: if(mai
break: BallColor_Whitel(
KnockCoveroff()
) if( maincolor
else if( maincolo
RollOut
break;
default:
FatalError("
break;
代码大全(第2版)

<==========================788end ==============================>
<==========================789start==============================>

该书下载自-书部落-分享计算机经典巨著!--www !--www.shubulo..com!仅供试看^
752
第31章布局与风格
如果新加一个case,其名字比现有的case名都长,就得将所有的case及其后
的代码移位。大量的初始缩进很难容纳更多的逻辑代码,正如 WhiteAndBlue条
件所示的那样。解决之道是改成标准缩进增量。如果循环使语句缩进三个空格,
就应像清单31-36那样对case语句缩进同样数目的空格。
清单31-36case语句按标准数目缩进的C++示例
switch ballColor )
case BallColor_Blue:
Rollout ()
breakirn
case BallColor_Orange:
SpinonFinger);
break
case BallColor_FluorescentGreen:
Spike();
breakiwhite:
case BallColor_White:
KnockCoveroff();
break;
case Ballcolor_WhiteAndBlue
if( maincolor= BallColor_White)
KnockCoveroff
else if( maincolor=Ballcolor_blue)
RollOut();
break
default:
FatalError("Unrecognized kind of ball.")
break;
很多人可能觉得前一个例子更美观。但以容纳更长语句、持久性和可维护性
的能力等来衡量,第二种方法才是赢家。
如果case语句里面所有的情况都是平行的,且操作都很短,可以考虑将case
和操作放在一行。但多数情况下你注定不能这样。这样格式化最初就很麻烦,修
改也会将它打乱,当短操作变长时很难再保持所有情况平行的结构。
代码大全(第2版)

<==========================789end ==============================>
<==========================790start==============================>

该书下载自-书部落分享计算机经典巨著!--www. !--www.shubulo.com!^.com!仅供试看
31.5单条语句的布局
753
31.5
Laying Out Individual Statements
单条语句的布局
本节说明在程序中改善单条语句布局的多种方法。
Statement Length
语句长度
关于一条常见但有点过时的规则,就是语句长度应限制在80个字符以内,理由如下
文档化单条语句
的详细内容,请参超过80个字符的语句很难读。
看32.5节中的“注
释单行”。
80个字符的限制不鼓励深度嵌套。
长于80字符的语句行在8.5×11英寸规格纸张上放不下,特别是当一面打印
两栏代码时(每张物理输出页面打印两页代码)。
有了大幅面的显示器、窄的字体和横向打印模式,80个字符行的限制日益显
得武断了。一行上有90个字符常比为避免超出80个字符将其拆分为两行要容易
读得多。通过现代技术的帮助,偶尔超过80个字符也没多大关系。
Using Spaces for Clarity
用空格使语句显得清楚
在语句中加入空格可以提高可读性。
使用空格会让逻辑表达式更易读下列表示:
while (pathname start Pathiposition]<>';)and
((startPath+position) <length(pathname)) do
读起来和“Idareyoutoreadthis”(我赌你读不懂这个)一样糟糕。
作为规则,应用空格来分隔标识符。这样的话,上述 while语句就该是:
While pathname startPath position <>' ' and
startPath+ position)< length( pathname))do
一些软件艺术家或许会建议再加些空格,来强调特定表达式以突出其逻辑结
构,也就是:
while pathname starta+ position 1<>';) and
( startPath+ position)< length pathname)do
这样做是好,不过前一种用空格的方法已经足够保证了可读性。话又说回来,
额外的空格极少起负面作用,所以尽量多用吧。
代大全(第2版)

<==========================790end ==============================>
<==========================791start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看^
754
第31章布局与风格
使用空格让数组引用更容易读下列表达式:
grossRate [census [groupId] gender census [groupId], ageGroup]
比起前面密密麻麻的 while表达式,其可读性好不到哪里去。在数组下标前后应
加上空格使其易读。采用这一规则时,上面表达式就应该如下:
grossRate[ census groupid], gender, census【 groupid], ageGroup
使用空格让子程序参数更容易读下面子程序的第四个参数是什么?
ReadEmployeeDate(maxEmps, empDate, inputFile, empCount, inputError)
那么下面这个子程序的第四个参数又是什么呢?
GetCensus inputFile, empcount, empData, maxEmps, inputRrror
哪个容易看到?这是一个有意义的现实问题,因为参数位置对所有主要的过程化
语言都是很重要的。很常见的做法是将子程序说明放在半个屏幕,而其调用位于
另半个屏幕,以便对照形参和实参。
Formatting Continuation Lines
格式化后续行
程序布局中最恼人的一个问题,就是需要确定如何将较长语句延续到下一行。
是该按照一般的缩进量对其缩进?还是将其关键字对齐?对赋值语句怎么处理?
这里有一个合理而特别耐用的方法,特别适宜于Java、C、C++、 Visual Basic
等提倡长变量名的语言。
使续行明显语句有时需分为几行,要么由于太长,超过了允许的编程标准,
要么因为占据一行会让行长得离谱。这时放在第一行中的那部分要清清楚楚地表
明它仅是语句的一部分。断句最简单的方法是将第一行部分做成若其单独时就有
明显语法错误的样子。清单31-37是一些示例。
清单31-37明显不完整的语句的ava示例
“&&标明该while( pathName startPath+ position&
语句没完。
(( startPath+ position)<= pathName. length())
“+”标明该语totalBill= totalBil1+ customerPur customerID+
_totai11etr
句没完。
SalesTax( customerPurchases[ customerID
window north windou sout
“,"标明该语DrawLine( window.norh,window.south, window.east
句没完。
currentWidth, currentAttribute)
代码大全(第2版)

<==========================791end ==============================>
<==========================792start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
31.5单条语句的布局
755
除了告诉读者第一行的语句不完整外,断句也有助于防止不当的修改。如果
语句其他部分删除,第一行看起来不只是忘加了括号或分号显然后面还有不
少内容。
另一个办法是将后续的字符置于后续行的开头如清单31-38中所示,这种
方式也工作得不错。
清单31-38另一种明显不完整的语句的Java示例
while pathName[ startPath position !=:
&&(( startPath+ position=pathName. length()
totalBi11 totalBi11+ customerPurchases customerID
+ SalesTax customerPurchases[ customerID)
尽管这种风格不会导致以“&&”或“+”结尾的语法错误,但扫视文本对齐
的左边界的运算符比右边界位置容易,后者较拥挤。另一个好处是标明运算的结
构,如清单31-39所示。
清单31-39能够清楚说明复杂运算风格的Java示例
totalBill totalBill[ customerID
+ CitysalesTax( customerPurchases customerID)
StatesalesTax( customerPurchases customerID])
+ FootballstadiumTax()
SalesTaxExemption( customerPurchases[ customerID
把紧密关联的元素放在一起如果要断句,应将属于一体的东西放在一起,
例如数组下标、子程序参数等。清单31-40中的例子做得就不好。
清单31-40中断句拙劣的Java示例
customerBi11 -PreviousBalance( paymentHistory( customerID
Latecharge
paymentHistory[ customerID
CODING
HORROR
说实话,这样断句确实遵守了将语句的不完整性明显标识的原则,但它使语
句无谓地难以读懂。有些情况下这样断句还可以,但本例则没有必要。最好是将
数组引用也放在同一行。清单31-41中的格式比较好。
代码大全(第2版)

<==========================792end ==============================>
<==========================793start==============================>

该书下载自-书部落-分享计算机经典巨著--www !--www.shubulo.cor.com!仅供试看^
756
第31章布局与风格
清单31-41恰当断句的Java示例
customerBillPreviousBalance( paymentHistory customerID+
LateCharge( paymentHistory customerID)
将子程序调用的后续行按标准量缩进如果在循环或条件语句中通常缩进三
个空格,就应将子程序调用语句的后续行也缩进三个空格。清单31-42给出了
些例子。
清单31-42Java示例:按标准缩进量对子程序调用语句的后续行缩进
DrawLine window. north, window. south window.east, window.west,
currentWid
th, currentAttribute)
SetFontAttributes( faceName fontId,size fontId, bold fontId,
italic fontId, syntheticattribute fontIa. underline,
syntheticAttribute[ fontid strikeout
另一个办法是将后续行对齐于子程序的首个参数处,如清单31-43所示。
清单31-43Java示例:缩进子程序调用语句的后续部分,以强调子程序名
DrawLine( window.north, window. south, window.east, window.west,
currentwi ath, currentAttribute )ira
italic[ fontId
syntheticAttribute fontIa. underline
syntheticAttribute fontId. strikeout)
从美观角度看,这样做不如第一个办法整齐,而且当子程序名、参数名之类
改变时,维护也麻烦些。多数程序员用一段时间后会被第一个办法吸引过去。
让续行的结尾易于发现上述的方法有一个问题,那就是不易找到一个行的
结尾。还有一个办法是每个参数占一行,最后用右括号括起来以示参数结束。清
单31-44给出了其外观。
清单31-44Java中将子程序调用后续行中的单个参数作为一行的例子
DrawLine(
window.north,
window. south,
window, east,
window. west,
currentWidth,
代码大全(第2版)

<==========================793end ==============================>
<==========================794start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! -www.shubulo.c.com!仅供试看^
31.5单条语句的布局
757
currentAttribute
);
SetFontAttributes
faceName[ fontId 1,
size[ fontId ]
bold[ fontId],
italic[ fontId],
syntheticAttribute[ fontid ] underline,
syntheticAttribute[ fontId ] strikeout
);
显然该方法要占用大量篇幅。如果子程序参数是长长的对象域引用或指针名,
就像上面例子中最后两个参数那样,则每行仅有一个参数会从根本上增强可读性。
块结尾处的“);”清楚地标明了调用结束。如果要增加参数,只需插入新行而不必
重新编排。
实际上,一般只有少数的子程序需分成几行,多数情况下都可以只用一行。
只要持久不变地使用这三个办法中的一个,都可以很好地格式化多行子程序调用
将控制语句的后续行缩进以标准的空格数如果for循环、 while循环或者
if语句头部太长,请将后续行与循环体或if后的语句一样缩进。清单31-45给出
了两个示例。
清单31-45控制语句后续行缩进的Java例子
while pathName[ startPath position !=; &&
后续行按标准(( startPath+ position<= pathName. length()))
空格数缩进。
,∵
for( int employeeNum employee. first+ employee. offset
这里也一样。
+employeeNum employee. first employee. offset employee,total:
LemployeeNum++){
交叉参考有时
对复杂条件的最
这迎合了本章前面的规则,语句后续部分的布局很合乎逻辑它总是在所
好解决办法是将接续的语句下面缩进。缩进可以一贯进行下去只比首行多几个空格而已,同
其置于布尔函数
中。有关示例可参样易读、可维护。有时微调缩进或者空白可以改善可读性,但微调时要务必兼顾
看第191节中的可维护性。
“简化复杂的表
达式”
代码大全(第2版)

<==========================794end ==============================>
<==========================795start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^.com!仅供试看^
758
第31章布局与风格
不要将赋值语句按等号对齐在本书的第版中,曾建议将含有赋值的语句
按等号对齐,如清单31-46所示。
清单31-46Java示例:对赋值语句后续行按行尾原则布局,这是不当的做法
customerPurchases customerPurchases+ CustomerSales CustomerID
customerBill customerPurchases;
totalCustomerBil1 customerBill+ PreviousBalance( customerID)+
customerratinaatecharges cust omerrot aicustomer
经过十年的实践我才发现,尽管这种缩进看上去不错,但若变量名称改变,
或运行将制表符换作空格和以空格换作制表符的工具时,要维持以等号对齐就会
很麻烦。还有,将程序行移往其他不同缩进级别的位置时,也很不好维护。
为了与其他缩进规则保持一致,也为了可维护性,应将包含赋值操作的语句
组与其他语句同等看待,如清单31-47所示。
清单31-47Java示例:对赋值语句后续部分缩进标准量,这是正确的做法
customerPurchases customerPurchases Customersales CustomerID
customerBill customerBil1 customerPurchases:
totalcustomerBi11 customerBi1l PreviousBalance( customerID
LateCharge( customerID)
customerRating Rating customerID, totalCustomerBill)
对赋值语句后续行按标准量缩进在清单31-47中,第三个赋值语句的后续
行以标准数量缩进。不对其以特殊方式格式化赋值语句还是基于同样理由:通用
的可读性和可维护性。
Using Only One Statement Per Line
每行仅写一条语句
诸如C++语言和Java的现代语言允许每行有多条语句。然而,在一行里放上
几条语句,对这种随心所欲的格式化风格褒贬不一。包含若干语句的行在逻辑上
可分解为各语句单独占一行:
i=0;j=0;k=0; DestroyBadLoopNames(i,j,k);
代码大全(第2版)

<==========================795end ==============================>
<==========================796start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.com!^^.com!仅供试看^
31.5单条语句的布局
759
将多个语句放在一行的理由是,这样可以少占屏幕或者打印纸篇幅,从而一
次能多看些代码;它也能将相关语句集中在一起有些程序员还觉得能为编译器
提供优化线索。
这些理由都有道理,但每行只写一个语句的理由更具说服力。
将每个语句单独置于一行,能够提供有关程序复杂性的准确观点。这样就不会
因为使复杂的语句看起来简单而隐藏了程序的复杂性应该让复杂的语句一看
就是复杂的,简单语句一看就是简单的。
交叉参考第25对于现代编译器,将多个语句放在一行不能提供任何优化线索。不要指望格式
章“代码调整策
略”和第26章编排来优化编译过程。本节后面还会有所说明。
“代码调整技
术”讨论了代码各语句单独占一行,则代码仅需自上而下读,而不必自上而下,还要从左往右
级的执行优化。去读。当寻找某特定行的代码时,你只用盯着代码的左边界,不再由于某一行
可能包括两条语句而去深入每一行。
各语句单独占一行,在编译器以行号指出某行有错误时,你将更容易找出语法
错误。如果一行有多条语句,行号并不能告诉你究竟是哪一条语句出了错。
各语句单独占一行,在基于行的调试器中就容易单步地执行代码。如果一行有
多条语句,调试器就会一次执行这些语句,你必须切换到汇编程序中才能单步
执行各语句。
各语句单独占一行,编辑单个语句也更容易删除一行或者临时将某行改为
注释。如果一行有多条语句,就只能在语句间做这些编辑工作。
C++中,不要让一行里有多个操作(副作用)“副作用”指语句除了主要
结果之外还有其他效用。对于C++,如果一行里既有“++”操作符又有其他操作,
则“++”就是副作用。类似地,向变量赋值,将赋值语句的左边作为条件也是副作
用。
副作用使代码难以看懂。例如,如果n等于4,清单31-48示例中的语句会打
印输出什么呢?
清单31-48意义不明的有副作用的C++示例
PrintMessage( ++n, n +2
代码大全(第2版)

<==========================796end ==============================>
<==========================797start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看^
760
第31章布局与风格
是4和6吗?是5和7吗?抑或是5和6?这些答案都不对。第一个参数“++n”
是5,但C++并未定义表达式的运算次序,也没有定义子程序参数的求值次序。
所以编译器在第一个参数或前或后,来计算第二个参数n+2,结果可能是6或7,
依编译器而定。清单31-49给出该如何重写此语句,以便使意图清楚
清单31-49避免意图不清的有副作用的C++示例
++n:
如果你对“让有副作用的语句单独占一行”不以为然,就试着说明清单31-50
中的子程序做的什么。
清单31-50一行上有过多操作的C示例
strcpy( char *t, char s
while(*++t=*++s)
一些经验丰富的C语言程序员并不觉得例子复杂,因为这是个常见的函数。
他们会瞥一眼,说道:“不就是strcpy()嘛。然而它并不完全是 strcpy(),因
为这里有个错误。如果你看着这些代码说“是 strcpy()”,说明你认出了代码
而没有理解之,这正是你调试程序时的情景正因为你“认得”这些代码而没有
理解它们,你就不会注意到,其实它还有难以发现的错误。
清单31-51所示片段的功能和上例相同,也容易读懂。
清单31-51把各操作放在各自的行中,从而改善了可读性的语言示例
strcpy(char*t,chars
++
++;
*t=*s
while *t !='\0'
在这样改编后的代码,错误是显而易见的。显然,在*s拷贝给之前,t和
s就已递增了,所以错过了第一个字符的拷贝。
第二个例子看起来比第一个例子啰嗦,尽管两者完成的操作一样。之所以显
得啰嗦,是因为它没有掩饰操作的复杂性。
代码大全(第2版)

<==========================797end ==============================>
<==========================798start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!^.com!仅供试看^
31.5单条语句的布局
761
交叉参考有关
性能的改善并不靠将多个操作置于一行实现。由于这两个 strcpy()子程序逻
代码调整的细辑上等效,你可能认为编译器会产生相同的代码。然而,在测量这两个版本的子
节,请参看第25
章“代码调整策程序时发现,要拷贝五百万个字符串,第一个版本需花费4.81秒的时间,而第二
略"和第26章代
码调整技术”。
个版本只需耗时4.35秒。
在本例中,“聪明”的版本反而多花了11%的时间,使其显得不怎样了。结果
因编译器而异,但通常建议最好还是先求清晰正确,其次才是执行效率,除非你
对性能收益已经了如指掌。
即使你能轻松地看懂有副作用的语句,你也得照顾那些将来要读你的代码的
人。多数优秀的程序员在理解带副作用的表达式时都会三思。让他们的脑袋去考
虑你的代码如何工作等大问题吧,而不是去思考其中的特殊表达式的语法细节。
Laying Out Data Declarations
数据声明的布局
交叉参考有每行只声明一个数据前面示例已说明,应将每个数据声明单独列一行。这
关数据声明的样的话,就容易在声明旁添加注释;每个声明自成一体也便于修改;只需按列查
文档化,请参看
32.5节中的“注找而不必通读每一行,从而找到特定变量会容易些;由于编译器只给出错误行号,
释数据声明”所以定位并改正语法错误也方便了。
用请第10看清单31-52中的数据声明,快说变量
清单31-52将多个变量的声明堆在一起的C++示例
int rowIndex, columnidx; Color previousColor, currentcolor, nextColor; Point
previousTop, previousBottom, currentTop, current Bottom, nextTop, nextBottomfont
previousTypeface, currentTypeface, nextTypeface; Color choices NUM_COLORS ]i
HORROR
这个例子比较极端,而清单31-53中的风格则很常见。
清单31-53将多个变量的声明堆在一起的C++示例
int rowIndex, columnIdxint
Color previouscolor, currentColor, nextColor;
Point previousTop, previousBottom, currentTop, currentBottom, nextTop,
nextBottom
CODING
HORROR
infacerre
peface. nextTypefa
Font previousTypeface, currentTyp, nextTypeface
Color choices NUM_COLORS
代码大全(第2版)

<==========================798end ==============================>
<==========================799start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
762
第31章布局与风格
这种变量声明的风格并不鲜见,变量依旧难以查找,因为所有声明都挤在一
起。变量类型同样也难查清。那么,清单3154 nex中的是什么类型呢?
清单31-54每行只声明一个变量来获得可读性的C++示例
int rowIndex;
int columnIdxi
Color previouscolor;
Color currentColor;
Color nextcolor;
Poi
oint previousTopi
Point previousBottom;
Point currentTop:
￥PO1nLYDeXL1ODH￥
P
Ffonnt rext gottomiface.
Font previousTypeface;
Font currentTypeface;
Font nextTypeface:
Color choices[ NUM_COLORS
而在清单31-53中,变量 nextColor找起来大概比变量 next Typeface容易
这一风格的特点是,每行一个变量,每行的声明也完整,都包含有变量类型。
坦白地说,这种风格占用了大量屏幕空间—20行,而第一个例子只有3行。
尽管后者看上去有些丑陋。我不是说这种风格会让bug少一点或者理解更容易
但是如果程序员 Sally请我审代码,而其数据声明看起来像第一个例子,我会说:
“算了吧—你的代码太难看懂了。”;如果代码像第二个例子,我会说:“好
吧我会尽快答复你的。”;如果看起来像最后的例子,我会说:“当然我很
乐意帮助你。”
变量声明应尽量接近其首次使用的位置比起将所有变量集中声明,将变量
在其首次使用的附近位置声明是更好的风格。这样减少了“跨度”和“生存期”,
便于必要时将代码重构为更小的子程序。详细内容请参见第10.4节中的“尽可能
缩短变量的‘存活’时间”
合理组织声明顺序清单31-54中,声明按类型分组。由于同类型的变量常
在相关操作中使用,按类型分组往往合乎情理另一种情况是,你可能选择按照
变量名称的字母顺序排列。尽管按字母顺序编排有众多鼓吹者,但我感觉它会花
费太多精力,以致超过了它带来的好处。假如变量清单太长,按字母排序会有所
帮助,但也表明你的子程序也许太大了。请将其分成几个子程序,让它们各自只
有较少的变量。
代码大全(第2版)

<==========================799end ==============================>