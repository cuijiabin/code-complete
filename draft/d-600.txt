<==========================500start==============================>

该书下载自-书部落-分享计算机经典巨著-ww. ! --www.shubulo.com!.com!仅供试看
The Software Quality
Landsc
第20章
软件质量概述
cc2e.com/2036/2036内容
20.1软件质量的特性:第463页
20.2改善软件质量的技术:第466页
20.3不同质量保障技术的相对效能:第469页
20.4什么时候进行质量保证工作:第473页
20.5软件质量的普遍原理:第474页
相关章节
协同构建:第21章
开发者测试:第22章
■调试:第23章
软件构建的前期准备:第3、4章
前期准备适用于现代软件项目么:第3.1节
本章从构建( construction)的角度来审视保障软件质量的技术。当然,这整
本书都是关于提高软件质量的,但是本章注重的是质量和保证质量本身。相对于
那些手把手就可以教会的方法来说,本章更注重从整体看问题。如果你需要的是
关于协同构建、测试和调试的实用建议,请直接看接下来的三章。
Characteristics of Software Quality
20.软件质量的特性
软件同时拥有外在的和内在的质量特性。外在特性指的是该产品的用户所能
够感受到的部分,包括下列内容。
正确性( Correctness)指系统规范、设计和实现方面的错误的稀少程度。
可用性( Usability)指用户学习和使用一个系统的容易程度。
代码大全(第2版)

<==========================500end ==============================>
<==========================501start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!供试看^
464
第20章软件质量概述
效率( Efficiency)指软件是否尽可能少地占用系统资源,包括内存和执
行时间。
可靠性(Reliability)指在指定的必需条件下,一个系统完成所需要功能
的能力应该有很长的平均无故障时间。
完整性( Integrity)指系统阻止对程序或者数据进行未经验证或者不正确
访问的能力。这里的完整性除了包括限制未经授权用户的访问外,还包括确
保数据能够正确访问,例如:保证那些保存着并行数据的表格能够正确地并
行修改,确保日期字段一定含有效的日期,等等。
适应性(Adaptability)指为特定的应用或者环境设计的系统,在不做修
改的情况下,能够在其他应用或者环境中使用的范围。
精确性(Accuracy)指对于一个已经开发出的系统,输出结果的误差程度,
尤其在输出的是数量值的时候。精确性和正确性的不同在于,前者是用来判
断系统完成工作的优劣程度,而后者则是判断系统是否被正确开发出来。
健壮性( Robustness)这指的是系统在接收无效输入或者处于压力环境
时继续正常运行的能力。
以上这些特性中,有一部分是互相重叠的,但它们都有不同的含义,并且在
不同的场合下,重要性也有所不同。
质量的外在特性是用户关心的唯一软件特性。用户只会关心软件是否容易使
用,而不会关心对于程序员来说修改起来是否容易。他们关心软件是否能正确运
行,而不关心里面的代码是否可读,或者是否有良好的结构。
而程序员除了关心软件质量的外在特性之外还要关心它的内在特性。本书
的核心是代码,所以它更关注软件内在的质量特性。
可维护性(Maintainability)指是否能够很容易对系统进行修改,改变或
者增加功能,提高性能,以及修正缺陷。
灵活性( Flexibility)指假如一个系统是为特定用途或者环境而设计的,那
么当该系统被用于其他目的或者环境的时候需要对系统做修改的程度。
可移植性(《(Porabilly《)指为了在原来设计的特定环境之外运行,对系统
所进行修改的难易程度。
可重用性( Reusability)指系统的某些部分可被应用到其他系统中的程度
以及此项工作的难易程度。
可读性( Readability)指阅读并理解系统代码的难易程度,尤其是在细节
语句的层次上。
代码大全(第2版)

<==========================501end ==============================>
<==========================502start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.cor.com!仅供试看
20.1软件质量的特性
465
可测试性(Testability)指的是你可以进行何种程度的单元测试或者系统
测试,以及在何种程度上验证系统是否符合需求。
可理解性(Understandability)指在系统组织和细节语句的层次上理解整
个系统的难易程度。与可读性相比,可理解性对系统提出了更高的内在一致
性要求。
同外在质量特性相仿,一些内在质量特性之间也是有所重叠的,同样,它们
中的每一个在特定场合有着不同的重要性。
系统质量的内在特性是本书的主要内容,但本章不准备对这个问题展开更进
步的讨论。
内在和外在特性并不能完全割裂开来,因为在某些层次上,内在特性会影响
某些外在特性。一个无法从系统内部理解或者维护的软件,其缺陷也是很难修正
的,而这又会影响正确性和可靠性等外在特性一个刻板的软件无法根据用户需
要进行改进,这就影响了可用性这一外在特性关键在于,某些特性强调软件要
让用户用起来方便,而另一些特性则强调软件让程序员维护起来方便。我们需
要弄清楚的问题是:哪一种特性是什么,什么时候这些特性之间会发生什么样的
相互作用。
要让所有特性都能表现得尽善尽美是绝无可能的。需要根据一组互相竞争的
目标寻找出一套优化的解决方案,正是这种情况使软件开发成为一个真正的工程
学科。图20-1显示了关注某些外在特性会如何影响另些外在特性。软件质量的
内在特性之间也存在类似的相互关系。
这个图里最有趣的情况是:关注某一个特性并非意味着必须牺性另一个特性。
有时一个特性会对另一个特性有所损害,有时候二者相互促进,而有时候它们毫
不相干。举一个例子,正确性是描述实际功能与说明是否完全一致的特性,健壮
性是指系统即使遇到了预料之外的条件,它仍然能够继续发挥功能的特性。强调
正确性会损害健壮性,反之亦然。与此相反,关注适应性却会对健壮性有所帮助,
反之亦然。
图20-1所示的仅仅是一些质量特性之间的典型关系。在任何一个项目中,两
个特性之间的关系可能会与典型的关系不同。思考一下软件的特定质量目标,以
及每一对目标之间的相互关系,是相互促进还是相互制约,这将是很有意义的
件事情。
代大全(第2版)

<==========================502end ==============================>
<==========================503start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo..com!仅供试看^
466
第20章软件质量概述
How focusing
on the factor
below affects
th
he factor to
the right
正确性↑
可用性
↑
效率↑↓↓
可靠性↑
↑
完整性
↓↑
适应性
↓↑
精确性 Helps it↑
健壮性 Hurts it
图20-1强调软件的某个外在特性,可能会对另一些特性产生正面或者负面的影响,
也可能没有任何影响
20.2
Techniques for Improving Software Quality
改善软件质量的技术
软件质量保证是一个需要预先计划的、系统性的活动,其目标就是为了确保
系统具备人们所期望的特性。虽然开发一个高质量产品的最好方法似乎就是专注
于产品本身,但就软件质量保证而言,你还需要关心软件开发的过程。下面一些
小节将会描述软件质量中的某些要素。
软件质量目标改善软件质量的一种强有力的方法,就是根据前面章节所提
到的各种外在特性和内在特性,明确定义出软件质量的目标。如果没有一个明确
的目标,那么程序员去极力增强的特性就可能同你所强调的特性有别。本节稍后
部分将对设置明确目标所带来的好处进行详细讨论。
明确定义质量保证工作在保证质量的工作中,一个最常见的问题是质量被
认为是次要目标。没错,在某些组织当中,快速而糟糕(quick and dirty)的编程
已经成了普遍现象,而非另类。在这种组织当中,有像“Global Gray”这种胡乱
堆砌劣质代码并能快速“完成”程序的程序员,也有像“High--Quality Henry”这
种编写完善程序,并在程序发布之前确保程序能正常工作的程序员,而前者在组
织中获得的报酬有可能会高于后者。如果你发现这些组织里面的程序员没有把质
量作为他们工作的头等大事,没什么好奇怪的。组织本身必须向程序员们说明,
质量应当放在第一位。因此,将质量保证工作明确下来,可以清楚地表明这件事
情的优先程度,如此一来,程序员就会据此做出响应。
代码大全(第2版)

<==========================503end ==============================>
<==========================504start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
20.2改善软件质量的技术
467
交叉参考在第测试策略执行测试可以为产品的可靠性进行详细的评估。质量保证的一部
22章“开发者测分就是制订出一套与产品需求、架构以及设计相关联的测试策略。许多项目开发
试”中有对测试的
详细讨论。商把测试作为质量评估和质量改善的首要方法,本章其余部分将会详细证明,这
样的想法将使得测试不堪重负。
交叉参考在第
软件工程指南在开发过程中,指南应当控制软件的技术特性,它应当贯彻
4.2节“编程约定”到所有的开发活动中去,包括问题定义、需求分析、架构设计、构建以及系统测
里介绍了一些适
合于软件构建的试。本书里讨论的指南,从某种意义上就是一套软件工程的构建指南。
软件工程指南。
非正式技术复查许多软件开发人员会在正式复查之前自行检查自己的
作。非正式复查(review)包括对设计或代码的桌面检查(desk-checking-),或者
和若干同事一起将代码走查(wak -through-)一遍。
交叉参考在第
正式技术复查管理一个软件工程过程的工作之一,就是要在低成本的环节
21章“协同构里抓出问题即,在投资最小并且修正问题成本最小的时候。要实现这一目标,
建里有对复查和
检查的介绍。开发人员周期性使用“质量门(quality gates)”测试或者复查,以检验某一阶段
的产品是否已经具备了进入下一阶段前所要求的质量。质量门通常用于从需求分
析到架构,从架构到构建,以及从构建到系统测试之间的转换过程。所谓“门”
可能是一次检查,也可能是一次同事互查,或一次客户复查,或者一次独立审查。
交叉开发到达一个“门”并不是说架构或需求必须要尽善尽美,或必须持久稳定在某
方法着项目类一水平。它的实际意义在于可以用它来判断需求或者架构是否已经足够的好,从
型的不同会有很
大的差异,在第而决定是否进入下游的开发工作。“足够好”既可能指大致实现了需求或架构中最
3.2节“辨你所重要的20%,也可能指你已经给出了其中95%的规范说明到底是何种程度应
从事的软件的类
型”有详细介绍。当根据特定项目的性质来决定。
外部审查外部审查是一种用于确定一个已开发项目或产品的状态的特殊技
术复查方法。一个审查小组由开发组织以外的人员构成,并且向委托人汇报审查
结果,这个委托人通常是经理。
Development Process
开发过程
课入阅读
到目前为止所提到的每一要素,都同软件质量保证有着明确关系,同软件开
s发流程也暗含脉络。相对于没有质量保证活动的开发流程,具备该活动的开发流
Software
Developmant程能生产出更好的软件。而其他并非显而易见的软件质量保证活动,也一样会对
(McConnell
1994书将软软件质量产生影响
件开发作为一个
过程详加讨论。
代大(第2版)

<==========================504end ==============================>
<==========================505start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
468
第20章软件质量概述
交叉参考第对变更进行控制的过程实现软件质量目标的拦路虎之一就是失控的变更。
28.2节“配需求变更的失控可能使设计和编码工作前功尽弃;设计变更的失控则会造成代码
理对变更控制进
行了说明。与需求背离,或代码自相矛盾,或是程序员为达到变更后的设计要求,不得不耗
费比推进项目更多的时间来修改代码。代码变更的失控则可能造成内部冲突,程
序员无法确定哪些代码已经过完全复查和测试而哪些没有。变来变去的自然影
响就是质量不稳定和恶化,因此,有效地管理变更是实现高质量的一个关键。
结果的量化除非质量保证计划的结果经过实际测量,否则你将完全不知道
这个计划是否有实效。量化结果能告诉你计划成功与否,并且允许你用可控的方
式来调整你的计划,去看你能如何改善它你也可以度量各种质量特性本身
正确性、可用性以及效率等,这么做是很有用的。有关度量质量特性的详细内容,
请参见《 Principles of software Engineering》(ilb1988)第9章
制作原型( Prototyping)制作原型是指开发出系统中关键功能的实际模型。
对一个开发者来说,开发出一部分用户界面的原型可以判断系统的可用性,开发
MARD DATA出关键算法的原型可以确定功能的执行时间,开发出典型数据集的原型能知道程
序的内存需求。有一项研究对16个已公布和8个未公布的个案进行了分析,以便
对原型开发方法和传统的依照规范开发的方法进行了对比。结果表明,构建原型
能产生更完善的设计,更贴近用户的需求,以及更好的可维护性( Gordon and
Bieman 1991).
Setting Objectives
设置目标
明确设置质量目标是开发高质量软件的一简单而清晰的步骤,但它常常被
忽视。你可能会问,如果设置了明确的质量目标程序员是否就会真的朝着这个
方向努力,并得到预期的结果呢?答案是肯定的,一旦程序员知道目标是什么,
并且这些目标合理的话,他们将会这么做。当然,程序员无法对一堆天天都在改
变,或者无法实现的目标做出反映。
Gcrald Weinberg和 Edward Schulman完成了一个反响强烈的试验(1974年)
该试验就是为了调查设置质量目标对于程序员的工作表现的影响。他们把程序员
分成5个小组,分别开发同一个程序的5个版本5个相同的质量目标交给了各
个小组,但每组都被要求强调对特定目标的最优实现。第一个小纽需要尽可能减
代码大全(第2版)

<==========================505end ==============================>
<==========================506start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. com!.com!仅供试看个
20.3不同质量保障技术的相对效能
469
少程序对内存的需求,第二个小组需要实现最清晰的输出,第三个需要编写出最
具可读性的代码,第四个小组要求尽可能地减少语句的数量,最后一个小组则要
求在尽可能短的时间内运行完整的程序。表201展示了每个小组如何在每个目标
上的排名。
表20-1各个小组在每个目标上的排名
小组被要求优减少内存输出可读程序可最少代码减少计算
化的目标
占用性读性
时间
减少内存占用
输出可读性
程序可读性
15324
性4125
41235
量2531
最少代码量
5343
减少计算时间
来源:修改自《计算机编程的目标和成绩》( Weinberg和 Schulman,1974年)
研究的结果很值得注意。在实现各自所要求的优化目标方面,有四组都取得
了第一,剩下一组则取得了第二,并且没有任何一组能在所有的方面都做得很好
HARD DATA
这一令人惊奇的结果暗示了人们确实会做要求他们去做的事情。程序员有很
高的成就激励:他们会向明确的目标进发,但必须有人告诉他们目标是什么。此
外,这一结果还暗示我们,不同目标之间是有冲突的,并且软件通常都不可能在
所有方面都做得很好,这也符合我们的预期。
20.3
Relative Effectiveness of Quality Techniques
不同质量保障技术的相对效能
各种质量保证方法的效能并不相同。人们已经研究过许多技术,并且理解它
们在检测和排除缺陷方面的效能。本节将讨论质量保证方法的“效能”的方方面
面问题。
Percentage of Defects Detected
缺陷检测率
如果建筑工人像
程序员写程序那某些方法在检测缺陷方面比其他方法更加有效,而且不同的方法能找出不同
样造房子,那么第类型的缺陷。测定所找到的缺陷占该项目当时所有存在缺陷的百分比,是评估各
一只飞到房顶上
的啄木鸟就足以
毁掉人类文明。
-Gerald Weinberg
代码大全(第2版)

<==========================506end ==============================>
<==========================507start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com! ^ .com!仅供试看^个
470
第20章软件质量概述
种缺陷检测方法的一种途径。表20-2展示了几种常见的缺陷检测技术的缺陷检测
率。
表20-2缺陷检测率
检错措施
最低检出率典型检出率最好检出率
非正式设计复查
25%
35%
40%
正式设计检查
45%
55%
65%
非正式代码复查
20%
25%
35%
正式代码检查
45%
60%
70%
建立模型或原型
35%
65%
80%
个人桌面代码检查
20%
40%
60%
单元测试
15%
30%
50%
新功能(组件)测试
20%
30%
35%
集成测试
25%
35%
40%
回归测试
15%
25%
30%
系统测试
25%
40%
55%
小规模Beta测试(小于10人25%
35%
40%
参与)
大规模Beta测试(大于100060%
75%
85%
人参与)
来源:修改自《Programming Productivity》(Jones986a),《Software Detect-Removal-
Efficiency))》(Jones1996),以及《 What We Have Learned About Fighting Defects》Shull
etal.2002)
这一数据所展示出来的最有趣的事实是,单独使用任何一个方法,其典型检
出率都没有超过75%,并且平均来说这一数值在40%左右。更有趣的是,最常用
HARD DATA的缺陷方法—单元测试以及集成测试,它们的一般检测率仅仅在30%到35%之
间。典型的组织会借助一项大规模测试来检测缺陷,这也仅仅能达到85%的缺陷
排除效率。先进的组织则使用范围广泛的更多方法,能够获得95%或者更高的缺
陷排除效率(Jones2000)
这些数据强烈提醒我们,如果项目的开发者要向更高的缺陷检测率发起冲击,
他们需要综合运用各种技术。 Glenford Myers所做的一个经典研究证实了这一命
题。 Myers研究了一组程序员,这些人具有至少7年、平均11年的专业经验。他
给出一个已知有15个错误的程序,然后让每个程序员单独使用下列技术中的一种
来找出这些错误:
针对规格说明进行测试
参考源代码根据规格说明进行测试
■结合规格说明和源代码来逐行检查
代码大全(第2版)

<==========================507end ==============================>
<==========================508start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubu.com!仅供试看^
20.3不同质量保障技术的相对效能
471
Myers发现,程序员们找出的错误数量的变化范围非常大,从1.0到9.0不等,
其平均值是5.1,或者说只找出了三分之一的错误。
HARD DATA
这些方法单独使用的时候,没有任何一个方法在统计意义上被认为明显好于
其他方法。人们所发现错误的数量变化如此之大,然而,一旦组合使用任意两种
方法,包括让两个独立的小组使用相同的方法,都能将所发现缺陷的总量提高几
乎一倍。根据NASA(美国国家航空航天局) Software Engineering Laboratory软
件工程实验室)、波音和其他公司的报告,不同的人更有可能找出不同的缺陷。这
些报告还分析了所找到的错误,发现其中只有大约20%被一个以上的测试者找出
来( Kouchakdjian, Green and Basili1989;trpp, Struck and Pflug1991 Schneider
Martin and Tsai 1992)
Glenford Myers指出,在查找某些特定类型的错误时,人工方法(比如检查和
通读代码)往往比用计算机更得心应手,而对另外一些错误类型则正好相反(1979
年)。这个结果在后来的一项研究中得到了肯定,该研究发现,阅读代码能够找出
较多的接口缺陷,而功能测试则可以检测出更多的控制缺陷(Basili, Selby and
Hutchens1986).测试大师 Boris Beizer的报告指出,非正式的测试方法通常只能
够获得50%到60%的测试覆盖率,除非程序员使用覆盖率分析工具(Johnson
1994)
这一结果表明,采用多种缺陷检测方法联合作战,效果比某种方法单打独斗
要好。 Jones观察到,不同方法累积产生的缺陷检出率明显高于任意一种方法,由
KEY FONT
此也得出了相同的结论。仅仅使用测试所达到的效能是惨不忍睹的 Jones还认为
即使把单元测试、功能测试以及系统测试等方法结合到一起,累积起来的缺陷检
出率一般也不会超过60%,对于产品级的软件来说,这通常是不够的
这些数据还可以解释为什么使用具备更规范缺陷检测技术的开发方法例
如极限编程,能够让程序员体验到比过去更高的缺陷排除水平。从表20-3中可以
看到,极限编程中使用的那一套缺陷排除方法在一般情况下可实现90%的缺陷
检出率,而在最好的情况下可以达到97%,这比85%这一业界平均水平来说要好
多了。虽然有些人将这一效率归功于极限编程实践中的协作,但只要使用了这些
特定的缺陷排除方法,这样的结果并非遥不可及结合使用多种实践的其他组合
也可以达到同样甚至更好的效果,而确定使用哪些缺陷排除方法来达到期望的质
量水平,正是有效的项目计划的一部分。
代码大全(第2版)

<==========================508end ==============================>
<==========================509start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看^
472
第20章软件质量概述
表20-3极限编程的缺陷检出率评估值
检错措施
最低检出率典型检出率最好检出率
非正式设计复查(结对编程)25%
35%
40%
非正式代码复查(结对编程)
20%
25%
35%
个人桌面代码检查
20%
40%
60%
单元测试
15%
30%
50%
集成测试
25%
35%
40%
回归测试
15%
25%
30%
缺陷排除的预期累积效率值
约74%
约90%
约97%
Cost of Finding Defects
找出缺陷的成本
某些缺陷检测方法的成本比其他方法要高。最经济的方法应当是找出缺陷的
成本最低,而在其他方面同别的方法并无二致后一个条件很重要,因为查找单
个缺陷的成本受到了很多因素的影响,例如特定的缺陷检测技术所能找到的缺陷
总量,缺陷被发现时所处的开发阶段,以及经济因素之外的其他因素。
大部分研究都发现,检查比测试的成本更小。NAA软件工程实验室的一项
研究发现,阅读代码每小时能够检测出的缺陷要比测试高出80%左右(Basili and
HARD DATA Selby1987),另一个组织则发现使用测试来检测缺陷的成本是检查的6倍
(Ackerman, Buchwald and Lewski1989).后来,IBM的一项研究又发现,检查发
现一个错误只需要3.5个工作时,而测试则需要花费15~25个工作时(Kaplan
1995)。
Cost of Fixing Defects
修正缺陷的成本
找出缺陷的成本只是综合成本的一部分,另一部分就是修正缺陷的成本。也
许看上去就如何找到缺陷并不会影响修正缺陷的成本因为修正相同缺陷的成
本应该相同。
交叉参考缺陷在事实并非如此。因为一个缺陷存在的时间越长,消除它的代价就越高昂,因
系统中存在的时间
越长,修正缺陷的此能够尽早发现错误的检测方法可以降低修正缺陷的成本。而更重要的是,有的
成本也越高。这一方法如代码检查,一举可以确定问题的现象和原因;而另一些方法如测试,则只
点在第31节中的能发现问题表象,而要找到并从根本上修正缺陷还需要额外的工作。我们可以得
“诉诸数据”中有
详细的讨论。第到的结论是,一步到位的方法明显比两步走的方法更划算。
224节“典型错
误”对错误本身展
开了讨论。
代码大全(第2版)

<==========================509end ==============================>
<==========================510start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c ^.com!仅供试看
20.4什么时候进行质量保证工作
473
微软的应用程序部门发现,用代码检查这种一步到位的方法找出并修正一个
错误要花费3个工作时,而通过测试这种两步完成的方法则要花费12个工作时
HARD DATA Moore992) Collofello和 Woodfield报告称,在一个由超过400名程序员创
建的有70万行代码的程序中,代码复查()的成本效益要比测试高出好
几倍前者的投资回报率达到1.38,而后者只有0.17
一个有效的软件质量项目的底线,必须包括在开发的所有阶段联合使用多种
技术。下面是一套推荐阵容,通过它们可以获取高于平均水平的质量:
对所有的需求、架构以及系统关键部分的设计进行正式检查
建模或者创建原型
代码阅读或者检查
执行测试
20.4什么时候进行质量保证工作
交叉参考前期准
备工作需求和
正如第3章“三思而后行:前期准备”当中提到的那样,错误越早引入到软
构架方面的质量保
件当中,问题就会越复杂,修正这个错误的代价也更高,因为错误会牵涉到系统
证不在本书讨论范的更多部分。需求中的一个缺陷会孕育出设计上的一个或多个缺陷,而这些设计
围之内。你可以从
本章末尾“更多资错误又会繁殖出更多的代码缺陷。需求中的一个错误会导致多余的架构设计或者
源”部分列出的书错误的架构决策。多余的架构设计又导致多余的代码、测试用例和文档,一个需
自中找到同这一主求上的错误可能产生最终不得不被抛弃的架构、代码以及测试用例。这就如同是
题相关的描述。
在浇注地基之前,应当先在建筑图纸上把问题解决了。在需求或者架构的缺陷影
响到后续工作之前将其拿下不失为上策。
此外,相对于编码阶段的错误,需求或架构上的错误往往会产生更为广泛的
影响。单个架构错误可以影响多个类以及几十个子程序,而单个构造错误的杀伤
范围则不会超过一个子程序或者类。也正是基于这一理由,尽早捕捉错误才能有
效地节省成本。
缺陷可能在任何阶段渗透到软件中。因此,你需要在早期阶段就开始强调质
量保证工作,并且将其贯彻到项目的余下部分中。在开工之时,这一工作就应当
添加到项目计划中,在项目进行中作为技术脉络的一部分,并且应该作为项目的
结束点,当整个工作结束的时候检验产品的质量。
代丹大全(第2版)

<==========================510end ==============================>
<==========================511start==============================>

该书下载自书部落-分享计算机经典巨著!-www. ! --www.shubul.com!仅供试看
474
第20章软件质概述
20.5
The General Principle of Software Quality
软件质量的普遍原理
世界上没有免费的午餐,即使有,味道也一定不会好到哪里去。但是软件开
发跟高级烹调技术差之十万八千里,并且软件质量是如此的与众不同。软件质量
KE
的普遍原理就是改善质量以降低开发成本。
理解这一原理依赖于理解一个很容易观察到的关键事实:提高生产效率和改
善质量的最佳途径就是减少花在这种代码返工上的时间,无论返工的代码是由需
求、设计改变还是调试引起的。软件产品的业界平均生产效率大约是每人每天10
到50行最终交付代码(包括所有非编码开支)敲出10到50行的代码也就只是
儿分钟的事情,那么每天剩下的时间是怎么度过的呢?
交叉参考编写这一生产力数据显得如此低下部分原因是这样的业界平均值把非程序员所
单个程序和编写花费的时间也纳入“每天代码行数”的计算里了测试人员、项目经理、行政支
软件产品是有区
别的,第27.5节持的时间都包含在里面。诸如需求开发和架构设计这种非编码工作,也会在计算
“程序、产品、系时被考虑进去。但这些都不是时间花费如此惊人的主要原因。
统和系统产品”对
此做了说明。
绝大多数项目的最大规模的一种活动就是调试以及修正那些无法正常工作的
代码。调试和与此相关的重构或者其他返工工作,在传统的不成熟的软件开发周
期当中可能消耗大约50%的时间(详细内容请参见3.1小节,“前期准备的重要
性”)。只要避免引入错误,就可以减少调试时间,从而提高生产力因此,效果
最明显的缩短开发周期的办法就是改善产品的质量,由此减少花费在调试和软件
返工上面的时间总量。
相关领域的数据可以证明这一分析结论。NASA软件工程实验室在分析了总
计400人年工作量的50个开发项目的300万行代码后发现,更多的质量保证工作
HARD DATA能降低错误率,但不会增加开发的总成本(Card1987)
IBM的一个研究也得到了类似的结论:
缺陷最少的软件项目的开发计划时间最短,并拥有最高的开发生产
率…消除软件缺陷实际上是最昂贵且最耗时的一种软件工作( Jones2000)
代码大全(第2版)

<==========================511end ==============================>
<==========================512start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo. cor.com!仅供试看^
20.5软件质量的普遍原理
475
在最小的尺度上这一结论同样正确。1985年有人进行了一项研究,要求166
个专业程序员根据相同的规范来写程序,他们写出来的程序平均有220行代码,
每个人平均花费时间略少于5个小时。令人十分惊奇的是,那些花费时间不多
HARD DATA
不少的程序员编写的程序错误最多,而那些花费时间较多或较少的程序员编写
的程序所含错误则明显要少得多(DeMarco and Lister1985)图20-2显示了这
一结果。
1.4
1.2
1.0
平均缺陷数8
0.6
0.4
0.2
100
500 Over
500
完成程序的时间(以分钟计)
图20-2既不是最快的,也不是最慢的开发方法生产出的软件缺陷最多
最慢的两个小组花费的时间大约是最快小组的5倍,缺陷率却不相上下。因
此,编写无缺陷软件并不一定会比编写富含缺陷软件花更多的时间。正如图中
所示的结果,编写无缺陷的软件可能让我们花费更少的时间。
不可否认的是,某些特定类型项目的质量保证是需要花费大量金钱的。如果
你正在为航天飞机或者某个医疗生命维持系统编写程序,所要求的可靠程度将会
使程序变得更加昂贵。
与传统的“编码一测试调试”相比,先进的软件质量计划可能更省钱。这
种计划把投入到调试和重构的资源重新分配到前期的质量保证工作中,而前期工
作在产品质量上体现的作用会比后期工作更为明显,因此把时间投入到前期工作
中,能让程序员在后期工作中节省更多的时间。这一方法的最终效果是软件的缺
陷更少,开发时间更短,成本也更低。在接下来的三章中,你还可以看到更多体
现这一软件质量普遍原理的例子。
代码大全(第2版)

<==========================512end ==============================>
<==========================513start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shuby.com!仅供试看
476
第20章软件质概述
CHECKLIST: A Quality-Assurance Plan
cco04核对表:质量保证计划
口是否确定出对项目至关重要的特定质量特性了?
口是否让其他人意识到项目的质量目标了?
口是否能够区分质量的外在特性和内在特性?
口是否考虑过某些特性与其他特性相互制约或相互促进的具体方式?
口在软件开发的每一个阶段,项目是否要求针对不同错误类型使用不同的
错误检测技术?
口项目计划中是否有计划有步骤地保证了软件在开发各阶段的质量?
口是否使用了某种质量评估方法,并由此确定质量是改善了还是下降了?
口管理层是否能理解为了质量保证在前期消耗额外成本,目的就是在项目
后期减少成本?
Additional Resources
更多资源
cc2e.com/2050
要列出同本章主题有关的书目并不困难,因为事实上任何关于高效软件方法
论的著作都会提到各种能够改善软件质量和生产率的方法。真正困难的是要找出
从本质上讨论软件质量的书籍,下面有两本。
Ginac, Frank.《 Customer Oriented Software Quality Assurance》(《面向用户
的软件质量保证》), Englewood Cliffs,nj: Prentice Hall,1998.这是一本言简意赅
的书,其中描述了质量特性、规律、质量保证计划、测试在质量保证中的角色以
及著名的质量改善计划,包括软件工程研究所制订的CMM和ISO9000标准
Lewis William.《 Software Testing and Continuous Quality Improvement》(《软
件测试和连续质量改进》),2ded. Auerbach Publishing,2000.这本书广泛讨论了
质量生命周期,包含有关测试技术的深入讨论它还提供了大量的表格和核对表。
代码大全(第2版)

<==========================513end ==============================>
<==========================514start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--www.shul.com!仅供试看
要点
477
Relevant Standards
相关标准
cc2e.com/2057 ieee std  730-2002, ieee  Standard for Software Quality Assurance Plans
IEEE 1061-1998, KIEEE Standard for Software Quality Metrics Methodology)
JEEE Std 1028-1997, (Standard for Software Review)
IEEE Std 1008-1987(R1993), (Standard for Software Unit Testing)
IEEE Std 829-1998, (Standard for Software Test Documentation)
Key Points
要点
开发高质量代码最终并没有要求你付出更多,只是你需要对资源进行重新分
配,以低廉的成本来防止缺陷出现,从而避免代价高昂的修正T作。
并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的,
并就这些目标和团队成员进行沟通。
没有任何一种错误检测方法能够解决全部问题,测试本身并不是排除错误的
最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同
类型的错误。
在构建期间应当使用一些有效的质量保证技术,但在这之前,一些具有同样
强大功能的质量保证技术也是必不可少的。错误发现越早,它与其余代码的
纠缠就越少,由此造成的损失也越小。
软件领域的质量保证是面向过程的。软件开发与制造业不一样,在这里并不
存在会影响最终产品的重复的阶段,因此,最终产品的质量受到开发软件所
用的过程的控制。
代码大全(第2版)

<==========================514end ==============================>
<==========================515start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! -www.shubulo...com!仅供试看^

<==========================515end ==============================>
<==========================516start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubul.com!仅供试看^
Collaborative Construction
第21章
协同构建
cc2com/2185内容
21.1协同开发实践概要:第480页
21.2结对编程:第483页
21.3正式检查:第485页
21.4其他类型的协同开发实践:第492页
相关章节
软件质量概述:第20章
开发者测试:第22章
■调试:第23章
软件构建的前期准备:第3、4章
你可能与很多程序员有类似的经历,你走到另一个程序员的工作间并说:“你
可以帮我看看这段代码么?它让我感到很棘手。”然后你开始解释这个问题:“这
个问题不可能是由这里引起的,因为我做了这些。它也不可能是由这里造成的,
因为我做了那些。并且它也不可能由…,它也许就是由那儿的代码造成的,谢
谢!”在你的“帮手”还没有机会发言时,你已经解决了自己的问题。
所有的协同构建技术都试图通过这样或那样的途径,将展示你工作的过程正
式化,以便把错误暴露出来。
如果你以前阅读过有关正式检查和结对编程的文章,你会发现本章所讲述的
内容并不算新奇。在21.3小节中提到的关于检查效能的一些客观数据,其变化范
围却可能会让你大吃一惊,同时你可能也没有注意过21.4小节所描述的替代方案
代码阅读。你可能还应该看看本章末尾的表21-1“协同构建技术的比较”。假
如你所有的知识都来自于你的亲身经历,那么请继续读下去!其他人也许有着不
同的经历,你可以从中得到一些新想法。
代码大全(第2版)

<==========================516end ==============================>
<==========================517start==============================>

该书下载自-书部落分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
480
第21章协同构建
2
Overview of Collaborative Development Practices
协同开发实践概要
“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读,以及
其他让开发人员共同承担创建代码及其他工作产品责任的技术。在我的公司里面,
“协同构建”这一术语是在2000年前后由Matt Peloquin杜撰出来的。在那一段时
间内,也有其他人独立提出过这一术语。
各种协同构建技术之间尽管存在着一些差异,但它们都基于一个相同的思想,
那就是在工作中开发人员总会对某些错误点视而不见,而其他人不会有相同的盲
点,所以开发人员让其他人来检查自己的工作是很有好处的。CMU软件工程研究
所(Software Engineering Institute)的调查表明,在设计过程中开发人员平均每个
HARD DATA小时会引入1到3个缺陷,在编码阶段则会平均每小时引入5到8个(Humphrey,
1997年),因此攻击这些盲点就成为了有效构建的关键。
Collaborative Construction Complements Other
Quality-Assurance Techniques
协同构建是其他质量保证技术的补充
协同构建的首要目的就是改善软件的质量。正如第20章“软件质量概述”当
中提到的那样,软件测试在单独运用的时候效果比较有限,单元测试的平均缺陷
HARD DATA检出率只有大约30%,集成测试大约是35%,小规模Beta测试是35%与此相反,
对设计和代码进行详细检查的平均效能为55%和60%( Jones1996)协同构建的
另一个好处是,它可以缩短开发周期,从而降低开发成本。
关于结对编程的早期报告指出,它的代码质量能够达到与正式检查相近的水
平(Shull et al.2002)。全程采用结对编程的成本可能比单人开发要高大约
KEY POINT
10%~25%,但开发周期大概会缩短45%。虽然很多情况下这样的结果相对于代码
检查来说并无优势,但却大大超越了单人开发的效率(Boehm and Turner2004)
人们对技术性复查的研究历史比结对编程要长得多,并且许多案例研究及其
他地方所描述的结论已经给人留下了深刻的印象:
IBM发现,一小时的代码检查能够节省大约100小时的相关工作(测试和缺
陷修正)(《HoIInd199《)。
HARD DATA通过一个关注检查工作的创意 Raytheon将修正缺陷的成本占项目总成本的
比例,从约40%降至约20%(Haley1996)。
代码大全(第2版)

<==========================517end ==============================>
<==========================518start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
21.1协同开发实践概要
481
惠普公司报告称,它的正式检查计划大约每年会为公司节省2150万美元
(Grady and Van Slack 1994).
帝国化工(Imperial Chemical Industries)发现维护400个程序所有文档的费
用,仅仅是维护与之类似但未经检查的程序的费用的十分之一。
对一些大型程序的一项研究发现,在正式检查上面花一个小时,平均可以避
免33个小时的维护工作,并且检查的效能是测试的20倍以上(Russel1991)
在引入代码复查之前,一个软件维护组织的55%的单行修改是有错误的。而
在引入代码复查之后,这一数字降低到了2%(Freedman and Weinberg1990)
如果考虑所有类型的变更,在引入复查之后5%的修正是一次性正确的,而
没有引入复查时只有20%是一次性正确的。
同一组人员开发了11个程序,并将它们发布到产品当中。其中的前5个没有
进行复查,其平均每百行代码存在4.5个错误。另外6个经过了代码检查,
平均每百行代码只有0.82个错误。复查消火了超过80%的错误(Freedman
and Weinberg 1990).
Capers Jones的报告称,他所研究过的所有排错率达到或超过99%的项目,
都采用了正式的代码检查。同样的,排错率低于75%的项目都未采用正式的
代码检查(Jones2000)
这些例子阐释了软件质量的普遍原理,该原理告诉我们,在减少软件中的缺
陷数量的同时,开发周期也能得到缩短。
各种不同的研究表明,协同开发不但在捕获错误方面比测试的效能更高,所
能发现的错误类型也不同于测试( Myers178; Basili, Selby and Hutchens1986)
KY FONT
正如 Karl Wiegers所指出的那样,“由人进行的复查能够发现不明显的错误信息
不恰当的注释、硬编码的变量值,以及重复出现的需要进行统一的代码模式,这
些是测试发现不了的”(Wiegers2002)。协同开发的另一个作用是让人们意识到他
们的工作会被复查,这样他们会小心谨慎地检查自己的工作因此,即使测试工
作完成得很有效率,作为完整的质量计划的一部分,复查或者其他类型的协作同
样很有必要。
代丹大全(第2版)

<==========================518end ==============================>
<==========================519start==============================>

该书下载自-书部落分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
482
第21章协同构建
Collaborative Construction Provides Mentoring in
Corporate Culture and Programming Expertise
协同构建有利于传授公司文化以及编程专业知识
在得到认可并形成软件标准可以写下来并发布出去,但是如果无人去讨论它们,也不鼓励使用
文字之前,非正式这些标准,那么就不会有人去按照这些标准做事情。复查是一个很重要的机制,
的复查过程往往会
在多年的开发文化它可以让程序员得到关于他们自己代码的反馈。代码、标准以及让代码符合标准
中为程序员们代代的理由等,都是复查讨论中的好主题。
理由显而易见,因程序员除了需要得到他们是否很好地遵循了标准的反馈之外,还需要得到程
为对最优秀的程序
员来说,他们自己序设计主观方面的回馈,例如格式、注释变量名、局部变量和全局变量的使用、
极少会在文字中提设计方法以及“我们这里采用的解决方法(the-way-we-do- -things-around--here
到复查;而对那些
水平很差的程序员等。刚出道的编程人员需要那些有更丰富知识的前辈给予指导,而资深程序员们
而言,他们往往又往往太忙而没时间同他人分享他们的知识。复查为这两种人提供了一个技术交流
坚信自己的代码无的平台,所以,无论在未来还是现在,查都是培养新人以提高其代码质量的好
可击,认定复查
毫无必要。
机会
-Daniel Freedman
和 Gerald Weinbea个采用正式检查的团队报告称,复查可以快速地将所有开发者的水平提升
到最优秀的开发者的高度(Tackett and Van Doren1999)
Collective Ownership Applies to All Forms of
Collaborative Construction
集体所有权适用于所有形式的协同构建
交叉参考将所有
在集体所有权下,所有的代码都属于团队而不是某一个人,并且团队中的所
的协同构建技术扩
展开来正是集体所
有成员都可以对其进行访问和修改。这会带来一些很有价值的好处。
有权的思想。在一众多双眼睛的检查,以及众多程序员的协力编写,可以使代码的质量变得史
序员拥有自己编写
好。
的代码,对别人已
有代码的修改往往某个人离开项目所造成的影响更小了,因为每一段代码都有多个人熟悉它。
则会受到正式或非总体上缺陷修正周期变短了,因为几个程序员中的任何一个有空,就能随时
正式的限制。集体
所有权对协调程序被指派去修正缺陷。
员之间工作尤其
是配置管理提出
有些方法论,例如极限编程,建议正式将程序员进行结对组合,并且在进程
了更高的要求。在中时常交换他们的工作安排。在我的公司里面,我们发现要达到良好的代码覆盖
第28.2节“配置管率,并不一定需要正式将程序员进行结对组合。我们通过结合正式的和非正式的
理”中对此有详细
的说明。
技术复查,在必要时进行结对编程,以及轮换指派修止缺陷的任务,从而逐渐达
到交叉覆盖。
代码大全(第2版)

<==========================519end ==============================>
<==========================520start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看
21.2结对编程
483
Collaboration Applies As Much Before Construction As After
在构建前后都应保持协作
本书的内容是关于构建的,因此在详细设计和编码阶段使用协作是本章的重
点。但是本章有关协同构建的思想同样适用于评估、计划、需求、架构、测试以
及维护工作等阶段。通过学习本章末尾的参考资料,你可以将协作技术应用在绝
大多数的软件开发活动中。
21.2
Pair Programming
结对编程
在进行结对编程的时候,一位程序员敲代码,另外一位注意有没有出现错误,
并考虑某些策略性的问题,例如代码的编写是否正确,正在编写的代码是否所需
等。结对编程最初是由极限编程(Extreme Programming)所普及推广的(eck
2000),现在已经使用得相当广泛了(Williams and Kessler2002)
Keys to Success with Pair Programming
成功运用结对编程的关键
虽然结对编程的基本概念很简单,但是要从中获得收益,就需要遵守下述几
条准则。
用编码规范来支持结对编程如果两个人整天把时间浪费在争论代码风格的
问题上,那么结对编程就不可能发挥它的威力。应该尝试对风格进行标准化,在
第5章“构建期间进行设计”里面将其称为“偶然属性”,以便程序员将精力集中
到“本质”任务上。
不要让结对编程变成旁观不掌握键盘的那个人应该主动参与到编程当中
他应该分析代码,提前思考接下来的代码应该做些什么,对设计进行评估,并对
如何测试代码做出计划。
不要强迫在简单的问题上使用结对编程一运用结对编程来解决最复杂问
题的小组发现,如果一起在白板上面画1分钟,然后再分别独立编程会更有利
(Manzo2002)。绝大多数尝试过结对编程的组织最终都是对部分工作采用结对编
程,而不是全部(Boehm and Turner2004)
有规律地对结对人员和分配的工作任务进行轮换如何在其他的协同开发实
践一样,结对编程的好处在于能够让不同的人熟悉系统的不同部分。有规律地进
行轮换有助于知识的互相转播有些专家建议尽可能经常进行人员轮换,甚至
每天进行( Reifer2002)
鼓励双方跟上对方的步伐要是其中一个人相对走得太快的话,那就会大大
限制了其结对搭档的作用。速度太快的人需要放慢步伐,否则这对组合应当被拆
开,然后和其他人重新组合。
代码大全(第2版)

<==========================520end ==============================>
<==========================521start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看
484
第21章协同构建
确认两个人都能够看到显示器即使是无法看到显示器、使用了太小的字体
等细枝末节,都可能造成问题。
不要强迫程序员与自己关系紧张的人组对有时个人性格之间的冲突会导致
组合的效能出问题,强迫无法配对的两个人进行组合是毫无意义的,因此请对个
性匹配的问题保持警觉(Beck2000, Reifer2002)
避免新手组合两个人当中至少一个有结对经历时,结对编程的效果最好
(Larman 2004).
指定一个组长即使你的整个队伍希望所有工作都通过结对编程的方法来
做,你还是需要指定一个人来协调工作的分配,对结果负责以及负责与项目外其
他人的联系。
Benefits of Pair Programming
结对编程的好处
结对编程有许多好处。
与单独开发相比,结对能够使人们在压力之下保持更好的状态。结对编程鼓
励双方保持代码的高质量,即使在出现了让人不得不飞快地编写代码的压力
时仍然如此。
■它能够改善代码质量。代码的可读性和可理解性都倾向于上升至团队中最优
秀程序员的水平。
它能缩短进度时间表。结对往往能够更快地编写代码,代码的错误也少。
这样一来,项目组在项目后期花费在修正缺陷的时间会更少。
它还具有协同构建的其他常见好处,包括传播公司文化,指导初级程序员,
以及培养集体归属感。
CHECKLIST: Effective Pair Programming
ce2e.com2192 :12核对表:有效的结对编程
口是否已经有一个编码规范,以便让程序员始终把精力集中到编程,而不
是编码风格的讨论上?
口结对的双方是否都积极地参与?
口是否避免了滥用结对编程,而是选择那些能够从中获得好处的工作进行
结对编程?
口是否有规律地对人员和工作任务进行轮换?
口结对组合是否在开发速度和个性方面互相匹配?
口是否有一个组长专注于项目管理以及与项目外其他人的沟通?
代码大全(第2版)

<==========================521end ==============================>
<==========================522start==============================>

该书下载自-书部落分享计算机经典巨著!-www. !--www.shubulo. com! ^ .com!仅供试看^
21.3正式检查
485
21.3
Formal Inspections
正式检查
深入阅读
详查(正式检查)是一种特殊的复查,种种迹象表明它在侦测缺陷方面特别有
Design and效,并且相对测试来说更加经济合理。详查是由 Michael Fagan首先提出来的,并且
Code
Reduce to在 Fagan发表相关论文并公诸于众之前已经在M内部应用多年虽然任何复查都
Inspections
Development涉及了阅读设计或者代码,但是详查还是在个关键问题上与普通复查有所区别。
(《在程序开发详查表关注的是复查者过去所遇到的问题。
和代码检查来减详查专注于缺陷的检测,而非修正。
少错误)
Fagan1976复查人员要为详查会议做好预先准备,并且带来一份他们所发现的已知问题
是最早对检查进
列表。
行研究的一篇论
文。
■参与者都被赋予了明确的角色。
详查的主持人不是被检查产品的作者。
详查的主持人应该已经接受过主持详查会议方面的培训。
只有在与会者都做好充分准备之后才会召开详查会议。
每次详查所收集的数据都会被应用到以后的详查当中,以便对详查进行改进。
高层管理人员不参加详查会议,除非你们正在详查一个项目的计划,或者其
他管理方面的资料。但技术负责人可能参加。
What Results Can You Expect from Inspections
你期望详查能够带来什么结果
独立的详查通常能够捕捉到60%的缺陷,这比除了原型和大规模beta测试之外
的其他技术都要好。这一结论已经多次被不同的组织所证实,包括 Harris BCSD,
HARD DATA美国国家软件质量实验室( National Software Quality Experiment),CM软件工程研
究所(Software Engineering Institude)以及惠普公司等(Shull et al002)
设计和代码的联合详查通常能够去除产品中70%到85%,其至是更多的缺陷
(Jones1996)详查能够在早期识别出容易产生错误的类 Capers Jones的报告称,
使用正式检查后,每千行代码的缺陷比不使用该实践时要低20%到30%。通过参
加详查,设计师和程序员们学会了如何改善自己的工作,而详查也让生产效率提
高了20%左右(Fagan1976: Humphrey1989; Gilb and Graham1993; Wiegers2 2002)
对设计和代码都进行详查的项目,详查会占到项目预算的10%到15%,并且通常
会降低项目的整体成本。
代大全(第2版

<==========================522end ==============================>
<==========================523start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubuld.com!仅供试看
486
第21章协同构建
详查还可以用来评估进度,不过评估的只是技术层面的进度。这通常意味着
回答了两个问题:技术层面的工作是否已经完成?以及技术层面的工作是否完成
良好?这两个问题的答案都是正式检查的副产品。
Roles During an Inspection
详查中的人员角色
详查的一个关键特征就是每个人都要扮演某一个明确的角色。下面是各种角
色的列表:
主持人主持人负责保证详查以特定的速度进行,使其既能保证效率,又能
发现尽可能多的错误。主持人在技术上面必须能够胜任虽然不一定是被检查
的特定设计或者代码方面的专家,但必须能够理解有关的细节。这个人负责管理
详查的其他方面,例如分派复查设计和代码的任务,分发详查所需的核对表,预
定会议室,报告详查结果,以及负责跟踪详查会议上指派的任务
作者直接参与设计或者代码的人,这种人在详查中扮演相对次要的角色。
详查的目标之一就是让设计或者代码本身能够表达自己。如果它不够明晰,那么
就需要向作者分配任务,使其更加清晰。除此之外,作者的责任就是解释设计和
代码中不清晰的部分,偶尔还需要解释那些看起来好像有错的地方为什么实际上
是可以接受的。如果参与评论的人对项目不熟悉,作者可能还需要陈述项目的概
况,为详查会议做准备。
评论员(reviewer)评论员是同设计和代码有直接关系,但又不是作者的人。
设计的评论员可以是实现这个设计的程序员测试人员或者高层架构师也可以参
与。评论员的职责是找出缺陷,他们通常在为详查会议做准备的时候就已经找出
了部分缺陷,然后,随着详查会议中对设计或者代码的讨论,他们应该能找出更
多的缺陷。
记录员记录员将详查会议期间发现的错误,以及指派的任务记录下来。作
者和主持人都不应该担任记录员。
经理在详查的时候让经理参与通常不是一个好主意。软件详查的要点是
这是一个纯技术性的复查。经理的出席会对交流产生影响:人们会觉得它们不是
在详查各种材料,而是在被评估,关注的焦点就会从技术问题转换到行政问题上
了。不过经理有权知道详查的结果,应当准备一份详查报告让经理了解情况
代码大全(第2版)

<==========================523end ==============================>
<==========================524start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubr.com!仅供试看^
21.3正式检查
487
类似的,无论在任何情况下,详查的结果都不应当作为员工表现的评估标准,
这种杀鸡取卵的行为不可取。在详查中被检验的代码仍处于开发阶段。对员上表
现的评估应当基于最终产品,而不是尚未完成的工作。
一般说来,参与详查的人数不应少于三个人,少于三个人就不可能有单独的
主持人、作者和评论员了,因为这三种角色不应当被合并。传统的建议是限制参
与详查的人数在六人左右,因为如果人数过多,那么这个小组就变得难以管理。
研究人员发现,通常情况下再增加两三个评论员并不会增加发现缺陷的数量(Bush
and Kelly1989 Porter and Votta1997)。但是这种说法并未得到公认,并且实际结
果因需要详查材料的类型不同而变化(Wiegers2002)无论如何,这是已有的经
验,你应根据情况调整自己的方式。
General Procedure for an Inspection
详查的一般步骤
详查由儿个明显的阶段组成。
计划(planning)作者将设计或者代码提交给主持人,而主持人则决定哪些
人复查这些材料,并决定会议在什么时间什么地点召开。接下来主持人会将设计
或代码,以及一个要求与会者注意的核对表分发给各人。材料应该打印出来,并
且应当有行号,以便在会议中更快标识出错误的位置。
概述(overview)当评论员不熟悉他们所要详查的项目时,作者可以花大
约一个小时来描述一下这些设计或代码的技术背景。加入概述也许有风险,因为
这往往会导致被检查的设计或代码中不清晰的地方被掩饰。设计或者代码本身应
该可以自我表达,在概述中不应该谈论它们。
交叉参考第
准备(Prcparation)每一个评论员独立地对设计或者代码进行详查,找出其
xx页有一份核中的错误。评论员使用核对表来激励和指导他们对材料的详查。
对表的清单,你
可以参考它来提
升代码质量
对于用高级语言编写的应用程序代码,评论员可以准备每小时检查500行代
码。对于用高级语言编写的系统级代码,评论员可以准备每小时只检查125行代
码(Humphrey1989)。最高效的详查速度的变化范围可以很大,因此,要保留所
在组织的详查速度记录,以便于确定你所在环境中最高效的详查速度。
有些组织发现,当每一个评论员都被赋予某一特定视角的时候,详查会更有
效。例如,一个评论员可以被要求以下列视角来准备详查:负责维护工作的程序
代码大全(第2版)

<==========================524end ==============================>
<==========================525start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubu.com!仅供试看^
488
第21章协同构建
员、客户,或者是设计师。对基于视角的复查的研究工作还不全面,但已有的成
果表明,与常规复查相比,基于视角的复查可以发现更多的错误。
详查准备工作的另一种方法是,对每一个评论员赋予一个以上的待详查场景。
场景可以涉及一些特定的问题,评论员需要回答它们例如:这种设计是否满足
了所有的需求?场景还可能对评论员赋予一些需要完成的特定任务,例如列出某
个特殊的设计元素所满足的特定需求。你还可以让某些评论员从头到尾阅读材料,
或者从后往前阅读,又或者从里到外等。
详查会议主持人挑选出除作者之外的某个来阐述设计或者阅读代码
(Wieger2003)所有的逻辑都应当解释,包括每个逻辑结构的每个分支。在陈述
期间,记录员需要记录他们发现的错误,但是所有的讨论应当在确认这是一个错
误的时候就停止。当记录员将错误的类型和严重程度记录下来之后,详查工作继
续向下进行。如果一直在对某些问题不停地争论,那么主持人就应当敲桌子(摇
铃)引起大家注意,以使讨论回到正轨。
对设计或者代码的思考速度不能够太慢或者太快如果速度太慢,那么大家
的注意力就会不集中,会议不会是富有成效的。如果速度太快,那么小组可能会
忽视某些本应被发现的问题。一个理想的详查速度如准备的速度一样,会随着环
境的不同有很大的变化。保留以前的记录,这样以后就可以逐渐知道你所在环境
的最佳速度是什么。有些组织发现,对于系统级代码,理想的速度是每小时90行
代码。而对于应用程序代码,速度可以高达每小时500行(Humphrey1989)每
小时平均150到200行非空非注释的代码是个不错的开始(Wiegers2 2002)
不要在开会的过程当中讨论解决方案,小组应该把注意力保持在识别缺陷上。
某些详查小组甚至不允许讨论某个缺陷是否确实是一个缺陷。他们认为如果使某
个人困惑,那么就应该认为是一个缺陷了,设计、码或者文档应该进一步清理。
通常会议不应该超过两个小时,这并不是说你两个小时一到就拉响火警,把
人们都赶出会议室。根据IBM和其他公司的经验,评论员不能够在连续超过两个
小时的时间里保持精力集中。同理,一天安排超过一个详查会议也是很不明智的。
详查报告一天的详查会议之后,主持人要写出一份详查报告(以email或
者其他类似的形式),列出每一个缺陷,包括它的类型和严重级别。详查报告有助
于确保所有的缺陷都将得到修正,它还可以用来开发一份核对表,强调与该组织
代码大全(第2版)

<==========================525end ==============================>
<==========================526start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
21.3正式检查
489
相关的特定问题。如果你收集了历次详查花费的时间和所发现错误数量的数据,
你就可以用这种客观数据来应对有关详查效率的质询。否则你只能够表示:详查
“看上去更好”。这对那些相信测试更有效的人来说毫无说服力。或者你也可以据
此断定在你所处的环境下,详查没什么用,然后对方法进行适当的修改或者干脆
放弃。之所以说收集数据很重要,是因为任何新的方法论都需要事实来证明它存
在的必要性。
返工主持人将缺陷分配给某人来修复,这个人通常是作者。得到任务的人
负责修正列表中的每个缺陷。
跟进主持人负责监督在详查过程中分配的返工任务。根据发现错误的数量
和这些错误的严重级别,你跟踪工作进展的方式可以是让评论员重新详查整个工
作成果,或者让评论员只重新详查修复的部分或者允许作者完成修改而不做任
何跟进。
第三个小时的会议虽然在进行详查的期间,与会者不允许讨论所发现问题
的解决方案,但还是可能有人想对此进行讨论。你可以主持一个非正式的第三个
小时的会议,允许有兴趣参与的人在正式检查结束之后讨论解决方案
Fine-Tuning the inspection
对详查进行细调
在你已经能够熟练地“丢掉书本”主持详查活动之后,通常你会发现些改
进它的途径。但是切忌胡乱地引入任何变化,应当对详查过程精雕细琢,这样才
能够知道你做出的更改是否有益。
许多公司常常发现,去掉或者合并某些步骤往往是增加而不是降低了成本
(Fagan1986)。如果你在未对改变的影响进行衡量的前提下,就试图改变详查的
流程,千万别那么做!如果你对流程进行定量分析,并且清楚地知道改变之后的
方法比这里所描述的方法更有利于你的工作,那就放心去做吧。
只要你做过详查,你就会注意到某些类型的错误比其他类型的错误更容易出
现。因此需要建立一个核对表,让人对那些常见错误保持警惕,这样评论员就可
以更关注它们。随着时间的流逝,你会发现某些类型的错误不在这份列表当中,
那就应该把它添加进去。经过若干次详查后你的组织就会拥有一份适应自身需
求的核对表,它还能提供一些线索,帮助弄清程序员需要在哪些麻烦领域中得到
更多的训练和支持。应该将核对表的长度限制在一页以内。从详查所需要的详细
程度来看,过长的核对表很难使用
代玛大全(第2版)

<==========================526end ==============================>
<==========================527start==============================>

该书下载自书部落分享计算机经典巨著!--www. :!--www.shubulo.com!^  ^.com!仅供试看
490
第21章协同构建
Egos in Inspections
详查中的自尊心
深入阅读the
进行详查的目的是发现设计或者代码中的缺陷,而不是探索替代方案,或者
Psychology of争论谁对谁错,其目的绝不应该是批评作者的设计或者代码。对于作者来说,详
ramming),2d查的过程应该是正面的,在这一过程中的团队参与使程序得到了明显改善,对所
ed.(程序开发有参与者都是一个学习的过程。这一过程不应该让作者认为团队里面某些人是白
心理学
Weinberg1 1998),或者认为自己应该另谋高就。“任何懂Java的人都知道,从0开始循环至num-1
书有对无我编要比从1开始到num效率要高得多,像这样的评论是极不恰当的。如果发生这
程gs种状况,主持人就应当明确纠正这种不恰当的评论。
ramming}的详
细介绍。
因为设计或代码受到了批评,作者可能感到自己难辞其咎,所以很自然地,
作者会觉得代码让他脸上无光。作者应该预料到他会听到对某些缺陷的批评,而
那些其实并不是缺陷,还有许多是有争议的。尽管如此,作者应该承认每一个所
谓的缺陷,然后继续详查。承认一个批评并不意味着作者认同批评的内容。在复
查工作中,作者不应该试图为正在被检查的工作辩护。在复查之后,作者可以独
自对每一个问题进行思考,判断它是否真的是一个缺陷。
评论员必须记住,最终是由作者来负责决定如何处理缺陷。我们应该享受寻
找缺陷的乐趣(并且可以在复查之后,享受为解决方案提供建议的乐趣),但每一
个评论员必须尊重作者决定如何解决某个错误的最终权力。
Inspections and Code Complete
详查和《代码大全》
在编写《代码大全(第2版)》的过程中,我对于使用详查有着切身的体会。
对于本书的第1版,我最初先写了一个很粗的草稿。让这堆粗稿在抽屉里面呆
了一两个礼拜之后,我重新阅读了每一章并修正了所发现的所有错误,身上直冒
冷汗。然后我把修改好的各章送给十来个人去复查( review,评阅),其中几位进
行了非常彻底的复查,我把他们发现的错误也修正了。几个礼拜之后,我再次阅
读并修正了更多的错误。最后我将手稿提交给出版社,在那里有一位审稿员、一
位技术编辑以及一位校对进行复查。从那本书出版以来已经过了10年,在此期间
读者们已经提供了大约200处错误的修正。
你可能在想,经过这么多的复查活动之后,这本书应当没有很多错误了,但
事实并非如此。为了这个第2版,我对第1版运用了正式检查的技术,以找出那
些需要在第2版中解决的问题。根据本章所描述的指导步骤成立了一个由三到四
个评论员组成的小组。让我感到非常意外的是,我们的正式检查在第1版的正文
中就发现了数处错误,它们在过去多次复查活动中从末被发现过。
代码大全(第2版)

<==========================527end ==============================>
<==========================528start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
21.3正式检查
491
如果说我过去还对正式检查的价值心存疑虑,那么我编写《代码大全(第2
版)》的经历已经让我心服口服了。
Inspection Summary
详查总结
用于洋查的核对表有助于集中注意力。由于详查有标准的核对表和标准的角色,
因此它是一个系统化过程。同时它也是可以自我优化的,因为它采用一个正式的反馈
循环来改进核对表,并跟踪准备和详查的速度。在这种全程控制和持续优化的努力下,
无论刚开始的时候状况如何,详查都很快就能成为一种非常强大的技术。
深入阅CMU软件工程研究所( Software Engineering Institute,sei定义了一个能力
Managing the
Software
成熟度模型(CMM),用于衡量一个组织的软件开发过程的效率(SEI1995)详
Process《管理查过程展示了该模型的最高级别的状况。这一过程是系统化的和可重复的,并且
软件过程
使用了量化的反馈方法来自我改进。你可以将这种思想应用在本书所描述的许多
1989)一书详细介
绍了SE提出的技术当中。如果这一思想被推广到整个开发组织,简而言之,它会把这个组织的
可发展成熟度的质量和生产力提升到到最高的水平。
概念。
CHECKLIST: Effective Inspections
cc2e.com/2199
核对表:有效的详查
口你是否有一个核对表,能让评论员将注意力集中于曾经发生过问题的
领域?
口你是否专注于找出错误,而不是修正它们?
口你是否考虑制定某些视角或者场景,以帮助评论员在准备工作的时候
集中注意力?
口你是否给予评论员足够的时间在详查会议之前进行准备,是否每一个
人都做了准备?
口是否每一个参与者都扮演一个明确的角色主持人、评论员及记录
员等?
口会议是否以某种高效的速度进行?
口会议是否限制在两个小时以内?
口是否所有详查会议的参与者都接受了如何进行详查的针对性培训,是
否主持人接受了有关主持技巧方面的针对性培训?
口是否将每次详查所发现的错误数据都收集起来,使你能调整本组织以
后使用的核对表?
代大全(第2版)

<==========================528end ==============================>
<==========================529start==============================>

该书下载自书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看
492
第21章协同构建
口是否收集了准备速度和详查速度方面的数据,以便你去优化以后的准备
和详查工作?
口是否每次详查中被指派下去的活动都被正确跟进了,无论是通过主持人
自己还是一次重新详查?
口管理层是否理解他们不应该参与详查会议?
口是否有一个用于保证修正正确性的跟进计划?
21.4
Other Kinds of Collaborative Development Practices
其他类型的协同开发实践
与结对编程相比,其他类型的协作方法还没有积累足够的实践经验作为支持,
因此在这里不进行很深入的讨论。本节所覆盖的协作技术包括走查、阅读代码和
公开演示。
Walk-Throughs
走查
走查是一种很流行的复查方式,这个词的定义很随意,其流行在于在某种程
度上,人们把任何形式的复查都称为“走查”
由于这个术语的定义实在是太随意了,因此很难准确地说出什么是走查。可
以肯定的是,走查会涉及两个或者更多的人,进行设计或者代码的相关讨论。它
可能如同一个在白板前面的随兴闲聊那样不正式;它也可以如同个计划好的会
议一样正式,由美工部门准备好一段荧屏演示,最后给经理呈上一份正式的总结
总之,三三两两小聚,即为走查。走查的鼓吹者喜欢这种宽松的定义方式,因此
我仅仅指出所有走查的几个共同点,而剩下的细节就留给你了。
走查通常由需要复查的设计或者代码的作者举行和主持
走查的焦点在技术事宜上一这是一个工作会议。
走查的所有参与者通过阅读设计或者代码来进行准备,并从中找出错误。
对于高级程序员来说,走查是一个向新手们传授经验与协作精神的机会。与
此同时,对于新手们来说这也是一个机会,可以阐述新的方法论,挑战那些
陈腐的、很可能已经过时的假设。
走查通常持续30到60分钟。
■重点在于检测错误,而非修止它们。
代码大全(第2版)

<==========================529end ==============================>
<==========================530start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看
21.4其他类型的协同开发实践
493
经理不会参加。
走查的概念很灵活,能适应采纳它的组织的各种特殊需要。
What Results Can You Expect from a Walk-Through
你期望走查能够得到什么样的结果
聪明的、有纪律地进行走查,你可以得到与正式检查相类似的结果即通
常可以找到程序中20%到40%的错误(Myes1979 Boehm1987b; Yourdon1989b;
Jones1996)。但是一般而言,人们发现走查远没有详查来得有效(Jones1996)
如果不动脑筋的话,走查带来的麻烦比好处要多在效率的低端20%,
可以说没有太大的价值,至少有一个组织(波音计算机服务中心, Boeing Computer
HARD DATA Services)发现对代码进行同事互查的成本“极端地高”。波音发现要持续地激励
项目中的雇员应用走查非常困难,而当项目的压力加的时候,走查就变得几乎
不可能了(Glass1982)。
过去的10年里,根据我在公司的咨询业务中看到的情况,使我对走查越来
越倾向于持批评态度。我发现,人们拥有糟糕的技术复查经历的原因,几乎都是
由于使用了如走查那样的非止式实践,而不是进行正式的检查。复查通常需要举
。。
行一次会议,而会议的成本是很高的。如果你决心承受召开会议的代价,那么将
此会议组织成正式检查是非常值得的。如果你要详查的工作成果不能为一次正式
检查的开销提供正当理由,那就根本没有理由召开一次会议。在这种情况下,运
用文档阅读或者其他交互性较少的方法是更好的途径。
与走查相比,详查在消除错误方面似乎更有效。因此,为什么会有人选择使
用走查呢?
如果你有一个很大的复查团队,那么走查是一种不错的复查方式,因为它能
为接受复查的事项带来许多不同的观点。如果参与走查的每一个人都能够被说服,
相信这一解决方案完全没问题,那么这个解决方案通常不会有重大的缺陷。
如果有其他组织的评审员参与进来,那么走查或许会更好。在详查中的角色
更加正式,并且要求人们先接受一定的训练,这样才能够有效地进行详查。没有
先期详查经历的评审员在详查中无法施展拳脚,如果你希望获得他们的帮助,选
择走查可能更好。
正式检查比走查更需要集中精力,同时通常有更高的回报因此如果你正
在为组织的复查策略做选择的话,将正式检查作为第一选择,除非你有充足的反
对理由。
代大全(第2版)

<==========================530end ==============================>
<==========================531start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看
494
第21章协同构建
Code Reading
代码阅读
代码阅读是详查和走查的另一种替代方案。在代码阅读中,你直接阅读原代
码并从中找出错误。同时你也从质量的角度对代码做出评价,例如代码的设计、
风格、可读性、可维护性以及效率等。
NASA软件工程实验室的一项研究表明,通过代码阅读,每小时能够发现3.3
个缺陷。而测试每小时只能够发现1.8个错误(Card1987)而且,在整个项目的
HARD DATA生命周期中,代码阅读能够比各种测试方法多发现20%到60%的错误。
像走查一样,代码阅读的定义也是相当宽松的。代码阅读通常会有两到三个
人参与,他们独立地阅读代码,然后与代码的作者开会进行讨论。下面说一下如
何进行代码阅读。
在会议的准备阶段,代码的作者将源代码分发给代码阅读人员。这份代码清
单的长度在1000行到10000行之间,4000行是典型的长度。
两个以上的人阅读代码。至少用两个人是为了鼓励评论员之间的竞争。如果
你使用了超过两个人,那就应该量化每一个人的贡献,以便让你知道其他人
员的贡献。
评论员独立地进行代码阅读,阅读速度估计为每天1000行代码。
■当评论员结束代码阅读之后,由代码的作者组织召开代码阅读会议会议持
续一到两个小时,注意力集中在代码读者所发现的问题上面。不用一行一行
地遍历代码。这样的会议并非必不可少。
代码的作者将评论员识别出来的问题一一修正。
代码阅读与详查、走查之间的区别,就在于代码阅读更多地关注对代码进行
的独立复查,而不是关注会议本身。其结果是每一个评论员的时间更多地花费在
yro从代码中找出错误上面,而将较少的时间花费在会议上。在会议里,每个人只在
部分时间做贡献,很大一部分精力用于保持团队的活力会议通常不得不被推迟
少许时间,直到团队中所有人都有两个小时的时间来开会。对于人员所处地理位
置分散的情况,代码阅读尤其有价值。
针对AT&T的13次复查的一份研究发现,人们对复查会议本身的重要性评
价过高了。90%的缺陷是在为复查会议做准备的时候发现的,剩下的10%才是在
会议上发现(Vota1991 Glass1999)
代码大全(第2版)

<==========================531end ==============================>
<==========================532start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubul.com!仅供试看
协同构建技术的比较
495
Dog-and-Pony Shows
公开演示
公开演示(宠物秀)是向客户展示软件产品的另一种复查形式。客户复查的
形式在政府项目中比较常见,项目合约通常规定需要为需求、设计以及代码召开
复查会议。公开演示的目的是向客户证明项目一切顺利,因此这是一种管理层的
复查,而不是技术复查。
不要指望公开演示能成为提高产品技术质量的灵丹妙药为展示做准备可能会对
技术质量带来间接的正面影响,但通常更多的准备时间用于制作漂亮的演讲幻灯片,
而不是改善软件品质。要改善技术品质应当依靠详查、走查或者代码阅读
Comparison of Collaborative Construction Techniques
协同构建技术的比较
这么多不同的协同构建技术之间有什么区别呢?表21-1为我们提供了各种技
术主要特征的概要。
表21-1协同构建技术的比较
对内容
结对编程
正式检查正式复森(走查
参与者角色做出定义是
包含有关如何执行角色有可能,通过指
是是
否否
的正式训练
导
谁“驾驭”协作
掌握键盘的人主持人
通常是作者
协作的焦点
设计、编码、测仅仅是检测缺
试以及错误修正陷
多方面
复查注意力集中在最常即使能够做到
见类型的错误
也只能算是非正是
式的
采取跟进措施以减少不
是
否否
正确的修正
由于每个程序员都得到
详细的错误反馈,未来偶尔如此
偶尔如此
出现的错误更少了
对结果的分析提高了流
程效率
否
是是是是
对非构建活动有用有可能
否是
典型的缺陷检出率
40%-60%
45%~70%20%~40%
代大全(第2版)

<==========================532end ==============================>
<==========================533start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^.com!仅供试看
496
第21章协同构建
有数十年的数据对正式检查的有效性提供事实证据支持,结对编程则没有。
但初始的数据表明它的效果与详查不相上下,并且各种有趣的报告都给出了积极
的结论。
如果结对编程与正式检查在品质、成本以及进度方面能够产生类似的结果,那么在
这两者之间进行选择与其说是技术性问题,还不如说是个人风格问题。有些人更喜欢单
独工作,仅仅需要偶尔为了详查会议从个人模式切换出来,而其他人更喜欢花大部分时
间直接与其他人共同工作。可以依据团队中特定开发人员的工作风格,在这两种技术之
间进行选择,甚至可以允许团队中的小团体选择以他们所喜欢的方式来完成大部分工
作。你也应该在项目中适当地运用不同的技术。
Additional Resources
更多资源
cc2e.com/2106
下面是有关协同构建的更多资料。
Pair Programming
结对编程
Williams, Laurie and Robert Kessler. <Pair Programming Illuminated>. Boston,
MA: Addison Wesley,2002.本书揭示了结对编程里里外外的各种细节,包括如何
处理各种个性匹配问题(例如,专家和非专家、内向和外向的人),以及其他实施
细节。
Beck, Kent. Extreme Programming Explained: Embrace Change). Reading,
MA: Addison Wesley,2000.本书简要地介绍了结对编程,并展示如何联合其他辅
助技术一起运用,包括编码标准、频繁集成以及回归测试。
Reifer, Donald. How to Get the Most Out of Extreme Programming/Agile
Methods》(《从极限编程/敏捷方法中获得最大利益》)《Methods/《ProcaigVgilxAgil
Universe2002. New York,ny Springerpp185196这篇论文总结了极限编程
和敏捷方法在业界的应用经验,并介绍了成功实施结对编程的关键
Inspections
详查
ie,ar. Peer Reviews in Software Practical Guide《软件中的同
行评审:实用指南》). Boston,mA: Addison Wesley,2002这本书写得很好,描述
了各种复查方法的细节,包括正式检查和其他不那么正式的实践方法。这本书基
于认真的研究,关注实践,并易于阅读。
代码大全(第2版)

<==========================533end ==============================>
<==========================534start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo..com!仅供试看^
要点
497
gilb, Tom and Dorothy Graham.Software Inspection》(《软件详查》)
Wokingham, England Addison-Wesley-,1993这本书包含了20世纪90年代初有关
详查的彻底讨论,它关注实践,并包含了一些研究案例,这些案例描述了几个组
织建立详查机制的经验。
Fagan, Michael E. "Design and Code Inspections to Reduce Errors in Program
DeYelopet《lBM(在程序开发中使用设计详查和代码详查来减少错误)《bM
Systems Journal 15, no. 3(1976): 182-211
Fagan, Michael.Advances in Software Inspections"(高级软件详查)《ieeE
Transactions on Software Engineering,se-12,n.7(uly1986):744751.这两篇文
章是由使用详查的开发人员所写,它们包含了有关如何实施详查的精华,包括所
有的标准详查形式。
Relevant Standards
相关标准
HEEE Std028-1997 Standard for Software Reviews》
IERE Std730-2002, Standard for Software Quality Assurance Plans》
Key Points
要点
协同开发实践往往能比测试发现更多的缺陷,并且更有效率。
协同开发实践所发现错误的类型通常跟测试所发现的不同,这意味着你需要
同时使用详查和测试来保证你软件的质量。
正式检查通过运用核对表、准备工作、明确定义的角色以及对方法的持续改善,
将缺陷侦测的效率提升至最高。它往往能比走查发现更多的缺陷。
通常,结对编程拥有和详查相同的成本,并能产生质量相当的代码。当需要
缩短开发周期的时候,结对编程就非常有价值。相对于单独工作来说,有些
开发人员更喜欢结对工作。
正式检查可以应用在除代码之外的很多工作成果上,例如需求、设计以及测
试用例等。
■走查和代码阅读是详查的替代方案。代码阅读更富有弹性,能有效地利用每
个人的时间。
代码大全(第2版)

<==========================534end ==============================>
<==========================535start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c.com!仅供试看

<==========================535end ==============================>
<==========================536start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co!.com!仅供试看^
Developer Testing
第22章
开发者测试
cce.com/261内容
22.1开发者测试在软件质量中的角色:第500页
22.2开发者测试的推荐方法:第503页
22.3测试技巧锦囊:第505页
22.4典型错误:第517页
22.5测试支持工具:第523页
22.6改善测试过程:第528页
22.7保留测试记录:第529页
相关章节
软件质量概述:第20章
协同构建实践:第21章
■调试:第23章
集成:第29章
软件构建的前期准备:第3章
测试是最常见的改善质量的活动——这种实践得到许多业界和学界研究,以
及商业经验的支持。软件可以通过许多的法进行测试,某些测试通常由开发人
员进行,而有些则更多由专门的测试人员进行。
单元测试(Unit testing)是将一个程序员或者一个开发团队所编写的,一个
完整的类、子程序或者小程序,从完整的系统中隔离出来进行测试。
组件测试( Component testing)是将一个类、包、小程序或者其他程序元素,
从一个更加完整的系统中隔离出来进行测试,这些被测代码涉及到多个程序
员或者多个团队。
集成测试( Integration testing)是对两个或更多的类、包、组件或者子系统
进行的联合测试,这些组件由多个程序员或者开发团队所创建。这种测试通
常在有了两个可以进行测试的类的时候就应该尽快开始,并且一直持续到整
个系统开发完成。
代码大全(第2版)

<==========================536end ==============================>
<==========================537start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看
500
第22章开发者测试
回归测试( Regression testing)是指重复执行以前的测试用例,以便在原先
通过了相同测试集合的软件中查找缺陷。
系统测试(System testing)是在最终的配置(包括同其他软硬件系统的集
成)运行整个软件。以便测试安全、性能、资源消耗、时序方面的问题,以
及其他无法在低级集成上测试的问题。
在本章,“测试”指的是由开发者进行的测试,这通常包括单元测试、组件测
试和集成测试,但有的时候还会包括回归测试和系统测试许多进一步的测试由
专门的测试人员进行,很少由开发人员来完成,包括beta测试、客户验收测试
性能测试、配置测试、平台测试、压力测试以及易用性测试等。这些类型的测试
本章中不再赘述。
测试通常分为两大类:黑盒测试(black-《bIcboxsigwhitebox《)和白盒(white-box,或
者玻璃盒 glass-b-box)测试“黑盒测试”指的是测试者无法了解测试对象内部工作
KEY POINT机制的测试。很明显,当你测试自己编写的代码时这种方法并不适用!“白盒测试”
指的是测试者清楚待测试对象内部工作机制的测试。这是你测试自己开发的代码
的那种测试。黑盒测试和白盒测试各有优劣,本章关注的是白盒测试,即由开发
者完成的测试。
有些程序员会将术语“测试( testing)”和“调试(debugging)”混用,但是
严谨的程序员会区分这两种活动。测试是一种检查错误的方法,而调试意味着错
误已经被发现,要做的是诊断错误并消灭造成这些错误的根本原因本章专门讨
论检测错误,修正错误将在第23章“调试”里详细讨论。
测试主题所涵盖的全部范围比构建期间的测试要广得多。其他关于系统测试、
压力测试、黑盒测试以及测试专家的讨论请见本章术尾的“更多资源”小节。
22.
Role of Developer Testing in Software Quality
开发者测试在软件质量中的角色
交叉参考有关
复查的细节,请
对于任何软件质量规划来说,测试都是一个重要的组成部分,并且在许多情
参见第21章协况下它是唯一的组成部分。这是非常不幸的,因为各种形式的协同开发实践都表
同构建”。
现出比测试更高的错误检测率,而且发现一条错误的成本不到测试的二分之一
(card1987:use1991: Kaplan1995)。每个独立的测试步骤(单元测试、组
件测试以及集成测试)通常只能够找到现有错误的50%不到,联合多个测试步骤
通常只能够找到少于60%的现有错误(Jone1998)
代码大全(第2版)

<==========================537end ==============================>
<==========================538start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shub.com!仅供试看
22.1开发者测试在软件质量中的角色
501
与其他臭虫成灾如果你在“芝麻街”的节目(译注:美国著名儿童电视节目)上列出软件开
的程序放在一起发活动的列表,然后问“这些东西当中有哪一个长得与众不同?”,答案很可能会
时,程序并不会
像人感染细菌那是“测试”。测试对于绝人多数开发人员来说都是一种煎熬,这里有很多理由。
样感染 bug Bug
都是程序员自己测试的目标与其他开发活动背道而驰,测试的目标是找出错误。个成功的
引入的。
Hadan Mills
测试应该弄垮软件,而其他开发活动的目标是避免程序错误和软件的崩溃。
测试永远不可能彻底证明程序中没有错误如果你做了很广泛的测试并且已
经发现数以千计的错误,这代表的是你已经找到所有的错误呢,还是有数以
千计的更多的错误等着你去发现呢?测试没有发现错误可能意味着软件完
美无缺,但也同样有可能暗示测试用例是无效的或者不完整的。
测试本身并不能改善软件的质量。测试的结果是软件质量的一个指示器,但
是结果本身并不改善软件质量。想通过更多测试来改善软件的质量,就跟妄
想通过天天称体重来减肥一样。你站到秤台上之前吃了多少东西,就决定了
你秤出来的重量是多少。同样的,你所使用的软件开发方法决定了测试的时
候会找到多少的错误。假如你希望减肥,不是应该买一个新的秤,而是应该
改变你的饮食习惯。假如希望改善你的软件,仅用更多的测试是没用的,你
需要的是更高质量的开发。
测试时要求你假设会在代码里面找到错误。假如你找不到,那么很可能就真
的找不到,但这仅仅是因为你建立了一个自我实现的预言。如果你执行一个
HARD DATA
程序并期望它没有有任何错误,那么你就很容易对已经发现的错误视而不
见。有一项研究很经典, Glenford Myers曾经召集了一群有经验的程序员米
对一个程序进行测试,该程序有15个已知的错误。平均每一个程序员找到
15个错误中的5个,最好的找到了9个。未被发现的错误主要是那些没有
仔细检查的输出错误,其实这些错误都是可以发现的,但程序员们却没有注
意到它们(Mycrs1978)
你必须期望在你的代码里有错误。尽管这种期望似乎有悖常理,但是你
应该期望找到这个错误的人是你,而不是别人。
一个关键的问题是,在一个典型的项目里面,开发者测试应该占多少时间?
一张被普遍引用的图表显示,所有的测试应该占整个项目50%的时间,但这是
带有误导性的。首先,那个图将测试和调试混为谈了,如果仪考虑测试,占
用的时间会少一些。其次,该图所表现的是测试的典型占用时间,而不是测试应
该占用的时间。再次,该图包含了独立测试和开发者测试。
代码大全(第2版)

<==========================538end ==============================>
<==========================539start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
502
第22章开发者测试
正如图22-1所示,根据项目大小和复杂程度的不同,开发者测试应该占整个
项目时间的8%~25%,这与许多已有数据相一致。
100%
系统测试
集成
开发者测试
开发时间的百分比
编码和调试
构建
详细设计
架构
0%
2K
8K
32K
128K512K
项目大小(以代码行数计)
图22-1随着项目规模的增大,开发者测试所耗费的开发时间百分比会更少。程序规
模对测试的影响将在第27章“程序规模对构建的影响”做出详细描述
第二个问题是,怎样利用开发者测试的结果?最直接地,你可以用这个结果
来评估正在开发的产品的可靠性。即使你根本不修正测试所发现的错误,测试结
果也可以描述该软件的可靠性情况。测试结果的另一用途是,它可以用于指导对
软件的修正,并且通常也是如此。最后,测试发现缺陷的记录有助于你归纳出程
序中最常见错误的类型。你可以用这一信息去选择适当的培训课程、指引今后的
技术复查活动,设计未来的测试用例。
Testing During Construction
构建中测试
在测试这一大千世界里,人们有时候会忽略本章的主题:“白盒”或者“玻璃
盒”测试。通常,你希望将一个类设计为一个黑盒这个类的用户不需要穿越
接口窥探类内部来了解类的功能。但是在测试一个类的时候,将它视为玻璃盒是
有好处的,你除了观察它的输入输出,还要察看内部的源代码。如果知道盒子里
面的情况,可以更彻底地测试这个类。当然,如果你在写代码的时候有盲点,测
试的时候也会有同样的盲点,所以黑盒测试也有它的优势。
在构建期间,通常你会写一个子程序或者类先在头脑中检查它,然后对它
进行复查或者测试。无论你的集成测试或者系统测试策略如何,在将一个部分同
其他部分组合之前,你都需要对它进行彻底的单元测试。假如你正在写几个子程
序,那么你应该一个一个地对它们进行测试。独立进行子程序的测试不是一件容
易的事情,但是单独调试它们,比集成之后再进行测试要简单得多。如果将几个
没有经过测试的子程序放到一起,结果发现了一个错误,那么这几个子程序都有
嫌疑。假如每次只将一个子程序加入到此前经过测试的子程序集合中,那么一旦
代码大全(第2版)

<==========================539end ==============================>
<==========================540start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.co.com!供试看^
22.2开发者测试的推荐方法
503
发现了新的错误,你就会知道这是新子程序或者其接口所引发的问题,调试工作
就轻松多了。
协同构建的实践拥有许多测试望莫及的优点。但是测试的部分问题在于它
通常并没有发挥应有的效力。一个开发人员执行了数以百计的测试,却只获得很
低的代码覆盖率。感觉上有好的代码覆盖率并不意味着实际的测试覆盖率就令人
满意。理解测试基概念可以更好地支持测试,也能提升测试的效率。
Recommended Approach to Developer Testing
开发者测试的推荐方法
采用系统化的开发者测试方法,能最大限度提高你发现各种错误的能力,同
时让你的花费也最少。请确保下面所有要点你都能做到。
对每一项相关的需求进行测试,以确保需求都已经被实现。在需求阶段就计划
好这一部分的测试用例,或者至少尽早开始最好在你开始编写待测试的单
元之前。注意对需求里面常见的疏漏进行测试安全级别、数据存储、安装过
程以及系统可靠性等,这些都是测试的绝佳素材,并且常常在需求阶段被忽略。
对每一个相关的设计关注点进行测试,以确保设计已经被实现。在设计阶段
就计划好这一部分的测试用例,或者尽早开始在你开始编写待测试子程
序或者类的具体代码之前。
用基础测试(basis testing)米扩充针对需求和设计的详细测试用例。增加数
据流测试(data- -flow test),然后补充其他所需的测试用例,以便对代码进
行彻底的考验。至少,你应该测试到每一行代码基础测试和数据流测试将
在本章稍后部分讨论。
使用一个检查表,其中记录着你在本项目迄今为止所犯的,以及在过去的项
目中所犯的错误类型。
在设计产品的时候设计测试用例,这样可以帮助避免在需求和设计中产生错
误,修正这些错误的代价往往比修正编码错误更品贵越早修复这些缺陷,成本
就越低,因此,要尽可能早地对测试进行规划并找出缺陷。
Test First or Test Last
测试先行还是测试后行
有的时候开发人员也很疑惑,到底是编写完代码之后写测试用例比较好呢,
还是预先写测试用例比较好(Beck2003)。第30贞的图3-1那个缺陷成本增长图
已经表明,首先写测试用例可以将从引入缺陷到发现并排除缺陷之间的时间缩减
至最短。这正是首先写测试用例的诸多原因之一。
■在开始写代码之前先写测试用例,并不比之后再写要多花功夫,只是调整了
一下测试用例编写活动的工作顺序而已。
代大全(第2版)

<==========================540end ==============================>
<==========================541start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看
504
第22章开发者测试
假如你首先编写测试用例,那么你将可以更早发现缺陷,同时也更容易修正
它们
首先编写测试用例,将迫使你在开始写代码之前至少思考一下需求和设计,
而这往往会催生更高质量的代码。
在编写代码之前先编写测试用例,能更早地把需求上的问题暴露出来,因为
对于一个糟糕的需求来说,要写出测试用例是一件困难的事情。
如果你保存了最初编写的测试用例一这是你应该做的,那么先进行测试并
非唯一选择,你仍然可以最后再进行测试。
总而言之,我认为测试先行的编程是过去十年中所形成的最有用的软件开发
实践之一,同时也是一个非常好的通用方法。但这并不是一种测试万能药,正如
接下来将要说明的那样,它同样受制于开发者测试本身的局限性。
LImitatlons of Developer Testing
开发者测试的局限性
应注意到开发者测试的下述局限性。
开发者测试倾向于“干净测试”开发人员往往去做一些检验代码能否工作
的测试(干净测试, clean tests),而不是做所有可能让代码失效的测试(肮脏测试,
dirty tests)在不成熟的测试机构里,肮脏测试同干净测试的数量比例是1:5成
熟的测试机构倾向于让肮脏测试的数量是干净测试的5倍。这个比率不能够通过
减少干净测试的方式来扭转,应该让肮脏测试的量增至目前的25倍(Boris Beizer
in Johnson 1994).
开发者测试对覆盖率有过于乐观的估计平均而言,程序员坚信他们的测试
覆盖率达到了95%,但通常,最佳情况下这一数字也只能达到大约80%,而在最
HARD DATA糟糕的情况下只有30%平均而言大约在50%~60%
开发者测试往往会忽略一些更复杂的测试覆盖率类型大多数开发人员看到
的测试覆盖率应该称作“100%的语句覆盖率”。这是一个好的开始,但这还远远
不够。更好的覆盖率标准是所谓的“100%分支覆盖率”,也就是对每一个判断语
句都至少测试一个真值和一个假值。第22.3节“测试技巧锦囊”里详细描述了
如何做到这一要求。
上面这些讨论绝不是想要贬低开发者测试的价值,相反,它们促使我们用正
确的观点来看待开发者测试。开发者测试是有价值的,但对于提供足够的质量保
证而言,仅仅进行开发者测试是不够的。我们需补充其他的实践,包括独立测
试(independent testing)技术以及协同构建(collaborative construction)技术
代码大全(第2版)

<==========================541end ==============================>
<==========================542start==============================>

该书下载自书部落分享计算机经典巨著--www. E!--www.shubulo.com! ^ .com!仅供试看
22.3测试技巧锦囊
505
22.3
Bag of Testing Tricks
测试技巧锦囊
为什么说要通过测试来证明程序的正确性是不可能的呢?如果要用测试来证
明一个程序的正确性,你需要对程序的每一种可能的输入值,以及它们之间的所
有可以想象的组合进行测试。即使是一个简单的程序,这样庞大的任务都会让人
望而却步。假设你有一个程序,它取一个姓名、一个地址及一个电话号码,并将
这些数据保存到文件当中。很明显这是个简单的程序,简单到你根本就不会担心
它的正确性。让我们做进一步的假设,其中的姓名和地址都是20个字符长度,每
一个字符有26个可选的字母,那么下面是可能的输入数量:
名字
262(20个字符,每个字符有26种选择)
地址
262(20个字符,每个字符有26种选择)
电话号码
10(10个数字,每一个数字有10种选择)
总共可能出现的情况=2620*2620*1010≈1066
即使是这种输入量很少的情况,你也需要1后面跟66个零这么多的测试用例。
为了让这个数据更直观,我们假设从诺亚在走出方舟的时候就开始测试这个程序,
并且以每秒钟1万亿个测试用例的速度进行,那么到今天为止,所完成的数量还
远远不到总量的百分之一。显然,如果你添加一些更贴近现实的数据量,完全测
试所有可能的情况就变得更加不可能了。
Incomplete Testing
不完整的测试
交叉参考知道
你是否已经覆盖
由于进行完全测试实际上是不可能的,因此测试的窍门就在于选择那些最有
所有代码的方法
可能找到错误的测试用例。在上面的10个可能的测试用例当中,只有极少数有
之一是使用一个可能把错误揪出来,剩下的则不会你需要集中注意力挑选出那些能告诉你不同
覆盖率监视器。答案的测试用例,而不选出一堆总是告诉你相同答案的测试用例。
详情请见本章稍
后部分的22.5节
当你规划测试的时候,要去除那些不会告诉你任何新情况的测试用例,也就
“测试支持工是说,如果测试的某个数据没有产生错误,那么新的类似数据可能也不会产生错
具”的“盖率
监视器”
误。不同的人会建议使用不同的方法来有效地覆盖程序基本情况,下面的几节将
会讨论其中的一些方法。
Structured Basis Testing
结构化的基础测试
尽管名字有点唬人,结构化的基础测试其实是一个相当简单的概念。其思想
是,你需要去测试程序中的每一条语句至少一次。如果语句是一个逻辑语句
代丹大全(第2版)

<==========================542end ==============================>
<==========================543start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. !--www.shubuld.com!仅供试看^
506
第22章开发者测试
例如if语句或者 while语句,那么你就需要根据if或者 while中表达式的复杂程度
来修改测试,以确保这个语句完全经过了测试。要确保你已经覆盖了所有的基础
情况,最简单的方法就是算一算有多少条通过程序的路径,然后据此开发出能通
过程序里每条路径的最少数量的测试用例。
你可能已经听说过“代码覆盖”测试或者“逻辑覆盖”测试,这是测试穿过
程序里的所有路径的两种方法。由于它们覆盖了所有的路径,因此,它们和结构
化的基础测试很相似,但是它们并不蕴涵着以最小数量的测试用例覆盖所有路径
的思想。如果使用代码覆盖测试或者逻辑覆盖测试,在覆盖相同逻辑的情况下,
你需要创建的测试用例远多于结构化的基础测试。
交叉参考这所需基础测试用例的最少数量可以用下面的简单方法计算。
一方法与第
19.6节“如何度
1.对通过子程序的直路,开始的时候记1。
量复杂度”中的
方法相类似。
2.遇到下面的每个关键字或者其等价物时,加1:if、 while、 repeat、for、and
以及or
3.遇到每一个case语句就加1,如果case语句没有缺省情况,则再加1
下面是一个例子:
子程序本身记作在Java程序中计算路径数的简单例子
Statementl;
statement2:
遇到if,记作2f(<10)
Statement3;
Statement4;
在这个例子中,你以1作为开始,然后遇到了一次if,使得总数变成了2。这
就是说,你至少需要两个测试用例来覆盖这段程序的所有路径。对于这个例子
我们需要如下两个测试用例。
由if控制的语句执行(x<10);
由if控制的语句不执行(x>=10)
或许这个简单例子需要更贴近现实一点,这样你才能够有一个更准确的认识,
知道这种测试方式为什么可行。现实中的情况包括了存在缺陷的代码。
代码大全(第2版)

<==========================543end ==============================>
<==========================544start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubulo.co.com!仅供试看^
22.3测试技巧锦囊
507
NARNNG
RUGGYODE
月HED!
下面是一个稍微复杂一点的例子,这一段代码将在本章中不断使用,并且包
含了一些可能的错误。
示例:计算一个Java程序的基础测试所需的用例数量
子程序自身计→1// Compute Net Pay
2 totalwithholdings =;
3
for语句计2.4for(id=0;id< numEmployees;id++)
5
compute social secur
thholding, if below the maximum
f语句计3。→7if(m_ employee[
tirementwithheld
MAX_GOVT REPIREMENT
8
governmentRetireme
ComputeGovernment Retiremen
9
10
1111 set default to no retire
12 companyRetirement =0;
13
i语句计4,
14 11 determine discretionary employe
ution
15 if m_employee[ id ]
&&计5
EligibleForRetirement m
17
companyRetirement =GetRe
ployee[id)
18
19
20 grossPay =ComputeGros
21
22
23 personalRetirement
f语句计6→24if( Eligib
id))
25
personalRetirem
PersonalRet
26
companyRetiremen
27
28
29 make weekly paych
30 withholding =Comput
31 net pay
id
netPay grossPay
governmentRetiremen
32
personalRetirement
33 PayEmployee(m_employ
代码大全(第2版)

<==========================544end ==============================>
<==========================545start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.c!.com!仅供试看^
508
第22章开发者测试
3511 add this employee's paycheck to total for accounting
36totalWithholdings totalwithholdings witbnoldin
37 totalGovernmentRetirement totalGovernmentRetirement+
government Retirementi Retirement companyRetirement;
39
40
41 SavePayRecords totalwithholdings, totalGovernmentRetirement
totalRetirement )
对这段例子而言,最开始你需要一个测试用例然后为遇到的5个关键字分
别添加一个测试用例,总共需要6个。这并不意味着任意6个测试用例都能覆盖
所有的基本情况。它的意思是至少需要6个测试用例。除非很小心仔细地构造测
试用例,否则几乎可以肯定它们无法覆盖所有的基本情况。这里有一个技巧,就
是注意那些导致你用例数量增加的关键字代码中的每一个关键字都描述了非真
即假的情况。因此,需要确保对每一种真的情况至少有一个测试用例,对每一种
假的情况也至少有一个测试用例。
下面是一套能够覆盖这一例子中所有基本情况的测试用例:
用例测试用例描述
测试数据
1正常情况
所有的布尔条件都为真
2初始for条件为假 numEmployee<1
3第一个为假
m_employee[ id ] governmentRetirement-
Withheld>=max_govt_RETIREMENT
第二个由于and
4之前的部分为假,notm employeeid. WantsRetirement
结果为假
第二个由于and
5后半部分为假,结not EligibleForRetirement(m_employee[id])
果为假
6第三个为假
not EligibleForPersonalRetirement(memployee
注意:在本章中,我们会不断地对该表增添更多的测试用例。
如果子程序比这个更复杂,那么覆盖全部路径所需要的测试用例数量将会急
速增加。较短子程序所需的测试路径数量往往较少。没有大量and和or的布尔表
达式需要的测试用例数量也较少。因此,保持子程序和布尔表达式简短能让程序
更易于测试。
现在你已经为该子程序创建了6个测试用例,这满足了结构化的基础测试的
要求,那么你认为这一个子程序已经经过完整的测试了吗?很可能并非如此。
代码大全(第2版)

<==========================545end ==============================>
<==========================546start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !--www.shubulo.com!仅供试看^
22.3测试技巧锦囊
509
这种测试能够向你保证所有的代码都得到执行,但它并不能说明数据的变化
情况。
Data-Flow Testing
数据流测试
将上一节和本节的内容综合起来考虑,给出了另一个例子,该例显示控制流
和数据流在计算机程序设计中的重要性不分伯仲。
数据流测试基于如下观念:数据使用的出错几率至少不亚于控制流。Boris
Beizer声称全部代码中至少有一半是数据声明和初始化(Beizer1990)
数据的状态可以是下列三种状态中的一种。
已定义(defined)数据已经初始化了,但是还没有使用
已使用(used)数据已经用于计算,或作为某子程序调用的一个参数,或者
用于其他用途。
已销毁killed)数据曾经定义过,但是现在已经通过某种途径取消了对它的
定义。例如,如果是一个指针数据,可能这个指针已经被释放(frcc)。如
果是一个for循环的下标,可能程序已经执行到循环外面了,并且程序设计
语言不会在for循环外面继续维持该循环下标变量的定义。如果它是一个指
向文件记录的指针,那么可能该文件已经被关闭,该记录指针就不再有效了。
除了“已定义”、“已使用”和“已销毁”这几个术语之外,为了方便起见,
还应该有一些术语来描述对变量进行某种操作之前或之后,控制流进入或退出某
个子程序的状态。
已进入(entered)控制流已经进入一个子程序,但还没有使用该变量。例如
个在子程序中使用的变量在子程序开始处进行初始化。
已退出(exited)在对变量产生影响之后,控制流立即退出子程序。例如在
子程序的结尾处把返回值赋给一个状态变量。
Combinations of Data States
数据状态的组合
正常的数据状态的组合是变量已定义,已经一次或多次使用,并且可能已经
销毁。请注意下面各种搭配形式:
已定义已定义如果在对变量赋值之前将其定义了两次,那么你需要的不
是一个更好的程序,而是一台更好的计算机!其实这是多此一举,就算当时
没有出错,也是非常危险的。
代大全(第2版)

<==========================546end ==============================>
<==========================547start==============================>

该书下载自-书部落-分享计算机经典巨著!-www ! --www.shubulo...com!仅供试看^
510
第22章开发者测试
已定义-已退出如果这是一个局部变量,那完全没有理由在定义后却不使
用就退出。如果是一个子程序的参数或者全局变量,那还说得过去。
已定义-已销毁定义一个变量然后就销毁它,这意味着要么这个变量对程
序没什么意义,要么就是程序员忘记写使用这个变量的代码了。
已进入-已销毁如果这是一个局部变量,那就有问题了。如果局部变量未
定义或者未使用,那么它完全不需要被销毁。而另一方面,如果这是一个子
程序的参数或者全局变量,只要在销毁之前确定该变量已经在别的什么地方
定义过,那么使用这种组合就没有问题。
已进入已使用还是一样,如果这是一个局部变量就有问题。这个变量应
该在使用之前被定义。反之,如果这是一个子程序的参数或者是个全局变
量,那么只要这个变量在使用之前已经在别的地方被定义过,那么就没有任
何问题。
已销毁已销毁一个变量不应该被销毁两次变量不能死而复生,如果变
量复活,那说明程序写得太随意了。同样,对指针销毁两次是致命的想
要让你的计算机崩溃的最好方法就是两次释放同个指针。
已销毁已使用使用一个已销毁的变量从逻辑上就讲不通。如果这样的
代码似乎还能正常工作(例如一个指针继续指向已释放的内存),这只是一
种例外情况,墨菲定律(译注: Murphy'sLaw,任何可能出错的事都会出错。)
也说代码如果停止工作将要引起极大混乱,那这时它就会停止工作。
已使用已定义对一个变量先使用后定义可能是问题也可能不是,这就
要看这个变量在使用之前是否已经定义过。当然,如果你看到某个已使用
已定义的模式,那么检查一下之前的定义是非常有必要的。
在开始测试之前,首先要检查一下,看看是否出现了这些反常的数据状态顺
序。在做过这些检查之后,编写数据流测试用例的关键是要对所有可能的定义使
用路径进行测试。你可以采用彻底程度不同的测试。
所有的定义。测试每一个变量的每一个定义在每个变量被赋值的地方。
这是一个很弱的策略,因为如果你曾经尝试对每一行代码进行测试,那么就
已经做过这件事了。
所有已定义已使用的组合。对每一个变量测试所有在某处定义而在另一处
使用的组合,与测试所有定义相比,这是一个更强的策略,因为仅仅执行每
一行代码并不能保证测试到每一种已定义已使用的组合。
代码大全(第2版)

<==========================547end ==============================>
<==========================548start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.co.com!仅供试看^
22.3测试技巧锦囊
511
下面是一个例子:
Java示例:用于数据流测试的一段代码
if Condition 1
=ai
else
x=
if Condition 2)
y=+1
else
y=×1
要覆盖程序里的每条路径,你需要一个使Condition1为真的测试用例,同
时需要一个使 Condition1为假的用例。对于 condition2,你同样需要一个使
之为真的测试用例和一个使之为假的测试用例。这可以通过两个测试用例实现:
用例1(Condition1为真, Condition2为真)以及用例2(Condition1为
假, Condition2为假)。这两个用例就是你进行结构化的基础测试所需的全部。
依靠这两个用例,你也能测试每一行定义变量的代码。这两个用例自动提供了数
据流测试的弱形式。
但如果要覆盖每一个已定义-已使用组合,就需要添加一些额外的用例。现在
你已经处理了两个情况,一个是Condition1和 Condition2同时为真,另
个是 Condition1和 Condition2都为假:
=a
y=+1
以及
=b
y=-1
要测试每一种已定义已使用的组合,你还需要另外两种情况:(1)x=a并且
接着y=x-1,以及;(2)×=b并且接着y=x+1在这个例子里面,你可
以通过增加两个用例来得到这些组合:用例3(Condition1为真, Condition2
为假),以及用例4(Condition1为假, Condition2为真)
开发测试用例的一个好方法是首先进行结构化的基础测试,即使它没有测试
所有的已定义已使用数据流形式,但至少也完成了其中的一部分然后你需要添
加完整的已定义已使用数据流测试所需的用例。
代码大全(第2版)

<==========================548end ==============================>
<==========================549start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co.com!仅供试看
512
第22章开发者测试
正如前一节所讨论的那样,结构化的基础测试已经为第507页的子程序提供
了6个测试用例。如果要对每一对已定义-已使用组合进行数据流测试,则需要更
多的测试用例,其中一部分已经被已有的测试用例所覆盖了,而其余部分并没有
被处理。下面是所有的数据流组合,正是它们补充了由结构化的基础测试所产生
的测试用例:
用例
测试用例描述
7在第 companyRetirement12行定义,并在第26行首次使用它。前面的
测试用例并没有覆盖这种情况
在第12行定义 companyRetirement,并在第31行首次使用它。前面的
8测试用例并没有覆盖这种情况
在第17行定义 companyRetirement,并在第31行首次使用它。前面的
9测试用例并没有覆盖这种情况
如果你尝试过几次按这种方法列出数据流测试用例之后,你就能够找到感觉,
知道哪些用例是富有成效的,而哪些用例的测试范围已经被之前的用例覆盖到了。
当工作毫无进展的时候,就应该列出所有的已定义已使用组合这样做看起来工
作量很大,但它保证你能够获得用基础测试方法并不能轻松发现的用例。
Equivalence Partitioning
等价类划分
交叉参考本一个好的测试用例应该覆盖可输入数据中的很大一部分。如果两个用例能揭
章末尾的“更多示的错误完全相同,那么只要一个就够了“等价类划分”的概念是这一想法的严
资源”列出了很
多深入讨论等格表达形式,应用它有助于减少所需用例的数量。
价类划分的书
籍。
在第507页开始的表中,第7行是使用等价类划分的好地方,这里需要测试的条
件是memployeeid government RetirementWithhel<max_govt_RETIREMENT
在这一情况中,有两个等价类:一个是employee【id].governmentRetirement
Withheld小于MAX_GOVT_RETIREMENT,而另一个是 employee[id.govern
mentRetirementwithheld大于或等于MAX_GOV_RETIREMENT.也许在程序的其
他部分还会有许多类似的情况,那就意味着需要对m_employee【id] govern
ment RetirementWithheld测试的数据不止两种,但就目前我们所看到的这段程
序来说,两种情况就已经足够了。
如果你已经通过基础测试和数据流测试覆盖了整个程序,那么对等价类划分
的研究并不会让你对程序产生多少新的认识。然而,如果你从程序的外部来审视
(从规格说明而非源代码角度),或是数据很复杂且程序的逻辑并未完全体现这种
复杂性的时候,等价类划分还是大有好处的。
代码大全(第2版)

<==========================549end ==============================>
<==========================550start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubul.com!仅供试看^
22.3测试技巧锦囊
513
Error Guessing
猜测错误
交叉参考有作为正式测试方法的补充优秀的程序员会使用各种不太规矩的、启发式的方法
关启发式方法去寻找他们代码中的错误,其中一种启发式方法就是猜测错误。“猜测错误”这一措
的细节,请参见
第2.2节“如何辞表现了对这一睿智概念的浅薄理解。它的真正含义应该是在猜测程序会在哪里出错
使用软件隐的基础之上建立测试用例,尽管这也意味着猜测中会有一些牵强附会的成分
猜测可以基于直觉或者过去的经验。第21章“协同构建”提到,详细检查的
一个好处是,这一过程能产生并维护一份常见错误列表,而该列表可以用于检查
新的代码。如果你保留了一份记录过去所犯错误种类的列表,那么你就能提高“猜
测错误”的命中率。
下面几个小节描述了一些特定的错误类型,这些错误很容易通过猜测错误的
方法发现。
Boundary Analysis
边界值分析
运用边界值条件进行测试最丰硕的战果之一就是off-by-one错误。这种错误
即当你想用num的时候写成了num-1,当你想用>”的时候写成了“>=”,这些
都是最常见的失误。
边界值分析的思想就是写一些测试用例来测试边界值条件。假如你要对小于
max的某个范围的数值进行测试,那么你会遇到下图所示的三种可能情况:
Boundary
Boundary
below Max Max above Max
正如图中所示,这三种边界情况是:刚好小于max、等于max本身以及刚好
大于max。需要三个测试用例去保证代码里没有出现任何一种常见错误。
在第507页的实例代码里面有一个判断:m_employeeid. government
Retirementwithheld<max_govT_RETIREMENT,而根据边界值分析原理,我们
需要测试三种情况:
用例
测试用例描述
用例1检查测试条件memployeeD]. government RetirementWithheld
<maxgovt_RETIREMENT结果为真的那一边的情形,于是在用例1中需要
1将memployee ID.governmentRetireme设置为
MAXGOVTRETIREMENT-1,这个测试用例已经有了
代码大全(第2版)

<==========================550end ==============================>
<==========================551start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.con.com!仅供试看^
514
第22章开发者测试
续表
用例
测试用例描述
用例3检查测试条件employee[i] government Retirementwithheld<
MAXGOVTRETIREMENT处于结果为假的那一边的情形,它需要将
3m_employee[d.governmentRetirementWithheldd设置为
MAXGOVT_RETIREMENT+1,这个测试用例也有了
还要加上一个测试用例,测试正好在边界值上面的情形,也就是
10m_employee ID. governmentRetire=
MAXGOVTRETIREMENT的时候
Compound Boundaries
复合边界值
边界值分析也适用于允许的最大最小值在这个例子里面,可能会出现
grossPay、 companyRetirement以及 RetirementC的最小值或最
大值,但是由于对这些值的计算在子程序考虑范围之外,因此它们的测试用例不
在这里做进一步的讨论。
有一种边界条件更加隐蔽,就是当边界条件涉及到互相关联的多个变量的时
候。例如,两个变量相乘,它们的值都是大的正数,会出现什么情况呢?都是大
负数呢?零呢?如果传入子程序的字符串都长得很不寻常呢?
在我们的例子里面,你可能希望看一下,当一大群员工都有巨额月薪的时候
—比如说每个程序员都有25万美元的月薪(我们梦寐以求的数字!),变量
totalWithholding. totalGovernmentRetirer以及 totalRetirement会发
生什么情况。这就需要另外的测试用例了:
用例
测试用例描述
有一大群的员工,他们每个人都有很高的薪水(多少才算大取
11
决于所开发的特定系统)一比如说,我们有1000位员工,每
人有$250000的月薪,他们都不需要交社会保险税,同时所有
人都希望得到退休金
基于同样的道理,也可以站在相反的方向问问看,我们也需要一个只有很少
人、每个人薪水都为0的测试用例:
用例
测试用例描述
12
10个员工,每个人的薪水都是$0.00
Classes of Bad Data
几类坏数据
除了假设错误会在边界条件上出现之外,你可以猜测并测试几种类型的坏数
据。典型的坏数据测试用例包括:
■数据太少(没有数据)
太多的数据
代码大全(第2版)

<==========================551end ==============================>
<==========================552start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor!^.com!仅供试看^
22.3测试技巧锦囊
515
错误的数据情况(无效数据)
长度错误的数据
未初始化的数据
你遵从这些建议所能想到的一些测试用例早已被前面的用例覆盖了。比如说,
“数据太少”就已经被用例2和12覆盖了,此外我们也很难提出任何“数据长度
错误”的情形。尽管如此,关于这几种坏数据的想法还是会带来如下几个新的用
例:
用例
测试用例描述
100000000工,测试太多数据的情况。当然,多少才能称之为“太多”
13要根据系统的不同做出不同的定义但是为了举例说明,我们就假设这已经
太多了
14薪水是负数,错误的数据情况
15员工数量是负数,错误的数据情况
Classes of Good Data
几类好数据
当你试图在程序中寻找错误的时候,这样一个事实很可能从你的眼皮底下
过去:正常的情况也可能暗含错误。通常来说,基础测试一节所提到的正常情形
所描述的就是一种好数据。下面是其他几种值得测试的好数据,根据待测试对象
的情况,测试下面每种数据类型时可能会有所收获。
正常的情形—大路正中间,所期望的值
最小的正常局面
最大的正常局面
与旧数据的兼容性
最小的正常局面在测试一组对象而非一个对象的时候比较有用。它和测试多
个边界条件的最小值的思想差不多,但还是有所区别,这里我们测试的是一组正
常期望值中的最小值的集合。比如说测试电子表格的时候保存一个空表格,测试
字处理软件的时候保存一个空的文档。而在本书中的例子里面,为了测试最小的
正常局面需要添加下面的测试用例:
用例
测试用例描述
16
只有一个员工。用于测试最小的正常局面
最大的正常局面是最小局面的对立面,它与边界测试的思想很像,但同样
它测试的是一组期望值中所有最大值的集合。比如说测试电子表格的时候就应该
代码大全(第2版)

<==========================552end ==============================>
<==========================553start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.cor!.com!仅供试看
516
第22章开发者测试
试试能否保存像产品包装上所说的“最大电子表格”那样的表格,或者打印一个
可容许的最大表格。对于字处理软件来说,则是保存一个所容许的最大规模的文
档。而在本例当中,测试最大正常形式需要看允许的最大员工数量是多少,比如
我们假设是500个,那么你可以添加下面这个测试用例:
用例
测试用例描述
17
500个员工。用于测试最大的正常局面
最后一种对正常数据的测试—测试与旧数据的兼容性,这是在新程序或子
程序替代旧版本的时候才需要进行。除非旧的子程序有缺陷,否则新的子程序应
该和旧的子程序有着相同的处理结果。版本间的连续性是回归测试的基础,回归
测试的目的是保证程序的修正和增强仍然保持了原有程序的质量水平而没有发生
倒退。在本例中不存在兼容性的问题,因此不需要添加任何测试用例。
Use Test Cases That Make Hand-Checks Convenient
采用容易手工检查的测试用例
让我们假设你正在写一个有关正常薪水的测试用例,你需要一个普通的薪水
值,得到这个数字的其中一种方法是随手敲几个数字,让我们来试试看:
1239078382346
好,这个薪水有点高,事实上比万亿元多一点。但是如果把它剪裁一下,使
数值看起来比较贴近现实,我可以得到$90783.82
现在我们进一步假设这个测试用例很成功——也就是说它发现了一个错误。
怎么知道确实发现了一个错误呢?嗯,你很可能是通过手工计算得知这个答案是
错误的,同时还算出了正确答案应该是多少但当你试着手工计算$90783.82这
样丑陋的数时,手工计算过程犯错的几率跟你在程序中发现错误的几率差不多。
在另一方面,一个好的数值,像$20000这样的数值也会让你的手工计算倍感轻松。
在计算器上面敲几个零不过是小菜一碟,而大多数程序员在做乘以2的运算时都
无须数手指和脚趾头。
你可能会想,那种像$90783.82的丑八怪应该更有可能把错误揪出来,但实际
上它发现错误的几率并不会比其他数值高。
代码大全(第2版)

<==========================553end ==============================>
<==========================554start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--www.shubulo.com!^ ^.com!仅供试看
22.4典型错误
517
22.4
Typical Errors
典型错误
本节所想要说的是,你如果越了解你的对手错误,你的测试就越有可能
做得更好。
Which Classes Contain the Most Errors
哪些类包含最多的错误
我们很自然会有这样的假设:缺陷在代码里面是均匀分布的。假如你的代码
平均每1000行就会有10个缺陷,你可能会假设一个有100行代码的类里面会存
rot在1个错误。做出这种假设是很自然的,但事实上是错误的。
Caper Jones的报告中写到,IBM的一个质量改善的计划发现了在IMS系统
425个类中的31个容易出错。为了解决问题,这31个类要么被修正过,要么经
过了彻底的重新开发。在不到一年的时间里,客户所报告的IMS缺陷数量降低到
了原来的十分之,整体维护成本也减少了45%,客户的满意度也从“不可接受”
上升至“良好”( Jones2000)
绝大多数错误往往与少数几个具有严重缺陷的子程序有关。下面是错误和代
码之间的普遍关系。
80%的错误存在于项目20%的类或者子程序当中(Endres1975; Gremillion
1984; Boebm 1987b; Shull et al. 2002).
50%的错误被发现存在于项目5%的类当中(Jones2000)。
如果你认为这些关系无关紧要,很可能是因为对下面几个结论一无所知。
首先,项目中20%的子程序占用了80%的开发成本( Boehm1987b)虽然这并不
是说成本最高的20%的代码就是有最多缺陷的0%的代码,但这很有启发性。
其次,无论高缺陷率子程序在成本中所占的具体比例如何,这些子程序的成
本的确是异常高昂的。20世纪60年代IBM做了一个经典的研究,对OS/360操作
HARD DATA系统所做的一次分析发现,错误并非平均地分布在所有的子程序里面,而是集中
在少数几个子程序里面。人们还发现这些容易出问题的子程序是“程序中最昂贵
的部分”(Jones1986a),它们每一下行代码包含的缺陷达到50个之多,修复它们
的代价是开发整个系统的成本的十倍(这里的成本包括客户支持以及现场维护)
代大全(第2版)

<==========================554end ==============================>
<==========================555start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.co.com!仅供试看
518
第22章开发者测试
交叉参考另一再次,子程序开发成本昂贵带来的影响也显而易见。俗话说“时间就是金钱”
种倾向于包含很
多错误的子程我的推论是“金钱也是时间”,也就是说,如果能避免卷入到那些烦人的子程序中,
序,就是那些极那么你就可以省下近80%的成本,从而节约一大段开发时间。这清晰地描述了软件
度复杂的子程
序。有关识别并质量的普遍原则:提高质量就能缩短开发周期,同时降低开发成本。
的细节,请参见最后,避免维护惹人厌烦的子程序同样具有明显的重要意义。维护工作应该
19.6节的“降低围绕如何确定容易出问题的子程序,如何把这些部分推倒重来,重新设计并编写
复杂度的一般原
则”。
代码。在前面提到的IMS项目中,替换了这些容易出错的类之后,IMS发布版的
运行效率提升了15%( Jones2000)
Errors by Classification
错误的分类
交叉参考在本
很多研究者都尝试着对错误进行分类,并对每种错误的出现范围做出判定。
书目录后面,有
本书所有核对表每一个程序员都有一份让自己感到棘手的错误列表off-by-one错误以及忘记对循
的一份清单。环变量重新初始化等。遍布本书各处的核对表能够为你提供更多的检查细节 Boris
Beizer将多个研究的数据综合起来,得到一种非常详尽的错误分类方法(Beizer
1990)下面是对他的研究结果的一个总结:
25.18%
结构方面的问题
22.44%
数据
16.19%
已实现的功能
9.88%
构建
8.98%
集成
8.12%
功能需求
2.76%
测试的定义或者执行
1.74%
整个系统,软件架构
4.71%
未归类
Beizer报告的结果精确到了小数点后两位,但其对错误类型的研究至今仍然
不是结论性的。不同研究所报告的错误类型就有很大差别,针对类似的错误类型
进行的不同研究也得到了非常不同的结果,并且差异可以达到50%而不止是百分
之几。
由于各种研究结果千差万别,因此像Beizer所做的这种将多个研究结果合并
起来所得到的数据也许并没有意义。但即便不能将其作为定论,这些数据中的某
些部分还是很有启发的。下面是这些数据给我们的提示。
代码大全(第2版)

<==========================555end ==============================>
<==========================556start==============================>

该书下载自-书部落-分享计算机经典巨著!- !--www.shubulo..com!仅供试看
22.4典型错误
519
大多数错误的影响范围是相当有限的一项研究发现,85%的错误可以在修
改不超过一个子程序的范围内得以修正。
HARD DATA
许多错误发生在构建的范畴之外有一次研究人员组织了系列的调查,这
97次调查发现了三种最为常见错误的源头,它们分别是:缺乏应用领域知识,频
繁变动且相互矛盾的需求,以及沟通和协调的失效。
如果你看到地上
的马蹄印,应当设
大多数的构建期错误是编程人员的失误造成的许多年前的两个研究发现,
想是马而不应设所有报告的错误中,由程序员造成的占了大约95%,由系统软件(包括编译器和
想成斑马操作系
统可能并没有崩操作系统)造成的占了2%,由其他软件造成的占2%,还有1%是硬件造成的(Brown
溃,数据库可能还
是好好的。
and Sampson1973 Ostrand and Weyuker184)与20世纪七八十年代相比,今天
Andy Hunt和有更多的人使用着系统软件和开发工具,因此我估计现在由程序员失误造成的错
ave Thomas
误所占的百分比会更高
让人惊奇的是,笔误(拼写错误)是一个常见的问题根源一项研究发现在
ha构建阶段产生的错误中,有36%是拼写错误( Weiss1 1975在1987年,
HARD DATA着接近300万行代码的飞行动力学软件的研究发现,其中18%的错误是拼写错误
(Card1987)。另一研究发现所有错误中的%是消息拼写错误(Endres1975)
我的一位同事仅仅借助一个拼写检查具对可执行文件中的所有字符串进行检
查,就在我写的一个程序里发现了许多的错误要小心这些细节问题可能产生的
后果。如果你对此有所怀疑的话,想一想三个有史以来最昂贵的软件错误其
代价分别为16亿美元、9亿美元和2.45亿美元,都是因为原本正确的程序中的一
个不正确的字符造成的(Weinberg1 1983)
研究程序员所犯错误原因时,错误理解设计这条会经常出现 Beizer的汇总
研究的价值之一在于,他发现有16%的错误是由于对设计的错误解释所造成的
(Beizer1990)。另一个研究则发现19%的错误是对设计的误解的产物(Weiss
1975)。因此,花点时间来彻底理解设计是很值得的。所花的时间并不会立竿见
影你不必像编写代码一样全力投入,但你会因此在整个项日的生命周期中持
续获得回报。
大多数错误都很容易修正大约85%的错误可以在几个小时的时间内修正,
大约15%的错误可以在几个小时到几天之内修正,只有大约1%的错误需要花更长
的时间( Weiss1975: Ostrand and Weyuker198; Grady1992)这个结论在 Barry
Boehm的观察中得到了印证,他发现修正大约20%的错误花费了大约80%的资源
(Boehm1987b)。因此,你应当尽可能地通过早期对需求和设计的复查来避免软
件中的硬伤,以及尽可能有效地处理大量存在的小错误。
代码大全(第2版)

<==========================556end ==============================>
<==========================557start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^^.com!仅供试看
520
第22章开发者测试
总结所在组织中对付错误的经验本节所引用的各种结论,正好说明了不同
组织的人会有完全不同的错误处理经验,因此,很难将在其他组织所获得的经验
应用到你所在的组织中。有些结论或许有违口常直觉,因此,你可能需要借助各
种工具来帮助你的直觉。一个良好的开始就是评估你的开发方法,以便了解问题
出在什么地方。
Proportion of Errors Resulting from Faulty Construction
不完善的构建过程引发错误所占的比例
如果说对错误进行分类的数据不是结论性的话,那么将错误归结于不同的开
发活动的多数数据也一样。但有一点是确定的,那就是构建总会出现大量的错误。
有些人会争辩说,修正构建中产生的错误的成本,比修正需求或者设计的错误的
成本要低。修正单个构建错误的成本可能确实会低一些,但是没有证据证明总成
本也比较低。
下面是我的一些结论。
在小型项目里面,构建中的缺陷占了所有错误的大多数。对一个小型项目
(1000行代码)中错误的研究发现,75%的错误由编码造成。与此相比较,
HARD DATA
另外有10%的错误源白需求,以及15%源自设计(Jones1986a)这一错误
分类对许多小型项目而言非常有代表性。
无论项目规模如何,构建缺陷至少了总缺陷的35%尽管在大型项目里面
构建缺陷所占的比例相对小一些,但它们仍然占有至少35%的比例(Beizer
1990; Jones2000),有研究人员甚至报告在一些巨无霸项目里这一比例能
达到75%( Grady1987)。总的来说,对于应用领域的理解越好,所设计的
总体架构也就越好。由此,错误往往更多地出现在详细设计和编码上(Basili
and Perricone 1984).
修正构建错误的代价虽然要比修正需求和设计的错误相对低廉,但从绝对值
来看仍然是高昂的。对惠普公司两个巨型项目的研究发现,修正构建缺陷的
平均成本相当于修正设计缺陷平均成本的25%至50%(Grady1987)在我
们将较大的构建缺陷数量纳入到构建缺陷总成本计算公式后,可以发现修
构建缺陷的总成本相当于修正设计缺陷的总成本的一至两倍。
图22-2展示了项目规模和错误来源之间的大致关系。
代码大全(第2版)

<==========================557end ==============================>
<==========================558start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !-www.shub com!.com!仅供试看^
22.4典型错误
521
100%
构建
种活动
各种活云
在某些项目中,
引发的错误
这一部分错误
设计
也可能来自构建
需求
0%
2K
832K128K512K
项目规模(以代码行数计)
图22-2随着项目规模的增长,在构建期间产生的错误所占的比例会下降,然而即使
是在巨型项目里面,构建错误也会占全部错误的45%至75%
How Many Errors Should You Expect to Find
你期望能发现多少错误
预期发现错误的数量会根据你所使用开发过程的质量而变化。下面列出可能
的范围。
业界的经验是,在已发行的软件中平均100行代码发现1~25个错误。软
件开发通常会使用各种各样的技术( Boehm181; Gremillion 11984;Yourdon
HARD DATA
1989a; Jones1998; Jones2000; Weber2003)。错误发生率只有上述数值
的十分之一的情形非常少见,而十倍于此的情形似乎从未听说(这些项目很
可能根本无法完成)。
微软应用程序部门的经验是,内部测试程序大约每1000行代码有10至20
个缺陷,而对于已发布产品则大约是每1000行代码0.5个缺陷。要达到这
一水平,需要结合运用第21.4节“其他类型的协同开发实践”中所描述的
代码阅读技术,以及独立测试技术。
Harlan Mills所倡导的“净室开发”的技术,可以获得低至每1000行代码3
个缺陷(内部测试阶段),以及每1000行代码0.1个缺陷(产品发布阶段)
的错误率(Cobb and Mills 11990)。只有少数几个项目,例如航天飞机的软
件,能够达到每50万行代码0缺陷的水平。这需要使用一个系统的形式化
开发方法、同事复查(peer review),以及统计测试(Fishman1996)。
Watts Humphrey报告称,使用“团队软件开发过程”(Team Software Process
TSP)的开发小组,可以达到大约每1000行代码0.06个缺陷的水平。sP
HARD DATA
把训练开发人员如何避免缺陷放在了第一位(Weber2003)。
代码大全(第2版)

<==========================558end ==============================>
<==========================559start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看
522
第22章开发者测试
TSP和净室开发项目的结论从另角度证明了软件质量的普遍原则:开发高质量
的软件,比开发低质量软件然后修止的成本要低廉一个使用净室开发技术、经过全
面检验合格并拥有8万行代码的项目,其生产效率相当于平均每个工作月740行代码。
而开发经过全面检验合格的代码的业界平均效率大约是平均每工作月250到300行代
码,这包含了所有非编码的日常销(Cusumano et a.2003)这里我们所看到的成本
节约和生产效率提升,其源泉在于使用TSP或者净室技术的项目几乎没有将时间投入
到调试当中。不在调试上面花时间?那真是一个很有价值的目标!
Errors in Testing Itself
测试本身的错误
你可能有过这样的经验:发现软件有错误,直觉立刻告诉自己一定是软件的
某个部分出错了,然而你猜测的所有地方看起来都是正确的。于是你增加了几个
EY POINT测试用例,尝试定位这个错误的根源,但是所有新增加的测试用例却都产生了
确的结果。你花了好几个小时一遍又一遍地阅读代码,并手动计算结果,这些都
被证实是正确的。又过了几个小时,其他的一些事情让你再次检查测试数据。找
到了!是测试数据本身的错误!花了无数小时跟踪调试,最终却发现错误存在于
测试数据而非代码中,这个时候真觉得自己是白痴!
这是一种非常普遍的经历,测试用例可能包含同被测代码同样多,甚至是更多
的错误(Weiland1983; Jones1986a Johnson1994)原因很简单尤其是由开
HARD DATA发人员在编写测试用例的时候。测试用例往往是临时抱佛脚的成果,没有经过仔
细的设计和构建。这些测试用例通常被认为是只测试一次,并且开发它们的人是
抱着用后即弃的心态来开发的。
你可以通过下列几项工作来减少测试用例当中的错误量。
检查你的工作要以开发代码般的谨慎态度来开发测试用例,这种谨慎当然
包括对测试进行双重检查。在调试器当中单步跟踪测试代码,要一行一行的来,
就像你对待产品级代码那样。对测试数据进行走查和详细检查也是适当的做法。
开发软件的时候就要计划好测试用例在需求阶段或者刚刚接手该程序时,
就应该开始对测试做出有效的计划。这有助将基于错误假定的测试用例扼杀在
摇篮中。
保留你的测试用例花上点时间来管理测试用例,把它们保存起来,这些东
西在回归测试或者开发下一个版本的时候还用得上。如果你知道应该保留这些测
试用例而非将其抛弃,就很容易努力去避免一些麻烦。
将单元测试纳入测试框架首先写单元测试中使用的代码,在每完成一次单
元测试后,记得将它们集成到一个系统级测试框架中去(例如JUnit)有了这样
的集成测试框架,就可以减少丢弃测试用例的可能性。
代码大全(第2版)

<==========================559end ==============================>
<==========================560start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! -www.shubu.com!仅供试看^
22.5测试支持工具
523
22.5
Test-Support Tools
测试支持工具
本节将概述几种你可以买得到,或者可以自己开发的测试工具。不过这里
不会写出特定产品的名称,因为在你阅读本书的时候它们很可能已经过时了。关
于最新的产品,请参考你所钟爱的程序员杂志。
Building Scaffolding to Test Individual Classes
为测试各个类构造脚手架
“脚手架( scaffolding)”是个建筑界的术语。建筑工人如果要对建筑的某个
部分进行施工,就必须搭建脚手架,除此之外别无他法。在软件中搭建脚手架只
有一个目的,那就是更方便地测试代码。
课入阅读在
有种脚手架是所谓的哑类(dummy class),测试的类可以使用它。这样的
Jon Bentley所类也被称为“模仿对象(mock object)”或者“桩对象(stub object)(Mackinnon
PBangrammind Freemand and Craig200 Thomas and Hunt2002)对于低层的子程序也可以用类似
s,2ded的方法,那就是“桩函数(stub routines)”。在制作假对象或者桩函数的时候,你可
2000年)书
中,“ Small以根据所需的真实性来决定它们与现实的近似程度。在这些情况中,脚手架可以
Matter
Programming立刻返回控制权,不做任何动作
一节里面有几个
有关脚手架的好检查传给它的数据
例子。
输出诊断信息,可能是显示所传入的参数,或者是将信息记录到日志文件中
返回用户交互输入的值:
不管输入是什么都返回一个标准的响应;
消耗原本分配给真实对象或者真实子程序的时钟周期
以某种慢速、臃肿、简单或粗略的方式实现真实对象或者子程序的功能
另一种脚架类型,是调用待测试的真实函数的伪造函数。这种脚手架称为
“驱动函数”,有时也称为“测试夹具”。这种脚手架可以:
用固定的一组输入调用对象;
提示用户输入,然后根据输入去调用对象;
从命令行取得参数(如果操作系统支持)去调用对象
■从文件中读入参数,并据此调用对象;
用一集预先定义的输入数据去多次调用有关的对象。
代大全(第2版)

<==========================560end ==============================>
<==========================561start==============================>

该书下载自书部落-分享计算机经典巨著!-www. ! --www.shubulo. com! ^.com!仅供试看
524
第22章开发者测试
交叉参考测试工最后一种脚手架是所谓的哑文件,即真实文件的一个小尺寸版本,它的构成
具和调试工具之间和全尺寸文件一模一样。一个小的哑文件有一些好处:首先,因为它尺寸小,你
限是的对它的内容一清二楚,并且可以毫不犹豫地断定这个文件本身没有错误。其次,
的
关于测试工具的详
细信息请参见23.5因为它是为了测试而被特别制作出来的,你可以设计它的内容,使任何使用文件
节“调试工具一的错误都能暴露出来。
明显的和不那么明
显的”。
显然,构造脚手架也需要付出一些劳动,但一旦在某个类当中发现了一个错
cc2c/2268误,你就可以重用这些脚手架了。并且有很多能流水线般创建假对象和其他脚手
架的工具。同时,被测试的类与其他类的交互可能会影响测试的结果,而如果使
用脚手架,就不用冒这样的风险。在遇到嗨涩的算法时,脚手架会相当有用。还
有一种常见的情况:由于所测试的代码是嵌入在其他代码当中,因此,执行每一
个测试用例都需要花费好几分钟的时间。而脚手架则可以让你直接测试那些需要
测试的代码。制作脚手架花不了多少时间但它可以直接测试非常底层的代码,
从而为你节约很多的调试时间。
目前已有许多现成的测试框架可以提供脚手架功能(JUnit、 CppUnit、 NUnit
等),你可以使用任意一款来测试你的程序如果你的开发环境不支持任何一种现
存的测试框架,你可以在写完某个类的若干子程序之后,在该文件当中添加一个
main()脚手架子程序来测试这个类,而被测试的类甚至不需要为此做任何准备。
这个main()子程序可以从命令行当中读取参数,然后将参数传递给被测试的子程
序,这样你就可以在这份代码集成到整个程序中之前首先自行测试一遍。集成的
时候,这些脚手架子程序可以和被测试子程序一同保留在文件当中,然后通过预
处理指令或者注释,使脚手架子程序处于非激活的状态。由于在预处理阶段已经
把它们排除在外,因此并不会影响可执行代码。同时由于它位于源代码文件的底
部,因此也不会在你阅读代码的时候十扰你的视线。把脚手架子程序保留在集成
代码中并无坏处。相反,当你再次需要的时候,它已经在那里等待召唤了。同时,
这么做也可以避免耗费时间来删除脚手架,或者对它进行归档。
Diff Tools
Dff工具
交叉参考有关
如果你有一个能自动对比实际输出与期望输出的工具,那么进行回归测试
回归测试的更多或者被称为重新测试的时候就会容易得多了。一种检查输出数据的简单方法是,
细节,请参见第
22.6小节的“重将程序的输出重定向到一个文件当中把预计输出也存放到一个文件中,然后用
新测试(回归测一个文件比较工具如diff对二者进行比较。如果两个输出不一致,你就已经发现
试”。
了一个回归错误。
Test-Data Generators
测试数据生成器
cc2e.com/2275
为了系统地对程序的某些部分进行测试,你可能会写些代码几年前我开
发了一个自己的加密算法,然后写了一个使用该算法的文件加密程序。该程序的
代码大全(第2版)

<==========================561end ==============================>
<==========================562start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shubul.com!仅供试看^
22.5测试支持工具
525
作用是对文件加密,加密后,除非输入正确的密码,否则无法对其解密。这个加
密算法并非只对文件稍加粉饰,而是彻底改变了里面的内容。因此,正确解密文
件是这个程序的关键,否则文件就遭到了破坏。
为了能够对程序的加密和解密部分做一个完整的测试,我设计了一个测试数
据生成器。它产生包含随机字符的文件,其长度是随机的,从0到500K字节不
等。它还产生由随机字符组成的密码,长度也是随机的,从1到255个字符不等。
对每一个随机生成的测试用例,该测试数据生成器所产生的文件都是一式两份。
程序首先对其中的一份进行加密,然后重新初始化并对加密后的内容解密,最后
将结果与另一份文件进行对比。如果有任何不相同的字节,这个生成器就会输出
所有有用信息,而根据这些信息我就可以重现这个错误了。
我将测试文件的平均长度控制在30K左右,与我的文件的平均长度差不多,
远比最大文件长度500K要小。如果我没有将测试用例的长度控制在一个较小的
长度,那么文件的长度就会均匀地分布在0到500K之间,其平均长度也就变成
了250K。更小的平均长度意味着我可以做更多的测试,包括更多的文件、密码、
文件结束状态、奇怪的文件长度以及考虑其他的各种可能造成错误的情况。
最后的结果让我感到满意,因为仅仅在运行了10个测试用例之后,我就发
现了程序里的两个错误。虽然这两个错误都是源自特例,实际上可能根本就不会
发生,但是这毕竟是错误,我非常高兴能够发现它们。在修正了这些错误之后,
我让这个程序花了几个星期对多达10万个文件进行加密和解密,没有出现任何错
误。我可以很自信地宣布,在我测试过的文件内容、长度以及密码的范围之内,
这个程序是正确的。
从这个故事当中我们可以得到如下经验。
正确设计的随机数据生成器可以产生让你意想不到的、不寻常的测试数据组
合
比起手工构造测试数据,随机数据生成器可以更加彻底地对程序进行测试。
你可以在很长时间中进一步精炼随机生成的测试用例,以强化所生成的输入
的真实性。这样就可以集中测试用户最可能使用到的范围,从而最大限度地
增强程序在这一输入范围内的可靠性。
在测试期间,模块化设计就显现出它的优势来了。我可以将加密和解密部分
的代码提取出来,独立于用户界面代码进行测试这使得编写测试驱动程序
的工作变得非常简单。
甚至在你修改了被测试的代码之后,你还可以重用测试驱动程序。当时,我
修改完最早的两个错误之后,就可以立刻重新对程序进行测试了。
代大全(第2版)

<==========================562end ==============================>
<==========================563start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo.com.com!仅供试看
526
第22章开发者测试
Coverage Monitors
覆盖率监视器
cc2e.com/2282 karl wiegers,22karlwiegers的报告称,那些没有测量代码覆盖率的测试,通常只测试到了大
约50%到60%的代码( Wiegers2002)覆盖率监视器就是用来跟踪哪些代码已经
测试过了,而哪些代码还没有。它在系统化测试的时候尤其有用,因为它会告诉
你某一组测试用例是否能够彻底地对代码进行测试。如果你在运行了一组完整测
HARD DATA试用例之后,覆盖率监视器还显示某些代码没有执行过,你就知道还需要进行更
多的测试。
Data Recorder/Logging
数据记录器/日志记录器
有些工具可以监视你的程序,并在发生错误的时候为你收集程序状态信息,
这就像飞机上用来分析空难原因的黑匣子一样。详细完整的日志记录可以为诊断
错误提供帮助,还可以在产品发布之后为客户提供有效的服务。
你可以编写一个自己的数据记录工具把关键事件记录到某个文件里,其中
要记录的是发生错误前的系统状态,以及发生错误的确切条件等详细信息。你可
以把这一功能编译进开发版本中,而在发布版本中去掉。另一个方案是,如果你
能使日志实现自动裁剪记录长度,并妥善考虑记录存放的位置以及错误信息的内
容,那么将此项功能纳入发布版也未偿不可。
Symbolic Debuggers
符号调试器
交叉参考调试
符号调试器可以作为走查和详查代码的技术辅助工具调试器可以一行行地对
技术环境的成熟代码进行单步调试,跟踪变量的值,并能完全按照计算机的方式来演绎代码的执行
而不断变化,有情况。在调试器中对某段代码进行单步调试,并观察其运行情况是很有价值的。
关这个现象的更
多信息,请参见
从很多方面来看,在调试器当中走查代码,就像是其他许多程序员同你一起
4.3节“你在技对代码进行逐行检查一样。调试器和你的同事们一样,不会有与你一模一样的盲
术浪中的位
置
点。使用调试器还有一个额外的好处,那就是它不需要像团队复查那样集中大量
人力。在各种输入数据组合下观察代码的执行情况,就可以知道你实现的是否正
是自己想要的东西。
优秀的调试器甚至是了解你所用语言的一个很好的工具,因为你可以通过它
准确地看到代码是如何被执行的;你可以在高级语言代码和汇编代码这两个视图
之间进行切换,据此了解高级语言是如何翻译成汇编的;你还可以监视寄存器和
堆栈的情况,看看参数是如何传递的;也可以查看编译器优化之后的代码,分析
代码大全(第2版)

<==========================563end ==============================>
<==========================564start==============================>

该书下载自-书部落-分享计算机经典巨著-- ! --www.shubulo.com^^.com!仅供试看
22.5测试支持工具
527
编译器实施进行了哪儿种优化。上述的优点都与调试器的基本作用分析已经
发现的错误没有多大关系,然而这些对调试器的创造性运用所带来的好处,远远
超越了其本来的用途。
System Perturbers
系统干扰器
cc2e.com/2289另一-类测试支持工具是用来对系统进行干扰的许多人都遇到过这样的事情:
对同样的数据测试了100遍,其中99次都成功了,但就是有1次失败了。这种问
题几乎总是源于忘记对某处变量进行初始化了,这种问题通常很难重现,因为100
次中的99次,这个没有初始化的变量的值都正好是0
这类测试支持工具有如下多种功能。
内存填充你可能想要确认程序中的所有变量都已经初始化了。有些工具可
以在你运行程序之前将任意数值填充到内存当中,这样没有初始化的变量就
不会正好是0。在某些情况下,内存也可以设置成某指定数值。例如在x86
处理器中,数值xCC是断点中断(int03h)的机器码。如果你用0xCC来
填充内存,那么当代码访问到本不该访问的内存区域时,你就能够在调试器
上捕捉断点从而发现这个错误。
内存抖动在多任务系统甲面,有些工具可以在你的程序运行的时候重新组
织内存,使用这种工具可以让你确信所有代码都只依赖存放在相对位置的数
据,而非某些绝对位置。
选择性内存失败一个内存驱动程序可以模拟内存容量不足的情况程序在
这种情况下有可能遇到各种内存问题,包括内存耗尽,内存请求失败,若干
次请求成功之后遭遇失败,或是若干次请求失败后才能成功等。在测试那些
动态分配内存的复杂程序的时候,这种工具就特别有用。
内存访问检查(边界检查)边界检查监视着各种指针操作,确保所有指针
都工作正常。这种工具在寻找未初始化的或者悬空的指针方面非常有用。
Error Databases
错误数据库
cc2e.com/2296
存放以往错误的数据库是另一种强大的测试工具这样一个数据库既是管理
工具,又是技术工具。它让你能检查重复出现的错误,即时获取已纠正错误和已
发现错误之比率,以及跟踪错误的处理状态和严重级别。第22章第7节“保留测
试记录”详细说明了错误数据库里面应该保存什么样的信息。
代大全(第2版)

<==========================564end ==============================>
<==========================565start==============================>

该书下载自-书部落-分享计算机经典巨著--www.sulo.com!l仅供试看
528
第22章开发者测试
Improving Your Testing
改善测试过程
改善测试过程的步骤同改善任何其他过程的步骤类似你必须清楚地知道这
一过程是干什么的,这样你才能对其略做调整,然后看看这样改变会产生什么效
果。当你观察到某种改变产生了积极的效果时你就可以继续下去,使其锦上添
花。下面的小节描述了在测试中应该如何去做。
Planning to Test
有计划的测试
交叉参考有计
划的测试包括了有效测试的关键之一,就是在待测试项目开始之初就拟定测试计划。就重要
编写正式的测试
性而言,测试应当与设计和编码平起平坐,这就要求项目为测试分配时间,重视
档的更多信息,请测试并保障这一过程的质量。测试计划也是使测试过程可重复的一个要素,如果
参考32章末尾部你无法重复它,那么就不可能改善它。
分的“更多资源”。
Retesting(Regression Testing)
重新测试(回归测试
假设你已经对某产品进行了彻底的检查,而且没有发现任何错误。在此之
后该产品的某个部分被修改,你想确定修改后的产品仍然能通过此前的所有测
试也就是说,这次的修改没有给产品引入任何新的错误。为确保软件没有倒
退,或者没有“回归”而设计的测试,被称为“回归测试”。
除非在每次修改后重新对程序进行系统化的测试,否则要开发出一个高质量
的软件产品几乎是痴人说梦。而如果每次修改后你都使用了不同的测试用例,那
么你将无法保证本次修改没有给程序引入任何新的错误。因此回归测试每次都应
该使用相同的测试用例。有时候,随着产品的不断成熟,你会添加新的测试用例,
但仍然应当保留旧的测试用例。
Automated Testing
自动化测试
管理回归测试唯可行的方法,就是将其变成一个自动化的过程。在一遍遍
执行相同的测试并观察到和同的测试结果后,人们常常会开始变得麻木,对所出
KEY POINT
现的错误视而不见。这直接违背了回归测试的目的。测试大师Boriz Beizer的报告
表明,手动测试发生错误的几率,与被测代码中错误存在的几率有得一拼。他估
计,手动测试的时候,只有一半的测试被正确地执行(Johnson1994)
自动化测试的好处如下。
自动化测试发生错误的儿率比手动测试要小。
一旦你把一个测试自动化了,那么你只需稍下功夫,就很容易在项目的剩余
部分继续实施自动化。
代码大全(第2版)

<==========================565end ==============================>
<==========================566start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo..com!仅供试看
22.7保留测试记录
529
如果测试是自动进行的,那么就可以频繁地运行,看看新 check in的代码是
否破坏了原有的程序。测试自动化是各种测试实践的基础部分之一,这些测
试实践包括 daily build、冒烟测试以及极限编程,等等。
自动化测试可以提高问题刚产生就被发现的可能性,这可能显著减少分析和
修正错误所需要的工作量。
由于自动化测试能够提升快速发现修改所引入错误的几率,因此它为大规模
代码修改提供了一张安全网。
交叉参考想要自动化测试在那些新的、不稳定的技术环境当中特别有价值,因为它提早稀
更详细地了解技
释了环境改变对系统的影响,而非事后补救。
术成熟度与开发
实践之间的关
进行自动化测试所需要的工具应该提供脚手架、生成输入、捕获输出,以及
系,请参见4.3比较实际输出与预期输出等功能。这些具在前面的小节当中已经提到过了,它
节“你在技术浪
潮中的位置”。们在自动化测试中会发挥部分甚至全部的功能。
22.7
Keeping Test Records
保留测试记录
除了使测试过程有重复之外,你还需要对整个项月进行量化评估,以确定所
做的修改是使程序质量有所提高还是降低。为了评估整个项目,你需要收集下列
KEY POINT几种数据:
缺陷的管理方面描述(报告日期、报告人、描述或标题、生成编号以及修正
错误的日期等)
■问题的完整描述
复现错误所需要的步骤
■绕过该问题的建议
相关的缺陷
问题的严重程度例如致命的、严重的或者表面的
■缺陷根源:需求、设计、编码还是测试
对编码缺陷的分类:of-by-one错误、错误赋值、错误数组下标,以及子程
序调用错误等
修正错误所改变的类和子程序
缺陷所影响的代码行数
■查找该错误所花的小时数
修正错误所花费的小时数
一旦你收集到了这些数据,你就可以对其中部分细加思考,从而判断项目是
向着更健康,还是更糟糕的趋势发展。
代大全(第2版)

<==========================566end ==============================>
<==========================567start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. !--www.shubuld.com!仅供试看^
530
第22章升发者测试
每一个类中的缺陷数目,从最糟糕的类到最好的类依次列出,如果类的规模
不同,可能需要对这一数字进行归一化处理。
按照同样的方式列出每个子程序中的缺陷数,也可能需要根据程序大小归
一化处理。
发现一个错误平均所需要花费的测试时间。
每个测试用例所发现缺陷的平均数。
修正一个缺陷花费的平均编程时间。
全部测试用例的代码覆盖率。
在各个严重级别中未处理缺陷的数量
Personal Test Records
个人测试记录
除了保留项目级的测试记录之外,你或许还会发现坚持编写个人的测试记录
也很有用。这份列表除了记录你最常犯的错误之外,还可以记录编写代码、测试
代码以及修正代码所花费的时间。
Additional Resources
更多资源
cc2.c/20联邦诚信法案迫使我向大家透露,有几本书比本章更深入地讨论了测试。这
些书专注于测试讨论系统,以及黑盒测试这些都是本章所没有提到的。这些书
也与在开发者有关的主题上走得更远,讨论了诸如因果图等形式化测试方法,以
及建立独立测试组织的细节。
Testing
测试
Kaner, Cem, Jack Falk, and Hung Q. Nguyen. KTesting Computer Software), 2d
ed.(《计算机软件测试》) New York,ny: John Wiley&ons,1999可能是现今
软件测试方面最好的书了。其内容最适用于指导测试那些用户基数很大的应用程
序,例如高流量的网站以及各种流行软件,在其他方面也很有用。
Kaner, Cem, James Bach, and Bret Pettichord. Lessons Learned in Software
Testing《软件测试:经验与教训》) New York,n: John Wiley&Sons,2002这
本书是对《Testing Computer Software,2d,e》的一个很好的补充。该书共有11
章,列举了作者们收获的250条经验教训。
Tannre, Louise. Introducing Software Testing》(软件测试导引》) Boston,A:
Addison-Wesley-,2002这是一本通俗易懂的测试书籍,面向的是那些需要理解测
试的开发人员。不要被这本书的标题所误导,这本书深入讨论了许多测试细节,
这些内容甚至对有经验的测试人员都非常有用。
代码大全(第2版)

<==========================567end ==============================>
<==========================568start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.c.com仅供试看
更多资源
531
Whittaker, James.《 How to Break Software Practical Guide to Testing》《怎
样摧毁软件:测试实用指南》). Boston,m: Addison-Wesley-,2002这本书列举了
23种测试人员可以尝试让软件崩溃的攻击方法,并且通过流行的软件包为每个攻
击方法给出了例子。你可以将这本书作为测试的第一手资料,或者将它作为其他
测试书籍的一个补充,因为该书中描述的方法太有特色了。
Whittaker, James A. "What Is Software Testing And Why Is It So Hard?"
(“什么是软件测试?为什么它使人头痛?”)《IEEESoftwareX,January20t《》,january2000
pp.70-79.这篇文章对软件测试进行了精彩的介绍,并解释了有效测试所面临的
一些挑战。
Myers, Glenford.《 The Art of Software Testing》(《软件测试的艺术》)ew
York,ny: John Wiley,1979.这是软件测试方面的一本经典图书,到今天它仍然在出
版(虽然非常贵)。这本书内容丰富:自评估测试;程序测试的心理学和经济学
程序的评审、走查以及复查;测试用例设计:类的测试;高阶测试;调试:测试
工具和其他技术。它很薄(177页),也很易读,开篇的提问让你从测试人员的角
度去思考哪几种情况会导致一段代码出错,该书随后进行了演示。
Test Scaffolding
测试脚手架
Bentley, Jon. "A Small Matter of Programming" in <Programming Pearls) 2d
ed(《编程珠玑第二版》) Boston,: Addison--sley,2000这篇短评包含了一
些很好的测试脚手架例子。
Mackinnon, Tim, Steve Freeman, and Philip Craig. "Endo-Testing: Unit Testing
with Mock Objects, eXtreme Programming and Flexible Processes Software
Engineering-020 Conference,000这是最早讨论用假对象辅助开发人员测试
的论文。
Thomas, Dave and Andy Hunt. "Mock Objects," KIEEE Sofiware), May/June
2002.这篇文章很容易读懂,它介绍了如何用假对象帮助开发人员进行测试。
cc2e.com/2217
www.junit.org,JUnit这个网站为开发人员使用Unit提供了支持
cppunitsourceforge.net和 nunit.sourceforge.net也有类似的资源。
Test First Development
测试先行开发
Beck,kent.test- -Driven Development: By Example》(《测试驱动开发:示例
导引》) Boston,m Aa: Addison-Wesley-,2003.beck这里描述了测试驱动开发的细
节,这种开发方法的特征是首先写测试用例,然后再写代码来满足这些测试用例
尽管Beck不时会对自己的方法表现出布道者的狂热,但他的建议还是很合理的。
代码大全(第2版)

<==========================568end ==============================>
<==========================569start==============================>

该书下载自书部落-分享计算机经典巨著!--www. !--www.shul ^.com!仅供试看
532
第22章开发者测试
这本书较薄,却击中要点,此外还有大量的例子,都是可以运行的真实代码。
Relevant Standards
相关标准
IEEE Std 1008-1987 (R1993), Standard for Software Unit Testing
IEEE Std 8291998, Standard for Software Test Documentation
IEEE Std 730-2002, Standard for Software Quality Assurance Plans
CHECKLIST: Test Cases
cc2e.com/2210
核对表:测试用例
口类和子程序所对应的每一项需求是否都有相应的测试用例?
口类和子程序所对应的每一个设计元素是否都有相应的测试用例?
口每行代码是否被至少一个测试用例所测试?你是否通过计算测试到每行
代码所需的最少测试用例数量来验证这一点?
口所有已定义已使用路径是否至少被一个测试用例测试过了?
口是否测试过那些不太可能正确的数据流模式,例如已定义定义、已定
义-已退出以及已定义已销毁?
口是否有一张常见错误列表,并据此编写测试用例以检测过去经常出现的
错误?
口所有的简单边界是否都已经测试过了:最大、最小以及off-by-one?
口是否测试了组合边界即,多个输入数据的组合导致输出数据过小或
者过大?
口测试用例是否检查了数据类型错误,例如一个薪水记账程序里的雇员数
量是负数?
口是否测试了那些中规中矩的典型数值?
口是否测试了最小正常形式?
口是否测试了最大正常形式?
口是否检查了与旧数据的兼容性?以及是否对旧硬件、旧操作系统版本以
及其他旧版本软件的接口进行了测试?
口测试用例是否容易手I检验?
代码大全(第2版)

<==========================569end ==============================>
<==========================570start==============================>

该书下载自-书部落-分享计算机经典巨著!-- !-www.shubu.com!仅供试看^
要点
533
Key Points
要点
开发人员测试是完整测试策略的一个关键部分独立测试也很重要,但这
主题超出了本书的范围。
同编码之后编写测试用例相比较,编码开始之前编写测试用例,工作量和花
费的时间差不多,但是后者可以缩短缺陷侦测调试修正这一周期。
即使考虑到了各种可用的测试手段,测试仍然只是良好软件质量计划的一部
分。高质量的开发方法至少和测试一样重要,这包括尽可能减少需求和设计
阶段的缺陷。在检测错误方面,协同开发的成效至少与测试相当。这些方法
所检测错误的类型也各不相同。
你可以根据各种不同的思路来产生很多测试用例,这些思路包括基础测试、
数据流分析、边界分析、错误数据类型以及正确数据类型等。你还可以通过
猜测错误的方式得到更多的测试用例。
错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码,重新
设计和编写它们。
测试数据本身出错的密度往往比被测代码还要高查找这种错误完全是浪费
时间,又不能对代码有所改善,因此测试数据里面的错误更加让人烦恼。要
像写代码一样小心地开发测试用例,这样才能避免产生这种问题。
自动化测试总体来说是很有用的,也是进行回归测试的基础。
从长远来看,改善测试过程的最好办法就是将其规范化,并对其进行评估,
然后用从评估中获得的经验教训来改善这个过程。
代码大全(第2版)

<==========================570end ==============================>
<==========================571start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! --www.shubulo.c.com!仅供试看

<==========================571end ==============================>
<==========================572start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. !--www.shubule.com!仅供试看
Debugging
第23章
调试
cc2e.com/2361/231内容
23.1调试概述:第535页
23.2寻找缺陷:第540页
23.3修正缺陷:第550页
23.4调试中的心理因素:第554页
23.5调试工具一明显的和不那么明显的:第556页
相关章节
软件质量概述:第20章
■开发者测试:第22章
■重构:第24章
调试代码的难度
是首次编写这些调试是确定错误根本原因并纠正此错误的过程。同测试不同,后者是检测错
代码的两倍。因误的过程。在一些项目中,调试可能占到整个开发周期的50%。对很多程序员来
此,如果你在编
写代码的时候就说,调试是程序设计中最为困难的部分。
已经发挥了全部
调试原本不应成为最难解决的问题。如果严格遵照本书所提供的建议,你几
从概念上讲,你乎没有什么错误需要调试。你所面对的绝大多数问题将都是一些微小的疏忽和拼
将无法凭借自己写错误,这些很容易通过阅读源代码列表或在调试器中单步跟踪来发现。针对剩
的智慧去调试这下的一些难于解决的bug,本章将为你介绍一些调试手段,这些手段比通常的一
Brian Kermighan方法为你节省更多精力。
23.调试概述
Overview of Debugging Issues
己故海军少将 Grace Hopper, COBOL的发明者之一,坚信“bug”一词可以
追溯到第一台大型数字计算机,即 Mark(IEEE992)。程序员们在一次解决电
路故障的时候看到了一只大飞蛾,并发现这只飞蛾飞到了计算机里面。从此计算
机故障就被归咎于“bug/虫子”。在软件领域之外,bug”一词最早源自托马斯·爱
迪生。他早在1878年就用这个词表达过现在我们常见的含义(Tenner1997)
ug”一词是一个生动的词汇,它勾勒出如下的画面:
代码大全(第2版)

<==========================572end ==============================>
<==========================573start==============================>

该书下载自-书部落-分享计算机经典巨著!--www ! --www.shubu.com!仅供试看
536
第23章调试
然而,看看软件缺陷的真实面目。虫子们(bugs)并不是那些在你忘了喷洒杀
虫剂时溜进代码的有机生物。它们是软件错误errors)软件中的bug意味着程序
员出了错。错误的结果并不像上面的图画那样可爱,而更像下面这张便笺纸:
/From: Your Boss
you
Re: your Job
?
you're
Firedl
在本书的上下文中,为保持术语的精确性,代码中的错误都称为errors”(错
误)、“defects(陷)或“faults”(失误)。
Role of Debugging in Software Quality
调试在软件质量中所扮演的角色
同测试一样,调试本身并不是改进代码质量的方法,而是诊断代码缺陷的一
种方法。软件的质量必须从开始逐步建立开发高质量软件产品的最佳途径是精
确描述需求,完善设计,并使用高质量的代码编写规范。调试只是迫不得已时采
用的手段。
Variations in Debugging Performance
调试效率的巨大差异
为什么还要讨论调试?难道还有人不知道怎么调试么?
的确如此,并不是每个人都知道怎么调试一项研究表明,针对同样一组缺
KEY Po陷,经验丰富的程序员找出缺陷所用的时间大约只是缺乏经验的程序员们的1/20
并且一些程序员能够找出更多的缺陷,且能更为准确地对这些缺陷进行修改。下
面是一项经典调查的结果:展示了一组具备四年以上工作经验的程序员,调试一
个带有12个缺陷的程序时的效率。
代码大全(第2版)

<==========================573end ==============================>
<==========================574start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. ! -www.shubul.com!仅供试看
23.1调试概述
537
最快的三位
最慢的三位
程序员
程序员
平均调试时间/min
5.0
14.1
未被发现缺陷的平均数量
0.7
1.7
修改缺陷时引入新缺陷的平均数量
3.0
7.7
数据来源:“Some Psychological Evidence on How People Debug Computer
Programs(关于人们如何调试计算机程序的一些心理上的证据)(Gould1975)
对于那三位精于调试的程序员来说,他们发现缺陷的速度是那些在这方面表
现拙劣的程序员们的三倍,而所引入的缺陷仅仅是后者的25最优秀的程序员在
HARD DATA发现所有缺陷并进行改正的同时没有引入任何新的缺陷。而最差的程序员漏掉了
12个缺陷中的4个,并且在改正所发现的8个缺陷的同时引入了11个新的缺陷。
但这项研究并没有实际反映出所有的情况。在第一轮调试之后,最快的三个
程序员仍然在代码中留下了3.7个缺陷,最慢的三个程序员还有94个然后两个
组没有继续调试。我很想知道,假设在后续调试循环中双方维持各自发现缺陷和
错误修正的概率不变,会出现什么情况。我的说法未必合乎统计结果,但这些还
是很有趣。在维持各自发现缺陷和错误修正的概率不变的情况下,到每个组剩下
的缺陷不到一半,最快的一组需要三轮循环,而最慢的一组则需要14轮。不要忘
了,最慢一组每一轮的调试时间是最快一组的三倍。因此根据我不甚科学的推断
如果要彻底调试程序,最慢的一组所花费的时间将是最快一组的13倍。类似的巨
大差异已经被其他一些研究所证实(Gilb1977, Curtis1981)
交叉参考想要
知道关于软件质
除了让我们深入了解调试效率的巨大差异之外这项研究还印证了软件质量
量和成本之间关的普遍性原则:提高软件质量能够减少开发成本。最好的程序员能够找出最多的
系的详细信息,
请阅读第20.5节错误,最快的找出错误,并且往往能够正确改正错误。不需要硬着头皮在质量、
“软件质置的普成本和开发周期之间做出选择鱼和熊掌尽可能兼得。
遍原理”
Defects as Opportunities
让你有所收获的缺陷
代码里面有缺陷意味着什么?如果你希望程序里面一个缺陷(defect)也没有,
那意味着你还没有完全理解程序的功能。这个观点可能让人有些费解。毕竟,如果
这个程序是你开发的,它就应当按照你的意愿来运行。如果你并不知道你到底想让
计算机做些什么,那么你的做法同胡乱尝试不同的东西直到结果看起来正确没什么
代大(第2版)

<==========================574end ==============================>
<==========================575start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.cor.com!仅供试看
538
第23章调试
差别—也就是通过反复尝试来完成编程。如果按照这样的方式,代码就必然会
有缺陷。你并不需要学会如何修正缺陷。你应该学会如何在一开始就避免缺陷的
产生。
绝大多数的人或多或少都会犯错,然而,如果只是适度的疏忽,你还是可能
会成为一位优秀的程序员。这时,程序中的错误为你提供了学习很多东西的绝好
机会。你可以从错误中得到以下好处。
理解你正在编写的程序你所面对的程序一定有一些东西需要你去了解。因
为如果你确实已经透彻地理解了它,这个程序就不应该还有缺陷,你应该早就纠
正了这些缺陷。
深入阅读一些
明确你犯了哪种类型的错误如果是你写的程序,缺陷就是你引进的。并不
方法可以帮助你是每天都有聚光灯把你的弱点照得一清二楚。但如果有这么一天,这就是个机会,
下哪种类型的错因此你要利用它。一旦你发现了错误,请问问自己为什么会犯这样的错误。你如
误。详细资料请阅何才能更快地发现这个错误?你如何才能预防此类错误的发生?代码里面还有类
读 Discipline
for Software似的错误么?你能在这些错误造成麻烦之前改正它们么?
Engineering
(《软件工程规
从代码阅读者的角度分析代码质量你必须阅读自己的代码,以便发现其中
范))(Humphrey的缺陷。这就使你有了带着挑剔的眼光审视自己代码的质量的机会。代码易读么?
1995)
它怎样才能更好?用你的结论重构你现在的代码,并让自己下次编写的代码更好。
审视自己解决问题的方法你自己解决调试问题时用到的方法使你感到自信
吗?你的方法管用么?你能够很快地发现缺陷么?或者正是你的方法导致调试工
作成效很差?调试过程中你有痛苦和挫败感么?你是在胡乱猜测么?你的调试方
法需要改进么?想想那么多项目已经在调试上耗费了大量时间,如果你注意审视
自己的调试方法,你或许就不会耗费那么多时间花点时间来分析并改进你的调
试方法,可能就是减少程序开发时间的最有效方法。
审视自己修正缺陷的方法除了审视自己如何发现缺陷,你还需要关注自己
如何修正缺陷。你是否用了goto这样的绷带或对一些处理特殊情况进行简单包扎
(这或许是最容易的修改方式),从而仅仅治标却不治本呢?还是从系统角度进
行修正,通过精确的分析对问题的根本原因对症下药呢?
想想所有这些,调试其实是一片极其富饶的土地,它孕育着你进步的种子。
这片土地也是所有软件构建之路所交织的地方可靠性、设计、软件质量,凡是
你能想到的无所不包。编写优秀代码所得到的回报,如果你能精于此道,你甚至
无须频繁调试。
代码大全(第2版)

<==========================575end ==============================>
<==========================576start==============================>

该书下载自-书部落分享计算机经典巨著!- ! --www.shubulo..com!仅供试看^
23.1调试概述
539
An Ineffective Approach
一种效率低下的调试方法
不幸的是,学院和大学的编程课程中几乎没有关于调试的内容。如果你是在
学校里学习编程的,那么你可能已经听过关于调试的几节课。尽管我受到了极好
,。
的计算机科学教育,所获得的调试建议也仅仅是“在程序中加上 print语句来找出
缺陷”。这并不够。如果其他程序员在这方面所获得的教育经历同我相似,那么
有很多程序员都将不得不彻底改变自己对调试概念的理解。这是多么大的浪费
The Devil's Guide to Debugging
调试之魔鬼指南
程序员们往往不在诗人但丁关于地狱的描述中,最深的一层留给了撒旦自己。如今,《旧约》
愿意使用现成的已经同意让那些不学习如何有效调试的程序员来共享这层最深的地狱了。他让程
的推理。他们往往序员们使用这些传统的调试方法,让他们受尽折磨。
喜欢进行琐碎和
无理性的修改,而凭猜测找出缺陷要找出缺陷请把print语句随机地散布在程序中。检查这
且他们通常不些语句的输出来确定缺陷到底在哪里。如果通过 print语句还是不能找到缺陷,那
意推翻以前不正
确的修改。
么就在程序中修改点什么,直到有些东西好像能干活了。不要备份程序的原始版
Iris Vessey本,也不要记录你做了哪些改变。只有在你无法确定自己的程序正在干什么的时
候,编程才比较刺激。请提早准备一些可乐和糖果,因为你会在显示器前度过一
个漫漫长夜。
不要把时间浪费在理解问题上出现的问题不值一提,要解决它们并不需要
彻底弄懂程序。只要找出问题就行了。
用最唾手可得的方式修正错误与其把时间浪费在一个庞大、雄心万丈的,
甚至可能影响整个程序的修正工作上,还不如直接去解决你所面对的那个特殊问
题。下面是一个完美的例子:
= Compute()
if(y=17)
x=25.15--当y=17的时候, Compute()没有起到作用,因此需要修改
如果在这里写一段特例处理代码就可以解决问题,谁会去对 Compute)寻根
究底,弄清与值17有关的棘手问题究竟是什么。
Debugging by Superstition
迷信式调试
撒旦已慷慨地将地狱的某个部分租给那些在调试时怨大尤人的程序员了。每
个团队里都也许有这样一个程序员,他总会遇到无穷的问题:不听话的机器,奇
怪的编译器错误,月圆时才会出现的编程语言的隐藏缺陷,失效的数据,忘记做
的重要改动,一个不能正常保存程序的疯狂的编辑器你怎么描述这种行为好
代大全(第2版)

<==========================576end ==============================>
<==========================577start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.com!^.com!仅供试看
540
第23章调试
呢。这就是“迷信式编程(programming by superstition)”。
要知道,如果你写的程序出了问题,那就是你的原因,不是计算机的,也不
是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的,是你写的,
所以,请对它负责。
即使某个错误初看似乎不能归咎于你,但出于你自身的利益,最好还是假设
它的产生同你有关。这样的假设将有助于你的调试。你集中注意去寻找,要在程
KY POINT
序里发现问题就已经够困难了,更何况在你认为自己的代码完美无缺的时候。如
果你称某个错误源自别人的代码,其他的程序员将会相信你已经仔细研究过这
个问题。因此,如果你从一开始就假设错误是你引发的,就能避免陷入这样的尴
尬境地:在公众面前先指责别人犯了错,最终却发现错误其实由你而生。
23.2
Finding a Defect
寻找缺陷
调试包括了寻找缺陷和修正缺陷。寻找缺陷——并且理解缺陷通常占到
了整个调试工作的90%。
幸运的是,你并不需要随机猜测,也不需要求助于撒旦。相对于借助蝶螈的
眼睛和青蛙耳朵上的尘土完成调试,思考问题本身将会更加有效,也更为有趣。
假设你要调查一桩谋杀悬案,下面两种做法哪一种会更为有趣?是在整个
城镇里挨家挨户确认每个人是否有10月17日晚不在现场的证据,还是通过蛛
丝马迹推断凶手的身份?绝大多数人都会选择后者,绝大多数的程序员也会发
现开动脑筋进行调试会给自己带来更多的满足感。更何况,高效的程序员只需
花费低效程序员的1/20的时间,他们并不是随机地猜测如何修正程序他们使
用科学的方法即所有科学探索所必需的发现和实证的过程。
The Scientific Method of Debugging
科学的调试方法
在运用经典的科学调试方法时,你会经历如下步骤
1.通过可重复的试验收集数据;
2.根据相关数据的统计构造个假说;
3.设计一个实验来证明或反证这个假说
代码大全(第2版)

<==========================577end ==============================>
<==========================578start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubu.com!仅供试看
23.2寻找缺陷
541
4.证明或反证假说
5.根据需要重复进行上面的步骤。
就科学调试方法而言,条条道路通罗马。下面给出了一种寻找缺陷的有效方
法:
KEY PONT
1.将错误状态稳定下来;
2.确定错误的来源(即那个失误“ fault”)
a.收集产生缺陷的相关数据,
b.分析所收集的数据,并构造对缺陷的假设,
C.确定怎样去证实或证伪这个假设,可以对程序进行测试或是通过检查
代码,
d.按照2(c)确定的方法对假设做出最终结论
3.修补缺陷:
4.对所修补的地方进行测试;
5.查找是否还有类似的错误。
第一个步骤同科学方法第一步类似,它们都依赖于可重复性。如果能把症状
稳定下来,确诊就会容易一些,也就是说让缺陷可以稳定地重现。第二个步骤借
用了科学方法的第二个步骤。收集同缺陷相关的测试数据,分析已经得到的这些
数据,然后对错误的原因提出假设。你可以设计一个测试用例,或者对代码进行
仔细检查,以便评价这个假设,然后,根据情况,要么你可以宣布大功告成(前
提是成功证明了你的假设),要么就是再做一次尝试。一旦已经证明了你的假设,
你就可以修正这个缺陷,对修正后的代码进行测试,然后搜索你的代码中还有没
有类似错误。
现在让我们结合一个例子来分析这些步骤。假设手头有一个时不时会出错的
员工数据库程序。该程序原本应该按照字母顺序打印份员工名称和交税金额列
表。以下内容是输出的一部分:
Formatting, Fred Freeform $5, 877
Global,Gary
$1,666
Modul
Mildred
10,788
Many-Loop, Mavis
8,889
statement, Sue Switch
4,000
Whileloop, Wendy
7,860
问题是Many-loop, Mavis以及 Modula, Mildred排列顺序颠倒了。
代大全(第2版)

<==========================578end ==============================>
<==========================579start==============================>

该书下载自-书部落-分享计算机经典巨著--www. ! --www.shubulo.com!^^.com!仅供试看
542
第23章调试
Stabilize the Error
把错误的发生稳定下来
如果错误只是时不时地出现,那么几乎没有可能找出它发生的原因。在调试
工作中,让某个不定期出现的错误有规律的重现几乎是最具挑战性的任务之一。
交叉参考如果如果一个错误无法重现,这通常会是一个初始化错误,或者是一个同时间有
知道如何安全关的问题,或者是悬空指针(dangling-pointer-)问题。如果某个求和结果时对时错,
地使用指针,请
参阅第13.2节很有可能是参与计算的某个变量未能正确地初始化可能正好在大多数情况它
“指针”
是从0开始。如果这个问题诡异且变幻莫测并且你又在使用指针,那么几乎可
以肯定是你的代码中有未初始化的指针,或者用了所指向的内存区域已经被释放
的指针。
同建立能引发错误的测试用例相比,将一个错误的发生稳定下来需要更多的
技巧。这包括生成能产生错误的最小化测试用例。简化测试用例的目标是使它尽
可能简单,其任何方面的修改都会改变相关错误的行为。这样一来,你就可以在
可控的条件,改变测试用例并仔细观察系统的变化,你就可能确定问题产生的根
源。如果你在某个拥有独立测试团队的组织中工作,简化测试用例有时会是测试
组的工作。但绝大部分时候,你需要自己来完成它。
在简化测试用例时,你需要再度祭起科学方法。假设在有10个因素组合的情
况下产生了错误。你可以做一个假设,假定某些因素同错误的发生有关。改变你
假设无关的那些因素,然后重新运行测试用例。如果错误仍然出现,你就可以在
测试用例中去掉这些因素,并由此简化了测试然后,你可以尝试进一步的简化
测试用例。如果错误不出现了,那么就是否证了你对特定因素做出的假设,山此
你也对工作有了更深的认识。有可能一些稍微不同的改动还是会引发错误,但是
你至少弄明白了一点:某种特定的改动不会出错。
在上面员工纳税的例子中,当程序最初运行时,Many-loop, Mavis被列在
Modula, Mildred之后。而当程序第二次运行时,结果又对了
Formatting, Fred Freeform $5, 877
Global, Gary
1666
Many-Loop, Mavis
s8889
Modula, Mildred
S10,788
statement, Sue Switch
4,000
Whileloop, Wendy
7,860
在输入 Fruit--loop, Frita后,显示的位置又出现了错误,这时你想起了在
输入 Modula, Mildred之后也出现了同样的错误。奇怪的是这两个测试用例都是
被单独输入的。通常,员工信息都是一组一组地输入的。
代码大全(第2版)

<==========================579end ==============================>
<==========================580start==============================>

该书下载自-书部落-分享计算机经典巨著--www. --www.shubulo.com! ^ ^.com!仅供试看^
23.2寻找缺陷
543
你可以假设:问题输入单个新员工的信息有关。如果这个假设成立,那么
再次运行程序, Fruit--loop, Frita将会在正确的位置上出现。下面就是第二次
运行的结果:
Formatting, Fred Freeform $5, 877
Fruit-Loop, Frita
5,771
Global, Gary
1,666
Many-Loop, Mavis
8,889
Modula, Mildre
10.788
Statement, Sue Switch
4,000
Whileloop, Wendy
7,860
这一次的运行结果成功地支持了假设。为了确认有关假设,还需要加入些
新的员工信息,每次只加一条,看看次序是否出现了错误,在第二次运行时次序
是否有了改变。
Locate the Source of the Error
确定错误原因
确定错误原因同样需要运用科学方法。你或许开始会怀疑缺陷是某个特定
问题的结果,例如某个off-by-one错误。这时你可以修改怀疑是导致问题的参
数一—让参数取值位于边界之外,恰好是边界值,或位于边界值以内以验证
你的假设是否正确。
在上面的例子中,问题的原因可能是某个 off-by-one缺陷即在添加条员工
信息的时候就会出问题,而添加两条或两条以上则不会出现。然而,检查代码,你
并没有发现某个明显的off -by-one-缺陷。根据B方案,需要运行一个含有单个新员
工信息的测试用例。于是将 Hardcase,henr作为一条单独的员工信息添加进去,
并假设这条记录将会不按次序排列。下面是测试用例的结果:
Formatting, Fred Freeform
5.877
Fruit-Loop, Frita
5.71
Global, Gary
1.666
Hardcase, Henry
Many-Loop, Mavis
493
$8889
Modula, Mildred.
10788
Statement, Sue Switch
4,000
Whileloop, Wendy
7.860
Hardcase, Henry这行出现在了它应该出现的位置,这表明你最初的假设是
错误的。问题并不是简单的由于每次添加了一条员工信息而产生的。它要么是一
个更为复杂的问题,要么就是同之前的假设完全不同。
检查测试运行的输出,你注意到 Fruit-Loop- Frita和many-loop, Mavis
有连字号,而其他的名字都没有。但是Fruit--lop在第一次被输入时就乱序了,
而Many-loop却没有,对吧?尽管你没有打印出最初的条目,但你应当还记得,
在最初的错误中, Modula, Mildred似乎就乱序了,而它紧接着Many-loop或
许是Many-oop乱序了,而 Modula是正确的
代大全(第2)

<==========================580end ==============================>
<==========================581start==============================>

该书下载自-书部落-分享计算机经典巨著!-ww. ! --www.shubu.com!仅供试看^
544
第23章调试
你再次假设:问题是连字号引发的,不是由于每次输入了单个条目。
但是如何解释问题只在第一次输入单个员信息的时候出现呢?你看看代
码,发现里面有两个不同的排序循环。一个用在员工信息输入的时候,另一个用
在保存数据的时候。仔细看看代码,在输入一条员工信息的时候,程序并不对数
据进行完整的排序。它只是将数据大致按顺序放置,以加速在保存数据时的排序。
因此,问题是数据在排序前被打印出来了。连字号问题是因为粗略排序循环并没
有精确处理标点等细节情况。好了,现在你可以进一步提炼你的假设。
现在,你开始了最后一次假设:对于有标点符号的员工姓名,在数据保存之
前的存放顺序都是乱的。
随后,你通过另外的测试用例验证了这一假设。
Tips for Finding Defects
寻找缺陷的一些小建议
一旦将错误的发生稳定下来并精简了产生该错误的测试用例,那么寻觅错误
根源对你要么是小事一桩,要么会让你绞尽脑汁这取决于你的代码编写质量
如果在寻找缺陷的时候遇到了麻烦,很可能是因为你的代码写得不好。你或许不
大喜欢听到这句话,但这是事实。如果有了麻烦,请考虑下面的建议。
在构造假设时考虑所有的可用数据在对缺陷原因创建某个假设时,考虑尽
可能多的数据。例如,你或许会注意到Fruit--loop, Frita乱序了,于是你就假
设以字母“F”打头的名字都会出问题。这个假设很没水平,因为它没有包括第二
次 Modula, Mildred也是乱序排列的这一事实。因此,如果数据无法满足假设,
不要将它弃置一旁,思考一下为什么这些数据不符合假设,然后再来构造新的假
设。
例子中的第二个假设认为问题产生于含有连字号的姓名,而不是被单个输入
的条目一最初这一假设也无法解释第二次的姓名为什么能够正确地排列。然而,
第二个假设引导我们照着正确的方向对假设进行提炼。即使最初的假设无法圆满
解释所有的数据,这也没什么,只要你能够保持不断对假设进行提炼,它终究会
给你满意的答案。
提炼产生错误的测试用例如果无法确定错误的根源,那么可以尝试重新提
炼测试用例。你可以尝试在更大的范围内调整参数,而不局限于之前的假设。在
关注众多参数中的某一个时可能带来关键性的突破。
代码大全(第2版)

<==========================581end ==============================>
<==========================582start==============================>

该书下载自-书部落-分享计算机经典巨著--ww. !--www.shubulo. com.com!仅供试看^
23.2寻找缺陷
545
交叉参考如果在自己的单元测试族(unit test suite)中测试代码相对于一个较大的集成程
想了解关于单元序,在一个小型代码片段中发现问题会容易得多。你应当独立地对代码进行单元
测试框架的更多
消息,请参阅第测试。
22.4节中的“将
单元测试纳入测
利用可用的工具有很多各种各样的工具可以为你的调试工作带来方便:交
试框架”。互式的调试器、“吹毛求疵”型编译器、内存检查工具、带有语法提示的编辑器
等。选择适当的工具可以使棘手的问题迎刃而解。例如,有一个难于发现原因的
错误:程序的某个模块覆盖了另一模块使用的内存。如果使用传统的调试手段,
程序员将很难诊断这个错误,因为无法准确地定位程序错误覆盖的内存位置。这
时,可以使用内存中断点来监视特定的内存地址。当程序对该内存位置写入数据
时,调试器就停止执行代码,这样一来,过错代码就浮出水面了。
这只是一个例子,说明只要应用了适当的工具难于分析的调试问题可以变
得容易解决。
采用多种不同的方法重现错误有时,尝试一些能够产生相似错误,而本身
又不尽相同的测试用例或许能让调试过程柳暗花明。这种方法就如同对缺陷进行
三角定位。如果从某个点可以定位这个缺陷,从另一个点也能定位这个缺陷,那
么你对缺陷的位置就会有更为精准的把握。
如图23-1所示,用不同方法重现错误将有助于确定错误的原因。你一旦认为
自己已经找出了问题,就运行一个与产生错误的那个测试用例很类似的用例,但
这个新的测试用例应该不产生错误。如果新的测试用例也产生了错误,那么看来
你还没有彻底理解问题本身。错误常常是由多种因素交织产生,仅仅通过一个测
试用例通常无法确定问题的根本原因。
Program
First test
Program
Defect
Defect
Second test
Program
Program
Defect
Defect
Subsequent tests
Third test
图23-1尝试用多种方法重现错误以准确判定错误原因
代码大全(第2版)

<==========================582end ==============================>
<==========================583start==============================>

该书下载自-书部落-分享计算机经典巨著!-- ! --www.shubulo...com!仅供试看^
546
第23章调试
用更多的数据生成更多的假设在选择测试用例的时候,要让新的测试用例
不同于你已确知正确或者出错的那些用例。这些新的测试用例将生成更多的数据,
有了这些数据你就可以扩充可能的假设列表了。
利用否定性测试用例的结果假定你提出了某个假设并运行测试用例去证实
它,再进一步假定这个测试用例推翻了该假设因此你还是不知道错误的根源。
但是你从这次的尝试中知道了一些此前不曾了解的东西,即,你知道了问题并不
在你此前所关注的那个部分。这一结果将你的搜索领域进一步地压缩,剩下需要
考虑的假设也更少了。
对可能的假设尝试头脑风暴不要把自己禁铜于想到的第一种假设,试试其
他的。最初不要去分析它们,只是看看自己在几分钟的时间里能想出多少种不同
的东西。然后再逐一研究各种假设,考虑能证实或推翻该假设的测试用例。不要
使劲在一个地方钻牛角尖,上述这样的智力练习可能有助于你从调试僵局中解脱
出来。
在桌上放一个记事本,把需要尝试的事情逐条列出程序员们在调试中陷入
困境的一个原因是他们在一条死胡同里面走得太久。把要尝试的事情列出米,如
果某种方法不能奏效,那就换一种方法。
缩小嫌疑代码的范围如果你一直在对整个程序或是整个类或程序进行测
试,请关注于一个更小的部分。使用打印语句日志记录或跟踪具来确定到底
是代码中的哪个部分出了问题。
如果需要更强力的手段来缩小嫌疑代码的范围,请尝试从系统组织的角度逐
步去掉程序的各个部分,来看看错误是否仍然存在。如果错误消失,你能确定它
就在刚刚被去掉的部分中。如果错误仍然存在,它一定还在剩下的代码中。
与其随便地删除某段代码,不如对整个代码分而治之。可以使用二分查找法
则来进行搜索。首先去掉代码中的一半。找出问题所在的一部分代码,继续将该
部分代码对分。如此继续下去,直到发现问题。
如果面对许多个小的子程序,你可以简单地通过将对子程序的调用注释掉来
削减代码。你还可以用注释或预编详命令来移除代码。
如果使用调试器,那么就不必一段段地将代码移除。你可以在程序的运行流
程中间设置断点,在那里检查是否错误已经发生如果调试器允许你跳过对子程
序的调用,那么可以跳过特定子程序的执行,检查错误是否仍然存在,以排除一
些嫌疑。通过调试器实现的这一过程,同实际将代码一段段移除是类似的。
代码大全(第2版)

<==========================583end ==============================>
<==========================584start==============================>

该书下载自-书部落分享计算机经典巨著-- !--www.shubu.com!仅供试看^
23.2寻找缺陷
547
交叉参考如果对之前出现过缺陷的类和子程序保持警惕如果此前某些类已经有过问题,
代解什么样的那么它们很可能还会有其他问题相对于一个完善的类而言,一个之前就让你棘
代码更容易犯错
可以参考24.5节手无比的类更容易包含新的缺陷。因此要反复检查容易出问题的类和子程序。
中的“关注易于出
错的模块”
检查最近修改过的代码如果出现了一个难于确诊的新错误,这个错误通常
是同那些最近修改的代码相关的。错误或许是来自全新写出的代码,也可能来自
于修改过的旧代码。如果无法发现错误,那么请运行一下程序的老版本,看看错
误是否仍然会发生。如果没有,那么就可以确认错误是新版本引入的,或是源于
旧代码同新代码的交互。请仔细对比新旧版本的代码。通过检查版本控制日志文
件来确定到底哪些代码最近被改变。如果无法这样做,就用比较工具来比较旧的
可工作代码与新的、有问题的代码。
扩展嫌疑代码的范围要专注于很小的一部分代码很容易,但前提是“问题
必须就在这个部分内。”如果你在这个部分没有找到问题,请考虑是否有可能问
题的确不在该代码段内。如果有所怀疑,请扩展被分析的代码区域,然后采用之
前所述的二分查找法来对所扩展的区域分而治之。
交叉参考在第
29章“集成”中
增量式集成当你一次只对系统添加一个代码片段,调试将会变得很容易
有对集成的完整如果在这一过程中出现了新错误,则应将所添加的代码提取出来单独测试
描述。
检查常见缺陷使用代码质量核对表来激发你对可能发生的缺陷的思考。如
果你按照21.3节“正式检查”所描述的检查方法,你可以针对自己的开发环境列
出一张精心定义的常见问题列表。你还可以借助遍布在本书中的核对表。请从本
书目录中查阅“核对表清单”。
交叉参考要了
同其他人讨论问题有人会把这种方法称之为“忏悔式调试”当你向别人
解如何借助其他开解释自己的程序时,常常能发现自己犯下的一些错误。举个例子,如果你向别人
发人员的力量尽快
解决问题,请阅读解释上面的关于薪水的例子,你或许会这样对别人说:
第21.1节“协同开
发实践
概要”。
嗨, Jennifer,你有空么?我现在遇到了一个麻烦。这张员工薪水列表
本来应当是按照顺序排列的,但里面有些名字乱序了。我原本打算看看是不
是新输入的名字就会出现这种情况,但有时是对的,有时又不是。我想这些
数据在我输入他们的时候就应当被排序,因为程序会在我输入数据的时候对
其排序,然后在数据保存的时候再排一遍。等一下,不对,它没有在输入数
据的时候对其排序。就是这里。程序只是粗略地对这些数据进行了排序。谢
谢你, Jennifer,你帮了我个大忙。
代码大全(第2)

<==========================584end ==============================>
<==========================585start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! -www.shubulo.com!仅供试看
548
第23章调试
Jennifer没有说一个字,你就解决了自己的问题。这样的结果是很典型的,
这种方法是解决棘手问题的有力工具。
抛开问题,休息一下有时你太关注于你的问题了,已经到了无法思考的程
度。你有多少次从工作中暂停下来去泡一杯咖啡,在你走向咖啡机的路上却灵光
一现解决了问题。或者是正在吃午饭的时候或者是在回家的路上?甚至在第二
天清晨冲澡的时候?如果你调试了很久却毫无进展,只要你尝试完所有的可能,
把问题放在一边吧!出去散散步,做些其他的事情。回家休息一天。让你的神经
在潜意识中释放出问题的解决方案。
暂时放弃思考的好处是可以减少调试带来的焦虑。不时潜入头脑中的焦虑感
是一个明确的信号:到了该休息的时候了。
Brute-Force Debugging
蛮力调试
在调试软件故障的时候,蛮力调试常常是一种被忽视的方法。“蛮力”指的
是一种或许会被认为乏味、费神、耗时但能确保最终可以解决问题的方法。保证
解决问题的特定技术需要结合具体情况来考虑,但这里还是可以给出一些普遍的
方法:
对崩溃代码的设计和编码进行彻底检查
抛弃有问题的代码,从头开始设计和编程
抛弃整个程序,从头开始设计和编程
■编译代码时生成全部的调试信息
在最为苛刻的警告级别中编译代码,不放过任何一个细微的编译器警告
全面执行单元测试,并将新的代码隔离起来单独测试
开发自动化测试工具,通宵达旦地对代码进行测试
在调试器中手动地遍历一个大的循环,直到发现错误条件
在代码中加入打印、显示和其他日志记录语句
用另一个不同的编译器来编译代码
在另一个不同的环境里编译和运行程序
在代码运行不正确的时候,使用能够产生警告信息的特殊库或者执行环境来
链接和运行代码
■复制最终用户的完整系统配置信息
将新的代码分小段进行集成,对每段集成的代码段进行完整的测试
代码大全(第2版)

<==========================585end ==============================>
<==========================586start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. --www.shubulo.c.com!仅供试看
23.2寻找缺陷
549
在使用“快速肮脏调试法”的时候设置一个时间上限对每一种蛮力调试方
法,你的反应都可能是:“我做不了!工作太多了!”但关键是,只有当调试工
作耗费的时间比我所说的“快速肮脏(quick and dirty)调试法”更多时,那才算
得上是太多的工作。人们往往会放弃让缺陷无处遁形的彻底系统分析,而去进行
快速的尝试。我们每个人的投机心理都宁愿去用一种有可能在五分钟内发现缺陷
的高风险方法,也不愿意为某种保证能找出缺陷的方法花上半个小时。这里的风
险就是如果五分钟的方法没有奏效,你也变得麻木了。一旦把使用这种“简便”
的查找缺陷方法作为信条,那么几个小时也许就在无所建树中流逝了,至是几
天、几周、几个月…有多少次你花上了两个小时来调试原本只用三十分钟就写
出来的代码?这样耗费程序员的劳动力是非常糟糕的,因此你会想,与其花这么
多时间调试这一堆垃圾,还不如早就动手重写代码更好。
如果打算通过捷径摘取胜利果实,那么请为你尝试捷径的时间设置一个上限。
如果耗时超过了上限,就应老老实实地承认问题比你最初想象的要更加难于分析,
应该转到困难的路上重新开始。这种方法使你可以很快地解决一些比较简单的问
题,而对那些比较困难的问题只是稍微多花了一点时间。
做出一张蛮力调试方法列表在开始调试一个难于解决的错误之前,问问自
己:“如果我在调试这个错误的时候被缠住了,有什么方法能够确保解决问题么?”
如果你可以确定地写出至少一种解决问题的蛮力技术包括重写存在问题的代
码,那么你就不太可能为一种貌似更简便的方法浪费数小时甚至数天的时间。
Syntax Errors
语法错误
语法错误的问题已经就如剑齿虎与猛犸象一样将要退出历史舞台了。在显示
诊断信息方面,编译器做得越来越好。以前花上两个小时在 Pascal中寻找一个位
置错误的分号的日子几乎已经一去不复返了。你可以参考下面一些建议来加速这
一稀有物种的灭绝。
不要过分信任编译器信息中的行号在编器报告了一个令人困惑的语法错
误时,请看看错误行的前后代码——编译器有可能没有正确理解问题,或者只是
简单地执行了一些拙劣的分析。一旦发现了真凶请尝试分析为什么编译器会提
供错误的信息。更好地理解自己的编译器有助于查找将来的缺陷。
不要迷信编译器信息编译器总是锲而不舍地想要告诉你到底是什么出了
错,但它也会掩饰自己的无赖。你常常只能通过在字里行间寻找蛛丝马迹,才能
知道这些信息的真正含义。举个例子,在UNC中,你将一个整数与零相除会
得到一条“floating exception”的消息。在使用C+标准模板库时,你可能会收到
代大全(第2版)

<==========================586end ==============================>
<==========================587start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shub.com!仅供试看^
550
第23章调试
两条错误消息:第一条是使用STL时真正的错误信息;第二条则是编译器在说“错
误消息太长而无法打印;消息有删节。”你自己或许还能想到很多例子。
不要轻信编译器的第二条信息有的编译器在处理多个错误的时候要比其他
编译器表现更好。有的编译器找到了第一个错误就会激动万分,些许沾沾自喜和
自负了。其他的一些编译器则行事稳健,尽管发现错误时感觉快要大功告成,还
是会保持厚道而不轻易打印出不甚准确的信息当你的编译器输出了一大堆的错
误信息时,如果无法迅速找出第二条或第三条错误信息的源头,不要担心。先把
第一条处理了,再重新编译。
分而治之将程序划分为几个部分的方法有助于寻找缺陷,尤其是那些语法
错误。如果碰到了一个麻烦的语法错误,尝试去掉代码的一部分,然后重新编译。
接下来会有三种可能:错误消失了(因为错误就在你去除的部分里),还是这个
错误(意味着你需要去掉另一个部分),有了一个不同的错误(你成功地诱使编
译器给出了一条更有意义的信息)。
交叉参考具有语
找出没有配对的注释或者引号很多的程序文本编辑器都会自动对注释和字
法分析能力的编辑符串以及其他的语法元素自动套用格式。在较为原始的开发环境中,一个没有配
器是开发环境成熟
与否的标志。想要对的注释或引号就足以绊倒编译器。如果要找出额外的注释或引号,可以把下面
了解更多内容,请这一行加入到你的C、C++或Java代码中:
参阅第4.3节“你
在技术浪潮中的位//大
置”。
这行代码能终结注释或字符串。在查找注释或字符串中止符号的时候,可以
有效地缩小搜索范围
23.3
Fixing a Defect
修正缺陷
调试过程中最让人头疼的部分是寻找缺陷。修正缺陷则是较为简单的部分
但如同很多简单的任务一样,正是因为它太过简单才让人们经常对它掉以轻心
至少已经有一项调查发现程序员在第一次对缺陷进行修正的时候,有超过50%的
几率出错(Yourdon1986b)。下面给出一些如何减少出错儿率的建议。
在动手之前先要理解问题“调试之魔鬼指南”说得很对:如果想让自己的
生活潦倒,让自己的代码质量一塌糊涂的最好方法,就是不懂装懂地动手修补程
NGY POINT
序缺陷。在修补问题之前,请保证你已经很透彻地理解了它。通过那些能重现和
不能重现错误的测试用例,对缺陷进行三角定位。直到你能真正地理解问题,每
次都能正确地预测出运行结果为止。
代码大全(第2版)

<==========================587end ==============================>
<==========================588start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubulo.c.com!仅供试看^
23.3修正缺陷
551
理解程序本身,而不仅仅是问题与对问题只知皮毛相比,如果理解了整个
问题的来龙去脉,你就能更容易解决它。一项对短小程序的研究发现,那些对整
个程序有着全局性理解的程序员们成功修改程序的可能性要比那些仅仅关注于局
部程序的程序员们高得多( Littman et al.198)。由于在此次研究中使用的程序很
小(280行),因此这项研究并不是要说服你在解决问题之前尝试去彻底理解一
个拥有五万行代码的程序。但它建议你至少应当理解问题附近的代码这个“附
近”指的不是几行,而应该是几百行。
验证对错误的分析在匆匆下手之前,需要确认你对问题的分析是正确的。
花点时间运行测试用例,证明你的假设,并证伪你的假设的逆命题。如果仅仅证
明了错误是由多个因素之中的一种所引起的那就仍然缺乏足够的证据说明应该
对这个因素采取措施。请先把其他因索排除掉。
绝对不要站着调
放松一下一位程序员已经准备着自己的滑雪度假了。他所参与开发的产品
试。
-Gerald Wenberg
即将上市,而他的任务已经拖了项目的后腿还好,他只有一个错误需要修正
于是他修改了原文件,然后把代码签入到版本控制系统中去。他并没有重新编译
程序,也没有验证自己所做的改动是否正确。
不幸的是,改动并不正确。于是他的经理暴怒了。程序员怎么能够改动即将
发布产品中的代码而不经检查?还有什么比这更糟糕的事情么?难道这不是职业
程序员登峰造极的鲁葬行径么?
如果这还不算是,那也是很接近了,而且这样的情况屡见不鲜。匆忙动手解
决问题是你所能做的最低效的事情之一。这将导致草率判断,片面分析,还有并
不彻底地改正。如果妄想一蹴而就,没有问题也会弄出问题。压力通常是来
自自身一将会使程序员更倾向于采用随机测试查找错误,并且让程序员在没经
过验证的情况下武断判定这种方法能奏效。
与此形成鲜明对比,在 Microsoft Windows2000开发的最后阶段,一位程序
员需要修补一个错误。而这个错误是创建发行版本之前整个开发所剩下的最后的
错误。这位程序员修改了自己的代码,对修改进行了检查,然后在自己的本地编
译环境下进行了测试。但这时他并没有把代码签入到版本控制系统中去。他选择
了去玩篮球。他说道:“现在我压力太大了,我没办法确信我已经考虑到了所有
需要考虑的问题。我要让大脑在一个小时时间里什么都不想,然后再回来检查代
码一直到我能确信自己所做的修改彻底无误。
休息足够长的时间能让你肯定自己的解决方案是对的。不要受到所谓捷径的
诱惑。休息一下或许会让你花掉更多时间,但在多数情况下,你为问题所付出的
成本会更少。如果没有其他意外,休息之后你将会正确地改正程序中的错误,你
的经理也决不会在你享受滑雪度假的时候打电话让你回到公司
代码大全(第2版)

<==========================588end ==============================>
<==========================589start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.co!.com!仅供试看^
552
第23章调试
交叉参考第24保存最初的源代码在对缺陷动手之前一定要把原始版本的代码打包存放
章“重构”对修改
起来,这样你才能在出问题的时候恢复到原始版本如果拥有最初的源代码,至
代码的相关事项
进行了深入讨论。少你能对新旧文件进行比较,看看自己到底改了哪些地方。
治本,而不是治标你也应该解决问题的表象但更应该把注意力放在解决
更深层次的问题上,而不是把编程绷带将代码裹起来。没有彻底理解问题,就不
要去修改代码。如果仅仅是治标,你只会把代码搞得更糟糕。假设你有下面这些
代码:
Java示例:待修正的代码 muber+
sum[ client sum[ client claimAmount claimNumber ]
进一步假设,当client等于45的时候,sum得出的结果有$3.45的误差。下
面就是解决问题的错误方法:
java例:“修正”代码,使之更糟
for( claimNumber=0 claimNumber numClaims client claimNumber++)
sum[ client= sum client+ claimAmount claimNumber]
这是“解决办法f( client=45)
sum[ 45 ]=sum[ 45 ]+3.45;
现在假设当 client等于37的时候,该 client WclaimNumber为0但你得
到的并不是0。下面也是解决问题的错误方法:
Java示例:“修正”代码,使之更糟(续)
for( claimNumber=0; claimNumber< numclaims client; claimNumber++
sum client= sum client+ claimAmount claimNumber
if client 45
sum45=sum45+3.45;
这是第二步“解决办seif(( client==37)&&( numclaims client=0))
法”。
sum37=0.0
如果这样的结果仍然不会让你感到一阵寒意从你的脊柱蔓延开来,你一定也
不会被这本书中的其他内容所打动。在这本大约1000页的书中要列出这种方法
所产生的所有问题是不可能的。现在给出最常见的三种。
代码大全(第2版)

<==========================589end ==============================>
<==========================590start==============================>

该书下载自-书部落-分享计算机经典巨著!--w. --www.shubulo.c.com!仅供试看
23.3修正缺陷
553
这样的修改在多数情况下不管用。问题似乎是由于初始化的毛病造成的。从概
念上讲,初始化带来的问题无法预测,因此,对 client为45时的sum所进行
的$3.45修正只能解决目前问题,而对将来无济于事。下一次或许需要对结果
进行1000002的修正,或者结果本身已经是对的这就是初始化问题的本质。
这样的代码根本无法维护。当代码试图通过处理某些特例来绕过错误,这样
的特例将会成为代码最碍眼的一个特性。修正值不会总是$3.45,另一个错误
迟早会冒出来。如果代码因兼容新的特例而被再度修改,那么针对$3.45的修
改也不能移除。代码总是被特例所纠缠。直到最终代码被束缚得无法再对新
的特例提供支持,它将会沉没到海底一那才是这段代码最好的归宿。
通过这样的方法麻烦计算机,还不如手工做更好些。计算机适合用于可预测
的系统性的计算。而人在数据的创造性使用上更胜一筹。与其这样胡乱地修
补代码,还不如老老实实地用修正液和打字机来处理输出数据。
修改代码时一定要有恰当的理由就解决问题的表象而言,一种方法是随机
地修改代码,直到你的代码看起来能工作。典型的思维逻辑是这样的:“这个循
环好像有问题。可能是一个off-by-one错误。让我先来写一个-1试试哦,这样
不行。那么我就写个+1试试。哈,看来程序正常工作了。我可以宣布问题搞定了。”
尽管这种方法受到了很多程序员的追捧,但它非常低效。随机地修改代码就
如同是把一辆 Pontiac Aztek汽车转来转去,以为这样能修复它的引擎故障。你学
不到任何东西,你只是在晃来晃去地浪费时间。你会争辩说随机修改程序是有效
的,因为“我不知道这段代码到底出了什么事,我想试试这样修改,希望它有用。
不要随机修改代码。这就是所谓的“voodoo programming(巫毒编程)”。在没有理
解代码的时候对它所做的修改越大,你对它能正确工作的信心就越低。
在做一项改动之前,先确信自己的修改能起作用。改错了代码只会让你目瞪
口呆愣在一旁。这会让你自我怀疑,甚至想重新衡量自己的价值并对自己的内心
进行深入剖析。这样的情况越少越好。
一次只做一个改动在一次只完成一个改动的情况下,你会发现错误已经够狡
猾了。如果同时进行两个,所做的修改可能引入妙的错误,而这些错误看上去很
像原来的那个错误。这时你就会弄不清你是没有修复掉原来的错误,还是你改了原
来的错误但又引入了相似的错误,或者不但没有修复原来的错误而且还引入了相似
的错误。这会把你置于万分尴尬的境地。让问题简单一点:一次只改一个地方。
交叉参如果
检查自己的改动自己检查程序,再让别人帮你检查程序,或者是同别人一
要了解关自动道检查程序。运行你在分析问题时所使用的三角定位测试用例,确保与问题相关
化回归测试的详
细内容,请参阅第的方方面面都被考虑到了。如果你仅仅解决了问题的一部分,你会发现还有很多
226节的“新测工作正在等着你。
试(回归测试)”。
代大全第2版)

<==========================590end ==============================>
<==========================591start==============================>

该书下载自-书部落-分享计算机经典巨著--www. !--www.shubulo.com!^ ^.com!仅供试看^个
554
第23章调试
重新运行整个程序,看看你的修改是否产生了什么副作用。最为简单的方法
就是通过自动回归测试工具对程序进行测试,你可以使用 JUnit、 CppUnit或其他
类似的工具。
增加能暴露问题的单元测试如果你的测试工具集无法检测出某个错误,那
么就往里面加入一个能揭示该错误的测试用例。这样一来,相同的错误就不会在
后面的阶段中被再次引入了。
搜索类似的缺陷找到一个缺陷以后,应该看看还有没有与之类似的缺陷。缺
陷常常会成群结队的出现,如果能抓住这一类里的一个,你就能改掉这一类缺陷。
但要找出这些类似的缺陷,需要你对整个程序有透彻的理解。请留意这样一个警告
信息:如果你想不出如何查找类似缺陷,这就意味着你还没有完全理解问题。
23.4
Psychological Considerations in Debugging
调试中的心理因素
深入阅读在The
如同任何其他的软件开发活动一样,调试是一种要求程序员花费大量脑力的
Psychology of Co-
mputer program
工作。就算是已经看到了一个缺陷,你的自负还是会让你觉得自己的代码完美无
mingX程序开发心缺。你必须仔细思考—构思假设收集数据,分析假设,然后通过各种方法证
理学Weinberg
19程中的伪这些假设—这些刻板的方法对很多人来说并不自然。如果你既编写代码又对
对调试过程中的心它进行调试,你不得不让自己的大脑不停地在流畅的创造性设计和刻板的调试过
发其他方面有精彩程之间疲于奔命。在阅读自己所编写的代码时,你不得不同这些非常熟悉的东西
的论述。
保持距离,并对自己希望出现的运行结果有所警惕。
How"Psychological Set"Contributes to Debugging Blindness
心理取向如何导致调试时的盲目
如果在程序里有一个名为“Num”的符号,你会把它看做是什么?会把它当
成是被拼错的“Numb”(麻木)一词么?或者认为它是“Number”的简写?绝
大多数情况下你的答案会是后者。这种现象就是“psychological set(心理取向)”
你会看到你所希望看到的。下面写的是什么?
Paris in the
the Spring
在这个经典问题中,人们常常只能看到一个“te”。人们看到的是他们所希
望看到的东西。请考虑下面的问题。
学生们在学习 while循环时,常常希望一个循环能持续不断地对循环条件进
行判断,也就是说,只要while条件一旦为 false,循环就立即终止,而不是
代码大全(第2版)

<==========================591end ==============================>
<==========================592start==============================>

该书下载自-书部落-分享计算机经典巨著!--ww. ! --www.shubul.com!仅供试看^
23.4调试中的心理因素
555
循环运行到循环体的顶部或底部(Curtis et al.196).他们希望 while循坏的表
现和日常生活中的“while”一样。
一位程序员不小心写出了 SYSTSTS和 SYSSTSTS两个变量,而他原本只要
用一个。直到他的程序运行了上百次,甚至错误的结果已经被写入书中,他
HARD DATA
才意识到这点。
程序员阅读下面这样的代码:
if x <)
swap x;
=Yi
= Swapi
有时看到的是另一种代码:
if (<){
=swapi
人总期望一个新的现象类似于他们见到过的某种现象。他们希望新的控制结
构像老的控制结构一样工作;程序设计语言(programming-la-)中的“while
语句就像现实生活中的“while”一样工作;变量的名字也和之前所看到的一样
你只看到你希望看到的东西,因而忽视了它们之间的差别,就如同你没有发现前
面一句话中被拼错的“language”一样。
心理取向对调试有什么影响?首先,它证明了养成良好的编程习惯的重要性。
规范的格式、恰当的注释、良好的变量和子程序命名方式,以及其他编程风格要
素都有助于构建编程的良好基础。在这样的基础之上,可能发生的错误将因为与
众不同而变得格外引人注目。
第二个影响表现在当发现错误的时候,程序员对于需要检查的程序部分的选
择方面。研究表明,调试程序最高效的程序员们能够在调试时对程序中的无关部
分视而不见( Basili,sby, and Hutchens 11986)。一般而言,这种方法使优秀的程
序员们收缩他们的研究范围,从而更快地发现问题。然而,有时包含错误的程序
部分也会被程序员们错误地排除在外。你在段代码上花很多时间,希望从中找
出问题,但却忽视了真正含有问题的代码。这就像在马路上转错了路口方向,只
有转回来之后才能继续前进。23.2节里关于查找错误的提示的一些讨论,就是为
了帮助你避免这种“调试盲区”。
代大全(第2版)

<==========================592end ==============================>
<==========================593start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
556
第23章调试
How"Psychological Distance"Can Help
“心理距离”在调试中的作用
交叉参考如何
心理距离可以定义为区分两事物的难易程度。如果你正在看着一个常见的单词
才能让变量名称表,此前被告知这些词都是有关鸭子的,那么你就很容易把“Queck”看做是“Quack”
不会被混淆?可(鸭子的呱呱叫声),因为二者太相似了。二者的心理距离很小。但你不大可能将
的“应该避免的名“Tuack”看做是“Quack”,即使二者只有一个字母不同。相对于“Queck”,“Tuack
字”找到详细答更不像“Quack”,因为单词首字母要比中间字母更能引起人的注意
案。
表23-1列出了一些变量名之间的心理距离。
表23-1变量名之间的心理距离示例
第一个变量第二个变量
心理距离
stoppt
stcppt
几乎不可见
shiftrn
shiftrm
几乎没有
dcount
bcount
claims1
claims2
product
sum
小小大
在做调试的时候,要警惕那些没有足够心理距离的相似变量名或者子程序名。
而在编写代码的时候,应该为变量或子程序选择差别较大的名字,这样你就可以
避免此类问题的发生。
23.5
Debugging Tools Obvious and Not-So-Obvious
调试工具一明显的和不那么明显的
交叉参考测试工
具和调试工具之间利用今天程序员们随处可得的调试工具,你已经能做很多纷繁芜杂的细致的
的界限很模糊。在本
书中,第22.5节重调试工作了。尽管那种能让缺陷一招毙命的调试工具还未问世,但每一年,现有
点介绍测试工具,而的调试工具的功能都能得到逐步的改进。
第30章重点介绍软
件开发工具。
Source-Code Comparators
源代码比较工具
如果修改了程序结果却出了错,诸如diff这样的源代码比较工具就会非常有
用。当你做了很多修改,又需要恢复其中你已经忘得差不多的部分时,一个比较
工具能够指出新旧代码的差异,从而唤醒你的记忆。如果在新版本中发现了一个
错误,而你不记得在旧版本中也有,那么就可以通过类似工具进行比较,看看自
己到底做了哪些修改。
代码大全(第2版)

<==========================593end ==============================>
<==========================594start==============================>

该书下载自-书部落分享计算机经典巨著!-- ! -www.shubu.com!仅供试看^
23.5调试工具一明显的和不那么明显的
557
Compiler Warning Messages
编译器的警告消息
最为简单同时也是最为高效的调试工具就是你手中的编译器。
将编译器的警告级别设置为最高级,尽可能不放过任何一个警告,然后修正
编译器所报告的全部错误忽略编译器所提示的程序错误太过草率,关掉编译器
KEY POINT
的警告功能则无异于掩耳盗铃。就像小孩子们有时会认为自己闭上眼睛看不到你,
就会让你消失了。关掉编详器的警告功能仅仅意味着你看不到错误,并不表示这
些错误就此消,正如同小孩闭上眼睛并不能让面前的父母从此消失一样。
要有这样一种假设:那些编写编译器的人对你所使用的语言的了解要远远胜
过你自己。如果他们对你的程序提出了警告,这常常会表示你现在有了一个学习
你所使用语言更多知识的良机。要努力去理解这些警告信息的真正含义。
用对待错误的态度来处理警告一些编译器允许将警告看做是错误。使用这
一功能的意义在于它能够提升警告信息所显示出的重要性。正如把手表拨快5分
钟会让你感觉到你的动作已经迟了5分钟一样将编译器设置为将警告看做是错
误能够让你更为严肃地对待警告。另一个理由是这样做能够让警告对编译过程产
生影响。当你编译并链接程序的时候,通常警告不会终止程序的链接,而错误则
可以。如果你希望在链接之前就检查是否会产生警告,那么就打开这项功能吧。
在项目组范围内使用统一的编译设置对项目设置一套编译规范,让团队中
的每个人在编译代码的时候都使用相同的编译器设置。否则,在集成不同程序员
用不同设置编译的代码的时候,你就会遭遇洪水般的错误信息,并不得不享受一
个噩梦般的集成过程。这件事很容易贯彻,只要在项目中使用统一的编译配置文
件或者编译脚本。
Extended Syntax and Logic Checking
增强的语法检查和逻辑检查
你可以使用其他工具对代码进行进一步的检查这些检查将比编译器所提供
的更为全面。例如,对C程序员来说,lint工具能非常仔细检查出对未初始化变
量的使用(错把==写成=)以及其他类似的微妙问题。
Execution Profilers
执行性能剖测器
或许你不会认为执行性能剖测器是一种调试工具但花上几分钟来研究某个
程序的性能分析结果,或许可以让你发现一些令人惊奇的隐藏错误
例如,我曾经怀疑我程序中的某个内存管理子程序是程序的性能瓶颈。内存
管理原来是由一些组件构成,这些组件使用一个指向内存的线性有序指针数组。
我用hash表代替线性有序队列,希望执行时间至少能减少一半。但对代码进行性
代大全(第2版)

<==========================594end ==============================>
<==========================595start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. !--www.shubulo.com!仅供试看^
558
第23章调试
能分析之后,我发现性能根本没有变化。我更为仔细地检查了程序,终于在资源
分配算法中找到了一个消耗大量时间的缺陷。性能瓶颈不是我的线性搜索方法,
而是这个缺陷。我其实根本就不需要对搜索算法进行优化。请检查一下执行性能
剖测器的输出结果,如果发现你的程序在每个区域内花费的时间都很合理,那么
你就可以放心了。
Test Frameworks/Scaffolding
测试框架/脚手架
交叉参考如果想
知道关于测试框架
的详细内容,可以
正如第23.2节所描述的那样,找出有问题的代码,对其编写测试程序,然后
参阅本第22.5节中通过运行程序找出问题,常常是对付麻烦程序里的恶魔的最有效方法。
的“为测试各个类
构造脚手架”。
Debuggers
调试器
这些年来,商业级的调试器一直在稳步发展,由此带来的新的功能已经改变
了当今程序员们的编程方式。优秀的调试器允许程序员设置断点,在某一行代码
执行时或循环执行n次之后使程序中断。全局变量发生改变,或变量被赋予特定
,。
值也能够触发调试器的中断。这些工具还允许逐行运行代码,步入或执行通过子
程序。还允许回溯执行程序,一步步回到产生缺陷的那一点。你还可以通过这些
工具记录特定语句的执行一—就像是在程序中四处放置一些“我到这里了!”
类的打印语句。
优秀的调试器允许程序员对数据进行全面的检查,包括结构化的和动态分配
的数据。程序员可以很方便地查看指针链表或者动态分配的数组的内容。调试器
还能够智能化地适应用户定义的数据类型,允许程序员通过特殊查询方法检索数
据,为其指定新值,然后继续运行程序。
你还可以通过这些工具查看高级语言或者山编译器所生成的汇编代码。如果
使用了多种语言,调试器将为各个部分的代码自动显示出相应的语言。你可以查
看对一系列子程序的调用链,迅速看到任子程序的源代码。你还可以在调试环
境中改变程序的参数。
现在,最为出色的调试器还能够针对每一个单独的程序保存你的调试参数(比
如断点、需要监视的变量等)。这样在调试每个程序的时候你就不需要重新设置
调试参数了。
系统调试器在系统一级上工作,而不是应用程序一级,因此这些工具并不会
干扰正被调试的程序的执行。如果你所调试的程序需要苛刻的运行速度或内存资
代码大全(第2版)

<==========================595end ==============================>
<==========================596start==============================>

该书下载自-书部落-分享计算机经典巨著!--www. ! --www.shubulo.co.com!仅供试看
23.5调试工具一明显的和不那么明显的
559
源,这种类型的调试器是必需的。
交互式调试器极好看到上面对如今调试器强大功能的介绍,你或许会奇怪居然会有人批评这些
地代表了那些程序调试器。但计算机科学领域中的某些泰山北斗的确建议完全不要使用调试器。他
员们并不需要的调
试器它鼓励程们主张使用你的大脑,避免使用调试工具他们的论据在于,调试工具就像拐杖
序员采用随机试验一样,如果不依赖这些工具依靠自己的思考你能更为快速更为准确地发现问
查找错误的方法,
而不是对程序进行题。他们建议,与其使用调试器,你不如在头脑里执行程序,把其中的缺陷清理
而
系统的分析同时,出来。
这样的工具也给了
那些几乎没有资格
抛开一些经验主义的证据,那些反对调试器的基本理由其实并不成立。某种
从事细致的程序设工具可能被错误地使用,但这并不表示这种工具应该被抛弃。人们不会因为存在
计的人滥竽充数的服药过量的可能就放弃使用阿斯匹林,同样不会因为割草机可能伤到自己就不用
机会
Harlan Mils它修剪草坪任何其他的强有力工具都可能被正确使用或者乱用,调试器也是一
样。
调试器当然无法代替良好的思维。但是在一些情况下,思维也无法取代优秀
的调试器。因此,最为有效的组合是良好的思维加上优秀的调试器。
NEY FOINT
CHECKLISTS: Debugging Reminders
ccec3核对表:关于调试的建议
寻找缺陷的方法
口使用所有可用数据来构造你的假设
口不断提炼产生错误的测试用例。
口在自己的单元测试族中测试代码。
借助可以获得的任何工具。
口用不同的方式重现错误。
口通过产生更多的数据来构造更多的假设。
利用证伪假设的测试结果
用头脑风暴的方式找出可能的假设。
口在桌上放一个记事本,把需要尝试的事情列出来。
口缩小被怀疑有问题的代码区域
口对之前出现过问题的类和子程序保持警惕。
口检查最近修改的代码。
口扩展被怀疑有问题的代码区域
代码大全(第2版)

<==========================596end ==============================>
<==========================597start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. !--www.shuby.com!仅供试看^
560
第23章调试
口采用增量集成。
口检查常见的缺陷。
口和其他人一起讨论你的问题。
口抛开问题休息一下。
口在使用快速肮脏调试法的时候,要设置一个时间上限。
口列出所有的蛮力调试方法,逐条应用。
解决语法错误的方法
口不要太信任编译器信息中给出的行号。
口不要太信任编译器信息。
口不要太信任编译器所给出的第二条出错信息。
口分而治之,各个击破。
口使用具有语法分析功能的编辑器来找出位置错误的注释和引号。
修正缺陷的方法
口在动手之前先理解程序。
口理解整个程序而非具体问题。
口验证对错误的分析。
口放松一下。
口要保存最初的源代码。
口治本,而非治标。
口只有当理由充分的时候才去修改代码。
口一次只做一个改动。
口检查白己所做的修订。
口添加单元测试来暴露代码中的缺陷。
口找出类似的缺陷。
调试的一般方法
口你是否会把调试看做是能让你更好地理解程序、错误、代码质量和解决
问题方法的良机?
口你是否会避免采用随机尝试查找错误或迷信式的调试方法?
代码大全(第2版)

<==========================597end ==============================>
<==========================598start==============================>

该书下载自-书部落-分享计算机经典巨著!-www. ! --www.shubulo.com!^.com!l仅供试看
更多资源
561
口你是否假设错误是你自己造成的?
口你是否使用了科学的方法将间歇性的错误稳定下米?
口你是否使用了科学的方法来寻找缺陷?
口你在寻找缺陷的时候会使用多种不同的方法么?还是每次都是用相同的
方法?
你会验证你的修改是否正确么?
口你会在调试中使用编译器警告信息、执行性能分析、利用测试框架和交
互式调试方法么?
Additional Resources
更多资源
cc2ec/2375下面的这些资料同样谈到了调试。
Agans, David J. (Debugging: The Nine Indispensable Rules for Finding Even the
Most Elusive Software and Hardware Problems》《调试:发现最难以琢磨的软件
和硬件问题的九条金科玉律》). Amacom,2003.这本书介绍了能够应用于任何编
程语言或者环境的通用调试原则。
Myers, Glenford.The Art of Software Testing》(《软件测试的艺术》)New
york,ny: John Wiley&sons,1979.这本经典著作的第7章是专门讲述关于调试
的。
Allen,eric.《 Bug Patterns In JavaJava的bug模式》). Berkeley,ca: Apress
2002.这本书提出了一种对Java程序进行调试的方法,从概念上来讲与本章所介
绍的相当类似,包括了“调试的科学方法”,区分调试与测试以及识别常见的错
误模式。
接下来的两本书比较类似,它们的标题表明了其只适用于 Microsoft Windows
与NET程序,但是它们都包含了对通用的调试方法的讨论,断言的使用,以及
帮助在前期防止错误产生的编码标准。
Robbins,john.《 Debugging Applications for MicrosoftNET. and Microsoft
Windows ) Redmond, WA: Microsoft Press, 2003.
McKay, Everett N. and Mike Woodring. Debugging Windows Programs:
Strategies, Tools,and Techniques for Visual C++ Programmers). Boston, MA:
Addison-Wesley, 2000.
代码大全(第2版)

<==========================598end ==============================>
<==========================599start==============================>

该书下载自-书部落-分享计算机经典巨著-- !-www.shubu.com!仅供试看
562
第23章调试
Key Points
要点
调试同整个软件开发的成败息息相关。最好的解决之道是使用本书中介绍的
其他方法来避免缺陷的产生。然而,花点时间来提高自己的调试技能还是很
划算的,因为优秀和拙劣的调试表现之间的差距至少是10:1
要想成功,系统化地查找和改正错误的方法至关重要。要专注于你的调试工
作,让每一次测试都能让你朝着正确的方向前进一步。要使用科学的调试方
一步。
法。
在动手解决问题之前,要理解问题的根胡乱猜测错误的来源和随机修改
将会让你的程序陷入比刚开始调试时更为糟糕的境地。
将编译器警告级别设置为最严格,把警告信息所报告的错误都改正。如果你
忽略了明显的错误,那么要改正那些微妙的错误就会非常麻烦。
调试工具对软件开发而言是强有力的支持手段。找出这些工具并加以应用,
当然,请记得在调试的时候开动脑筋。
代码大全(第2版)

<==========================599end ==============================>