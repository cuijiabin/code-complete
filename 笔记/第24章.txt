第24章 重构

24.1 软件进化的类型
	软件进化的哲学
24.2 重构简介
	重构的理由
	拒绝重构的理由
24.3 特定的重构
	数据级的重构
	语句级的重构
	子程序级重构
	类实现的重构
	类接口的重构
	系统级重构
24.4 安全的重构
	不宜重构的情况
24.5 重构策略
	推荐读物

什么时候该重构
	重复代码
	函数太长
	循环太长或嵌套太深
	低耦合的类
	接口的抽象级别不一致
	参数列表太长
	修改不知道在哪个类中进行，好像两个类中都可以
	改变一个地方要同时改变多个类
	改变一个类的继承要同时改变多个类
	case语句要同时改变多个地方
	有联系的数据没有放在同一个类中
	类中的一个方法调用其他类的次数比自己的类还多
	原始数据类型被重载
	一个类几乎什么都没做
	一个变量通过一条长长的函数链进行传递
	什么都没做的中介类
	一个类和其他的类太亲密
	函数的名字取的不好
	成员变量是公有的
	子类只使用了很少的父类
	代码太复杂，以至要用注释来解释
	使用了全局变量
	在调用一个方法之前进行初始化配置，或者在结束一个调用后清理配置
	一个程序包含一些以后才能可能用到的代码

具体的重构方法
	数据层面
		将一个数值换成有名字的常量
		将一个变量的名字变得更加整洁，包含更多信息
		将表达式移动到内联函数中
		将一个表达式换成函数
		引入中间变量
		将一个多功能的变量转变成单一功能的变量
		不要把参数当成局部变量进行赋值
		将原始数据转换成一个类
		将类型代号转换成一个类、枚举或子类
		将一个数组转换成对象
		封装一个集合
		将传统的记录转换成数据类

	语句层面
		分解布尔表达式
		将复杂的布尔表达式转移到一个函数中
		在不同的条件下，统一代码
		在循环中使用break或return而不是使用变量来控制循环
		当知道返回值之后马上返回，不要在if-else中赋值然后最后用return返回
		将多个判断（特别是重复的case语句）用多态代替
		让类来处理null的情况，而不是每次让别人处理null的情况

	函数层面
		提取一个函数
		将函数中的代码改成内联
		将一个很长的函数转换成类
		将复杂的算法替换成简单的算法
		添加一个参数
		删除一个参数
		将读取操作和写入操作分开
		将多个相似的函数通过参数的方式合并在一起
		如果一个函数的行为和参数有关，将其进行拆分
		将整个对象传入一个函数，而不是单独的成员变量
		将单独的变量传入一个函数，而不是整个对象
		封装向下转换：一个函数的返回值要返回最具体的对象

	类的层面
		将按值变量转换成引用
		将引用转换成按值变量
		将虚拟方法转换成数据初始化
		改变成员函数或变量位置
		将具体的代码放在子类中
		将相似的代码放在父类中

	接口层面
		将一个方法移动到类中
		将一个类转换成两个类
		消除一个类
		隐藏一个包含关系
		移除中介
		将继承转换成包含
		将包含转换成继承
		引入外部函数
		引入扩展类
		封装一个暴露的成员变量
		移除一个只读变量的Set方法
		不能被外部类调用的方法要隐藏
		封装没有使用的方法
		当父类和子类实现上都相同时，合并这两个类
		
	系统层面
		当你无法掌握数据的用法时，创建一个明确的数据定义
		将单项依赖的类转变成双向依赖的类
		将双向依赖的类转变成单项依赖的类
		将简单的构造函数转变成工厂模式
		将错误代码转换成异常

安全重构
	注意事项
	保存当前的代码
	尽量保持小范围重构
	一次只重构一个地方
	列出你想做的步骤
	做一个“停车场”：当你想重构A的时候必须要重构B，重构B的时候必须重构C，这时候要记下这些等待重构的地方
	做间隔很短的检查点
	利用编译器的警告
	重新测试
	添加测试用例
	重审变化
	什么时候不要重构
	重构的时候不要改变功能
	该重写的时候就不要重构了
	重构策略
	添加方法的时候要重构
	添加类的时候要重构
	修复缺陷的时候要重构
	瞄准容易出错的类
	瞄准复杂度高的模块
	在维护阶段，重构你接触的部分
	在好代码和烂代码之间建立接口